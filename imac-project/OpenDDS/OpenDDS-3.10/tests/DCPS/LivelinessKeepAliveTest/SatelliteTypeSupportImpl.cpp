/* Generated by /Users/yc/MyGithub/imac-project/OpenDDS/OpenDDS-3.10/bin/opendds_idl version 3.10 (ACE version 6.2a_p11) running on input file Satellite.idl */
#include "SatelliteTypeSupportImpl.h"

#include <cstring>
#include <stdexcept>
#include "dds/DCPS/BuiltInTopicUtils.h"
#include "dds/DCPS/ContentFilteredTopicImpl.h"
#include "dds/DCPS/DataReaderImpl_T.h"
#include "dds/DCPS/DataWriterImpl_T.h"
#include "dds/DCPS/FilterEvaluator.h"
#include "dds/DCPS/MultiTopicDataReader_T.h"
#include "dds/DCPS/PoolAllocator.h"
#include "dds/DCPS/PublicationInstance.h"
#include "dds/DCPS/PublisherImpl.h"
#include "dds/DCPS/Qos_Helper.h"
#include "dds/DCPS/RakeData.h"
#include "dds/DCPS/RakeResults_T.h"
#include "dds/DCPS/ReceivedDataElementList.h"
#include "dds/DCPS/Registered_Data_Types.h"
#include "dds/DCPS/Service_Participant.h"
#include "dds/DCPS/SubscriberImpl.h"
#include "dds/DCPS/Util.h"
#include "dds/DCPS/debug.h"
#include "dds/DdsDcpsDomainC.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: Satellite */



/* Begin STRUCT: Vector */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Satellite::Vector& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 8) {
    padding += 8 - ((size + padding) % 8);
  }
  size += gen_max_marshaled_size(stru.x);
  if ((size + padding) % 8) {
    padding += 8 - ((size + padding) % 8);
  }
  size += gen_max_marshaled_size(stru.y);
  if ((size + padding) % 8) {
    padding += 8 - ((size + padding) % 8);
  }
  size += gen_max_marshaled_size(stru.z);
}

bool operator<<(Serializer& strm, const Satellite::Vector& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.x)
    && (strm << stru.y)
    && (strm << stru.z);
}

bool operator>>(Serializer& strm, Satellite::Vector& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.x)
    && (strm >> stru.y)
    && (strm >> stru.z);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Satellite::Vector> : MetaStruct {
  typedef Satellite::Vector T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Satellite::Vector& typed = *static_cast<const Satellite::Vector*>(stru);
    if (std::strcmp(field, "x") == 0) {
      return typed.x;
    }
    if (std::strcmp(field, "y") == 0) {
      return typed.y;
    }
    if (std::strcmp(field, "z") == 0) {
      return typed.z;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Satellite::Vector)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "x") == 0) {
      ACE_CDR::LongLong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'x' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 8);
    }
    if (std::strcmp(field, "y") == 0) {
      ACE_CDR::LongLong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'y' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 8);
    }
    if (std::strcmp(field, "z") == 0) {
      ACE_CDR::LongLong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'z' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 8);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Satellite::Vector");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "x") == 0) {
      return make_field_cmp(&T::x, next);
    }
    if (std::strcmp(field, "y") == 0) {
      return make_field_cmp(&T::y, next);
    }
    if (std::strcmp(field, "z") == 0) {
      return make_field_cmp(&T::z, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Satellite::Vector)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"x", "y", "z", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "x") == 0) {
      return &static_cast<const T*>(stru)->x;
    }
    if (std::strcmp(field, "y") == 0) {
      return &static_cast<const T*>(stru)->y;
    }
    if (std::strcmp(field, "z") == 0) {
      return &static_cast<const T*>(stru)->z;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Satellite::Vector)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "x") == 0) {
      static_cast<T*>(lhs)->x = *static_cast<const CORBA::LongLong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "y") == 0) {
      static_cast<T*>(lhs)->y = *static_cast<const CORBA::LongLong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "z") == 0) {
      static_cast<T*>(lhs)->z = *static_cast<const CORBA::LongLong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Satellite::Vector)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "x") == 0) {
      return static_cast<const T*>(lhs)->x == static_cast<const T*>(rhs)->x;
    }
    if (std::strcmp(field, "y") == 0) {
      return static_cast<const T*>(lhs)->y == static_cast<const T*>(rhs)->y;
    }
    if (std::strcmp(field, "z") == 0) {
      return static_cast<const T*>(lhs)->z == static_cast<const T*>(rhs)->z;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Satellite::Vector)");
  }
};

template<>
const MetaStruct& getMetaStruct<Satellite::Vector>()
{
  static MetaStructImpl<Satellite::Vector> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Satellite::Vector*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Satellite::Vector>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Vector */


/* Begin STRUCT: Telemetry */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Satellite::Telemetry& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.satellite.in()) + 1;
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.message_number);
  gen_find_size(stru.position, size, padding);
  gen_find_size(stru.velocity, size, padding);
}

bool operator<<(Serializer& strm, const Satellite::Telemetry& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.satellite.in())
    && (strm << stru.message_number)
    && (strm << stru.position)
    && (strm << stru.velocity);
}

bool operator>>(Serializer& strm, Satellite::Telemetry& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.satellite.out())
    && (strm >> stru.message_number)
    && (strm >> stru.position)
    && (strm >> stru.velocity);
}

size_t gen_max_marshaled_size(const Satellite::Telemetry& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const Satellite::Telemetry> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Satellite::Telemetry> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.t.satellite.in()) + 1;
}

bool operator<<(Serializer& strm, KeyOnly<const Satellite::Telemetry> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.t.satellite.in());
}

bool operator>>(Serializer& strm, KeyOnly<Satellite::Telemetry> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.t.satellite.out());
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Satellite {
::DDS::DataWriter_ptr TelemetryTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<Telemetry> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr TelemetryTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<Telemetry> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr TelemetryTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<Telemetry> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<Telemetry, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& TelemetryTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<Telemetry>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool TelemetryTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* TelemetryTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
TelemetryTypeSupport::_ptr_type TelemetryTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Satellite::Telemetry> : MetaStruct {
  typedef Satellite::Telemetry T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 1; }

  Value getValue(const void* stru, const char* field) const
  {
    const Satellite::Telemetry& typed = *static_cast<const Satellite::Telemetry*>(stru);
    if (std::strcmp(field, "satellite") == 0) {
      return typed.satellite.in();
    }
    if (std::strcmp(field, "message_number") == 0) {
      return typed.message_number;
    }
    if (std::strncmp(field, "position.", 9) == 0) {
      return getMetaStruct<Satellite::Vector>().getValue(&typed.position, field + 9);
    }
    if (std::strncmp(field, "velocity.", 9) == 0) {
      return getMetaStruct<Satellite::Vector>().getValue(&typed.velocity, field + 9);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Satellite::Telemetry)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "satellite") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'satellite' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'satellite' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strcmp(field, "message_number") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'message_number' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strncmp(field, "position.", 9) == 0) {
      return getMetaStruct<Satellite::Vector>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<Satellite::Vector*>(0));
    }
    if (std::strncmp(field, "velocity.", 9) == 0) {
      return getMetaStruct<Satellite::Vector>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<Satellite::Vector*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Satellite::Telemetry");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "satellite") == 0) {
      return make_field_cmp(&T::satellite, next);
    }
    if (std::strcmp(field, "message_number") == 0) {
      return make_field_cmp(&T::message_number, next);
    }
    if (std::strncmp(field, "position.", 9) == 0) {
      return make_struct_cmp(&T::position, getMetaStruct<Satellite::Vector>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "velocity.", 9) == 0) {
      return make_struct_cmp(&T::velocity, getMetaStruct<Satellite::Vector>().create_qc_comparator(field + 9), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Satellite::Telemetry)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"satellite", "message_number", "position", "velocity", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "satellite") == 0) {
      return &static_cast<const T*>(stru)->satellite;
    }
    if (std::strcmp(field, "message_number") == 0) {
      return &static_cast<const T*>(stru)->message_number;
    }
    if (std::strcmp(field, "position") == 0) {
      return &static_cast<const T*>(stru)->position;
    }
    if (std::strcmp(field, "velocity") == 0) {
      return &static_cast<const T*>(stru)->velocity;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Satellite::Telemetry)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "satellite") == 0) {
      static_cast<T*>(lhs)->satellite = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "message_number") == 0) {
      static_cast<T*>(lhs)->message_number = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "position") == 0) {
      static_cast<T*>(lhs)->position = *static_cast<const Satellite::Vector*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "velocity") == 0) {
      static_cast<T*>(lhs)->velocity = *static_cast<const Satellite::Vector*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Satellite::Telemetry)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "satellite") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->satellite.in(), static_cast<const T*>(rhs)->satellite.in());
    }
    if (std::strcmp(field, "message_number") == 0) {
      return static_cast<const T*>(lhs)->message_number == static_cast<const T*>(rhs)->message_number;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Satellite::Telemetry)");
  }
};

template<>
const MetaStruct& getMetaStruct<Satellite::Telemetry>()
{
  static MetaStructImpl<Satellite::Telemetry> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Satellite::Telemetry*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Satellite::Telemetry>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Telemetry */


/* Begin TYPEDEF: ItemCode */


/* End TYPEDEF: ItemCode */


/* Begin CONST: FUEL */


/* End CONST: FUEL */


/* Begin CONST: BATTERY */


/* End CONST: BATTERY */


/* Begin CONST: SYSTEM */


/* End CONST: SYSTEM */


/* Begin TYPEDEF: AlertCode */


/* End TYPEDEF: AlertCode */


/* Begin CONST: LOW */


/* End CONST: LOW */


/* Begin CONST: DEAD */


/* End CONST: DEAD */


/* Begin CONST: SYSTEM_SHUTDOWN */


/* End CONST: SYSTEM_SHUTDOWN */


/* Begin STRUCT: Alert */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Satellite::Alert& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.satellite.in()) + 1;
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.item.in()) + 1;
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.code.in()) + 1;
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.message.in()) + 1;
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.index);
}

bool operator<<(Serializer& strm, const Satellite::Alert& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.satellite.in())
    && (strm << stru.item.in())
    && (strm << stru.code.in())
    && (strm << stru.message.in())
    && (strm << stru.index);
}

bool operator>>(Serializer& strm, Satellite::Alert& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.satellite.out())
    && (strm >> stru.item.out())
    && (strm >> stru.code.out())
    && (strm >> stru.message.out())
    && (strm >> stru.index);
}

size_t gen_max_marshaled_size(const Satellite::Alert& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const Satellite::Alert> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Satellite::Alert> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.t.satellite.in()) + 1;
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.t.item.in()) + 1;
}

bool operator<<(Serializer& strm, KeyOnly<const Satellite::Alert> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.t.satellite.in())
    && (strm << stru.t.item.in());
}

bool operator>>(Serializer& strm, KeyOnly<Satellite::Alert> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.t.satellite.out())
    && (strm >> stru.t.item.out());
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Satellite {
::DDS::DataWriter_ptr AlertTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<Alert> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr AlertTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<Alert> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr AlertTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<Alert> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<Alert, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& AlertTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<Alert>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool AlertTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* AlertTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
AlertTypeSupport::_ptr_type AlertTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Satellite::Alert> : MetaStruct {
  typedef Satellite::Alert T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 2; }

  Value getValue(const void* stru, const char* field) const
  {
    const Satellite::Alert& typed = *static_cast<const Satellite::Alert*>(stru);
    if (std::strcmp(field, "satellite") == 0) {
      return typed.satellite.in();
    }
    if (std::strcmp(field, "item") == 0) {
      return typed.item.in();
    }
    if (std::strcmp(field, "code") == 0) {
      return typed.code.in();
    }
    if (std::strcmp(field, "message") == 0) {
      return typed.message.in();
    }
    if (std::strcmp(field, "index") == 0) {
      return typed.index;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Satellite::Alert)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "satellite") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'satellite' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'satellite' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strcmp(field, "item") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'item' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'item' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strcmp(field, "code") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'code' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'code' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strcmp(field, "message") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'message' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'message' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strcmp(field, "index") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'index' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Satellite::Alert");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "satellite") == 0) {
      return make_field_cmp(&T::satellite, next);
    }
    if (std::strcmp(field, "item") == 0) {
      return make_field_cmp(&T::item, next);
    }
    if (std::strcmp(field, "code") == 0) {
      return make_field_cmp(&T::code, next);
    }
    if (std::strcmp(field, "message") == 0) {
      return make_field_cmp(&T::message, next);
    }
    if (std::strcmp(field, "index") == 0) {
      return make_field_cmp(&T::index, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Satellite::Alert)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"satellite", "item", "code", "message", "index", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "satellite") == 0) {
      return &static_cast<const T*>(stru)->satellite;
    }
    if (std::strcmp(field, "item") == 0) {
      return &static_cast<const T*>(stru)->item;
    }
    if (std::strcmp(field, "code") == 0) {
      return &static_cast<const T*>(stru)->code;
    }
    if (std::strcmp(field, "message") == 0) {
      return &static_cast<const T*>(stru)->message;
    }
    if (std::strcmp(field, "index") == 0) {
      return &static_cast<const T*>(stru)->index;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Satellite::Alert)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "satellite") == 0) {
      static_cast<T*>(lhs)->satellite = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "item") == 0) {
      static_cast<T*>(lhs)->item = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "code") == 0) {
      static_cast<T*>(lhs)->code = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "message") == 0) {
      static_cast<T*>(lhs)->message = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "index") == 0) {
      static_cast<T*>(lhs)->index = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Satellite::Alert)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "satellite") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->satellite.in(), static_cast<const T*>(rhs)->satellite.in());
    }
    if (std::strcmp(field, "item") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->item.in(), static_cast<const T*>(rhs)->item.in());
    }
    if (std::strcmp(field, "code") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->code.in(), static_cast<const T*>(rhs)->code.in());
    }
    if (std::strcmp(field, "message") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->message.in(), static_cast<const T*>(rhs)->message.in());
    }
    if (std::strcmp(field, "index") == 0) {
      return static_cast<const T*>(lhs)->index == static_cast<const T*>(rhs)->index;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Satellite::Alert)");
  }
};

template<>
const MetaStruct& getMetaStruct<Satellite::Alert>()
{
  static MetaStructImpl<Satellite::Alert> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Satellite::Alert*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Satellite::Alert>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Alert */

/* End MODULE: Satellite */
