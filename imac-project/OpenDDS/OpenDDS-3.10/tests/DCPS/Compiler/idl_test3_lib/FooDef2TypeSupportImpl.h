/* -*- C++ -*- */
/* Generated by /Users/yc/MyGithub/imac-project/OpenDDS/OpenDDS-3.10/bin/opendds_idl version 3.10 (ACE version 6.2a_p11) running on input file FooDef2.idl */
#ifndef OPENDDS_IDL_GENERATED_FOODEF2TYPESUPPORTIMPL_H_93H5QT
#define OPENDDS_IDL_GENERATED_FOODEF2TYPESUPPORTIMPL_H_93H5QT
#include "FooDef2C.h"
#include "dds/DCPS/Definitions.h"
#include "FooDef2TypeSupportC.h"
#include "SharedTypesC.h"
#include "dds/DCPS/Serializer.h"
#include "dds/DCPS/TypeSupportImpl.h"
#include "foolib_export.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: Xyz */



/* Begin ENUM: AnEnum */


/* End ENUM: AnEnum */


/* Begin TYPEDEF: SeqOfBoolean */


/* End TYPEDEF: SeqOfBoolean */


/* Begin TYPEDEF: SeqOfString */


/* End TYPEDEF: SeqOfString */


/* Begin TYPEDEF: SeqOfChar */


/* End TYPEDEF: SeqOfChar */


/* Begin TYPEDEF: SeqOfOctet */


/* End TYPEDEF: SeqOfOctet */


/* Begin TYPEDEF: SeqOfLong */


/* End TYPEDEF: SeqOfLong */


/* Begin TYPEDEF: SeqOfAnEnum */


/* End TYPEDEF: SeqOfAnEnum */


/* Begin TYPEDEF: ArrayOfBoolean */


/* End TYPEDEF: ArrayOfBoolean */


/* Begin TYPEDEF: ArrayOfString */


/* End TYPEDEF: ArrayOfString */


/* Begin TYPEDEF: ArrayOfChar */


/* End TYPEDEF: ArrayOfChar */


/* Begin TYPEDEF: ArrayOfOctet */


/* End TYPEDEF: ArrayOfOctet */


/* Begin TYPEDEF: ArrayOfLong */


/* End TYPEDEF: ArrayOfLong */


/* Begin TYPEDEF: ArrayOfAnEnum */


/* End TYPEDEF: ArrayOfAnEnum */


/* Begin TYPEDEF: ArrayOfSeqOfBoolean */


/* End TYPEDEF: ArrayOfSeqOfBoolean */


/* Begin TYPEDEF: ArrayOfSeqOfString */


/* End TYPEDEF: ArrayOfSeqOfString */


/* Begin TYPEDEF: ArrayOfSeqOfChar */


/* End TYPEDEF: ArrayOfSeqOfChar */


/* Begin TYPEDEF: ArrayOfSeqOfOctet */


/* End TYPEDEF: ArrayOfSeqOfOctet */


/* Begin TYPEDEF: ArrayOfSeqOfLong */


/* End TYPEDEF: ArrayOfSeqOfLong */


/* Begin TYPEDEF: ArrayOfSeqOfAnEnum */


/* End TYPEDEF: ArrayOfSeqOfAnEnum */

/* End MODULE: Xyz */


/* Begin MODULE: Xyz */



/* Begin STRUCT: StructOfArrayOfBoolean */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::StructOfArrayOfBoolean& stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfBoolean& stru);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::StructOfArrayOfBoolean& stru);

FooLib_Export
size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfBoolean& stru, bool align);

FooLib_Export
size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfBoolean> stru, bool align);

FooLib_Export
void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfBoolean> stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfBoolean> stru);

FooLib_Export
bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfBoolean> stru);

template <>
struct MarshalTraits<Xyz::StructOfArrayOfBoolean> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct FooLib_Export StructOfArrayOfBoolean_OpenDDS_KeyLessThan {
  bool operator()(const Xyz::StructOfArrayOfBoolean&, const Xyz::StructOfArrayOfBoolean&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Xyz {
class StructOfArrayOfBooleanTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Xyz::StructOfArrayOfBoolean> {
  typedef Xyz::StructOfArrayOfBoolean MessageType;
  typedef Xyz::StructOfArrayOfBooleanSeq MessageSequenceType;
  typedef Xyz::StructOfArrayOfBooleanTypeSupport TypeSupportType;
  typedef Xyz::StructOfArrayOfBooleanTypeSupportImpl TypeSupportTypeImpl;
  typedef Xyz::StructOfArrayOfBooleanDataWriter DataWriterType;
  typedef Xyz::StructOfArrayOfBooleanDataReader DataReaderType;
  typedef Xyz::StructOfArrayOfBoolean_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Xyz::StructOfArrayOfBoolean"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
class FooLib_Export StructOfArrayOfBooleanTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<StructOfArrayOfBooleanTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<StructOfArrayOfBoolean> TraitsType;
  typedef StructOfArrayOfBooleanTypeSupport TypeSupportType;
  typedef StructOfArrayOfBooleanTypeSupport::_var_type _var_type;
  typedef StructOfArrayOfBooleanTypeSupport::_ptr_type _ptr_type;

  StructOfArrayOfBooleanTypeSupportImpl() {}
  virtual ~StructOfArrayOfBooleanTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static StructOfArrayOfBooleanTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

class MetaStruct;

template<typename T>
const MetaStruct& getMetaStruct();

template<>
FooLib_Export
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfBoolean>();
FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfBoolean*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StructOfArrayOfBoolean */


/* Begin STRUCT: StructOfArrayOfString */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::StructOfArrayOfString& stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfString& stru);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::StructOfArrayOfString& stru);

FooLib_Export
size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfString& stru, bool align);

FooLib_Export
size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfString> stru, bool align);

FooLib_Export
void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfString> stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfString> stru);

FooLib_Export
bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfString> stru);

template <>
struct MarshalTraits<Xyz::StructOfArrayOfString> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct FooLib_Export StructOfArrayOfString_OpenDDS_KeyLessThan {
  bool operator()(const Xyz::StructOfArrayOfString&, const Xyz::StructOfArrayOfString&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Xyz {
class StructOfArrayOfStringTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Xyz::StructOfArrayOfString> {
  typedef Xyz::StructOfArrayOfString MessageType;
  typedef Xyz::StructOfArrayOfStringSeq MessageSequenceType;
  typedef Xyz::StructOfArrayOfStringTypeSupport TypeSupportType;
  typedef Xyz::StructOfArrayOfStringTypeSupportImpl TypeSupportTypeImpl;
  typedef Xyz::StructOfArrayOfStringDataWriter DataWriterType;
  typedef Xyz::StructOfArrayOfStringDataReader DataReaderType;
  typedef Xyz::StructOfArrayOfString_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Xyz::StructOfArrayOfString"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
class FooLib_Export StructOfArrayOfStringTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<StructOfArrayOfStringTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<StructOfArrayOfString> TraitsType;
  typedef StructOfArrayOfStringTypeSupport TypeSupportType;
  typedef StructOfArrayOfStringTypeSupport::_var_type _var_type;
  typedef StructOfArrayOfStringTypeSupport::_ptr_type _ptr_type;

  StructOfArrayOfStringTypeSupportImpl() {}
  virtual ~StructOfArrayOfStringTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static StructOfArrayOfStringTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
FooLib_Export
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfString>();
FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfString*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StructOfArrayOfString */


/* Begin STRUCT: StructOfArrayOfChar */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::StructOfArrayOfChar& stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfChar& stru);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::StructOfArrayOfChar& stru);

FooLib_Export
size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfChar& stru, bool align);

FooLib_Export
size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfChar> stru, bool align);

FooLib_Export
void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfChar> stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfChar> stru);

FooLib_Export
bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfChar> stru);

template <>
struct MarshalTraits<Xyz::StructOfArrayOfChar> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct FooLib_Export StructOfArrayOfChar_OpenDDS_KeyLessThan {
  bool operator()(const Xyz::StructOfArrayOfChar&, const Xyz::StructOfArrayOfChar&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Xyz {
class StructOfArrayOfCharTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Xyz::StructOfArrayOfChar> {
  typedef Xyz::StructOfArrayOfChar MessageType;
  typedef Xyz::StructOfArrayOfCharSeq MessageSequenceType;
  typedef Xyz::StructOfArrayOfCharTypeSupport TypeSupportType;
  typedef Xyz::StructOfArrayOfCharTypeSupportImpl TypeSupportTypeImpl;
  typedef Xyz::StructOfArrayOfCharDataWriter DataWriterType;
  typedef Xyz::StructOfArrayOfCharDataReader DataReaderType;
  typedef Xyz::StructOfArrayOfChar_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Xyz::StructOfArrayOfChar"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
class FooLib_Export StructOfArrayOfCharTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<StructOfArrayOfCharTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<StructOfArrayOfChar> TraitsType;
  typedef StructOfArrayOfCharTypeSupport TypeSupportType;
  typedef StructOfArrayOfCharTypeSupport::_var_type _var_type;
  typedef StructOfArrayOfCharTypeSupport::_ptr_type _ptr_type;

  StructOfArrayOfCharTypeSupportImpl() {}
  virtual ~StructOfArrayOfCharTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static StructOfArrayOfCharTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
FooLib_Export
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfChar>();
FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfChar*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StructOfArrayOfChar */


/* Begin STRUCT: StructOfArrayOfOctet */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::StructOfArrayOfOctet& stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfOctet& stru);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::StructOfArrayOfOctet& stru);

FooLib_Export
size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfOctet& stru, bool align);

FooLib_Export
size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfOctet> stru, bool align);

FooLib_Export
void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfOctet> stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfOctet> stru);

FooLib_Export
bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfOctet> stru);

template <>
struct MarshalTraits<Xyz::StructOfArrayOfOctet> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct FooLib_Export StructOfArrayOfOctet_OpenDDS_KeyLessThan {
  bool operator()(const Xyz::StructOfArrayOfOctet&, const Xyz::StructOfArrayOfOctet&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Xyz {
class StructOfArrayOfOctetTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Xyz::StructOfArrayOfOctet> {
  typedef Xyz::StructOfArrayOfOctet MessageType;
  typedef Xyz::StructOfArrayOfOctetSeq MessageSequenceType;
  typedef Xyz::StructOfArrayOfOctetTypeSupport TypeSupportType;
  typedef Xyz::StructOfArrayOfOctetTypeSupportImpl TypeSupportTypeImpl;
  typedef Xyz::StructOfArrayOfOctetDataWriter DataWriterType;
  typedef Xyz::StructOfArrayOfOctetDataReader DataReaderType;
  typedef Xyz::StructOfArrayOfOctet_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Xyz::StructOfArrayOfOctet"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
class FooLib_Export StructOfArrayOfOctetTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<StructOfArrayOfOctetTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<StructOfArrayOfOctet> TraitsType;
  typedef StructOfArrayOfOctetTypeSupport TypeSupportType;
  typedef StructOfArrayOfOctetTypeSupport::_var_type _var_type;
  typedef StructOfArrayOfOctetTypeSupport::_ptr_type _ptr_type;

  StructOfArrayOfOctetTypeSupportImpl() {}
  virtual ~StructOfArrayOfOctetTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static StructOfArrayOfOctetTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
FooLib_Export
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfOctet>();
FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfOctet*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StructOfArrayOfOctet */


/* Begin STRUCT: StructOfArrayOfLong */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::StructOfArrayOfLong& stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfLong& stru);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::StructOfArrayOfLong& stru);

FooLib_Export
size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfLong& stru, bool align);

FooLib_Export
size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfLong> stru, bool align);

FooLib_Export
void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfLong> stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfLong> stru);

FooLib_Export
bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfLong> stru);

template <>
struct MarshalTraits<Xyz::StructOfArrayOfLong> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct FooLib_Export StructOfArrayOfLong_OpenDDS_KeyLessThan {
  bool operator()(const Xyz::StructOfArrayOfLong&, const Xyz::StructOfArrayOfLong&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Xyz {
class StructOfArrayOfLongTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Xyz::StructOfArrayOfLong> {
  typedef Xyz::StructOfArrayOfLong MessageType;
  typedef Xyz::StructOfArrayOfLongSeq MessageSequenceType;
  typedef Xyz::StructOfArrayOfLongTypeSupport TypeSupportType;
  typedef Xyz::StructOfArrayOfLongTypeSupportImpl TypeSupportTypeImpl;
  typedef Xyz::StructOfArrayOfLongDataWriter DataWriterType;
  typedef Xyz::StructOfArrayOfLongDataReader DataReaderType;
  typedef Xyz::StructOfArrayOfLong_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Xyz::StructOfArrayOfLong"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
class FooLib_Export StructOfArrayOfLongTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<StructOfArrayOfLongTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<StructOfArrayOfLong> TraitsType;
  typedef StructOfArrayOfLongTypeSupport TypeSupportType;
  typedef StructOfArrayOfLongTypeSupport::_var_type _var_type;
  typedef StructOfArrayOfLongTypeSupport::_ptr_type _ptr_type;

  StructOfArrayOfLongTypeSupportImpl() {}
  virtual ~StructOfArrayOfLongTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static StructOfArrayOfLongTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
FooLib_Export
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfLong>();
FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfLong*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StructOfArrayOfLong */


/* Begin STRUCT: StructOfArrayOfAnEnum */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::StructOfArrayOfAnEnum& stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfAnEnum& stru);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::StructOfArrayOfAnEnum& stru);

FooLib_Export
size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfAnEnum& stru, bool align);

FooLib_Export
size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfAnEnum> stru, bool align);

FooLib_Export
void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfAnEnum> stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfAnEnum> stru);

FooLib_Export
bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfAnEnum> stru);

template <>
struct MarshalTraits<Xyz::StructOfArrayOfAnEnum> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct FooLib_Export StructOfArrayOfAnEnum_OpenDDS_KeyLessThan {
  bool operator()(const Xyz::StructOfArrayOfAnEnum&, const Xyz::StructOfArrayOfAnEnum&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Xyz {
class StructOfArrayOfAnEnumTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Xyz::StructOfArrayOfAnEnum> {
  typedef Xyz::StructOfArrayOfAnEnum MessageType;
  typedef Xyz::StructOfArrayOfAnEnumSeq MessageSequenceType;
  typedef Xyz::StructOfArrayOfAnEnumTypeSupport TypeSupportType;
  typedef Xyz::StructOfArrayOfAnEnumTypeSupportImpl TypeSupportTypeImpl;
  typedef Xyz::StructOfArrayOfAnEnumDataWriter DataWriterType;
  typedef Xyz::StructOfArrayOfAnEnumDataReader DataReaderType;
  typedef Xyz::StructOfArrayOfAnEnum_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Xyz::StructOfArrayOfAnEnum"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
class FooLib_Export StructOfArrayOfAnEnumTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<StructOfArrayOfAnEnumTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<StructOfArrayOfAnEnum> TraitsType;
  typedef StructOfArrayOfAnEnumTypeSupport TypeSupportType;
  typedef StructOfArrayOfAnEnumTypeSupport::_var_type _var_type;
  typedef StructOfArrayOfAnEnumTypeSupport::_ptr_type _ptr_type;

  StructOfArrayOfAnEnumTypeSupportImpl() {}
  virtual ~StructOfArrayOfAnEnumTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static StructOfArrayOfAnEnumTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
FooLib_Export
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfAnEnum>();
FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfAnEnum*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StructOfArrayOfAnEnum */


/* Begin TYPEDEF: ArrayOfBoolean2 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::ArrayOfBoolean2_forany& arr, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::ArrayOfBoolean2_forany& arr);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::ArrayOfBoolean2_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::ArrayOfBoolean2_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: ArrayOfBoolean2 */


/* Begin TYPEDEF: ArrayOfString2 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::ArrayOfString2_forany& arr, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::ArrayOfString2_forany& arr);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::ArrayOfString2_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::ArrayOfString2_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: ArrayOfString2 */


/* Begin TYPEDEF: ArrayOfChar2 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::ArrayOfChar2_forany& arr, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::ArrayOfChar2_forany& arr);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::ArrayOfChar2_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::ArrayOfChar2_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: ArrayOfChar2 */


/* Begin TYPEDEF: ArrayOfOctet2 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::ArrayOfOctet2_forany& arr, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::ArrayOfOctet2_forany& arr);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::ArrayOfOctet2_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::ArrayOfOctet2_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: ArrayOfOctet2 */


/* Begin TYPEDEF: ArrayOfLong2 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::ArrayOfLong2_forany& arr, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::ArrayOfLong2_forany& arr);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::ArrayOfLong2_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::ArrayOfLong2_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: ArrayOfLong2 */


/* Begin TYPEDEF: ArrayOfAnEnum2 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::ArrayOfAnEnum2_forany& arr, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::ArrayOfAnEnum2_forany& arr);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::ArrayOfAnEnum2_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::ArrayOfAnEnum2_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: ArrayOfAnEnum2 */


/* Begin STRUCT: StructOfSeqOfBoolean */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::StructOfSeqOfBoolean& stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::StructOfSeqOfBoolean& stru);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::StructOfSeqOfBoolean& stru);

FooLib_Export
size_t gen_max_marshaled_size(const Xyz::StructOfSeqOfBoolean& stru, bool align);

FooLib_Export
size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfSeqOfBoolean> stru, bool align);

FooLib_Export
void gen_find_size(KeyOnly<const Xyz::StructOfSeqOfBoolean> stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfSeqOfBoolean> stru);

FooLib_Export
bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfSeqOfBoolean> stru);

template <>
struct MarshalTraits<Xyz::StructOfSeqOfBoolean> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct FooLib_Export StructOfSeqOfBoolean_OpenDDS_KeyLessThan {
  bool operator()(const Xyz::StructOfSeqOfBoolean&, const Xyz::StructOfSeqOfBoolean&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Xyz {
class StructOfSeqOfBooleanTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Xyz::StructOfSeqOfBoolean> {
  typedef Xyz::StructOfSeqOfBoolean MessageType;
  typedef Xyz::StructOfSeqOfBooleanSeq MessageSequenceType;
  typedef Xyz::StructOfSeqOfBooleanTypeSupport TypeSupportType;
  typedef Xyz::StructOfSeqOfBooleanTypeSupportImpl TypeSupportTypeImpl;
  typedef Xyz::StructOfSeqOfBooleanDataWriter DataWriterType;
  typedef Xyz::StructOfSeqOfBooleanDataReader DataReaderType;
  typedef Xyz::StructOfSeqOfBoolean_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Xyz::StructOfSeqOfBoolean"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
class FooLib_Export StructOfSeqOfBooleanTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<StructOfSeqOfBooleanTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<StructOfSeqOfBoolean> TraitsType;
  typedef StructOfSeqOfBooleanTypeSupport TypeSupportType;
  typedef StructOfSeqOfBooleanTypeSupport::_var_type _var_type;
  typedef StructOfSeqOfBooleanTypeSupport::_ptr_type _ptr_type;

  StructOfSeqOfBooleanTypeSupportImpl() {}
  virtual ~StructOfSeqOfBooleanTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static StructOfSeqOfBooleanTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
FooLib_Export
const MetaStruct& getMetaStruct<Xyz::StructOfSeqOfBoolean>();
FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::StructOfSeqOfBoolean*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StructOfSeqOfBoolean */


/* Begin STRUCT: StructOfSeqOfString */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::StructOfSeqOfString& stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::StructOfSeqOfString& stru);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::StructOfSeqOfString& stru);

FooLib_Export
size_t gen_max_marshaled_size(const Xyz::StructOfSeqOfString& stru, bool align);

FooLib_Export
size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfSeqOfString> stru, bool align);

FooLib_Export
void gen_find_size(KeyOnly<const Xyz::StructOfSeqOfString> stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfSeqOfString> stru);

FooLib_Export
bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfSeqOfString> stru);

template <>
struct MarshalTraits<Xyz::StructOfSeqOfString> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct FooLib_Export StructOfSeqOfString_OpenDDS_KeyLessThan {
  bool operator()(const Xyz::StructOfSeqOfString&, const Xyz::StructOfSeqOfString&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Xyz {
class StructOfSeqOfStringTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Xyz::StructOfSeqOfString> {
  typedef Xyz::StructOfSeqOfString MessageType;
  typedef Xyz::StructOfSeqOfStringSeq MessageSequenceType;
  typedef Xyz::StructOfSeqOfStringTypeSupport TypeSupportType;
  typedef Xyz::StructOfSeqOfStringTypeSupportImpl TypeSupportTypeImpl;
  typedef Xyz::StructOfSeqOfStringDataWriter DataWriterType;
  typedef Xyz::StructOfSeqOfStringDataReader DataReaderType;
  typedef Xyz::StructOfSeqOfString_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Xyz::StructOfSeqOfString"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
class FooLib_Export StructOfSeqOfStringTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<StructOfSeqOfStringTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<StructOfSeqOfString> TraitsType;
  typedef StructOfSeqOfStringTypeSupport TypeSupportType;
  typedef StructOfSeqOfStringTypeSupport::_var_type _var_type;
  typedef StructOfSeqOfStringTypeSupport::_ptr_type _ptr_type;

  StructOfSeqOfStringTypeSupportImpl() {}
  virtual ~StructOfSeqOfStringTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static StructOfSeqOfStringTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
FooLib_Export
const MetaStruct& getMetaStruct<Xyz::StructOfSeqOfString>();
FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::StructOfSeqOfString*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StructOfSeqOfString */


/* Begin STRUCT: StructOfSeqOfChar */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::StructOfSeqOfChar& stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::StructOfSeqOfChar& stru);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::StructOfSeqOfChar& stru);

FooLib_Export
size_t gen_max_marshaled_size(const Xyz::StructOfSeqOfChar& stru, bool align);

FooLib_Export
size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfSeqOfChar> stru, bool align);

FooLib_Export
void gen_find_size(KeyOnly<const Xyz::StructOfSeqOfChar> stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfSeqOfChar> stru);

FooLib_Export
bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfSeqOfChar> stru);

template <>
struct MarshalTraits<Xyz::StructOfSeqOfChar> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct FooLib_Export StructOfSeqOfChar_OpenDDS_KeyLessThan {
  bool operator()(const Xyz::StructOfSeqOfChar&, const Xyz::StructOfSeqOfChar&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Xyz {
class StructOfSeqOfCharTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Xyz::StructOfSeqOfChar> {
  typedef Xyz::StructOfSeqOfChar MessageType;
  typedef Xyz::StructOfSeqOfCharSeq MessageSequenceType;
  typedef Xyz::StructOfSeqOfCharTypeSupport TypeSupportType;
  typedef Xyz::StructOfSeqOfCharTypeSupportImpl TypeSupportTypeImpl;
  typedef Xyz::StructOfSeqOfCharDataWriter DataWriterType;
  typedef Xyz::StructOfSeqOfCharDataReader DataReaderType;
  typedef Xyz::StructOfSeqOfChar_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Xyz::StructOfSeqOfChar"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
class FooLib_Export StructOfSeqOfCharTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<StructOfSeqOfCharTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<StructOfSeqOfChar> TraitsType;
  typedef StructOfSeqOfCharTypeSupport TypeSupportType;
  typedef StructOfSeqOfCharTypeSupport::_var_type _var_type;
  typedef StructOfSeqOfCharTypeSupport::_ptr_type _ptr_type;

  StructOfSeqOfCharTypeSupportImpl() {}
  virtual ~StructOfSeqOfCharTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static StructOfSeqOfCharTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
FooLib_Export
const MetaStruct& getMetaStruct<Xyz::StructOfSeqOfChar>();
FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::StructOfSeqOfChar*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StructOfSeqOfChar */


/* Begin STRUCT: StructOfSeqOfOctet */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::StructOfSeqOfOctet& stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::StructOfSeqOfOctet& stru);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::StructOfSeqOfOctet& stru);

FooLib_Export
size_t gen_max_marshaled_size(const Xyz::StructOfSeqOfOctet& stru, bool align);

FooLib_Export
size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfSeqOfOctet> stru, bool align);

FooLib_Export
void gen_find_size(KeyOnly<const Xyz::StructOfSeqOfOctet> stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfSeqOfOctet> stru);

FooLib_Export
bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfSeqOfOctet> stru);

template <>
struct MarshalTraits<Xyz::StructOfSeqOfOctet> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct FooLib_Export StructOfSeqOfOctet_OpenDDS_KeyLessThan {
  bool operator()(const Xyz::StructOfSeqOfOctet&, const Xyz::StructOfSeqOfOctet&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Xyz {
class StructOfSeqOfOctetTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Xyz::StructOfSeqOfOctet> {
  typedef Xyz::StructOfSeqOfOctet MessageType;
  typedef Xyz::StructOfSeqOfOctetSeq MessageSequenceType;
  typedef Xyz::StructOfSeqOfOctetTypeSupport TypeSupportType;
  typedef Xyz::StructOfSeqOfOctetTypeSupportImpl TypeSupportTypeImpl;
  typedef Xyz::StructOfSeqOfOctetDataWriter DataWriterType;
  typedef Xyz::StructOfSeqOfOctetDataReader DataReaderType;
  typedef Xyz::StructOfSeqOfOctet_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Xyz::StructOfSeqOfOctet"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
class FooLib_Export StructOfSeqOfOctetTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<StructOfSeqOfOctetTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<StructOfSeqOfOctet> TraitsType;
  typedef StructOfSeqOfOctetTypeSupport TypeSupportType;
  typedef StructOfSeqOfOctetTypeSupport::_var_type _var_type;
  typedef StructOfSeqOfOctetTypeSupport::_ptr_type _ptr_type;

  StructOfSeqOfOctetTypeSupportImpl() {}
  virtual ~StructOfSeqOfOctetTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static StructOfSeqOfOctetTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
FooLib_Export
const MetaStruct& getMetaStruct<Xyz::StructOfSeqOfOctet>();
FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::StructOfSeqOfOctet*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StructOfSeqOfOctet */


/* Begin STRUCT: StructOfSeqOfLong */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::StructOfSeqOfLong& stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::StructOfSeqOfLong& stru);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::StructOfSeqOfLong& stru);

FooLib_Export
size_t gen_max_marshaled_size(const Xyz::StructOfSeqOfLong& stru, bool align);

FooLib_Export
size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfSeqOfLong> stru, bool align);

FooLib_Export
void gen_find_size(KeyOnly<const Xyz::StructOfSeqOfLong> stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfSeqOfLong> stru);

FooLib_Export
bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfSeqOfLong> stru);

template <>
struct MarshalTraits<Xyz::StructOfSeqOfLong> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct FooLib_Export StructOfSeqOfLong_OpenDDS_KeyLessThan {
  bool operator()(const Xyz::StructOfSeqOfLong&, const Xyz::StructOfSeqOfLong&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Xyz {
class StructOfSeqOfLongTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Xyz::StructOfSeqOfLong> {
  typedef Xyz::StructOfSeqOfLong MessageType;
  typedef Xyz::StructOfSeqOfLongSeq MessageSequenceType;
  typedef Xyz::StructOfSeqOfLongTypeSupport TypeSupportType;
  typedef Xyz::StructOfSeqOfLongTypeSupportImpl TypeSupportTypeImpl;
  typedef Xyz::StructOfSeqOfLongDataWriter DataWriterType;
  typedef Xyz::StructOfSeqOfLongDataReader DataReaderType;
  typedef Xyz::StructOfSeqOfLong_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Xyz::StructOfSeqOfLong"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
class FooLib_Export StructOfSeqOfLongTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<StructOfSeqOfLongTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<StructOfSeqOfLong> TraitsType;
  typedef StructOfSeqOfLongTypeSupport TypeSupportType;
  typedef StructOfSeqOfLongTypeSupport::_var_type _var_type;
  typedef StructOfSeqOfLongTypeSupport::_ptr_type _ptr_type;

  StructOfSeqOfLongTypeSupportImpl() {}
  virtual ~StructOfSeqOfLongTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static StructOfSeqOfLongTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
FooLib_Export
const MetaStruct& getMetaStruct<Xyz::StructOfSeqOfLong>();
FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::StructOfSeqOfLong*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StructOfSeqOfLong */


/* Begin STRUCT: StructOfSeqOfAnEnum */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::StructOfSeqOfAnEnum& stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::StructOfSeqOfAnEnum& stru);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::StructOfSeqOfAnEnum& stru);

FooLib_Export
size_t gen_max_marshaled_size(const Xyz::StructOfSeqOfAnEnum& stru, bool align);

FooLib_Export
size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfSeqOfAnEnum> stru, bool align);

FooLib_Export
void gen_find_size(KeyOnly<const Xyz::StructOfSeqOfAnEnum> stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfSeqOfAnEnum> stru);

FooLib_Export
bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfSeqOfAnEnum> stru);

template <>
struct MarshalTraits<Xyz::StructOfSeqOfAnEnum> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct FooLib_Export StructOfSeqOfAnEnum_OpenDDS_KeyLessThan {
  bool operator()(const Xyz::StructOfSeqOfAnEnum&, const Xyz::StructOfSeqOfAnEnum&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Xyz {
class StructOfSeqOfAnEnumTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Xyz::StructOfSeqOfAnEnum> {
  typedef Xyz::StructOfSeqOfAnEnum MessageType;
  typedef Xyz::StructOfSeqOfAnEnumSeq MessageSequenceType;
  typedef Xyz::StructOfSeqOfAnEnumTypeSupport TypeSupportType;
  typedef Xyz::StructOfSeqOfAnEnumTypeSupportImpl TypeSupportTypeImpl;
  typedef Xyz::StructOfSeqOfAnEnumDataWriter DataWriterType;
  typedef Xyz::StructOfSeqOfAnEnumDataReader DataReaderType;
  typedef Xyz::StructOfSeqOfAnEnum_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Xyz::StructOfSeqOfAnEnum"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
class FooLib_Export StructOfSeqOfAnEnumTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<StructOfSeqOfAnEnumTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<StructOfSeqOfAnEnum> TraitsType;
  typedef StructOfSeqOfAnEnumTypeSupport TypeSupportType;
  typedef StructOfSeqOfAnEnumTypeSupport::_var_type _var_type;
  typedef StructOfSeqOfAnEnumTypeSupport::_ptr_type _ptr_type;

  StructOfSeqOfAnEnumTypeSupportImpl() {}
  virtual ~StructOfSeqOfAnEnumTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static StructOfSeqOfAnEnumTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
FooLib_Export
const MetaStruct& getMetaStruct<Xyz::StructOfSeqOfAnEnum>();
FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::StructOfSeqOfAnEnum*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StructOfSeqOfAnEnum */

/* End MODULE: Xyz */
#endif /* OPENDDS_IDL_GENERATED_FOODEF2TYPESUPPORTIMPL_H_93H5QT */
