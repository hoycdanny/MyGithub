/* -*- C++ -*- */
/* Generated by /Users/yc/MyGithub/imac-project/OpenDDS/OpenDDS-3.10/bin/opendds_idl version 3.10 (ACE version 6.2a_p11) running on input file FooDef3.idl */
#ifndef OPENDDS_IDL_GENERATED_FOODEF3TYPESUPPORTIMPL_H_Q0KCYA
#define OPENDDS_IDL_GENERATED_FOODEF3TYPESUPPORTIMPL_H_Q0KCYA
#include "FooDef3C.h"
#include "dds/DCPS/Definitions.h"
#include "FooDef3TypeSupportC.h"
#include "SharedTypesC.h"
#include "dds/DCPS/Serializer.h"
#include "dds/DCPS/TypeSupportImpl.h"
#include "foolib_export.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: Xyz */



/* Begin ENUM: AnEnum */


/* End ENUM: AnEnum */


/* Begin TYPEDEF: SeqOfBoolean */


/* End TYPEDEF: SeqOfBoolean */


/* Begin TYPEDEF: SeqOfString */


/* End TYPEDEF: SeqOfString */


/* Begin TYPEDEF: SeqOfChar */


/* End TYPEDEF: SeqOfChar */


/* Begin TYPEDEF: SeqOfOctet */


/* End TYPEDEF: SeqOfOctet */


/* Begin TYPEDEF: SeqOfLong */


/* End TYPEDEF: SeqOfLong */


/* Begin TYPEDEF: SeqOfAnEnum */


/* End TYPEDEF: SeqOfAnEnum */


/* Begin TYPEDEF: ArrayOfBoolean */


/* End TYPEDEF: ArrayOfBoolean */


/* Begin TYPEDEF: ArrayOfString */


/* End TYPEDEF: ArrayOfString */


/* Begin TYPEDEF: ArrayOfChar */


/* End TYPEDEF: ArrayOfChar */


/* Begin TYPEDEF: ArrayOfOctet */


/* End TYPEDEF: ArrayOfOctet */


/* Begin TYPEDEF: ArrayOfLong */


/* End TYPEDEF: ArrayOfLong */


/* Begin TYPEDEF: ArrayOfAnEnum */


/* End TYPEDEF: ArrayOfAnEnum */


/* Begin TYPEDEF: ArrayOfSeqOfBoolean */


/* End TYPEDEF: ArrayOfSeqOfBoolean */


/* Begin TYPEDEF: ArrayOfSeqOfString */


/* End TYPEDEF: ArrayOfSeqOfString */


/* Begin TYPEDEF: ArrayOfSeqOfChar */


/* End TYPEDEF: ArrayOfSeqOfChar */


/* Begin TYPEDEF: ArrayOfSeqOfOctet */


/* End TYPEDEF: ArrayOfSeqOfOctet */


/* Begin TYPEDEF: ArrayOfSeqOfLong */


/* End TYPEDEF: ArrayOfSeqOfLong */


/* Begin TYPEDEF: ArrayOfSeqOfAnEnum */


/* End TYPEDEF: ArrayOfSeqOfAnEnum */

/* End MODULE: Xyz */


/* Begin MODULE: Xyz */



/* Begin TYPEDEF: SeqOfBoolean2 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::SeqOfBoolean2& seq, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::SeqOfBoolean2& seq);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::SeqOfBoolean2& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::SeqOfBoolean2*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfBoolean2 */


/* Begin TYPEDEF: SeqOfString2 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::SeqOfString2& seq, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::SeqOfString2& seq);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::SeqOfString2& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::SeqOfString2*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfString2 */


/* Begin TYPEDEF: SeqOfChar2 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::SeqOfChar2& seq, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::SeqOfChar2& seq);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::SeqOfChar2& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::SeqOfChar2*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfChar2 */


/* Begin TYPEDEF: SeqOfOctet2 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::SeqOfOctet2& seq, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::SeqOfOctet2& seq);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::SeqOfOctet2& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::SeqOfOctet2*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfOctet2 */


/* Begin TYPEDEF: SeqOfLong2 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::SeqOfLong2& seq, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::SeqOfLong2& seq);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::SeqOfLong2& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::SeqOfLong2*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfLong2 */


/* Begin TYPEDEF: SeqOfAnEnum2 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::SeqOfAnEnum2& seq, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::SeqOfAnEnum2& seq);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::SeqOfAnEnum2& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::SeqOfAnEnum2*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfAnEnum2 */


/* Begin STRUCT: SimpleStruct */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::SimpleStruct& stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::SimpleStruct& stru);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::SimpleStruct& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

class MetaStruct;

template<typename T>
const MetaStruct& getMetaStruct();

template<>
FooLib_Export
const MetaStruct& getMetaStruct<Xyz::SimpleStruct>();
FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::SimpleStruct*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SimpleStruct */


/* Begin STRUCT: StructOfArrayOfSeqOfBoolean */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::StructOfArrayOfSeqOfBoolean& stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfSeqOfBoolean& stru);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::StructOfArrayOfSeqOfBoolean& stru);

FooLib_Export
size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfSeqOfBoolean& stru, bool align);

FooLib_Export
size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfSeqOfBoolean> stru, bool align);

FooLib_Export
void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfSeqOfBoolean> stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfSeqOfBoolean> stru);

FooLib_Export
bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfSeqOfBoolean> stru);

template <>
struct MarshalTraits<Xyz::StructOfArrayOfSeqOfBoolean> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct FooLib_Export StructOfArrayOfSeqOfBoolean_OpenDDS_KeyLessThan {
  bool operator()(const Xyz::StructOfArrayOfSeqOfBoolean&, const Xyz::StructOfArrayOfSeqOfBoolean&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Xyz {
class StructOfArrayOfSeqOfBooleanTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Xyz::StructOfArrayOfSeqOfBoolean> {
  typedef Xyz::StructOfArrayOfSeqOfBoolean MessageType;
  typedef Xyz::StructOfArrayOfSeqOfBooleanSeq MessageSequenceType;
  typedef Xyz::StructOfArrayOfSeqOfBooleanTypeSupport TypeSupportType;
  typedef Xyz::StructOfArrayOfSeqOfBooleanTypeSupportImpl TypeSupportTypeImpl;
  typedef Xyz::StructOfArrayOfSeqOfBooleanDataWriter DataWriterType;
  typedef Xyz::StructOfArrayOfSeqOfBooleanDataReader DataReaderType;
  typedef Xyz::StructOfArrayOfSeqOfBoolean_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Xyz::StructOfArrayOfSeqOfBoolean"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
class FooLib_Export StructOfArrayOfSeqOfBooleanTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<StructOfArrayOfSeqOfBooleanTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<StructOfArrayOfSeqOfBoolean> TraitsType;
  typedef StructOfArrayOfSeqOfBooleanTypeSupport TypeSupportType;
  typedef StructOfArrayOfSeqOfBooleanTypeSupport::_var_type _var_type;
  typedef StructOfArrayOfSeqOfBooleanTypeSupport::_ptr_type _ptr_type;

  StructOfArrayOfSeqOfBooleanTypeSupportImpl() {}
  virtual ~StructOfArrayOfSeqOfBooleanTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static StructOfArrayOfSeqOfBooleanTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
FooLib_Export
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfSeqOfBoolean>();
FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfSeqOfBoolean*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StructOfArrayOfSeqOfBoolean */


/* Begin STRUCT: StructOfArrayOfSeqOfString */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::StructOfArrayOfSeqOfString& stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfSeqOfString& stru);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::StructOfArrayOfSeqOfString& stru);

FooLib_Export
size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfSeqOfString& stru, bool align);

FooLib_Export
size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfSeqOfString> stru, bool align);

FooLib_Export
void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfSeqOfString> stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfSeqOfString> stru);

FooLib_Export
bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfSeqOfString> stru);

template <>
struct MarshalTraits<Xyz::StructOfArrayOfSeqOfString> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct FooLib_Export StructOfArrayOfSeqOfString_OpenDDS_KeyLessThan {
  bool operator()(const Xyz::StructOfArrayOfSeqOfString&, const Xyz::StructOfArrayOfSeqOfString&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Xyz {
class StructOfArrayOfSeqOfStringTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Xyz::StructOfArrayOfSeqOfString> {
  typedef Xyz::StructOfArrayOfSeqOfString MessageType;
  typedef Xyz::StructOfArrayOfSeqOfStringSeq MessageSequenceType;
  typedef Xyz::StructOfArrayOfSeqOfStringTypeSupport TypeSupportType;
  typedef Xyz::StructOfArrayOfSeqOfStringTypeSupportImpl TypeSupportTypeImpl;
  typedef Xyz::StructOfArrayOfSeqOfStringDataWriter DataWriterType;
  typedef Xyz::StructOfArrayOfSeqOfStringDataReader DataReaderType;
  typedef Xyz::StructOfArrayOfSeqOfString_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Xyz::StructOfArrayOfSeqOfString"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
class FooLib_Export StructOfArrayOfSeqOfStringTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<StructOfArrayOfSeqOfStringTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<StructOfArrayOfSeqOfString> TraitsType;
  typedef StructOfArrayOfSeqOfStringTypeSupport TypeSupportType;
  typedef StructOfArrayOfSeqOfStringTypeSupport::_var_type _var_type;
  typedef StructOfArrayOfSeqOfStringTypeSupport::_ptr_type _ptr_type;

  StructOfArrayOfSeqOfStringTypeSupportImpl() {}
  virtual ~StructOfArrayOfSeqOfStringTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static StructOfArrayOfSeqOfStringTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
FooLib_Export
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfSeqOfString>();
FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfSeqOfString*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StructOfArrayOfSeqOfString */


/* Begin STRUCT: StructOfArrayOfSeqOfChar */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::StructOfArrayOfSeqOfChar& stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfSeqOfChar& stru);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::StructOfArrayOfSeqOfChar& stru);

FooLib_Export
size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfSeqOfChar& stru, bool align);

FooLib_Export
size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfSeqOfChar> stru, bool align);

FooLib_Export
void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfSeqOfChar> stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfSeqOfChar> stru);

FooLib_Export
bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfSeqOfChar> stru);

template <>
struct MarshalTraits<Xyz::StructOfArrayOfSeqOfChar> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct FooLib_Export StructOfArrayOfSeqOfChar_OpenDDS_KeyLessThan {
  bool operator()(const Xyz::StructOfArrayOfSeqOfChar&, const Xyz::StructOfArrayOfSeqOfChar&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Xyz {
class StructOfArrayOfSeqOfCharTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Xyz::StructOfArrayOfSeqOfChar> {
  typedef Xyz::StructOfArrayOfSeqOfChar MessageType;
  typedef Xyz::StructOfArrayOfSeqOfCharSeq MessageSequenceType;
  typedef Xyz::StructOfArrayOfSeqOfCharTypeSupport TypeSupportType;
  typedef Xyz::StructOfArrayOfSeqOfCharTypeSupportImpl TypeSupportTypeImpl;
  typedef Xyz::StructOfArrayOfSeqOfCharDataWriter DataWriterType;
  typedef Xyz::StructOfArrayOfSeqOfCharDataReader DataReaderType;
  typedef Xyz::StructOfArrayOfSeqOfChar_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Xyz::StructOfArrayOfSeqOfChar"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
class FooLib_Export StructOfArrayOfSeqOfCharTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<StructOfArrayOfSeqOfCharTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<StructOfArrayOfSeqOfChar> TraitsType;
  typedef StructOfArrayOfSeqOfCharTypeSupport TypeSupportType;
  typedef StructOfArrayOfSeqOfCharTypeSupport::_var_type _var_type;
  typedef StructOfArrayOfSeqOfCharTypeSupport::_ptr_type _ptr_type;

  StructOfArrayOfSeqOfCharTypeSupportImpl() {}
  virtual ~StructOfArrayOfSeqOfCharTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static StructOfArrayOfSeqOfCharTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
FooLib_Export
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfSeqOfChar>();
FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfSeqOfChar*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StructOfArrayOfSeqOfChar */


/* Begin STRUCT: StructOfArrayOfSeqOfOctet */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::StructOfArrayOfSeqOfOctet& stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfSeqOfOctet& stru);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::StructOfArrayOfSeqOfOctet& stru);

FooLib_Export
size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfSeqOfOctet& stru, bool align);

FooLib_Export
size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfSeqOfOctet> stru, bool align);

FooLib_Export
void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfSeqOfOctet> stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfSeqOfOctet> stru);

FooLib_Export
bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfSeqOfOctet> stru);

template <>
struct MarshalTraits<Xyz::StructOfArrayOfSeqOfOctet> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct FooLib_Export StructOfArrayOfSeqOfOctet_OpenDDS_KeyLessThan {
  bool operator()(const Xyz::StructOfArrayOfSeqOfOctet&, const Xyz::StructOfArrayOfSeqOfOctet&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Xyz {
class StructOfArrayOfSeqOfOctetTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Xyz::StructOfArrayOfSeqOfOctet> {
  typedef Xyz::StructOfArrayOfSeqOfOctet MessageType;
  typedef Xyz::StructOfArrayOfSeqOfOctetSeq MessageSequenceType;
  typedef Xyz::StructOfArrayOfSeqOfOctetTypeSupport TypeSupportType;
  typedef Xyz::StructOfArrayOfSeqOfOctetTypeSupportImpl TypeSupportTypeImpl;
  typedef Xyz::StructOfArrayOfSeqOfOctetDataWriter DataWriterType;
  typedef Xyz::StructOfArrayOfSeqOfOctetDataReader DataReaderType;
  typedef Xyz::StructOfArrayOfSeqOfOctet_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Xyz::StructOfArrayOfSeqOfOctet"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
class FooLib_Export StructOfArrayOfSeqOfOctetTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<StructOfArrayOfSeqOfOctetTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<StructOfArrayOfSeqOfOctet> TraitsType;
  typedef StructOfArrayOfSeqOfOctetTypeSupport TypeSupportType;
  typedef StructOfArrayOfSeqOfOctetTypeSupport::_var_type _var_type;
  typedef StructOfArrayOfSeqOfOctetTypeSupport::_ptr_type _ptr_type;

  StructOfArrayOfSeqOfOctetTypeSupportImpl() {}
  virtual ~StructOfArrayOfSeqOfOctetTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static StructOfArrayOfSeqOfOctetTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
FooLib_Export
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfSeqOfOctet>();
FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfSeqOfOctet*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StructOfArrayOfSeqOfOctet */


/* Begin STRUCT: StructOfArrayOfSeqOfLong */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::StructOfArrayOfSeqOfLong& stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfSeqOfLong& stru);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::StructOfArrayOfSeqOfLong& stru);

FooLib_Export
size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfSeqOfLong& stru, bool align);

FooLib_Export
size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfSeqOfLong> stru, bool align);

FooLib_Export
void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfSeqOfLong> stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfSeqOfLong> stru);

FooLib_Export
bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfSeqOfLong> stru);

template <>
struct MarshalTraits<Xyz::StructOfArrayOfSeqOfLong> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct FooLib_Export StructOfArrayOfSeqOfLong_OpenDDS_KeyLessThan {
  bool operator()(const Xyz::StructOfArrayOfSeqOfLong&, const Xyz::StructOfArrayOfSeqOfLong&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Xyz {
class StructOfArrayOfSeqOfLongTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Xyz::StructOfArrayOfSeqOfLong> {
  typedef Xyz::StructOfArrayOfSeqOfLong MessageType;
  typedef Xyz::StructOfArrayOfSeqOfLongSeq MessageSequenceType;
  typedef Xyz::StructOfArrayOfSeqOfLongTypeSupport TypeSupportType;
  typedef Xyz::StructOfArrayOfSeqOfLongTypeSupportImpl TypeSupportTypeImpl;
  typedef Xyz::StructOfArrayOfSeqOfLongDataWriter DataWriterType;
  typedef Xyz::StructOfArrayOfSeqOfLongDataReader DataReaderType;
  typedef Xyz::StructOfArrayOfSeqOfLong_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Xyz::StructOfArrayOfSeqOfLong"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
class FooLib_Export StructOfArrayOfSeqOfLongTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<StructOfArrayOfSeqOfLongTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<StructOfArrayOfSeqOfLong> TraitsType;
  typedef StructOfArrayOfSeqOfLongTypeSupport TypeSupportType;
  typedef StructOfArrayOfSeqOfLongTypeSupport::_var_type _var_type;
  typedef StructOfArrayOfSeqOfLongTypeSupport::_ptr_type _ptr_type;

  StructOfArrayOfSeqOfLongTypeSupportImpl() {}
  virtual ~StructOfArrayOfSeqOfLongTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static StructOfArrayOfSeqOfLongTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
FooLib_Export
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfSeqOfLong>();
FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfSeqOfLong*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StructOfArrayOfSeqOfLong */


/* Begin STRUCT: StructOfArrayOfSeqOfAnEnum */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::StructOfArrayOfSeqOfAnEnum& stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfSeqOfAnEnum& stru);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::StructOfArrayOfSeqOfAnEnum& stru);

FooLib_Export
size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfSeqOfAnEnum& stru, bool align);

FooLib_Export
size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfSeqOfAnEnum> stru, bool align);

FooLib_Export
void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfSeqOfAnEnum> stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfSeqOfAnEnum> stru);

FooLib_Export
bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfSeqOfAnEnum> stru);

template <>
struct MarshalTraits<Xyz::StructOfArrayOfSeqOfAnEnum> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct FooLib_Export StructOfArrayOfSeqOfAnEnum_OpenDDS_KeyLessThan {
  bool operator()(const Xyz::StructOfArrayOfSeqOfAnEnum&, const Xyz::StructOfArrayOfSeqOfAnEnum&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Xyz {
class StructOfArrayOfSeqOfAnEnumTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Xyz::StructOfArrayOfSeqOfAnEnum> {
  typedef Xyz::StructOfArrayOfSeqOfAnEnum MessageType;
  typedef Xyz::StructOfArrayOfSeqOfAnEnumSeq MessageSequenceType;
  typedef Xyz::StructOfArrayOfSeqOfAnEnumTypeSupport TypeSupportType;
  typedef Xyz::StructOfArrayOfSeqOfAnEnumTypeSupportImpl TypeSupportTypeImpl;
  typedef Xyz::StructOfArrayOfSeqOfAnEnumDataWriter DataWriterType;
  typedef Xyz::StructOfArrayOfSeqOfAnEnumDataReader DataReaderType;
  typedef Xyz::StructOfArrayOfSeqOfAnEnum_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Xyz::StructOfArrayOfSeqOfAnEnum"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
class FooLib_Export StructOfArrayOfSeqOfAnEnumTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<StructOfArrayOfSeqOfAnEnumTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<StructOfArrayOfSeqOfAnEnum> TraitsType;
  typedef StructOfArrayOfSeqOfAnEnumTypeSupport TypeSupportType;
  typedef StructOfArrayOfSeqOfAnEnumTypeSupport::_var_type _var_type;
  typedef StructOfArrayOfSeqOfAnEnumTypeSupport::_ptr_type _ptr_type;

  StructOfArrayOfSeqOfAnEnumTypeSupportImpl() {}
  virtual ~StructOfArrayOfSeqOfAnEnumTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static StructOfArrayOfSeqOfAnEnumTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
FooLib_Export
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfSeqOfAnEnum>();
FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfSeqOfAnEnum*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StructOfArrayOfSeqOfAnEnum */

/* End MODULE: Xyz */
#endif /* OPENDDS_IDL_GENERATED_FOODEF3TYPESUPPORTIMPL_H_Q0KCYA */
