// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.2a_p11
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// be/be_codegen.cpp:152

#ifndef _TAO_IDL_BOUNDTEST2TYPESUPPORTC_YPLAQG_H_
#define _TAO_IDL_BOUNDTEST2TYPESUPPORTC_YPLAQG_H_

#include /**/ "ace/pre.h"


#include /**/ "ace/config-all.h"

#if !defined (ACE_LACKS_PRAGMA_ONCE)
# pragma once
#endif /* ACE_LACKS_PRAGMA_ONCE */


#include /**/ "KeyTest_export.h"
#include "tao/ORB.h"
#include "tao/SystemException.h"
#include "tao/Basic_Types.h"
#include "tao/ORB_Constants.h"
#include "dds/DCPS/ZeroCopyInfoSeq_T.h"
#include "dds/DCPS/ZeroCopySeq_T.h"
#include "tao/Object.h"
#include "tao/String_Manager_T.h"
#include "tao/Sequence_T.h"
#include "tao/Objref_VarOut_T.h"
#include "tao/Seq_Var_T.h"
#include "tao/Seq_Out_T.h"
#include "tao/Arg_Traits_T.h"
#include "tao/Basic_Arguments.h"
#include "tao/Special_Basic_Arguments.h"
#include "tao/Any_Insert_Policy_T.h"
#include "tao/Fixed_Size_Argument_T.h"
#include "tao/Var_Size_Argument_T.h"
#include /**/ "tao/Version.h"
#include /**/ "tao/Versioned_Namespace.h"

#include "BoundTest2C.h"
#include "dds/DdsDcpsInfrastructureC.h"
#include "dds/DdsDcpsPublicationC.h"
#include "dds/DdsDcpsSubscriptionExtC.h"
#include "dds/DdsDcpsTopicC.h"
#include "dds/DdsDcpsTypeSupportExtC.h"

#if TAO_MAJOR_VERSION != 2 || TAO_MINOR_VERSION != 2 || TAO_BETA_VERSION != 0
#error This file should be regenerated with TAO_IDL
#endif

#if defined (TAO_EXPORT_MACRO)
#undef TAO_EXPORT_MACRO
#endif
#define TAO_EXPORT_MACRO KeyTest_Export

// TAO_IDL - Generated from
// be/be_visitor_module/module_ch.cpp:38

namespace Bound
{

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:102

  typedef ::TAO::DCPS::ZeroCopyDataSeq< Bound::BoundedSequenceOfBoundedMessage, DCPS_ZERO_COPY_SEQ_DEFAULT_SIZE> BoundedSequenceOfBoundedMessageSeq;
  

  // TAO_IDL - Generated from
  // be/be_interface.cpp:751

#if !defined (_BOUND_BOUNDEDSEQUENCEOFBOUNDEDMESSAGETYPESUPPORT__VAR_OUT_CH_)
#define _BOUND_BOUNDEDSEQUENCEOFBOUNDEDMESSAGETYPESUPPORT__VAR_OUT_CH_

  class BoundedSequenceOfBoundedMessageTypeSupport;
  typedef BoundedSequenceOfBoundedMessageTypeSupport *BoundedSequenceOfBoundedMessageTypeSupport_ptr;

  typedef
    TAO_Objref_Var_T<
        BoundedSequenceOfBoundedMessageTypeSupport
      >
    BoundedSequenceOfBoundedMessageTypeSupport_var;
  
  typedef
    TAO_Objref_Out_T<
        BoundedSequenceOfBoundedMessageTypeSupport
      >
    BoundedSequenceOfBoundedMessageTypeSupport_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:43

  class KeyTest_Export BoundedSequenceOfBoundedMessageTypeSupport
    : public virtual ::OpenDDS::DCPS::TypeSupport
  
  {
  public:

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    typedef BoundedSequenceOfBoundedMessageTypeSupport_ptr _ptr_type;
    typedef BoundedSequenceOfBoundedMessageTypeSupport_var _var_type;
    typedef BoundedSequenceOfBoundedMessageTypeSupport_out _out_type;

    // The static operations.
    static BoundedSequenceOfBoundedMessageTypeSupport_ptr _duplicate (BoundedSequenceOfBoundedMessageTypeSupport_ptr obj);

    static void _tao_release (BoundedSequenceOfBoundedMessageTypeSupport_ptr obj);

    static BoundedSequenceOfBoundedMessageTypeSupport_ptr _narrow (::CORBA::Object_ptr obj);
    static BoundedSequenceOfBoundedMessageTypeSupport_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static BoundedSequenceOfBoundedMessageTypeSupport_ptr _nil (void);

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:140

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  protected:
    // Abstract or local interface only.
    BoundedSequenceOfBoundedMessageTypeSupport (void);

    

    virtual ~BoundedSequenceOfBoundedMessageTypeSupport (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    BoundedSequenceOfBoundedMessageTypeSupport (const BoundedSequenceOfBoundedMessageTypeSupport &);

    void operator= (const BoundedSequenceOfBoundedMessageTypeSupport &);
  };

  // TAO_IDL - Generated from
  // be/be_interface.cpp:751

#if !defined (_BOUND_BOUNDEDSEQUENCEOFBOUNDEDMESSAGEDATAWRITER__VAR_OUT_CH_)
#define _BOUND_BOUNDEDSEQUENCEOFBOUNDEDMESSAGEDATAWRITER__VAR_OUT_CH_

  class BoundedSequenceOfBoundedMessageDataWriter;
  typedef BoundedSequenceOfBoundedMessageDataWriter *BoundedSequenceOfBoundedMessageDataWriter_ptr;

  typedef
    TAO_Objref_Var_T<
        BoundedSequenceOfBoundedMessageDataWriter
      >
    BoundedSequenceOfBoundedMessageDataWriter_var;
  
  typedef
    TAO_Objref_Out_T<
        BoundedSequenceOfBoundedMessageDataWriter
      >
    BoundedSequenceOfBoundedMessageDataWriter_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:43

  class KeyTest_Export BoundedSequenceOfBoundedMessageDataWriter
    : public virtual ::DDS::DataWriter
  
  {
  public:

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    typedef BoundedSequenceOfBoundedMessageDataWriter_ptr _ptr_type;
    typedef BoundedSequenceOfBoundedMessageDataWriter_var _var_type;
    typedef BoundedSequenceOfBoundedMessageDataWriter_out _out_type;

    // The static operations.
    static BoundedSequenceOfBoundedMessageDataWriter_ptr _duplicate (BoundedSequenceOfBoundedMessageDataWriter_ptr obj);

    static void _tao_release (BoundedSequenceOfBoundedMessageDataWriter_ptr obj);

    static BoundedSequenceOfBoundedMessageDataWriter_ptr _narrow (::CORBA::Object_ptr obj);
    static BoundedSequenceOfBoundedMessageDataWriter_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static BoundedSequenceOfBoundedMessageDataWriter_ptr _nil (void);

    virtual ::DDS::InstanceHandle_t register_instance (
      const ::Bound::BoundedSequenceOfBoundedMessage & instance) = 0;

    virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::Bound::BoundedSequenceOfBoundedMessage & instance,
      const ::DDS::Time_t & timestamp) = 0;

    virtual ::DDS::ReturnCode_t unregister_instance (
      const ::Bound::BoundedSequenceOfBoundedMessage & instance,
      ::DDS::InstanceHandle_t handle) = 0;

    virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::Bound::BoundedSequenceOfBoundedMessage & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp) = 0;

    virtual ::DDS::ReturnCode_t write (
      const ::Bound::BoundedSequenceOfBoundedMessage & instance_data,
      ::DDS::InstanceHandle_t handle) = 0;

    virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::Bound::BoundedSequenceOfBoundedMessage & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp) = 0;

    virtual ::DDS::ReturnCode_t dispose (
      const ::Bound::BoundedSequenceOfBoundedMessage & instance_data,
      ::DDS::InstanceHandle_t instance_handle) = 0;

    virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::Bound::BoundedSequenceOfBoundedMessage & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp) = 0;

    virtual ::DDS::ReturnCode_t get_key_value (
      ::Bound::BoundedSequenceOfBoundedMessage & key_holder,
      ::DDS::InstanceHandle_t handle) = 0;

    virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::Bound::BoundedSequenceOfBoundedMessage & instance_data) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:140

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  protected:
    // Abstract or local interface only.
    BoundedSequenceOfBoundedMessageDataWriter (void);

    

    virtual ~BoundedSequenceOfBoundedMessageDataWriter (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    BoundedSequenceOfBoundedMessageDataWriter (const BoundedSequenceOfBoundedMessageDataWriter &);

    void operator= (const BoundedSequenceOfBoundedMessageDataWriter &);
  };

  // TAO_IDL - Generated from
  // be/be_interface.cpp:751

#if !defined (_BOUND_BOUNDEDSEQUENCEOFBOUNDEDMESSAGEDATAREADER__VAR_OUT_CH_)
#define _BOUND_BOUNDEDSEQUENCEOFBOUNDEDMESSAGEDATAREADER__VAR_OUT_CH_

  class BoundedSequenceOfBoundedMessageDataReader;
  typedef BoundedSequenceOfBoundedMessageDataReader *BoundedSequenceOfBoundedMessageDataReader_ptr;

  typedef
    TAO_Objref_Var_T<
        BoundedSequenceOfBoundedMessageDataReader
      >
    BoundedSequenceOfBoundedMessageDataReader_var;
  
  typedef
    TAO_Objref_Out_T<
        BoundedSequenceOfBoundedMessageDataReader
      >
    BoundedSequenceOfBoundedMessageDataReader_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:43

  class KeyTest_Export BoundedSequenceOfBoundedMessageDataReader
    : public virtual ::OpenDDS::DCPS::DataReaderEx
  
  {
  public:

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    typedef BoundedSequenceOfBoundedMessageDataReader_ptr _ptr_type;
    typedef BoundedSequenceOfBoundedMessageDataReader_var _var_type;
    typedef BoundedSequenceOfBoundedMessageDataReader_out _out_type;

    // The static operations.
    static BoundedSequenceOfBoundedMessageDataReader_ptr _duplicate (BoundedSequenceOfBoundedMessageDataReader_ptr obj);

    static void _tao_release (BoundedSequenceOfBoundedMessageDataReader_ptr obj);

    static BoundedSequenceOfBoundedMessageDataReader_ptr _narrow (::CORBA::Object_ptr obj);
    static BoundedSequenceOfBoundedMessageDataReader_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static BoundedSequenceOfBoundedMessageDataReader_ptr _nil (void);

    virtual ::DDS::ReturnCode_t read (
      ::Bound::BoundedSequenceOfBoundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t take (
      ::Bound::BoundedSequenceOfBoundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t read_w_condition (
      ::Bound::BoundedSequenceOfBoundedMessageSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t take_w_condition (
      ::Bound::BoundedSequenceOfBoundedMessageSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t read_next_sample (
      ::Bound::BoundedSequenceOfBoundedMessage & received_data,
      ::DDS::SampleInfo & sample_info) = 0;

    virtual ::DDS::ReturnCode_t take_next_sample (
      ::Bound::BoundedSequenceOfBoundedMessage & received_data,
      ::DDS::SampleInfo & sample_info) = 0;

    virtual ::DDS::ReturnCode_t read_instance (
      ::Bound::BoundedSequenceOfBoundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t take_instance (
      ::Bound::BoundedSequenceOfBoundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t read_instance_w_condition (
      ::Bound::BoundedSequenceOfBoundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t take_instance_w_condition (
      ::Bound::BoundedSequenceOfBoundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t read_next_instance (
      ::Bound::BoundedSequenceOfBoundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t take_next_instance (
      ::Bound::BoundedSequenceOfBoundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::Bound::BoundedSequenceOfBoundedMessageSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::Bound::BoundedSequenceOfBoundedMessageSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t return_loan (
      ::Bound::BoundedSequenceOfBoundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq) = 0;

    virtual ::DDS::ReturnCode_t get_key_value (
      ::Bound::BoundedSequenceOfBoundedMessage & key_holder,
      ::DDS::InstanceHandle_t handle) = 0;

    virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::Bound::BoundedSequenceOfBoundedMessage & instance_data) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:140

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  protected:
    // Abstract or local interface only.
    BoundedSequenceOfBoundedMessageDataReader (void);

    

    virtual ~BoundedSequenceOfBoundedMessageDataReader (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    BoundedSequenceOfBoundedMessageDataReader (const BoundedSequenceOfBoundedMessageDataReader &);

    void operator= (const BoundedSequenceOfBoundedMessageDataReader &);
  };

// TAO_IDL - Generated from
// be/be_visitor_module/module_ch.cpp:67

} // module Bound

// TAO_IDL - Generated from
// be/be_visitor_module/module_ch.cpp:38

namespace Bound
{

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:102

  typedef ::TAO::DCPS::ZeroCopyDataSeq< Bound::UnboundedSequenceOfBoundedMessage, DCPS_ZERO_COPY_SEQ_DEFAULT_SIZE> UnboundedSequenceOfBoundedMessageSeq;
  

  // TAO_IDL - Generated from
  // be/be_interface.cpp:751

#if !defined (_BOUND_UNBOUNDEDSEQUENCEOFBOUNDEDMESSAGETYPESUPPORT__VAR_OUT_CH_)
#define _BOUND_UNBOUNDEDSEQUENCEOFBOUNDEDMESSAGETYPESUPPORT__VAR_OUT_CH_

  class UnboundedSequenceOfBoundedMessageTypeSupport;
  typedef UnboundedSequenceOfBoundedMessageTypeSupport *UnboundedSequenceOfBoundedMessageTypeSupport_ptr;

  typedef
    TAO_Objref_Var_T<
        UnboundedSequenceOfBoundedMessageTypeSupport
      >
    UnboundedSequenceOfBoundedMessageTypeSupport_var;
  
  typedef
    TAO_Objref_Out_T<
        UnboundedSequenceOfBoundedMessageTypeSupport
      >
    UnboundedSequenceOfBoundedMessageTypeSupport_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:43

  class KeyTest_Export UnboundedSequenceOfBoundedMessageTypeSupport
    : public virtual ::OpenDDS::DCPS::TypeSupport
  
  {
  public:

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    typedef UnboundedSequenceOfBoundedMessageTypeSupport_ptr _ptr_type;
    typedef UnboundedSequenceOfBoundedMessageTypeSupport_var _var_type;
    typedef UnboundedSequenceOfBoundedMessageTypeSupport_out _out_type;

    // The static operations.
    static UnboundedSequenceOfBoundedMessageTypeSupport_ptr _duplicate (UnboundedSequenceOfBoundedMessageTypeSupport_ptr obj);

    static void _tao_release (UnboundedSequenceOfBoundedMessageTypeSupport_ptr obj);

    static UnboundedSequenceOfBoundedMessageTypeSupport_ptr _narrow (::CORBA::Object_ptr obj);
    static UnboundedSequenceOfBoundedMessageTypeSupport_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static UnboundedSequenceOfBoundedMessageTypeSupport_ptr _nil (void);

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:140

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  protected:
    // Abstract or local interface only.
    UnboundedSequenceOfBoundedMessageTypeSupport (void);

    

    virtual ~UnboundedSequenceOfBoundedMessageTypeSupport (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    UnboundedSequenceOfBoundedMessageTypeSupport (const UnboundedSequenceOfBoundedMessageTypeSupport &);

    void operator= (const UnboundedSequenceOfBoundedMessageTypeSupport &);
  };

  // TAO_IDL - Generated from
  // be/be_interface.cpp:751

#if !defined (_BOUND_UNBOUNDEDSEQUENCEOFBOUNDEDMESSAGEDATAWRITER__VAR_OUT_CH_)
#define _BOUND_UNBOUNDEDSEQUENCEOFBOUNDEDMESSAGEDATAWRITER__VAR_OUT_CH_

  class UnboundedSequenceOfBoundedMessageDataWriter;
  typedef UnboundedSequenceOfBoundedMessageDataWriter *UnboundedSequenceOfBoundedMessageDataWriter_ptr;

  typedef
    TAO_Objref_Var_T<
        UnboundedSequenceOfBoundedMessageDataWriter
      >
    UnboundedSequenceOfBoundedMessageDataWriter_var;
  
  typedef
    TAO_Objref_Out_T<
        UnboundedSequenceOfBoundedMessageDataWriter
      >
    UnboundedSequenceOfBoundedMessageDataWriter_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:43

  class KeyTest_Export UnboundedSequenceOfBoundedMessageDataWriter
    : public virtual ::DDS::DataWriter
  
  {
  public:

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    typedef UnboundedSequenceOfBoundedMessageDataWriter_ptr _ptr_type;
    typedef UnboundedSequenceOfBoundedMessageDataWriter_var _var_type;
    typedef UnboundedSequenceOfBoundedMessageDataWriter_out _out_type;

    // The static operations.
    static UnboundedSequenceOfBoundedMessageDataWriter_ptr _duplicate (UnboundedSequenceOfBoundedMessageDataWriter_ptr obj);

    static void _tao_release (UnboundedSequenceOfBoundedMessageDataWriter_ptr obj);

    static UnboundedSequenceOfBoundedMessageDataWriter_ptr _narrow (::CORBA::Object_ptr obj);
    static UnboundedSequenceOfBoundedMessageDataWriter_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static UnboundedSequenceOfBoundedMessageDataWriter_ptr _nil (void);

    virtual ::DDS::InstanceHandle_t register_instance (
      const ::Bound::UnboundedSequenceOfBoundedMessage & instance) = 0;

    virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::Bound::UnboundedSequenceOfBoundedMessage & instance,
      const ::DDS::Time_t & timestamp) = 0;

    virtual ::DDS::ReturnCode_t unregister_instance (
      const ::Bound::UnboundedSequenceOfBoundedMessage & instance,
      ::DDS::InstanceHandle_t handle) = 0;

    virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::Bound::UnboundedSequenceOfBoundedMessage & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp) = 0;

    virtual ::DDS::ReturnCode_t write (
      const ::Bound::UnboundedSequenceOfBoundedMessage & instance_data,
      ::DDS::InstanceHandle_t handle) = 0;

    virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::Bound::UnboundedSequenceOfBoundedMessage & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp) = 0;

    virtual ::DDS::ReturnCode_t dispose (
      const ::Bound::UnboundedSequenceOfBoundedMessage & instance_data,
      ::DDS::InstanceHandle_t instance_handle) = 0;

    virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::Bound::UnboundedSequenceOfBoundedMessage & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp) = 0;

    virtual ::DDS::ReturnCode_t get_key_value (
      ::Bound::UnboundedSequenceOfBoundedMessage & key_holder,
      ::DDS::InstanceHandle_t handle) = 0;

    virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::Bound::UnboundedSequenceOfBoundedMessage & instance_data) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:140

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  protected:
    // Abstract or local interface only.
    UnboundedSequenceOfBoundedMessageDataWriter (void);

    

    virtual ~UnboundedSequenceOfBoundedMessageDataWriter (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    UnboundedSequenceOfBoundedMessageDataWriter (const UnboundedSequenceOfBoundedMessageDataWriter &);

    void operator= (const UnboundedSequenceOfBoundedMessageDataWriter &);
  };

  // TAO_IDL - Generated from
  // be/be_interface.cpp:751

#if !defined (_BOUND_UNBOUNDEDSEQUENCEOFBOUNDEDMESSAGEDATAREADER__VAR_OUT_CH_)
#define _BOUND_UNBOUNDEDSEQUENCEOFBOUNDEDMESSAGEDATAREADER__VAR_OUT_CH_

  class UnboundedSequenceOfBoundedMessageDataReader;
  typedef UnboundedSequenceOfBoundedMessageDataReader *UnboundedSequenceOfBoundedMessageDataReader_ptr;

  typedef
    TAO_Objref_Var_T<
        UnboundedSequenceOfBoundedMessageDataReader
      >
    UnboundedSequenceOfBoundedMessageDataReader_var;
  
  typedef
    TAO_Objref_Out_T<
        UnboundedSequenceOfBoundedMessageDataReader
      >
    UnboundedSequenceOfBoundedMessageDataReader_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:43

  class KeyTest_Export UnboundedSequenceOfBoundedMessageDataReader
    : public virtual ::OpenDDS::DCPS::DataReaderEx
  
  {
  public:

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    typedef UnboundedSequenceOfBoundedMessageDataReader_ptr _ptr_type;
    typedef UnboundedSequenceOfBoundedMessageDataReader_var _var_type;
    typedef UnboundedSequenceOfBoundedMessageDataReader_out _out_type;

    // The static operations.
    static UnboundedSequenceOfBoundedMessageDataReader_ptr _duplicate (UnboundedSequenceOfBoundedMessageDataReader_ptr obj);

    static void _tao_release (UnboundedSequenceOfBoundedMessageDataReader_ptr obj);

    static UnboundedSequenceOfBoundedMessageDataReader_ptr _narrow (::CORBA::Object_ptr obj);
    static UnboundedSequenceOfBoundedMessageDataReader_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static UnboundedSequenceOfBoundedMessageDataReader_ptr _nil (void);

    virtual ::DDS::ReturnCode_t read (
      ::Bound::UnboundedSequenceOfBoundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t take (
      ::Bound::UnboundedSequenceOfBoundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t read_w_condition (
      ::Bound::UnboundedSequenceOfBoundedMessageSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t take_w_condition (
      ::Bound::UnboundedSequenceOfBoundedMessageSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t read_next_sample (
      ::Bound::UnboundedSequenceOfBoundedMessage & received_data,
      ::DDS::SampleInfo & sample_info) = 0;

    virtual ::DDS::ReturnCode_t take_next_sample (
      ::Bound::UnboundedSequenceOfBoundedMessage & received_data,
      ::DDS::SampleInfo & sample_info) = 0;

    virtual ::DDS::ReturnCode_t read_instance (
      ::Bound::UnboundedSequenceOfBoundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t take_instance (
      ::Bound::UnboundedSequenceOfBoundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t read_instance_w_condition (
      ::Bound::UnboundedSequenceOfBoundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t take_instance_w_condition (
      ::Bound::UnboundedSequenceOfBoundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t read_next_instance (
      ::Bound::UnboundedSequenceOfBoundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t take_next_instance (
      ::Bound::UnboundedSequenceOfBoundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::Bound::UnboundedSequenceOfBoundedMessageSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::Bound::UnboundedSequenceOfBoundedMessageSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t return_loan (
      ::Bound::UnboundedSequenceOfBoundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq) = 0;

    virtual ::DDS::ReturnCode_t get_key_value (
      ::Bound::UnboundedSequenceOfBoundedMessage & key_holder,
      ::DDS::InstanceHandle_t handle) = 0;

    virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::Bound::UnboundedSequenceOfBoundedMessage & instance_data) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:140

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  protected:
    // Abstract or local interface only.
    UnboundedSequenceOfBoundedMessageDataReader (void);

    

    virtual ~UnboundedSequenceOfBoundedMessageDataReader (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    UnboundedSequenceOfBoundedMessageDataReader (const UnboundedSequenceOfBoundedMessageDataReader &);

    void operator= (const UnboundedSequenceOfBoundedMessageDataReader &);
  };

// TAO_IDL - Generated from
// be/be_visitor_module/module_ch.cpp:67

} // module Bound

// TAO_IDL - Generated from
// be/be_visitor_module/module_ch.cpp:38

namespace Bound
{

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:102

  typedef ::TAO::DCPS::ZeroCopyDataSeq< Bound::BoundedSequenceOfUnboundedMessage, DCPS_ZERO_COPY_SEQ_DEFAULT_SIZE> BoundedSequenceOfUnboundedMessageSeq;
  

  // TAO_IDL - Generated from
  // be/be_interface.cpp:751

#if !defined (_BOUND_BOUNDEDSEQUENCEOFUNBOUNDEDMESSAGETYPESUPPORT__VAR_OUT_CH_)
#define _BOUND_BOUNDEDSEQUENCEOFUNBOUNDEDMESSAGETYPESUPPORT__VAR_OUT_CH_

  class BoundedSequenceOfUnboundedMessageTypeSupport;
  typedef BoundedSequenceOfUnboundedMessageTypeSupport *BoundedSequenceOfUnboundedMessageTypeSupport_ptr;

  typedef
    TAO_Objref_Var_T<
        BoundedSequenceOfUnboundedMessageTypeSupport
      >
    BoundedSequenceOfUnboundedMessageTypeSupport_var;
  
  typedef
    TAO_Objref_Out_T<
        BoundedSequenceOfUnboundedMessageTypeSupport
      >
    BoundedSequenceOfUnboundedMessageTypeSupport_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:43

  class KeyTest_Export BoundedSequenceOfUnboundedMessageTypeSupport
    : public virtual ::OpenDDS::DCPS::TypeSupport
  
  {
  public:

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    typedef BoundedSequenceOfUnboundedMessageTypeSupport_ptr _ptr_type;
    typedef BoundedSequenceOfUnboundedMessageTypeSupport_var _var_type;
    typedef BoundedSequenceOfUnboundedMessageTypeSupport_out _out_type;

    // The static operations.
    static BoundedSequenceOfUnboundedMessageTypeSupport_ptr _duplicate (BoundedSequenceOfUnboundedMessageTypeSupport_ptr obj);

    static void _tao_release (BoundedSequenceOfUnboundedMessageTypeSupport_ptr obj);

    static BoundedSequenceOfUnboundedMessageTypeSupport_ptr _narrow (::CORBA::Object_ptr obj);
    static BoundedSequenceOfUnboundedMessageTypeSupport_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static BoundedSequenceOfUnboundedMessageTypeSupport_ptr _nil (void);

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:140

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  protected:
    // Abstract or local interface only.
    BoundedSequenceOfUnboundedMessageTypeSupport (void);

    

    virtual ~BoundedSequenceOfUnboundedMessageTypeSupport (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    BoundedSequenceOfUnboundedMessageTypeSupport (const BoundedSequenceOfUnboundedMessageTypeSupport &);

    void operator= (const BoundedSequenceOfUnboundedMessageTypeSupport &);
  };

  // TAO_IDL - Generated from
  // be/be_interface.cpp:751

#if !defined (_BOUND_BOUNDEDSEQUENCEOFUNBOUNDEDMESSAGEDATAWRITER__VAR_OUT_CH_)
#define _BOUND_BOUNDEDSEQUENCEOFUNBOUNDEDMESSAGEDATAWRITER__VAR_OUT_CH_

  class BoundedSequenceOfUnboundedMessageDataWriter;
  typedef BoundedSequenceOfUnboundedMessageDataWriter *BoundedSequenceOfUnboundedMessageDataWriter_ptr;

  typedef
    TAO_Objref_Var_T<
        BoundedSequenceOfUnboundedMessageDataWriter
      >
    BoundedSequenceOfUnboundedMessageDataWriter_var;
  
  typedef
    TAO_Objref_Out_T<
        BoundedSequenceOfUnboundedMessageDataWriter
      >
    BoundedSequenceOfUnboundedMessageDataWriter_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:43

  class KeyTest_Export BoundedSequenceOfUnboundedMessageDataWriter
    : public virtual ::DDS::DataWriter
  
  {
  public:

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    typedef BoundedSequenceOfUnboundedMessageDataWriter_ptr _ptr_type;
    typedef BoundedSequenceOfUnboundedMessageDataWriter_var _var_type;
    typedef BoundedSequenceOfUnboundedMessageDataWriter_out _out_type;

    // The static operations.
    static BoundedSequenceOfUnboundedMessageDataWriter_ptr _duplicate (BoundedSequenceOfUnboundedMessageDataWriter_ptr obj);

    static void _tao_release (BoundedSequenceOfUnboundedMessageDataWriter_ptr obj);

    static BoundedSequenceOfUnboundedMessageDataWriter_ptr _narrow (::CORBA::Object_ptr obj);
    static BoundedSequenceOfUnboundedMessageDataWriter_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static BoundedSequenceOfUnboundedMessageDataWriter_ptr _nil (void);

    virtual ::DDS::InstanceHandle_t register_instance (
      const ::Bound::BoundedSequenceOfUnboundedMessage & instance) = 0;

    virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::Bound::BoundedSequenceOfUnboundedMessage & instance,
      const ::DDS::Time_t & timestamp) = 0;

    virtual ::DDS::ReturnCode_t unregister_instance (
      const ::Bound::BoundedSequenceOfUnboundedMessage & instance,
      ::DDS::InstanceHandle_t handle) = 0;

    virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::Bound::BoundedSequenceOfUnboundedMessage & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp) = 0;

    virtual ::DDS::ReturnCode_t write (
      const ::Bound::BoundedSequenceOfUnboundedMessage & instance_data,
      ::DDS::InstanceHandle_t handle) = 0;

    virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::Bound::BoundedSequenceOfUnboundedMessage & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp) = 0;

    virtual ::DDS::ReturnCode_t dispose (
      const ::Bound::BoundedSequenceOfUnboundedMessage & instance_data,
      ::DDS::InstanceHandle_t instance_handle) = 0;

    virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::Bound::BoundedSequenceOfUnboundedMessage & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp) = 0;

    virtual ::DDS::ReturnCode_t get_key_value (
      ::Bound::BoundedSequenceOfUnboundedMessage & key_holder,
      ::DDS::InstanceHandle_t handle) = 0;

    virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::Bound::BoundedSequenceOfUnboundedMessage & instance_data) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:140

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  protected:
    // Abstract or local interface only.
    BoundedSequenceOfUnboundedMessageDataWriter (void);

    

    virtual ~BoundedSequenceOfUnboundedMessageDataWriter (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    BoundedSequenceOfUnboundedMessageDataWriter (const BoundedSequenceOfUnboundedMessageDataWriter &);

    void operator= (const BoundedSequenceOfUnboundedMessageDataWriter &);
  };

  // TAO_IDL - Generated from
  // be/be_interface.cpp:751

#if !defined (_BOUND_BOUNDEDSEQUENCEOFUNBOUNDEDMESSAGEDATAREADER__VAR_OUT_CH_)
#define _BOUND_BOUNDEDSEQUENCEOFUNBOUNDEDMESSAGEDATAREADER__VAR_OUT_CH_

  class BoundedSequenceOfUnboundedMessageDataReader;
  typedef BoundedSequenceOfUnboundedMessageDataReader *BoundedSequenceOfUnboundedMessageDataReader_ptr;

  typedef
    TAO_Objref_Var_T<
        BoundedSequenceOfUnboundedMessageDataReader
      >
    BoundedSequenceOfUnboundedMessageDataReader_var;
  
  typedef
    TAO_Objref_Out_T<
        BoundedSequenceOfUnboundedMessageDataReader
      >
    BoundedSequenceOfUnboundedMessageDataReader_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:43

  class KeyTest_Export BoundedSequenceOfUnboundedMessageDataReader
    : public virtual ::OpenDDS::DCPS::DataReaderEx
  
  {
  public:

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    typedef BoundedSequenceOfUnboundedMessageDataReader_ptr _ptr_type;
    typedef BoundedSequenceOfUnboundedMessageDataReader_var _var_type;
    typedef BoundedSequenceOfUnboundedMessageDataReader_out _out_type;

    // The static operations.
    static BoundedSequenceOfUnboundedMessageDataReader_ptr _duplicate (BoundedSequenceOfUnboundedMessageDataReader_ptr obj);

    static void _tao_release (BoundedSequenceOfUnboundedMessageDataReader_ptr obj);

    static BoundedSequenceOfUnboundedMessageDataReader_ptr _narrow (::CORBA::Object_ptr obj);
    static BoundedSequenceOfUnboundedMessageDataReader_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static BoundedSequenceOfUnboundedMessageDataReader_ptr _nil (void);

    virtual ::DDS::ReturnCode_t read (
      ::Bound::BoundedSequenceOfUnboundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t take (
      ::Bound::BoundedSequenceOfUnboundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t read_w_condition (
      ::Bound::BoundedSequenceOfUnboundedMessageSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t take_w_condition (
      ::Bound::BoundedSequenceOfUnboundedMessageSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t read_next_sample (
      ::Bound::BoundedSequenceOfUnboundedMessage & received_data,
      ::DDS::SampleInfo & sample_info) = 0;

    virtual ::DDS::ReturnCode_t take_next_sample (
      ::Bound::BoundedSequenceOfUnboundedMessage & received_data,
      ::DDS::SampleInfo & sample_info) = 0;

    virtual ::DDS::ReturnCode_t read_instance (
      ::Bound::BoundedSequenceOfUnboundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t take_instance (
      ::Bound::BoundedSequenceOfUnboundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t read_instance_w_condition (
      ::Bound::BoundedSequenceOfUnboundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t take_instance_w_condition (
      ::Bound::BoundedSequenceOfUnboundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t read_next_instance (
      ::Bound::BoundedSequenceOfUnboundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t take_next_instance (
      ::Bound::BoundedSequenceOfUnboundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::Bound::BoundedSequenceOfUnboundedMessageSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::Bound::BoundedSequenceOfUnboundedMessageSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t return_loan (
      ::Bound::BoundedSequenceOfUnboundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq) = 0;

    virtual ::DDS::ReturnCode_t get_key_value (
      ::Bound::BoundedSequenceOfUnboundedMessage & key_holder,
      ::DDS::InstanceHandle_t handle) = 0;

    virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::Bound::BoundedSequenceOfUnboundedMessage & instance_data) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:140

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  protected:
    // Abstract or local interface only.
    BoundedSequenceOfUnboundedMessageDataReader (void);

    

    virtual ~BoundedSequenceOfUnboundedMessageDataReader (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    BoundedSequenceOfUnboundedMessageDataReader (const BoundedSequenceOfUnboundedMessageDataReader &);

    void operator= (const BoundedSequenceOfUnboundedMessageDataReader &);
  };

// TAO_IDL - Generated from
// be/be_visitor_module/module_ch.cpp:67

} // module Bound

// TAO_IDL - Generated from
// be/be_visitor_module/module_ch.cpp:38

namespace Bound
{

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:102

  typedef ::TAO::DCPS::ZeroCopyDataSeq< Bound::UnboundedSequenceOfUnboundedMessage, DCPS_ZERO_COPY_SEQ_DEFAULT_SIZE> UnboundedSequenceOfUnboundedMessageSeq;
  

  // TAO_IDL - Generated from
  // be/be_interface.cpp:751

#if !defined (_BOUND_UNBOUNDEDSEQUENCEOFUNBOUNDEDMESSAGETYPESUPPORT__VAR_OUT_CH_)
#define _BOUND_UNBOUNDEDSEQUENCEOFUNBOUNDEDMESSAGETYPESUPPORT__VAR_OUT_CH_

  class UnboundedSequenceOfUnboundedMessageTypeSupport;
  typedef UnboundedSequenceOfUnboundedMessageTypeSupport *UnboundedSequenceOfUnboundedMessageTypeSupport_ptr;

  typedef
    TAO_Objref_Var_T<
        UnboundedSequenceOfUnboundedMessageTypeSupport
      >
    UnboundedSequenceOfUnboundedMessageTypeSupport_var;
  
  typedef
    TAO_Objref_Out_T<
        UnboundedSequenceOfUnboundedMessageTypeSupport
      >
    UnboundedSequenceOfUnboundedMessageTypeSupport_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:43

  class KeyTest_Export UnboundedSequenceOfUnboundedMessageTypeSupport
    : public virtual ::OpenDDS::DCPS::TypeSupport
  
  {
  public:

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    typedef UnboundedSequenceOfUnboundedMessageTypeSupport_ptr _ptr_type;
    typedef UnboundedSequenceOfUnboundedMessageTypeSupport_var _var_type;
    typedef UnboundedSequenceOfUnboundedMessageTypeSupport_out _out_type;

    // The static operations.
    static UnboundedSequenceOfUnboundedMessageTypeSupport_ptr _duplicate (UnboundedSequenceOfUnboundedMessageTypeSupport_ptr obj);

    static void _tao_release (UnboundedSequenceOfUnboundedMessageTypeSupport_ptr obj);

    static UnboundedSequenceOfUnboundedMessageTypeSupport_ptr _narrow (::CORBA::Object_ptr obj);
    static UnboundedSequenceOfUnboundedMessageTypeSupport_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static UnboundedSequenceOfUnboundedMessageTypeSupport_ptr _nil (void);

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:140

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  protected:
    // Abstract or local interface only.
    UnboundedSequenceOfUnboundedMessageTypeSupport (void);

    

    virtual ~UnboundedSequenceOfUnboundedMessageTypeSupport (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    UnboundedSequenceOfUnboundedMessageTypeSupport (const UnboundedSequenceOfUnboundedMessageTypeSupport &);

    void operator= (const UnboundedSequenceOfUnboundedMessageTypeSupport &);
  };

  // TAO_IDL - Generated from
  // be/be_interface.cpp:751

#if !defined (_BOUND_UNBOUNDEDSEQUENCEOFUNBOUNDEDMESSAGEDATAWRITER__VAR_OUT_CH_)
#define _BOUND_UNBOUNDEDSEQUENCEOFUNBOUNDEDMESSAGEDATAWRITER__VAR_OUT_CH_

  class UnboundedSequenceOfUnboundedMessageDataWriter;
  typedef UnboundedSequenceOfUnboundedMessageDataWriter *UnboundedSequenceOfUnboundedMessageDataWriter_ptr;

  typedef
    TAO_Objref_Var_T<
        UnboundedSequenceOfUnboundedMessageDataWriter
      >
    UnboundedSequenceOfUnboundedMessageDataWriter_var;
  
  typedef
    TAO_Objref_Out_T<
        UnboundedSequenceOfUnboundedMessageDataWriter
      >
    UnboundedSequenceOfUnboundedMessageDataWriter_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:43

  class KeyTest_Export UnboundedSequenceOfUnboundedMessageDataWriter
    : public virtual ::DDS::DataWriter
  
  {
  public:

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    typedef UnboundedSequenceOfUnboundedMessageDataWriter_ptr _ptr_type;
    typedef UnboundedSequenceOfUnboundedMessageDataWriter_var _var_type;
    typedef UnboundedSequenceOfUnboundedMessageDataWriter_out _out_type;

    // The static operations.
    static UnboundedSequenceOfUnboundedMessageDataWriter_ptr _duplicate (UnboundedSequenceOfUnboundedMessageDataWriter_ptr obj);

    static void _tao_release (UnboundedSequenceOfUnboundedMessageDataWriter_ptr obj);

    static UnboundedSequenceOfUnboundedMessageDataWriter_ptr _narrow (::CORBA::Object_ptr obj);
    static UnboundedSequenceOfUnboundedMessageDataWriter_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static UnboundedSequenceOfUnboundedMessageDataWriter_ptr _nil (void);

    virtual ::DDS::InstanceHandle_t register_instance (
      const ::Bound::UnboundedSequenceOfUnboundedMessage & instance) = 0;

    virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::Bound::UnboundedSequenceOfUnboundedMessage & instance,
      const ::DDS::Time_t & timestamp) = 0;

    virtual ::DDS::ReturnCode_t unregister_instance (
      const ::Bound::UnboundedSequenceOfUnboundedMessage & instance,
      ::DDS::InstanceHandle_t handle) = 0;

    virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::Bound::UnboundedSequenceOfUnboundedMessage & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp) = 0;

    virtual ::DDS::ReturnCode_t write (
      const ::Bound::UnboundedSequenceOfUnboundedMessage & instance_data,
      ::DDS::InstanceHandle_t handle) = 0;

    virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::Bound::UnboundedSequenceOfUnboundedMessage & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp) = 0;

    virtual ::DDS::ReturnCode_t dispose (
      const ::Bound::UnboundedSequenceOfUnboundedMessage & instance_data,
      ::DDS::InstanceHandle_t instance_handle) = 0;

    virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::Bound::UnboundedSequenceOfUnboundedMessage & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp) = 0;

    virtual ::DDS::ReturnCode_t get_key_value (
      ::Bound::UnboundedSequenceOfUnboundedMessage & key_holder,
      ::DDS::InstanceHandle_t handle) = 0;

    virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::Bound::UnboundedSequenceOfUnboundedMessage & instance_data) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:140

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  protected:
    // Abstract or local interface only.
    UnboundedSequenceOfUnboundedMessageDataWriter (void);

    

    virtual ~UnboundedSequenceOfUnboundedMessageDataWriter (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    UnboundedSequenceOfUnboundedMessageDataWriter (const UnboundedSequenceOfUnboundedMessageDataWriter &);

    void operator= (const UnboundedSequenceOfUnboundedMessageDataWriter &);
  };

  // TAO_IDL - Generated from
  // be/be_interface.cpp:751

#if !defined (_BOUND_UNBOUNDEDSEQUENCEOFUNBOUNDEDMESSAGEDATAREADER__VAR_OUT_CH_)
#define _BOUND_UNBOUNDEDSEQUENCEOFUNBOUNDEDMESSAGEDATAREADER__VAR_OUT_CH_

  class UnboundedSequenceOfUnboundedMessageDataReader;
  typedef UnboundedSequenceOfUnboundedMessageDataReader *UnboundedSequenceOfUnboundedMessageDataReader_ptr;

  typedef
    TAO_Objref_Var_T<
        UnboundedSequenceOfUnboundedMessageDataReader
      >
    UnboundedSequenceOfUnboundedMessageDataReader_var;
  
  typedef
    TAO_Objref_Out_T<
        UnboundedSequenceOfUnboundedMessageDataReader
      >
    UnboundedSequenceOfUnboundedMessageDataReader_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:43

  class KeyTest_Export UnboundedSequenceOfUnboundedMessageDataReader
    : public virtual ::OpenDDS::DCPS::DataReaderEx
  
  {
  public:

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    typedef UnboundedSequenceOfUnboundedMessageDataReader_ptr _ptr_type;
    typedef UnboundedSequenceOfUnboundedMessageDataReader_var _var_type;
    typedef UnboundedSequenceOfUnboundedMessageDataReader_out _out_type;

    // The static operations.
    static UnboundedSequenceOfUnboundedMessageDataReader_ptr _duplicate (UnboundedSequenceOfUnboundedMessageDataReader_ptr obj);

    static void _tao_release (UnboundedSequenceOfUnboundedMessageDataReader_ptr obj);

    static UnboundedSequenceOfUnboundedMessageDataReader_ptr _narrow (::CORBA::Object_ptr obj);
    static UnboundedSequenceOfUnboundedMessageDataReader_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static UnboundedSequenceOfUnboundedMessageDataReader_ptr _nil (void);

    virtual ::DDS::ReturnCode_t read (
      ::Bound::UnboundedSequenceOfUnboundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t take (
      ::Bound::UnboundedSequenceOfUnboundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t read_w_condition (
      ::Bound::UnboundedSequenceOfUnboundedMessageSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t take_w_condition (
      ::Bound::UnboundedSequenceOfUnboundedMessageSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t read_next_sample (
      ::Bound::UnboundedSequenceOfUnboundedMessage & received_data,
      ::DDS::SampleInfo & sample_info) = 0;

    virtual ::DDS::ReturnCode_t take_next_sample (
      ::Bound::UnboundedSequenceOfUnboundedMessage & received_data,
      ::DDS::SampleInfo & sample_info) = 0;

    virtual ::DDS::ReturnCode_t read_instance (
      ::Bound::UnboundedSequenceOfUnboundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t take_instance (
      ::Bound::UnboundedSequenceOfUnboundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t read_instance_w_condition (
      ::Bound::UnboundedSequenceOfUnboundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t take_instance_w_condition (
      ::Bound::UnboundedSequenceOfUnboundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t read_next_instance (
      ::Bound::UnboundedSequenceOfUnboundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t take_next_instance (
      ::Bound::UnboundedSequenceOfUnboundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::Bound::UnboundedSequenceOfUnboundedMessageSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::Bound::UnboundedSequenceOfUnboundedMessageSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t return_loan (
      ::Bound::UnboundedSequenceOfUnboundedMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq) = 0;

    virtual ::DDS::ReturnCode_t get_key_value (
      ::Bound::UnboundedSequenceOfUnboundedMessage & key_holder,
      ::DDS::InstanceHandle_t handle) = 0;

    virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::Bound::UnboundedSequenceOfUnboundedMessage & instance_data) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:140

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  protected:
    // Abstract or local interface only.
    UnboundedSequenceOfUnboundedMessageDataReader (void);

    

    virtual ~UnboundedSequenceOfUnboundedMessageDataReader (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    UnboundedSequenceOfUnboundedMessageDataReader (const UnboundedSequenceOfUnboundedMessageDataReader &);

    void operator= (const UnboundedSequenceOfUnboundedMessageDataReader &);
  };

// TAO_IDL - Generated from
// be/be_visitor_module/module_ch.cpp:67

} // module Bound

// TAO_IDL - Generated from
// be/be_visitor_module/module_ch.cpp:38

namespace Bound
{

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:102

  typedef ::TAO::DCPS::ZeroCopyDataSeq< Bound::BoundedUnionMessage, DCPS_ZERO_COPY_SEQ_DEFAULT_SIZE> BoundedUnionMessageSeq;
  

  // TAO_IDL - Generated from
  // be/be_interface.cpp:751

#if !defined (_BOUND_BOUNDEDUNIONMESSAGETYPESUPPORT__VAR_OUT_CH_)
#define _BOUND_BOUNDEDUNIONMESSAGETYPESUPPORT__VAR_OUT_CH_

  class BoundedUnionMessageTypeSupport;
  typedef BoundedUnionMessageTypeSupport *BoundedUnionMessageTypeSupport_ptr;

  typedef
    TAO_Objref_Var_T<
        BoundedUnionMessageTypeSupport
      >
    BoundedUnionMessageTypeSupport_var;
  
  typedef
    TAO_Objref_Out_T<
        BoundedUnionMessageTypeSupport
      >
    BoundedUnionMessageTypeSupport_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:43

  class KeyTest_Export BoundedUnionMessageTypeSupport
    : public virtual ::OpenDDS::DCPS::TypeSupport
  
  {
  public:

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    typedef BoundedUnionMessageTypeSupport_ptr _ptr_type;
    typedef BoundedUnionMessageTypeSupport_var _var_type;
    typedef BoundedUnionMessageTypeSupport_out _out_type;

    // The static operations.
    static BoundedUnionMessageTypeSupport_ptr _duplicate (BoundedUnionMessageTypeSupport_ptr obj);

    static void _tao_release (BoundedUnionMessageTypeSupport_ptr obj);

    static BoundedUnionMessageTypeSupport_ptr _narrow (::CORBA::Object_ptr obj);
    static BoundedUnionMessageTypeSupport_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static BoundedUnionMessageTypeSupport_ptr _nil (void);

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:140

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  protected:
    // Abstract or local interface only.
    BoundedUnionMessageTypeSupport (void);

    

    virtual ~BoundedUnionMessageTypeSupport (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    BoundedUnionMessageTypeSupport (const BoundedUnionMessageTypeSupport &);

    void operator= (const BoundedUnionMessageTypeSupport &);
  };

  // TAO_IDL - Generated from
  // be/be_interface.cpp:751

#if !defined (_BOUND_BOUNDEDUNIONMESSAGEDATAWRITER__VAR_OUT_CH_)
#define _BOUND_BOUNDEDUNIONMESSAGEDATAWRITER__VAR_OUT_CH_

  class BoundedUnionMessageDataWriter;
  typedef BoundedUnionMessageDataWriter *BoundedUnionMessageDataWriter_ptr;

  typedef
    TAO_Objref_Var_T<
        BoundedUnionMessageDataWriter
      >
    BoundedUnionMessageDataWriter_var;
  
  typedef
    TAO_Objref_Out_T<
        BoundedUnionMessageDataWriter
      >
    BoundedUnionMessageDataWriter_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:43

  class KeyTest_Export BoundedUnionMessageDataWriter
    : public virtual ::DDS::DataWriter
  
  {
  public:

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    typedef BoundedUnionMessageDataWriter_ptr _ptr_type;
    typedef BoundedUnionMessageDataWriter_var _var_type;
    typedef BoundedUnionMessageDataWriter_out _out_type;

    // The static operations.
    static BoundedUnionMessageDataWriter_ptr _duplicate (BoundedUnionMessageDataWriter_ptr obj);

    static void _tao_release (BoundedUnionMessageDataWriter_ptr obj);

    static BoundedUnionMessageDataWriter_ptr _narrow (::CORBA::Object_ptr obj);
    static BoundedUnionMessageDataWriter_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static BoundedUnionMessageDataWriter_ptr _nil (void);

    virtual ::DDS::InstanceHandle_t register_instance (
      const ::Bound::BoundedUnionMessage & instance) = 0;

    virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::Bound::BoundedUnionMessage & instance,
      const ::DDS::Time_t & timestamp) = 0;

    virtual ::DDS::ReturnCode_t unregister_instance (
      const ::Bound::BoundedUnionMessage & instance,
      ::DDS::InstanceHandle_t handle) = 0;

    virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::Bound::BoundedUnionMessage & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp) = 0;

    virtual ::DDS::ReturnCode_t write (
      const ::Bound::BoundedUnionMessage & instance_data,
      ::DDS::InstanceHandle_t handle) = 0;

    virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::Bound::BoundedUnionMessage & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp) = 0;

    virtual ::DDS::ReturnCode_t dispose (
      const ::Bound::BoundedUnionMessage & instance_data,
      ::DDS::InstanceHandle_t instance_handle) = 0;

    virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::Bound::BoundedUnionMessage & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp) = 0;

    virtual ::DDS::ReturnCode_t get_key_value (
      ::Bound::BoundedUnionMessage & key_holder,
      ::DDS::InstanceHandle_t handle) = 0;

    virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::Bound::BoundedUnionMessage & instance_data) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:140

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  protected:
    // Abstract or local interface only.
    BoundedUnionMessageDataWriter (void);

    

    virtual ~BoundedUnionMessageDataWriter (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    BoundedUnionMessageDataWriter (const BoundedUnionMessageDataWriter &);

    void operator= (const BoundedUnionMessageDataWriter &);
  };

  // TAO_IDL - Generated from
  // be/be_interface.cpp:751

#if !defined (_BOUND_BOUNDEDUNIONMESSAGEDATAREADER__VAR_OUT_CH_)
#define _BOUND_BOUNDEDUNIONMESSAGEDATAREADER__VAR_OUT_CH_

  class BoundedUnionMessageDataReader;
  typedef BoundedUnionMessageDataReader *BoundedUnionMessageDataReader_ptr;

  typedef
    TAO_Objref_Var_T<
        BoundedUnionMessageDataReader
      >
    BoundedUnionMessageDataReader_var;
  
  typedef
    TAO_Objref_Out_T<
        BoundedUnionMessageDataReader
      >
    BoundedUnionMessageDataReader_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:43

  class KeyTest_Export BoundedUnionMessageDataReader
    : public virtual ::OpenDDS::DCPS::DataReaderEx
  
  {
  public:

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    typedef BoundedUnionMessageDataReader_ptr _ptr_type;
    typedef BoundedUnionMessageDataReader_var _var_type;
    typedef BoundedUnionMessageDataReader_out _out_type;

    // The static operations.
    static BoundedUnionMessageDataReader_ptr _duplicate (BoundedUnionMessageDataReader_ptr obj);

    static void _tao_release (BoundedUnionMessageDataReader_ptr obj);

    static BoundedUnionMessageDataReader_ptr _narrow (::CORBA::Object_ptr obj);
    static BoundedUnionMessageDataReader_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static BoundedUnionMessageDataReader_ptr _nil (void);

    virtual ::DDS::ReturnCode_t read (
      ::Bound::BoundedUnionMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t take (
      ::Bound::BoundedUnionMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t read_w_condition (
      ::Bound::BoundedUnionMessageSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t take_w_condition (
      ::Bound::BoundedUnionMessageSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t read_next_sample (
      ::Bound::BoundedUnionMessage & received_data,
      ::DDS::SampleInfo & sample_info) = 0;

    virtual ::DDS::ReturnCode_t take_next_sample (
      ::Bound::BoundedUnionMessage & received_data,
      ::DDS::SampleInfo & sample_info) = 0;

    virtual ::DDS::ReturnCode_t read_instance (
      ::Bound::BoundedUnionMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t take_instance (
      ::Bound::BoundedUnionMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t read_instance_w_condition (
      ::Bound::BoundedUnionMessageSeq & received_data,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t take_instance_w_condition (
      ::Bound::BoundedUnionMessageSeq & received_data,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t read_next_instance (
      ::Bound::BoundedUnionMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t take_next_instance (
      ::Bound::BoundedUnionMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::Bound::BoundedUnionMessageSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::Bound::BoundedUnionMessageSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t return_loan (
      ::Bound::BoundedUnionMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq) = 0;

    virtual ::DDS::ReturnCode_t get_key_value (
      ::Bound::BoundedUnionMessage & key_holder,
      ::DDS::InstanceHandle_t handle) = 0;

    virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::Bound::BoundedUnionMessage & instance_data) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:140

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  protected:
    // Abstract or local interface only.
    BoundedUnionMessageDataReader (void);

    

    virtual ~BoundedUnionMessageDataReader (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    BoundedUnionMessageDataReader (const BoundedUnionMessageDataReader &);

    void operator= (const BoundedUnionMessageDataReader &);
  };

// TAO_IDL - Generated from
// be/be_visitor_module/module_ch.cpp:67

} // module Bound

// TAO_IDL - Generated from
// be/be_visitor_module/module_ch.cpp:38

namespace Bound
{

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:102

  typedef ::TAO::DCPS::ZeroCopyDataSeq< Bound::UnboundedUnionMessage, DCPS_ZERO_COPY_SEQ_DEFAULT_SIZE> UnboundedUnionMessageSeq;
  

  // TAO_IDL - Generated from
  // be/be_interface.cpp:751

#if !defined (_BOUND_UNBOUNDEDUNIONMESSAGETYPESUPPORT__VAR_OUT_CH_)
#define _BOUND_UNBOUNDEDUNIONMESSAGETYPESUPPORT__VAR_OUT_CH_

  class UnboundedUnionMessageTypeSupport;
  typedef UnboundedUnionMessageTypeSupport *UnboundedUnionMessageTypeSupport_ptr;

  typedef
    TAO_Objref_Var_T<
        UnboundedUnionMessageTypeSupport
      >
    UnboundedUnionMessageTypeSupport_var;
  
  typedef
    TAO_Objref_Out_T<
        UnboundedUnionMessageTypeSupport
      >
    UnboundedUnionMessageTypeSupport_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:43

  class KeyTest_Export UnboundedUnionMessageTypeSupport
    : public virtual ::OpenDDS::DCPS::TypeSupport
  
  {
  public:

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    typedef UnboundedUnionMessageTypeSupport_ptr _ptr_type;
    typedef UnboundedUnionMessageTypeSupport_var _var_type;
    typedef UnboundedUnionMessageTypeSupport_out _out_type;

    // The static operations.
    static UnboundedUnionMessageTypeSupport_ptr _duplicate (UnboundedUnionMessageTypeSupport_ptr obj);

    static void _tao_release (UnboundedUnionMessageTypeSupport_ptr obj);

    static UnboundedUnionMessageTypeSupport_ptr _narrow (::CORBA::Object_ptr obj);
    static UnboundedUnionMessageTypeSupport_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static UnboundedUnionMessageTypeSupport_ptr _nil (void);

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:140

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  protected:
    // Abstract or local interface only.
    UnboundedUnionMessageTypeSupport (void);

    

    virtual ~UnboundedUnionMessageTypeSupport (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    UnboundedUnionMessageTypeSupport (const UnboundedUnionMessageTypeSupport &);

    void operator= (const UnboundedUnionMessageTypeSupport &);
  };

  // TAO_IDL - Generated from
  // be/be_interface.cpp:751

#if !defined (_BOUND_UNBOUNDEDUNIONMESSAGEDATAWRITER__VAR_OUT_CH_)
#define _BOUND_UNBOUNDEDUNIONMESSAGEDATAWRITER__VAR_OUT_CH_

  class UnboundedUnionMessageDataWriter;
  typedef UnboundedUnionMessageDataWriter *UnboundedUnionMessageDataWriter_ptr;

  typedef
    TAO_Objref_Var_T<
        UnboundedUnionMessageDataWriter
      >
    UnboundedUnionMessageDataWriter_var;
  
  typedef
    TAO_Objref_Out_T<
        UnboundedUnionMessageDataWriter
      >
    UnboundedUnionMessageDataWriter_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:43

  class KeyTest_Export UnboundedUnionMessageDataWriter
    : public virtual ::DDS::DataWriter
  
  {
  public:

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    typedef UnboundedUnionMessageDataWriter_ptr _ptr_type;
    typedef UnboundedUnionMessageDataWriter_var _var_type;
    typedef UnboundedUnionMessageDataWriter_out _out_type;

    // The static operations.
    static UnboundedUnionMessageDataWriter_ptr _duplicate (UnboundedUnionMessageDataWriter_ptr obj);

    static void _tao_release (UnboundedUnionMessageDataWriter_ptr obj);

    static UnboundedUnionMessageDataWriter_ptr _narrow (::CORBA::Object_ptr obj);
    static UnboundedUnionMessageDataWriter_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static UnboundedUnionMessageDataWriter_ptr _nil (void);

    virtual ::DDS::InstanceHandle_t register_instance (
      const ::Bound::UnboundedUnionMessage & instance) = 0;

    virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::Bound::UnboundedUnionMessage & instance,
      const ::DDS::Time_t & timestamp) = 0;

    virtual ::DDS::ReturnCode_t unregister_instance (
      const ::Bound::UnboundedUnionMessage & instance,
      ::DDS::InstanceHandle_t handle) = 0;

    virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::Bound::UnboundedUnionMessage & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp) = 0;

    virtual ::DDS::ReturnCode_t write (
      const ::Bound::UnboundedUnionMessage & instance_data,
      ::DDS::InstanceHandle_t handle) = 0;

    virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::Bound::UnboundedUnionMessage & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp) = 0;

    virtual ::DDS::ReturnCode_t dispose (
      const ::Bound::UnboundedUnionMessage & instance_data,
      ::DDS::InstanceHandle_t instance_handle) = 0;

    virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::Bound::UnboundedUnionMessage & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp) = 0;

    virtual ::DDS::ReturnCode_t get_key_value (
      ::Bound::UnboundedUnionMessage & key_holder,
      ::DDS::InstanceHandle_t handle) = 0;

    virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::Bound::UnboundedUnionMessage & instance_data) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:140

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  protected:
    // Abstract or local interface only.
    UnboundedUnionMessageDataWriter (void);

    

    virtual ~UnboundedUnionMessageDataWriter (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    UnboundedUnionMessageDataWriter (const UnboundedUnionMessageDataWriter &);

    void operator= (const UnboundedUnionMessageDataWriter &);
  };

  // TAO_IDL - Generated from
  // be/be_interface.cpp:751

#if !defined (_BOUND_UNBOUNDEDUNIONMESSAGEDATAREADER__VAR_OUT_CH_)
#define _BOUND_UNBOUNDEDUNIONMESSAGEDATAREADER__VAR_OUT_CH_

  class UnboundedUnionMessageDataReader;
  typedef UnboundedUnionMessageDataReader *UnboundedUnionMessageDataReader_ptr;

  typedef
    TAO_Objref_Var_T<
        UnboundedUnionMessageDataReader
      >
    UnboundedUnionMessageDataReader_var;
  
  typedef
    TAO_Objref_Out_T<
        UnboundedUnionMessageDataReader
      >
    UnboundedUnionMessageDataReader_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:43

  class KeyTest_Export UnboundedUnionMessageDataReader
    : public virtual ::OpenDDS::DCPS::DataReaderEx
  
  {
  public:

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    typedef UnboundedUnionMessageDataReader_ptr _ptr_type;
    typedef UnboundedUnionMessageDataReader_var _var_type;
    typedef UnboundedUnionMessageDataReader_out _out_type;

    // The static operations.
    static UnboundedUnionMessageDataReader_ptr _duplicate (UnboundedUnionMessageDataReader_ptr obj);

    static void _tao_release (UnboundedUnionMessageDataReader_ptr obj);

    static UnboundedUnionMessageDataReader_ptr _narrow (::CORBA::Object_ptr obj);
    static UnboundedUnionMessageDataReader_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static UnboundedUnionMessageDataReader_ptr _nil (void);

    virtual ::DDS::ReturnCode_t read (
      ::Bound::UnboundedUnionMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t take (
      ::Bound::UnboundedUnionMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t read_w_condition (
      ::Bound::UnboundedUnionMessageSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t take_w_condition (
      ::Bound::UnboundedUnionMessageSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t read_next_sample (
      ::Bound::UnboundedUnionMessage & received_data,
      ::DDS::SampleInfo & sample_info) = 0;

    virtual ::DDS::ReturnCode_t take_next_sample (
      ::Bound::UnboundedUnionMessage & received_data,
      ::DDS::SampleInfo & sample_info) = 0;

    virtual ::DDS::ReturnCode_t read_instance (
      ::Bound::UnboundedUnionMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t take_instance (
      ::Bound::UnboundedUnionMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t read_instance_w_condition (
      ::Bound::UnboundedUnionMessageSeq & received_data,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t take_instance_w_condition (
      ::Bound::UnboundedUnionMessageSeq & received_data,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t read_next_instance (
      ::Bound::UnboundedUnionMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t take_next_instance (
      ::Bound::UnboundedUnionMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::Bound::UnboundedUnionMessageSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::Bound::UnboundedUnionMessageSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t return_loan (
      ::Bound::UnboundedUnionMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq) = 0;

    virtual ::DDS::ReturnCode_t get_key_value (
      ::Bound::UnboundedUnionMessage & key_holder,
      ::DDS::InstanceHandle_t handle) = 0;

    virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::Bound::UnboundedUnionMessage & instance_data) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:140

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  protected:
    // Abstract or local interface only.
    UnboundedUnionMessageDataReader (void);

    

    virtual ~UnboundedUnionMessageDataReader (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    UnboundedUnionMessageDataReader (const UnboundedUnionMessageDataReader &);

    void operator= (const UnboundedUnionMessageDataReader &);
  };

// TAO_IDL - Generated from
// be/be_visitor_module/module_ch.cpp:67

} // module Bound

// TAO_IDL - Generated from
// be/be_visitor_module/module_ch.cpp:38

namespace Bound
{

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:102

  typedef ::TAO::DCPS::ZeroCopyDataSeq< Bound::RecursiveMessage, DCPS_ZERO_COPY_SEQ_DEFAULT_SIZE> RecursiveMessageSeq;
  

  // TAO_IDL - Generated from
  // be/be_interface.cpp:751

#if !defined (_BOUND_RECURSIVEMESSAGETYPESUPPORT__VAR_OUT_CH_)
#define _BOUND_RECURSIVEMESSAGETYPESUPPORT__VAR_OUT_CH_

  class RecursiveMessageTypeSupport;
  typedef RecursiveMessageTypeSupport *RecursiveMessageTypeSupport_ptr;

  typedef
    TAO_Objref_Var_T<
        RecursiveMessageTypeSupport
      >
    RecursiveMessageTypeSupport_var;
  
  typedef
    TAO_Objref_Out_T<
        RecursiveMessageTypeSupport
      >
    RecursiveMessageTypeSupport_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:43

  class KeyTest_Export RecursiveMessageTypeSupport
    : public virtual ::OpenDDS::DCPS::TypeSupport
  
  {
  public:

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    typedef RecursiveMessageTypeSupport_ptr _ptr_type;
    typedef RecursiveMessageTypeSupport_var _var_type;
    typedef RecursiveMessageTypeSupport_out _out_type;

    // The static operations.
    static RecursiveMessageTypeSupport_ptr _duplicate (RecursiveMessageTypeSupport_ptr obj);

    static void _tao_release (RecursiveMessageTypeSupport_ptr obj);

    static RecursiveMessageTypeSupport_ptr _narrow (::CORBA::Object_ptr obj);
    static RecursiveMessageTypeSupport_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static RecursiveMessageTypeSupport_ptr _nil (void);

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:140

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  protected:
    // Abstract or local interface only.
    RecursiveMessageTypeSupport (void);

    

    virtual ~RecursiveMessageTypeSupport (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    RecursiveMessageTypeSupport (const RecursiveMessageTypeSupport &);

    void operator= (const RecursiveMessageTypeSupport &);
  };

  // TAO_IDL - Generated from
  // be/be_interface.cpp:751

#if !defined (_BOUND_RECURSIVEMESSAGEDATAWRITER__VAR_OUT_CH_)
#define _BOUND_RECURSIVEMESSAGEDATAWRITER__VAR_OUT_CH_

  class RecursiveMessageDataWriter;
  typedef RecursiveMessageDataWriter *RecursiveMessageDataWriter_ptr;

  typedef
    TAO_Objref_Var_T<
        RecursiveMessageDataWriter
      >
    RecursiveMessageDataWriter_var;
  
  typedef
    TAO_Objref_Out_T<
        RecursiveMessageDataWriter
      >
    RecursiveMessageDataWriter_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:43

  class KeyTest_Export RecursiveMessageDataWriter
    : public virtual ::DDS::DataWriter
  
  {
  public:

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    typedef RecursiveMessageDataWriter_ptr _ptr_type;
    typedef RecursiveMessageDataWriter_var _var_type;
    typedef RecursiveMessageDataWriter_out _out_type;

    // The static operations.
    static RecursiveMessageDataWriter_ptr _duplicate (RecursiveMessageDataWriter_ptr obj);

    static void _tao_release (RecursiveMessageDataWriter_ptr obj);

    static RecursiveMessageDataWriter_ptr _narrow (::CORBA::Object_ptr obj);
    static RecursiveMessageDataWriter_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static RecursiveMessageDataWriter_ptr _nil (void);

    virtual ::DDS::InstanceHandle_t register_instance (
      const ::Bound::RecursiveMessage & instance) = 0;

    virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::Bound::RecursiveMessage & instance,
      const ::DDS::Time_t & timestamp) = 0;

    virtual ::DDS::ReturnCode_t unregister_instance (
      const ::Bound::RecursiveMessage & instance,
      ::DDS::InstanceHandle_t handle) = 0;

    virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::Bound::RecursiveMessage & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp) = 0;

    virtual ::DDS::ReturnCode_t write (
      const ::Bound::RecursiveMessage & instance_data,
      ::DDS::InstanceHandle_t handle) = 0;

    virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::Bound::RecursiveMessage & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp) = 0;

    virtual ::DDS::ReturnCode_t dispose (
      const ::Bound::RecursiveMessage & instance_data,
      ::DDS::InstanceHandle_t instance_handle) = 0;

    virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::Bound::RecursiveMessage & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp) = 0;

    virtual ::DDS::ReturnCode_t get_key_value (
      ::Bound::RecursiveMessage & key_holder,
      ::DDS::InstanceHandle_t handle) = 0;

    virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::Bound::RecursiveMessage & instance_data) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:140

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  protected:
    // Abstract or local interface only.
    RecursiveMessageDataWriter (void);

    

    virtual ~RecursiveMessageDataWriter (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    RecursiveMessageDataWriter (const RecursiveMessageDataWriter &);

    void operator= (const RecursiveMessageDataWriter &);
  };

  // TAO_IDL - Generated from
  // be/be_interface.cpp:751

#if !defined (_BOUND_RECURSIVEMESSAGEDATAREADER__VAR_OUT_CH_)
#define _BOUND_RECURSIVEMESSAGEDATAREADER__VAR_OUT_CH_

  class RecursiveMessageDataReader;
  typedef RecursiveMessageDataReader *RecursiveMessageDataReader_ptr;

  typedef
    TAO_Objref_Var_T<
        RecursiveMessageDataReader
      >
    RecursiveMessageDataReader_var;
  
  typedef
    TAO_Objref_Out_T<
        RecursiveMessageDataReader
      >
    RecursiveMessageDataReader_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:43

  class KeyTest_Export RecursiveMessageDataReader
    : public virtual ::OpenDDS::DCPS::DataReaderEx
  
  {
  public:

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    typedef RecursiveMessageDataReader_ptr _ptr_type;
    typedef RecursiveMessageDataReader_var _var_type;
    typedef RecursiveMessageDataReader_out _out_type;

    // The static operations.
    static RecursiveMessageDataReader_ptr _duplicate (RecursiveMessageDataReader_ptr obj);

    static void _tao_release (RecursiveMessageDataReader_ptr obj);

    static RecursiveMessageDataReader_ptr _narrow (::CORBA::Object_ptr obj);
    static RecursiveMessageDataReader_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static RecursiveMessageDataReader_ptr _nil (void);

    virtual ::DDS::ReturnCode_t read (
      ::Bound::RecursiveMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t take (
      ::Bound::RecursiveMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t read_w_condition (
      ::Bound::RecursiveMessageSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t take_w_condition (
      ::Bound::RecursiveMessageSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t read_next_sample (
      ::Bound::RecursiveMessage & received_data,
      ::DDS::SampleInfo & sample_info) = 0;

    virtual ::DDS::ReturnCode_t take_next_sample (
      ::Bound::RecursiveMessage & received_data,
      ::DDS::SampleInfo & sample_info) = 0;

    virtual ::DDS::ReturnCode_t read_instance (
      ::Bound::RecursiveMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t take_instance (
      ::Bound::RecursiveMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t read_instance_w_condition (
      ::Bound::RecursiveMessageSeq & received_data,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t take_instance_w_condition (
      ::Bound::RecursiveMessageSeq & received_data,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t read_next_instance (
      ::Bound::RecursiveMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t take_next_instance (
      ::Bound::RecursiveMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states) = 0;

    virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::Bound::RecursiveMessageSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::Bound::RecursiveMessageSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition) = 0;

    virtual ::DDS::ReturnCode_t return_loan (
      ::Bound::RecursiveMessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq) = 0;

    virtual ::DDS::ReturnCode_t get_key_value (
      ::Bound::RecursiveMessage & key_holder,
      ::DDS::InstanceHandle_t handle) = 0;

    virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::Bound::RecursiveMessage & instance_data) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:140

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  protected:
    // Abstract or local interface only.
    RecursiveMessageDataReader (void);

    

    virtual ~RecursiveMessageDataReader (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    RecursiveMessageDataReader (const RecursiveMessageDataReader &);

    void operator= (const RecursiveMessageDataReader &);
  };

// TAO_IDL - Generated from
// be/be_visitor_module/module_ch.cpp:67

} // module Bound

// TAO_IDL - Generated from
// be/be_visitor_arg_traits.cpp:68

TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Arg traits specializations.
namespace TAO
{
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_traits.cpp:62

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations.
namespace TAO
{

#if !defined (_BOUND_BOUNDEDSEQUENCEOFBOUNDEDMESSAGETYPESUPPORT__TRAITS_)
#define _BOUND_BOUNDEDSEQUENCEOFBOUNDEDMESSAGETYPESUPPORT__TRAITS_

  template<>
  struct KeyTest_Export Objref_Traits< ::Bound::BoundedSequenceOfBoundedMessageTypeSupport>
  {
    static ::Bound::BoundedSequenceOfBoundedMessageTypeSupport_ptr duplicate (
        ::Bound::BoundedSequenceOfBoundedMessageTypeSupport_ptr p);
    static void release (
        ::Bound::BoundedSequenceOfBoundedMessageTypeSupport_ptr p);
    static ::Bound::BoundedSequenceOfBoundedMessageTypeSupport_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::Bound::BoundedSequenceOfBoundedMessageTypeSupport_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_BOUND_BOUNDEDSEQUENCEOFBOUNDEDMESSAGEDATAWRITER__TRAITS_)
#define _BOUND_BOUNDEDSEQUENCEOFBOUNDEDMESSAGEDATAWRITER__TRAITS_

  template<>
  struct KeyTest_Export Objref_Traits< ::Bound::BoundedSequenceOfBoundedMessageDataWriter>
  {
    static ::Bound::BoundedSequenceOfBoundedMessageDataWriter_ptr duplicate (
        ::Bound::BoundedSequenceOfBoundedMessageDataWriter_ptr p);
    static void release (
        ::Bound::BoundedSequenceOfBoundedMessageDataWriter_ptr p);
    static ::Bound::BoundedSequenceOfBoundedMessageDataWriter_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::Bound::BoundedSequenceOfBoundedMessageDataWriter_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_BOUND_BOUNDEDSEQUENCEOFBOUNDEDMESSAGEDATAREADER__TRAITS_)
#define _BOUND_BOUNDEDSEQUENCEOFBOUNDEDMESSAGEDATAREADER__TRAITS_

  template<>
  struct KeyTest_Export Objref_Traits< ::Bound::BoundedSequenceOfBoundedMessageDataReader>
  {
    static ::Bound::BoundedSequenceOfBoundedMessageDataReader_ptr duplicate (
        ::Bound::BoundedSequenceOfBoundedMessageDataReader_ptr p);
    static void release (
        ::Bound::BoundedSequenceOfBoundedMessageDataReader_ptr p);
    static ::Bound::BoundedSequenceOfBoundedMessageDataReader_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::Bound::BoundedSequenceOfBoundedMessageDataReader_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_BOUND_UNBOUNDEDSEQUENCEOFBOUNDEDMESSAGETYPESUPPORT__TRAITS_)
#define _BOUND_UNBOUNDEDSEQUENCEOFBOUNDEDMESSAGETYPESUPPORT__TRAITS_

  template<>
  struct KeyTest_Export Objref_Traits< ::Bound::UnboundedSequenceOfBoundedMessageTypeSupport>
  {
    static ::Bound::UnboundedSequenceOfBoundedMessageTypeSupport_ptr duplicate (
        ::Bound::UnboundedSequenceOfBoundedMessageTypeSupport_ptr p);
    static void release (
        ::Bound::UnboundedSequenceOfBoundedMessageTypeSupport_ptr p);
    static ::Bound::UnboundedSequenceOfBoundedMessageTypeSupport_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::Bound::UnboundedSequenceOfBoundedMessageTypeSupport_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_BOUND_UNBOUNDEDSEQUENCEOFBOUNDEDMESSAGEDATAWRITER__TRAITS_)
#define _BOUND_UNBOUNDEDSEQUENCEOFBOUNDEDMESSAGEDATAWRITER__TRAITS_

  template<>
  struct KeyTest_Export Objref_Traits< ::Bound::UnboundedSequenceOfBoundedMessageDataWriter>
  {
    static ::Bound::UnboundedSequenceOfBoundedMessageDataWriter_ptr duplicate (
        ::Bound::UnboundedSequenceOfBoundedMessageDataWriter_ptr p);
    static void release (
        ::Bound::UnboundedSequenceOfBoundedMessageDataWriter_ptr p);
    static ::Bound::UnboundedSequenceOfBoundedMessageDataWriter_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::Bound::UnboundedSequenceOfBoundedMessageDataWriter_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_BOUND_UNBOUNDEDSEQUENCEOFBOUNDEDMESSAGEDATAREADER__TRAITS_)
#define _BOUND_UNBOUNDEDSEQUENCEOFBOUNDEDMESSAGEDATAREADER__TRAITS_

  template<>
  struct KeyTest_Export Objref_Traits< ::Bound::UnboundedSequenceOfBoundedMessageDataReader>
  {
    static ::Bound::UnboundedSequenceOfBoundedMessageDataReader_ptr duplicate (
        ::Bound::UnboundedSequenceOfBoundedMessageDataReader_ptr p);
    static void release (
        ::Bound::UnboundedSequenceOfBoundedMessageDataReader_ptr p);
    static ::Bound::UnboundedSequenceOfBoundedMessageDataReader_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::Bound::UnboundedSequenceOfBoundedMessageDataReader_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_BOUND_BOUNDEDSEQUENCEOFUNBOUNDEDMESSAGETYPESUPPORT__TRAITS_)
#define _BOUND_BOUNDEDSEQUENCEOFUNBOUNDEDMESSAGETYPESUPPORT__TRAITS_

  template<>
  struct KeyTest_Export Objref_Traits< ::Bound::BoundedSequenceOfUnboundedMessageTypeSupport>
  {
    static ::Bound::BoundedSequenceOfUnboundedMessageTypeSupport_ptr duplicate (
        ::Bound::BoundedSequenceOfUnboundedMessageTypeSupport_ptr p);
    static void release (
        ::Bound::BoundedSequenceOfUnboundedMessageTypeSupport_ptr p);
    static ::Bound::BoundedSequenceOfUnboundedMessageTypeSupport_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::Bound::BoundedSequenceOfUnboundedMessageTypeSupport_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_BOUND_BOUNDEDSEQUENCEOFUNBOUNDEDMESSAGEDATAWRITER__TRAITS_)
#define _BOUND_BOUNDEDSEQUENCEOFUNBOUNDEDMESSAGEDATAWRITER__TRAITS_

  template<>
  struct KeyTest_Export Objref_Traits< ::Bound::BoundedSequenceOfUnboundedMessageDataWriter>
  {
    static ::Bound::BoundedSequenceOfUnboundedMessageDataWriter_ptr duplicate (
        ::Bound::BoundedSequenceOfUnboundedMessageDataWriter_ptr p);
    static void release (
        ::Bound::BoundedSequenceOfUnboundedMessageDataWriter_ptr p);
    static ::Bound::BoundedSequenceOfUnboundedMessageDataWriter_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::Bound::BoundedSequenceOfUnboundedMessageDataWriter_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_BOUND_BOUNDEDSEQUENCEOFUNBOUNDEDMESSAGEDATAREADER__TRAITS_)
#define _BOUND_BOUNDEDSEQUENCEOFUNBOUNDEDMESSAGEDATAREADER__TRAITS_

  template<>
  struct KeyTest_Export Objref_Traits< ::Bound::BoundedSequenceOfUnboundedMessageDataReader>
  {
    static ::Bound::BoundedSequenceOfUnboundedMessageDataReader_ptr duplicate (
        ::Bound::BoundedSequenceOfUnboundedMessageDataReader_ptr p);
    static void release (
        ::Bound::BoundedSequenceOfUnboundedMessageDataReader_ptr p);
    static ::Bound::BoundedSequenceOfUnboundedMessageDataReader_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::Bound::BoundedSequenceOfUnboundedMessageDataReader_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_BOUND_UNBOUNDEDSEQUENCEOFUNBOUNDEDMESSAGETYPESUPPORT__TRAITS_)
#define _BOUND_UNBOUNDEDSEQUENCEOFUNBOUNDEDMESSAGETYPESUPPORT__TRAITS_

  template<>
  struct KeyTest_Export Objref_Traits< ::Bound::UnboundedSequenceOfUnboundedMessageTypeSupport>
  {
    static ::Bound::UnboundedSequenceOfUnboundedMessageTypeSupport_ptr duplicate (
        ::Bound::UnboundedSequenceOfUnboundedMessageTypeSupport_ptr p);
    static void release (
        ::Bound::UnboundedSequenceOfUnboundedMessageTypeSupport_ptr p);
    static ::Bound::UnboundedSequenceOfUnboundedMessageTypeSupport_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::Bound::UnboundedSequenceOfUnboundedMessageTypeSupport_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_BOUND_UNBOUNDEDSEQUENCEOFUNBOUNDEDMESSAGEDATAWRITER__TRAITS_)
#define _BOUND_UNBOUNDEDSEQUENCEOFUNBOUNDEDMESSAGEDATAWRITER__TRAITS_

  template<>
  struct KeyTest_Export Objref_Traits< ::Bound::UnboundedSequenceOfUnboundedMessageDataWriter>
  {
    static ::Bound::UnboundedSequenceOfUnboundedMessageDataWriter_ptr duplicate (
        ::Bound::UnboundedSequenceOfUnboundedMessageDataWriter_ptr p);
    static void release (
        ::Bound::UnboundedSequenceOfUnboundedMessageDataWriter_ptr p);
    static ::Bound::UnboundedSequenceOfUnboundedMessageDataWriter_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::Bound::UnboundedSequenceOfUnboundedMessageDataWriter_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_BOUND_UNBOUNDEDSEQUENCEOFUNBOUNDEDMESSAGEDATAREADER__TRAITS_)
#define _BOUND_UNBOUNDEDSEQUENCEOFUNBOUNDEDMESSAGEDATAREADER__TRAITS_

  template<>
  struct KeyTest_Export Objref_Traits< ::Bound::UnboundedSequenceOfUnboundedMessageDataReader>
  {
    static ::Bound::UnboundedSequenceOfUnboundedMessageDataReader_ptr duplicate (
        ::Bound::UnboundedSequenceOfUnboundedMessageDataReader_ptr p);
    static void release (
        ::Bound::UnboundedSequenceOfUnboundedMessageDataReader_ptr p);
    static ::Bound::UnboundedSequenceOfUnboundedMessageDataReader_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::Bound::UnboundedSequenceOfUnboundedMessageDataReader_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_BOUND_BOUNDEDUNIONMESSAGETYPESUPPORT__TRAITS_)
#define _BOUND_BOUNDEDUNIONMESSAGETYPESUPPORT__TRAITS_

  template<>
  struct KeyTest_Export Objref_Traits< ::Bound::BoundedUnionMessageTypeSupport>
  {
    static ::Bound::BoundedUnionMessageTypeSupport_ptr duplicate (
        ::Bound::BoundedUnionMessageTypeSupport_ptr p);
    static void release (
        ::Bound::BoundedUnionMessageTypeSupport_ptr p);
    static ::Bound::BoundedUnionMessageTypeSupport_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::Bound::BoundedUnionMessageTypeSupport_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_BOUND_BOUNDEDUNIONMESSAGEDATAWRITER__TRAITS_)
#define _BOUND_BOUNDEDUNIONMESSAGEDATAWRITER__TRAITS_

  template<>
  struct KeyTest_Export Objref_Traits< ::Bound::BoundedUnionMessageDataWriter>
  {
    static ::Bound::BoundedUnionMessageDataWriter_ptr duplicate (
        ::Bound::BoundedUnionMessageDataWriter_ptr p);
    static void release (
        ::Bound::BoundedUnionMessageDataWriter_ptr p);
    static ::Bound::BoundedUnionMessageDataWriter_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::Bound::BoundedUnionMessageDataWriter_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_BOUND_BOUNDEDUNIONMESSAGEDATAREADER__TRAITS_)
#define _BOUND_BOUNDEDUNIONMESSAGEDATAREADER__TRAITS_

  template<>
  struct KeyTest_Export Objref_Traits< ::Bound::BoundedUnionMessageDataReader>
  {
    static ::Bound::BoundedUnionMessageDataReader_ptr duplicate (
        ::Bound::BoundedUnionMessageDataReader_ptr p);
    static void release (
        ::Bound::BoundedUnionMessageDataReader_ptr p);
    static ::Bound::BoundedUnionMessageDataReader_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::Bound::BoundedUnionMessageDataReader_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_BOUND_UNBOUNDEDUNIONMESSAGETYPESUPPORT__TRAITS_)
#define _BOUND_UNBOUNDEDUNIONMESSAGETYPESUPPORT__TRAITS_

  template<>
  struct KeyTest_Export Objref_Traits< ::Bound::UnboundedUnionMessageTypeSupport>
  {
    static ::Bound::UnboundedUnionMessageTypeSupport_ptr duplicate (
        ::Bound::UnboundedUnionMessageTypeSupport_ptr p);
    static void release (
        ::Bound::UnboundedUnionMessageTypeSupport_ptr p);
    static ::Bound::UnboundedUnionMessageTypeSupport_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::Bound::UnboundedUnionMessageTypeSupport_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_BOUND_UNBOUNDEDUNIONMESSAGEDATAWRITER__TRAITS_)
#define _BOUND_UNBOUNDEDUNIONMESSAGEDATAWRITER__TRAITS_

  template<>
  struct KeyTest_Export Objref_Traits< ::Bound::UnboundedUnionMessageDataWriter>
  {
    static ::Bound::UnboundedUnionMessageDataWriter_ptr duplicate (
        ::Bound::UnboundedUnionMessageDataWriter_ptr p);
    static void release (
        ::Bound::UnboundedUnionMessageDataWriter_ptr p);
    static ::Bound::UnboundedUnionMessageDataWriter_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::Bound::UnboundedUnionMessageDataWriter_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_BOUND_UNBOUNDEDUNIONMESSAGEDATAREADER__TRAITS_)
#define _BOUND_UNBOUNDEDUNIONMESSAGEDATAREADER__TRAITS_

  template<>
  struct KeyTest_Export Objref_Traits< ::Bound::UnboundedUnionMessageDataReader>
  {
    static ::Bound::UnboundedUnionMessageDataReader_ptr duplicate (
        ::Bound::UnboundedUnionMessageDataReader_ptr p);
    static void release (
        ::Bound::UnboundedUnionMessageDataReader_ptr p);
    static ::Bound::UnboundedUnionMessageDataReader_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::Bound::UnboundedUnionMessageDataReader_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_BOUND_RECURSIVEMESSAGETYPESUPPORT__TRAITS_)
#define _BOUND_RECURSIVEMESSAGETYPESUPPORT__TRAITS_

  template<>
  struct KeyTest_Export Objref_Traits< ::Bound::RecursiveMessageTypeSupport>
  {
    static ::Bound::RecursiveMessageTypeSupport_ptr duplicate (
        ::Bound::RecursiveMessageTypeSupport_ptr p);
    static void release (
        ::Bound::RecursiveMessageTypeSupport_ptr p);
    static ::Bound::RecursiveMessageTypeSupport_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::Bound::RecursiveMessageTypeSupport_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_BOUND_RECURSIVEMESSAGEDATAWRITER__TRAITS_)
#define _BOUND_RECURSIVEMESSAGEDATAWRITER__TRAITS_

  template<>
  struct KeyTest_Export Objref_Traits< ::Bound::RecursiveMessageDataWriter>
  {
    static ::Bound::RecursiveMessageDataWriter_ptr duplicate (
        ::Bound::RecursiveMessageDataWriter_ptr p);
    static void release (
        ::Bound::RecursiveMessageDataWriter_ptr p);
    static ::Bound::RecursiveMessageDataWriter_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::Bound::RecursiveMessageDataWriter_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_BOUND_RECURSIVEMESSAGEDATAREADER__TRAITS_)
#define _BOUND_RECURSIVEMESSAGEDATAREADER__TRAITS_

  template<>
  struct KeyTest_Export Objref_Traits< ::Bound::RecursiveMessageDataReader>
  {
    static ::Bound::RecursiveMessageDataReader_ptr duplicate (
        ::Bound::RecursiveMessageDataReader_ptr p);
    static void release (
        ::Bound::RecursiveMessageDataReader_ptr p);
    static ::Bound::RecursiveMessageDataReader_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::Bound::RecursiveMessageDataReader_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_codegen.cpp:1703
#if defined (__ACE_INLINE__)
#include "BoundTest2TypeSupportC.inl"
#endif /* defined INLINE */

#include /**/ "ace/post.h"

#endif /* ifndef */

