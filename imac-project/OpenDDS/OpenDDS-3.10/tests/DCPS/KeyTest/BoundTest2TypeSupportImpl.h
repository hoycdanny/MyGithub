/* -*- C++ -*- */
/* Generated by /Users/yc/MyGithub/imac-project/OpenDDS/OpenDDS-3.10/bin/opendds_idl version 3.10 (ACE version 6.2a_p11) running on input file BoundTest2.idl */
#ifndef OPENDDS_IDL_GENERATED_BOUNDTEST2TYPESUPPORTIMPL_H_FKAM8P
#define OPENDDS_IDL_GENERATED_BOUNDTEST2TYPESUPPORTIMPL_H_FKAM8P
#include "BoundTest2C.h"
#include "dds/DCPS/Definitions.h"
#include "BoundTest2TypeSupportC.h"
#include "dds/DCPS/Serializer.h"
#include "dds/DCPS/TypeSupportImpl.h"
#include "tao/FloatSeqC.h"
#include "tao/StringSeqC.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: FloatSeq */


/* End TYPEDEF: FloatSeq */

/* End MODULE: CORBA */


/* Begin MODULE: Bound */



/* Begin TYPEDEF: BoundedFloatSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::BoundedFloatSeq& seq, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::BoundedFloatSeq& seq);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::BoundedFloatSeq& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::BoundedFloatSeq*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: BoundedFloatSeq */


/* Begin STRUCT: BoundedSequenceOfBoundedMessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::BoundedSequenceOfBoundedMessage& stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::BoundedSequenceOfBoundedMessage& stru);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::BoundedSequenceOfBoundedMessage& stru);

KeyTest_Export
size_t gen_max_marshaled_size(const Bound::BoundedSequenceOfBoundedMessage& stru, bool align);

KeyTest_Export
size_t gen_max_marshaled_size(KeyOnly<const Bound::BoundedSequenceOfBoundedMessage> stru, bool align);

KeyTest_Export
void gen_find_size(KeyOnly<const Bound::BoundedSequenceOfBoundedMessage> stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, KeyOnly<const Bound::BoundedSequenceOfBoundedMessage> stru);

KeyTest_Export
bool operator>>(Serializer& strm, KeyOnly<Bound::BoundedSequenceOfBoundedMessage> stru);

template <>
struct MarshalTraits<Bound::BoundedSequenceOfBoundedMessage> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Bound {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct KeyTest_Export BoundedSequenceOfBoundedMessage_OpenDDS_KeyLessThan {
  bool operator()(const Bound::BoundedSequenceOfBoundedMessage&, const Bound::BoundedSequenceOfBoundedMessage&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Bound {
class BoundedSequenceOfBoundedMessageTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Bound::BoundedSequenceOfBoundedMessage> {
  typedef Bound::BoundedSequenceOfBoundedMessage MessageType;
  typedef Bound::BoundedSequenceOfBoundedMessageSeq MessageSequenceType;
  typedef Bound::BoundedSequenceOfBoundedMessageTypeSupport TypeSupportType;
  typedef Bound::BoundedSequenceOfBoundedMessageTypeSupportImpl TypeSupportTypeImpl;
  typedef Bound::BoundedSequenceOfBoundedMessageDataWriter DataWriterType;
  typedef Bound::BoundedSequenceOfBoundedMessageDataReader DataReaderType;
  typedef Bound::BoundedSequenceOfBoundedMessage_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Bound::BoundedSequenceOfBoundedMessage"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Bound {
class KeyTest_Export BoundedSequenceOfBoundedMessageTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<BoundedSequenceOfBoundedMessageTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<BoundedSequenceOfBoundedMessage> TraitsType;
  typedef BoundedSequenceOfBoundedMessageTypeSupport TypeSupportType;
  typedef BoundedSequenceOfBoundedMessageTypeSupport::_var_type _var_type;
  typedef BoundedSequenceOfBoundedMessageTypeSupport::_ptr_type _ptr_type;

  BoundedSequenceOfBoundedMessageTypeSupportImpl() {}
  virtual ~BoundedSequenceOfBoundedMessageTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static BoundedSequenceOfBoundedMessageTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

class MetaStruct;

template<typename T>
const MetaStruct& getMetaStruct();

template<>
KeyTest_Export
const MetaStruct& getMetaStruct<Bound::BoundedSequenceOfBoundedMessage>();
KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::BoundedSequenceOfBoundedMessage*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: BoundedSequenceOfBoundedMessage */


/* Begin TYPEDEF: UnboundedFloatSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::UnboundedFloatSeq& seq, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::UnboundedFloatSeq& seq);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::UnboundedFloatSeq& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::UnboundedFloatSeq*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: UnboundedFloatSeq */


/* Begin STRUCT: UnboundedSequenceOfBoundedMessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::UnboundedSequenceOfBoundedMessage& stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::UnboundedSequenceOfBoundedMessage& stru);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::UnboundedSequenceOfBoundedMessage& stru);

KeyTest_Export
size_t gen_max_marshaled_size(const Bound::UnboundedSequenceOfBoundedMessage& stru, bool align);

KeyTest_Export
size_t gen_max_marshaled_size(KeyOnly<const Bound::UnboundedSequenceOfBoundedMessage> stru, bool align);

KeyTest_Export
void gen_find_size(KeyOnly<const Bound::UnboundedSequenceOfBoundedMessage> stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, KeyOnly<const Bound::UnboundedSequenceOfBoundedMessage> stru);

KeyTest_Export
bool operator>>(Serializer& strm, KeyOnly<Bound::UnboundedSequenceOfBoundedMessage> stru);

template <>
struct MarshalTraits<Bound::UnboundedSequenceOfBoundedMessage> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Bound {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct KeyTest_Export UnboundedSequenceOfBoundedMessage_OpenDDS_KeyLessThan {
  bool operator()(const Bound::UnboundedSequenceOfBoundedMessage&, const Bound::UnboundedSequenceOfBoundedMessage&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Bound {
class UnboundedSequenceOfBoundedMessageTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Bound::UnboundedSequenceOfBoundedMessage> {
  typedef Bound::UnboundedSequenceOfBoundedMessage MessageType;
  typedef Bound::UnboundedSequenceOfBoundedMessageSeq MessageSequenceType;
  typedef Bound::UnboundedSequenceOfBoundedMessageTypeSupport TypeSupportType;
  typedef Bound::UnboundedSequenceOfBoundedMessageTypeSupportImpl TypeSupportTypeImpl;
  typedef Bound::UnboundedSequenceOfBoundedMessageDataWriter DataWriterType;
  typedef Bound::UnboundedSequenceOfBoundedMessageDataReader DataReaderType;
  typedef Bound::UnboundedSequenceOfBoundedMessage_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Bound::UnboundedSequenceOfBoundedMessage"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Bound {
class KeyTest_Export UnboundedSequenceOfBoundedMessageTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<UnboundedSequenceOfBoundedMessageTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<UnboundedSequenceOfBoundedMessage> TraitsType;
  typedef UnboundedSequenceOfBoundedMessageTypeSupport TypeSupportType;
  typedef UnboundedSequenceOfBoundedMessageTypeSupport::_var_type _var_type;
  typedef UnboundedSequenceOfBoundedMessageTypeSupport::_ptr_type _ptr_type;

  UnboundedSequenceOfBoundedMessageTypeSupportImpl() {}
  virtual ~UnboundedSequenceOfBoundedMessageTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static UnboundedSequenceOfBoundedMessageTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
KeyTest_Export
const MetaStruct& getMetaStruct<Bound::UnboundedSequenceOfBoundedMessage>();
KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::UnboundedSequenceOfBoundedMessage*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: UnboundedSequenceOfBoundedMessage */


/* Begin TYPEDEF: BoundedStringSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::BoundedStringSeq& seq, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::BoundedStringSeq& seq);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::BoundedStringSeq& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::BoundedStringSeq*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: BoundedStringSeq */


/* Begin STRUCT: BoundedSequenceOfUnboundedMessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::BoundedSequenceOfUnboundedMessage& stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::BoundedSequenceOfUnboundedMessage& stru);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::BoundedSequenceOfUnboundedMessage& stru);

KeyTest_Export
size_t gen_max_marshaled_size(const Bound::BoundedSequenceOfUnboundedMessage& stru, bool align);

KeyTest_Export
size_t gen_max_marshaled_size(KeyOnly<const Bound::BoundedSequenceOfUnboundedMessage> stru, bool align);

KeyTest_Export
void gen_find_size(KeyOnly<const Bound::BoundedSequenceOfUnboundedMessage> stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, KeyOnly<const Bound::BoundedSequenceOfUnboundedMessage> stru);

KeyTest_Export
bool operator>>(Serializer& strm, KeyOnly<Bound::BoundedSequenceOfUnboundedMessage> stru);

template <>
struct MarshalTraits<Bound::BoundedSequenceOfUnboundedMessage> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Bound {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct KeyTest_Export BoundedSequenceOfUnboundedMessage_OpenDDS_KeyLessThan {
  bool operator()(const Bound::BoundedSequenceOfUnboundedMessage&, const Bound::BoundedSequenceOfUnboundedMessage&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Bound {
class BoundedSequenceOfUnboundedMessageTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Bound::BoundedSequenceOfUnboundedMessage> {
  typedef Bound::BoundedSequenceOfUnboundedMessage MessageType;
  typedef Bound::BoundedSequenceOfUnboundedMessageSeq MessageSequenceType;
  typedef Bound::BoundedSequenceOfUnboundedMessageTypeSupport TypeSupportType;
  typedef Bound::BoundedSequenceOfUnboundedMessageTypeSupportImpl TypeSupportTypeImpl;
  typedef Bound::BoundedSequenceOfUnboundedMessageDataWriter DataWriterType;
  typedef Bound::BoundedSequenceOfUnboundedMessageDataReader DataReaderType;
  typedef Bound::BoundedSequenceOfUnboundedMessage_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Bound::BoundedSequenceOfUnboundedMessage"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Bound {
class KeyTest_Export BoundedSequenceOfUnboundedMessageTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<BoundedSequenceOfUnboundedMessageTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<BoundedSequenceOfUnboundedMessage> TraitsType;
  typedef BoundedSequenceOfUnboundedMessageTypeSupport TypeSupportType;
  typedef BoundedSequenceOfUnboundedMessageTypeSupport::_var_type _var_type;
  typedef BoundedSequenceOfUnboundedMessageTypeSupport::_ptr_type _ptr_type;

  BoundedSequenceOfUnboundedMessageTypeSupportImpl() {}
  virtual ~BoundedSequenceOfUnboundedMessageTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static BoundedSequenceOfUnboundedMessageTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
KeyTest_Export
const MetaStruct& getMetaStruct<Bound::BoundedSequenceOfUnboundedMessage>();
KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::BoundedSequenceOfUnboundedMessage*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: BoundedSequenceOfUnboundedMessage */


/* Begin TYPEDEF: UnboundedStringSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::UnboundedStringSeq& seq, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::UnboundedStringSeq& seq);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::UnboundedStringSeq& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::UnboundedStringSeq*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: UnboundedStringSeq */


/* Begin STRUCT: UnboundedSequenceOfUnboundedMessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::UnboundedSequenceOfUnboundedMessage& stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::UnboundedSequenceOfUnboundedMessage& stru);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::UnboundedSequenceOfUnboundedMessage& stru);

KeyTest_Export
size_t gen_max_marshaled_size(const Bound::UnboundedSequenceOfUnboundedMessage& stru, bool align);

KeyTest_Export
size_t gen_max_marshaled_size(KeyOnly<const Bound::UnboundedSequenceOfUnboundedMessage> stru, bool align);

KeyTest_Export
void gen_find_size(KeyOnly<const Bound::UnboundedSequenceOfUnboundedMessage> stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, KeyOnly<const Bound::UnboundedSequenceOfUnboundedMessage> stru);

KeyTest_Export
bool operator>>(Serializer& strm, KeyOnly<Bound::UnboundedSequenceOfUnboundedMessage> stru);

template <>
struct MarshalTraits<Bound::UnboundedSequenceOfUnboundedMessage> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Bound {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct KeyTest_Export UnboundedSequenceOfUnboundedMessage_OpenDDS_KeyLessThan {
  bool operator()(const Bound::UnboundedSequenceOfUnboundedMessage&, const Bound::UnboundedSequenceOfUnboundedMessage&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Bound {
class UnboundedSequenceOfUnboundedMessageTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Bound::UnboundedSequenceOfUnboundedMessage> {
  typedef Bound::UnboundedSequenceOfUnboundedMessage MessageType;
  typedef Bound::UnboundedSequenceOfUnboundedMessageSeq MessageSequenceType;
  typedef Bound::UnboundedSequenceOfUnboundedMessageTypeSupport TypeSupportType;
  typedef Bound::UnboundedSequenceOfUnboundedMessageTypeSupportImpl TypeSupportTypeImpl;
  typedef Bound::UnboundedSequenceOfUnboundedMessageDataWriter DataWriterType;
  typedef Bound::UnboundedSequenceOfUnboundedMessageDataReader DataReaderType;
  typedef Bound::UnboundedSequenceOfUnboundedMessage_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Bound::UnboundedSequenceOfUnboundedMessage"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Bound {
class KeyTest_Export UnboundedSequenceOfUnboundedMessageTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<UnboundedSequenceOfUnboundedMessageTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<UnboundedSequenceOfUnboundedMessage> TraitsType;
  typedef UnboundedSequenceOfUnboundedMessageTypeSupport TypeSupportType;
  typedef UnboundedSequenceOfUnboundedMessageTypeSupport::_var_type _var_type;
  typedef UnboundedSequenceOfUnboundedMessageTypeSupport::_ptr_type _ptr_type;

  UnboundedSequenceOfUnboundedMessageTypeSupportImpl() {}
  virtual ~UnboundedSequenceOfUnboundedMessageTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static UnboundedSequenceOfUnboundedMessageTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
KeyTest_Export
const MetaStruct& getMetaStruct<Bound::UnboundedSequenceOfUnboundedMessage>();
KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::UnboundedSequenceOfUnboundedMessage*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: UnboundedSequenceOfUnboundedMessage */


/* Begin UNION: BoundedUnion */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::BoundedUnion& uni, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::BoundedUnion& uni);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::BoundedUnion& uni);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::BoundedUnion*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End UNION: BoundedUnion */


/* Begin STRUCT: BoundedUnionMessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::BoundedUnionMessage& stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::BoundedUnionMessage& stru);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::BoundedUnionMessage& stru);

KeyTest_Export
size_t gen_max_marshaled_size(const Bound::BoundedUnionMessage& stru, bool align);

KeyTest_Export
size_t gen_max_marshaled_size(KeyOnly<const Bound::BoundedUnionMessage> stru, bool align);

KeyTest_Export
void gen_find_size(KeyOnly<const Bound::BoundedUnionMessage> stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, KeyOnly<const Bound::BoundedUnionMessage> stru);

KeyTest_Export
bool operator>>(Serializer& strm, KeyOnly<Bound::BoundedUnionMessage> stru);

template <>
struct MarshalTraits<Bound::BoundedUnionMessage> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Bound {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct KeyTest_Export BoundedUnionMessage_OpenDDS_KeyLessThan {
  bool operator()(const Bound::BoundedUnionMessage&, const Bound::BoundedUnionMessage&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Bound {
class BoundedUnionMessageTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Bound::BoundedUnionMessage> {
  typedef Bound::BoundedUnionMessage MessageType;
  typedef Bound::BoundedUnionMessageSeq MessageSequenceType;
  typedef Bound::BoundedUnionMessageTypeSupport TypeSupportType;
  typedef Bound::BoundedUnionMessageTypeSupportImpl TypeSupportTypeImpl;
  typedef Bound::BoundedUnionMessageDataWriter DataWriterType;
  typedef Bound::BoundedUnionMessageDataReader DataReaderType;
  typedef Bound::BoundedUnionMessage_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Bound::BoundedUnionMessage"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Bound {
class KeyTest_Export BoundedUnionMessageTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<BoundedUnionMessageTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<BoundedUnionMessage> TraitsType;
  typedef BoundedUnionMessageTypeSupport TypeSupportType;
  typedef BoundedUnionMessageTypeSupport::_var_type _var_type;
  typedef BoundedUnionMessageTypeSupport::_ptr_type _ptr_type;

  BoundedUnionMessageTypeSupportImpl() {}
  virtual ~BoundedUnionMessageTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static BoundedUnionMessageTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
KeyTest_Export
const MetaStruct& getMetaStruct<Bound::BoundedUnionMessage>();
KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::BoundedUnionMessage*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: BoundedUnionMessage */


/* Begin UNION: UnboundedUnion */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::UnboundedUnion& uni, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::UnboundedUnion& uni);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::UnboundedUnion& uni);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::UnboundedUnion*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End UNION: UnboundedUnion */


/* Begin STRUCT: UnboundedUnionMessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::UnboundedUnionMessage& stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::UnboundedUnionMessage& stru);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::UnboundedUnionMessage& stru);

KeyTest_Export
size_t gen_max_marshaled_size(const Bound::UnboundedUnionMessage& stru, bool align);

KeyTest_Export
size_t gen_max_marshaled_size(KeyOnly<const Bound::UnboundedUnionMessage> stru, bool align);

KeyTest_Export
void gen_find_size(KeyOnly<const Bound::UnboundedUnionMessage> stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, KeyOnly<const Bound::UnboundedUnionMessage> stru);

KeyTest_Export
bool operator>>(Serializer& strm, KeyOnly<Bound::UnboundedUnionMessage> stru);

template <>
struct MarshalTraits<Bound::UnboundedUnionMessage> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Bound {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct KeyTest_Export UnboundedUnionMessage_OpenDDS_KeyLessThan {
  bool operator()(const Bound::UnboundedUnionMessage&, const Bound::UnboundedUnionMessage&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Bound {
class UnboundedUnionMessageTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Bound::UnboundedUnionMessage> {
  typedef Bound::UnboundedUnionMessage MessageType;
  typedef Bound::UnboundedUnionMessageSeq MessageSequenceType;
  typedef Bound::UnboundedUnionMessageTypeSupport TypeSupportType;
  typedef Bound::UnboundedUnionMessageTypeSupportImpl TypeSupportTypeImpl;
  typedef Bound::UnboundedUnionMessageDataWriter DataWriterType;
  typedef Bound::UnboundedUnionMessageDataReader DataReaderType;
  typedef Bound::UnboundedUnionMessage_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Bound::UnboundedUnionMessage"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Bound {
class KeyTest_Export UnboundedUnionMessageTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<UnboundedUnionMessageTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<UnboundedUnionMessage> TraitsType;
  typedef UnboundedUnionMessageTypeSupport TypeSupportType;
  typedef UnboundedUnionMessageTypeSupport::_var_type _var_type;
  typedef UnboundedUnionMessageTypeSupport::_ptr_type _ptr_type;

  UnboundedUnionMessageTypeSupportImpl() {}
  virtual ~UnboundedUnionMessageTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static UnboundedUnionMessageTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
KeyTest_Export
const MetaStruct& getMetaStruct<Bound::UnboundedUnionMessage>();
KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::UnboundedUnionMessage*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: UnboundedUnionMessage */


/* Begin STRUCT-FWD: RecursiveMessage */


/* End STRUCT-FWD: RecursiveMessage */


/* Begin TYPEDEF: SingleMessageSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::SingleMessageSeq& seq, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::SingleMessageSeq& seq);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::SingleMessageSeq& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::SingleMessageSeq*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SingleMessageSeq */


/* Begin UNION: NestedMessageUnion */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::NestedMessageUnion& uni, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::NestedMessageUnion& uni);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::NestedMessageUnion& uni);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::NestedMessageUnion*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End UNION: NestedMessageUnion */


/* Begin STRUCT: RecursiveMessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::RecursiveMessage& stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::RecursiveMessage& stru);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::RecursiveMessage& stru);

KeyTest_Export
size_t gen_max_marshaled_size(const Bound::RecursiveMessage& stru, bool align);

KeyTest_Export
size_t gen_max_marshaled_size(KeyOnly<const Bound::RecursiveMessage> stru, bool align);

KeyTest_Export
void gen_find_size(KeyOnly<const Bound::RecursiveMessage> stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, KeyOnly<const Bound::RecursiveMessage> stru);

KeyTest_Export
bool operator>>(Serializer& strm, KeyOnly<Bound::RecursiveMessage> stru);

template <>
struct MarshalTraits<Bound::RecursiveMessage> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Bound {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct KeyTest_Export RecursiveMessage_OpenDDS_KeyLessThan {
  bool operator()(const Bound::RecursiveMessage&, const Bound::RecursiveMessage&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Bound {
class RecursiveMessageTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Bound::RecursiveMessage> {
  typedef Bound::RecursiveMessage MessageType;
  typedef Bound::RecursiveMessageSeq MessageSequenceType;
  typedef Bound::RecursiveMessageTypeSupport TypeSupportType;
  typedef Bound::RecursiveMessageTypeSupportImpl TypeSupportTypeImpl;
  typedef Bound::RecursiveMessageDataWriter DataWriterType;
  typedef Bound::RecursiveMessageDataReader DataReaderType;
  typedef Bound::RecursiveMessage_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Bound::RecursiveMessage"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Bound {
class KeyTest_Export RecursiveMessageTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<RecursiveMessageTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<RecursiveMessage> TraitsType;
  typedef RecursiveMessageTypeSupport TypeSupportType;
  typedef RecursiveMessageTypeSupport::_var_type _var_type;
  typedef RecursiveMessageTypeSupport::_ptr_type _ptr_type;

  RecursiveMessageTypeSupportImpl() {}
  virtual ~RecursiveMessageTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static RecursiveMessageTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
KeyTest_Export
const MetaStruct& getMetaStruct<Bound::RecursiveMessage>();
KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::RecursiveMessage*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: RecursiveMessage */

/* End MODULE: Bound */
#endif /* OPENDDS_IDL_GENERATED_BOUNDTEST2TYPESUPPORTIMPL_H_FKAM8P */
