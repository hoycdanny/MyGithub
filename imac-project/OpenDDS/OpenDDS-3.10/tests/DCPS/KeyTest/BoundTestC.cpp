// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.2a_p11
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// be/be_codegen.cpp:376


#include "BoundTestC.h"
#include "tao/CDR.h"

#if !defined (__ACE_INLINE__)
#include "BoundTestC.inl"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:97

Bound::ShortArray_slice *
Bound::ShortArray_dup (const Bound::ShortArray_slice *_tao_src_array)
{
  Bound::ShortArray_slice *_tao_dup_array =
    Bound::ShortArray_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <Bound::ShortArray_slice *> (0);
    }
  
  Bound::ShortArray_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

Bound::ShortArray_slice *
Bound::ShortArray_alloc (void)
{
  Bound::ShortArray_slice *retval = 0;
  ACE_NEW_RETURN (retval, ::CORBA::Short[10], 0);
  return retval;
}

void
Bound::ShortArray_free (
    Bound::ShortArray_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
Bound::ShortArray_copy (
    Bound::ShortArray_slice * _tao_to,
    const Bound::ShortArray_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 10; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:97

Bound::UnsignedShortArray_slice *
Bound::UnsignedShortArray_dup (const Bound::UnsignedShortArray_slice *_tao_src_array)
{
  Bound::UnsignedShortArray_slice *_tao_dup_array =
    Bound::UnsignedShortArray_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <Bound::UnsignedShortArray_slice *> (0);
    }
  
  Bound::UnsignedShortArray_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

Bound::UnsignedShortArray_slice *
Bound::UnsignedShortArray_alloc (void)
{
  Bound::UnsignedShortArray_slice *retval = 0;
  ACE_NEW_RETURN (retval, ::CORBA::UShort[10], 0);
  return retval;
}

void
Bound::UnsignedShortArray_free (
    Bound::UnsignedShortArray_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
Bound::UnsignedShortArray_copy (
    Bound::UnsignedShortArray_slice * _tao_to,
    const Bound::UnsignedShortArray_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 10; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:97

Bound::LongArray_slice *
Bound::LongArray_dup (const Bound::LongArray_slice *_tao_src_array)
{
  Bound::LongArray_slice *_tao_dup_array =
    Bound::LongArray_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <Bound::LongArray_slice *> (0);
    }
  
  Bound::LongArray_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

Bound::LongArray_slice *
Bound::LongArray_alloc (void)
{
  Bound::LongArray_slice *retval = 0;
  ACE_NEW_RETURN (retval, ::CORBA::Long[10], 0);
  return retval;
}

void
Bound::LongArray_free (
    Bound::LongArray_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
Bound::LongArray_copy (
    Bound::LongArray_slice * _tao_to,
    const Bound::LongArray_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 10; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:97

Bound::UnsignedLongArray_slice *
Bound::UnsignedLongArray_dup (const Bound::UnsignedLongArray_slice *_tao_src_array)
{
  Bound::UnsignedLongArray_slice *_tao_dup_array =
    Bound::UnsignedLongArray_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <Bound::UnsignedLongArray_slice *> (0);
    }
  
  Bound::UnsignedLongArray_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

Bound::UnsignedLongArray_slice *
Bound::UnsignedLongArray_alloc (void)
{
  Bound::UnsignedLongArray_slice *retval = 0;
  ACE_NEW_RETURN (retval, ::CORBA::ULong[10], 0);
  return retval;
}

void
Bound::UnsignedLongArray_free (
    Bound::UnsignedLongArray_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
Bound::UnsignedLongArray_copy (
    Bound::UnsignedLongArray_slice * _tao_to,
    const Bound::UnsignedLongArray_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 10; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:97

Bound::LongLongArray_slice *
Bound::LongLongArray_dup (const Bound::LongLongArray_slice *_tao_src_array)
{
  Bound::LongLongArray_slice *_tao_dup_array =
    Bound::LongLongArray_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <Bound::LongLongArray_slice *> (0);
    }
  
  Bound::LongLongArray_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

Bound::LongLongArray_slice *
Bound::LongLongArray_alloc (void)
{
  Bound::LongLongArray_slice *retval = 0;
  ACE_NEW_RETURN (retval, ::CORBA::LongLong[10], 0);
  return retval;
}

void
Bound::LongLongArray_free (
    Bound::LongLongArray_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
Bound::LongLongArray_copy (
    Bound::LongLongArray_slice * _tao_to,
    const Bound::LongLongArray_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 10; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:97

Bound::UnsignedLongLongArray_slice *
Bound::UnsignedLongLongArray_dup (const Bound::UnsignedLongLongArray_slice *_tao_src_array)
{
  Bound::UnsignedLongLongArray_slice *_tao_dup_array =
    Bound::UnsignedLongLongArray_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <Bound::UnsignedLongLongArray_slice *> (0);
    }
  
  Bound::UnsignedLongLongArray_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

Bound::UnsignedLongLongArray_slice *
Bound::UnsignedLongLongArray_alloc (void)
{
  Bound::UnsignedLongLongArray_slice *retval = 0;
  ACE_NEW_RETURN (retval, ::CORBA::ULongLong[10], 0);
  return retval;
}

void
Bound::UnsignedLongLongArray_free (
    Bound::UnsignedLongLongArray_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
Bound::UnsignedLongLongArray_copy (
    Bound::UnsignedLongLongArray_slice * _tao_to,
    const Bound::UnsignedLongLongArray_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 10; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:97

Bound::CharArray_slice *
Bound::CharArray_dup (const Bound::CharArray_slice *_tao_src_array)
{
  Bound::CharArray_slice *_tao_dup_array =
    Bound::CharArray_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <Bound::CharArray_slice *> (0);
    }
  
  Bound::CharArray_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

Bound::CharArray_slice *
Bound::CharArray_alloc (void)
{
  Bound::CharArray_slice *retval = 0;
  ACE_NEW_RETURN (retval, ::CORBA::Char[10], 0);
  return retval;
}

void
Bound::CharArray_free (
    Bound::CharArray_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
Bound::CharArray_copy (
    Bound::CharArray_slice * _tao_to,
    const Bound::CharArray_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 10; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:97

Bound::WCharArray_slice *
Bound::WCharArray_dup (const Bound::WCharArray_slice *_tao_src_array)
{
  Bound::WCharArray_slice *_tao_dup_array =
    Bound::WCharArray_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <Bound::WCharArray_slice *> (0);
    }
  
  Bound::WCharArray_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

Bound::WCharArray_slice *
Bound::WCharArray_alloc (void)
{
  Bound::WCharArray_slice *retval = 0;
  ACE_NEW_RETURN (retval, ::CORBA::WChar[10], 0);
  return retval;
}

void
Bound::WCharArray_free (
    Bound::WCharArray_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
Bound::WCharArray_copy (
    Bound::WCharArray_slice * _tao_to,
    const Bound::WCharArray_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 10; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:97

Bound::FloatArray_slice *
Bound::FloatArray_dup (const Bound::FloatArray_slice *_tao_src_array)
{
  Bound::FloatArray_slice *_tao_dup_array =
    Bound::FloatArray_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <Bound::FloatArray_slice *> (0);
    }
  
  Bound::FloatArray_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

Bound::FloatArray_slice *
Bound::FloatArray_alloc (void)
{
  Bound::FloatArray_slice *retval = 0;
  ACE_NEW_RETURN (retval, ::CORBA::Float[10], 0);
  return retval;
}

void
Bound::FloatArray_free (
    Bound::FloatArray_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
Bound::FloatArray_copy (
    Bound::FloatArray_slice * _tao_to,
    const Bound::FloatArray_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 10; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:97

Bound::DoubleArray_slice *
Bound::DoubleArray_dup (const Bound::DoubleArray_slice *_tao_src_array)
{
  Bound::DoubleArray_slice *_tao_dup_array =
    Bound::DoubleArray_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <Bound::DoubleArray_slice *> (0);
    }
  
  Bound::DoubleArray_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

Bound::DoubleArray_slice *
Bound::DoubleArray_alloc (void)
{
  Bound::DoubleArray_slice *retval = 0;
  ACE_NEW_RETURN (retval, ::CORBA::Double[10], 0);
  return retval;
}

void
Bound::DoubleArray_free (
    Bound::DoubleArray_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
Bound::DoubleArray_copy (
    Bound::DoubleArray_slice * _tao_to,
    const Bound::DoubleArray_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 10; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:97

Bound::LongDoubleArray_slice *
Bound::LongDoubleArray_dup (const Bound::LongDoubleArray_slice *_tao_src_array)
{
  Bound::LongDoubleArray_slice *_tao_dup_array =
    Bound::LongDoubleArray_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <Bound::LongDoubleArray_slice *> (0);
    }
  
  Bound::LongDoubleArray_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

Bound::LongDoubleArray_slice *
Bound::LongDoubleArray_alloc (void)
{
  Bound::LongDoubleArray_slice *retval = 0;
  ACE_NEW_RETURN (retval, ::CORBA::LongDouble[10], 0);
  return retval;
}

void
Bound::LongDoubleArray_free (
    Bound::LongDoubleArray_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
Bound::LongDoubleArray_copy (
    Bound::LongDoubleArray_slice * _tao_to,
    const Bound::LongDoubleArray_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 10; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:97

Bound::BooleanArray_slice *
Bound::BooleanArray_dup (const Bound::BooleanArray_slice *_tao_src_array)
{
  Bound::BooleanArray_slice *_tao_dup_array =
    Bound::BooleanArray_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <Bound::BooleanArray_slice *> (0);
    }
  
  Bound::BooleanArray_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

Bound::BooleanArray_slice *
Bound::BooleanArray_alloc (void)
{
  Bound::BooleanArray_slice *retval = 0;
  ACE_NEW_RETURN (retval, ::CORBA::Boolean[10], 0);
  return retval;
}

void
Bound::BooleanArray_free (
    Bound::BooleanArray_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
Bound::BooleanArray_copy (
    Bound::BooleanArray_slice * _tao_to,
    const Bound::BooleanArray_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 10; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:97

Bound::OctetArray_slice *
Bound::OctetArray_dup (const Bound::OctetArray_slice *_tao_src_array)
{
  Bound::OctetArray_slice *_tao_dup_array =
    Bound::OctetArray_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <Bound::OctetArray_slice *> (0);
    }
  
  Bound::OctetArray_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

Bound::OctetArray_slice *
Bound::OctetArray_alloc (void)
{
  Bound::OctetArray_slice *retval = 0;
  ACE_NEW_RETURN (retval, ::CORBA::Octet[10], 0);
  return retval;
}

void
Bound::OctetArray_free (
    Bound::OctetArray_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
Bound::OctetArray_copy (
    Bound::OctetArray_slice * _tao_to,
    const Bound::OctetArray_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 10; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:97

Bound::EnumTypeArray_slice *
Bound::EnumTypeArray_dup (const Bound::EnumTypeArray_slice *_tao_src_array)
{
  Bound::EnumTypeArray_slice *_tao_dup_array =
    Bound::EnumTypeArray_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <Bound::EnumTypeArray_slice *> (0);
    }
  
  Bound::EnumTypeArray_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

Bound::EnumTypeArray_slice *
Bound::EnumTypeArray_alloc (void)
{
  Bound::EnumTypeArray_slice *retval = 0;
  ACE_NEW_RETURN (retval, Bound::EnumType[10], 0);
  return retval;
}

void
Bound::EnumTypeArray_free (
    Bound::EnumTypeArray_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
Bound::EnumTypeArray_copy (
    Bound::EnumTypeArray_slice * _tao_to,
    const Bound::EnumTypeArray_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 10; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:97

Bound::StringArray_slice *
Bound::StringArray_dup (const Bound::StringArray_slice *_tao_src_array)
{
  Bound::StringArray_slice *_tao_dup_array =
    Bound::StringArray_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <Bound::StringArray_slice *> (0);
    }
  
  Bound::StringArray_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

Bound::StringArray_slice *
Bound::StringArray_alloc (void)
{
  Bound::StringArray_slice *retval = 0;
  ACE_NEW_RETURN (retval, ::TAO::String_Manager[10], 0);
  return retval;
}

void
Bound::StringArray_free (
    Bound::StringArray_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
Bound::StringArray_copy (
    Bound::StringArray_slice * _tao_to,
    const Bound::StringArray_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 10; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:97

Bound::WStringArray_slice *
Bound::WStringArray_dup (const Bound::WStringArray_slice *_tao_src_array)
{
  Bound::WStringArray_slice *_tao_dup_array =
    Bound::WStringArray_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <Bound::WStringArray_slice *> (0);
    }
  
  Bound::WStringArray_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

Bound::WStringArray_slice *
Bound::WStringArray_alloc (void)
{
  Bound::WStringArray_slice *retval = 0;
  ACE_NEW_RETURN (retval, ::TAO::WString_Manager[10], 0);
  return retval;
}

void
Bound::WStringArray_free (
    Bound::WStringArray_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
Bound::WStringArray_copy (
    Bound::WStringArray_slice * _tao_to,
    const Bound::WStringArray_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 10; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_enum/cdr_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, Bound::EnumType _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, Bound::EnumType & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<Bound::EnumType> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Bound::SimpleBoundedMessage &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.short_field) &&
    (strm << _tao_aggregate.unsigned_short_field) &&
    (strm << _tao_aggregate.long_field) &&
    (strm << _tao_aggregate.unsigned_long_field) &&
    (strm << _tao_aggregate.long_long_field) &&
    (strm << _tao_aggregate.unsigned_long_long_field) &&
    (strm << ::ACE_OutputCDR::from_char (_tao_aggregate.char_field)) &&
    (strm << ::ACE_OutputCDR::from_wchar (_tao_aggregate.wchar_field)) &&
    (strm << _tao_aggregate.float_field) &&
    (strm << _tao_aggregate.double_field) &&
    (strm << _tao_aggregate.long_double_field) &&
    (strm << ::ACE_OutputCDR::from_boolean (_tao_aggregate.boolean_field)) &&
    (strm << ::ACE_OutputCDR::from_octet (_tao_aggregate.octet_field)) &&
    (strm << _tao_aggregate.enum_field);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Bound::SimpleBoundedMessage &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.short_field) &&
    (strm >> _tao_aggregate.unsigned_short_field) &&
    (strm >> _tao_aggregate.long_field) &&
    (strm >> _tao_aggregate.unsigned_long_field) &&
    (strm >> _tao_aggregate.long_long_field) &&
    (strm >> _tao_aggregate.unsigned_long_long_field) &&
    (strm >> ::ACE_InputCDR::to_char (_tao_aggregate.char_field)) &&
    (strm >> ::ACE_InputCDR::to_wchar (_tao_aggregate.wchar_field)) &&
    (strm >> _tao_aggregate.float_field) &&
    (strm >> _tao_aggregate.double_field) &&
    (strm >> _tao_aggregate.long_double_field) &&
    (strm >> ::ACE_InputCDR::to_boolean (_tao_aggregate.boolean_field)) &&
    (strm >> ::ACE_InputCDR::to_octet (_tao_aggregate.octet_field)) &&
    (strm >> _tao_aggregate.enum_field);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Bound::StringMessage &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.string_field.in ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Bound::StringMessage &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.string_field.out ());
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Bound::WStringMessage &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.wstring_field.in ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Bound::WStringMessage &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.wstring_field.out ());
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:166


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Bound::ShortArray_forany &_tao_array)
{
  return
    strm.write_short_array (
        reinterpret_cast <const ACE_CDR::Short *> (_tao_array.in ()),
        10);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Bound::ShortArray_forany &_tao_array)
{
  return
    strm.read_short_array (
        reinterpret_cast <ACE_CDR::Short *> (_tao_array.out ()),
        10);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:166


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Bound::UnsignedShortArray_forany &_tao_array)
{
  return
    strm.write_ushort_array (
        reinterpret_cast <const ACE_CDR::UShort *> (_tao_array.in ()),
        10);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Bound::UnsignedShortArray_forany &_tao_array)
{
  return
    strm.read_ushort_array (
        reinterpret_cast <ACE_CDR::UShort *> (_tao_array.out ()),
        10);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:166


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Bound::LongArray_forany &_tao_array)
{
  return
    strm.write_long_array (
        reinterpret_cast <const ACE_CDR::Long *> (_tao_array.in ()),
        10);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Bound::LongArray_forany &_tao_array)
{
  return
    strm.read_long_array (
        reinterpret_cast <ACE_CDR::Long *> (_tao_array.out ()),
        10);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:166


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Bound::UnsignedLongArray_forany &_tao_array)
{
  return
    strm.write_ulong_array (
        reinterpret_cast <const ACE_CDR::ULong *> (_tao_array.in ()),
        10);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Bound::UnsignedLongArray_forany &_tao_array)
{
  return
    strm.read_ulong_array (
        reinterpret_cast <ACE_CDR::ULong *> (_tao_array.out ()),
        10);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:166


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Bound::LongLongArray_forany &_tao_array)
{
  return
    strm.write_longlong_array (
        reinterpret_cast <const ACE_CDR::LongLong *> (_tao_array.in ()),
        10);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Bound::LongLongArray_forany &_tao_array)
{
  return
    strm.read_longlong_array (
        reinterpret_cast <ACE_CDR::LongLong *> (_tao_array.out ()),
        10);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:166


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Bound::UnsignedLongLongArray_forany &_tao_array)
{
  return
    strm.write_ulonglong_array (
        reinterpret_cast <const ACE_CDR::ULongLong *> (_tao_array.in ()),
        10);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Bound::UnsignedLongLongArray_forany &_tao_array)
{
  return
    strm.read_ulonglong_array (
        reinterpret_cast <ACE_CDR::ULongLong *> (_tao_array.out ()),
        10);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:166


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Bound::CharArray_forany &_tao_array)
{
  return
    strm.write_char_array (
        reinterpret_cast <const ACE_CDR::Char *> (_tao_array.in ()),
        10);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Bound::CharArray_forany &_tao_array)
{
  return
    strm.read_char_array (
        reinterpret_cast <ACE_CDR::Char *> (_tao_array.out ()),
        10);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:166


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Bound::WCharArray_forany &_tao_array)
{
  return
    strm.write_wchar_array (
        reinterpret_cast <const ACE_CDR::WChar *> (_tao_array.in ()),
        10);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Bound::WCharArray_forany &_tao_array)
{
  return
    strm.read_wchar_array (
        reinterpret_cast <ACE_CDR::WChar *> (_tao_array.out ()),
        10);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:166


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Bound::FloatArray_forany &_tao_array)
{
  return
    strm.write_float_array (
        reinterpret_cast <const ACE_CDR::Float *> (_tao_array.in ()),
        10);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Bound::FloatArray_forany &_tao_array)
{
  return
    strm.read_float_array (
        reinterpret_cast <ACE_CDR::Float *> (_tao_array.out ()),
        10);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:166


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Bound::DoubleArray_forany &_tao_array)
{
  return
    strm.write_double_array (
        reinterpret_cast <const ACE_CDR::Double *> (_tao_array.in ()),
        10);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Bound::DoubleArray_forany &_tao_array)
{
  return
    strm.read_double_array (
        reinterpret_cast <ACE_CDR::Double *> (_tao_array.out ()),
        10);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:166


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Bound::LongDoubleArray_forany &_tao_array)
{
  return
    strm.write_longdouble_array (
        reinterpret_cast <const ACE_CDR::LongDouble *> (_tao_array.in ()),
        10);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Bound::LongDoubleArray_forany &_tao_array)
{
  return
    strm.read_longdouble_array (
        reinterpret_cast <ACE_CDR::LongDouble *> (_tao_array.out ()),
        10);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:166


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Bound::BooleanArray_forany &_tao_array)
{
  return
    strm.write_boolean_array (
        reinterpret_cast <const ACE_CDR::Boolean *> (_tao_array.in ()),
        10);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Bound::BooleanArray_forany &_tao_array)
{
  return
    strm.read_boolean_array (
        reinterpret_cast <ACE_CDR::Boolean *> (_tao_array.out ()),
        10);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:166


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Bound::OctetArray_forany &_tao_array)
{
  return
    strm.write_octet_array (
        reinterpret_cast <const ACE_CDR::Octet *> (_tao_array.in ()),
        10);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Bound::OctetArray_forany &_tao_array)
{
  return
    strm.read_octet_array (
        reinterpret_cast <ACE_CDR::Octet *> (_tao_array.out ()),
        10);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:166


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Bound::EnumTypeArray_forany &_tao_array)
{
  CORBA::Boolean _tao_marshal_flag = true;
  
  for ( ::CORBA::ULong i0 = 0; i0 < 10 && _tao_marshal_flag; ++i0)
    {
      _tao_marshal_flag = (strm << _tao_array [i0]);
    }

  return _tao_marshal_flag;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Bound::EnumTypeArray_forany &_tao_array)
{
  CORBA::Boolean _tao_marshal_flag = true;
  
  for ( ::CORBA::ULong i0 = 0; i0 < 10 && _tao_marshal_flag; ++i0)
    {
      _tao_marshal_flag = (strm >> _tao_array [i0]);
    }

  return _tao_marshal_flag;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Bound::SimpleBoundedArrayMessage &_tao_aggregate)
{
  Bound::ShortArray_forany _tao_aggregate_short_array
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Bound::ShortArray_slice*) (
      #else
      (const_cast<
          Bound::ShortArray_slice*> (
      #endif
          _tao_aggregate.short_array
        )
    );
  Bound::UnsignedShortArray_forany _tao_aggregate_unsigned_short_array
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Bound::UnsignedShortArray_slice*) (
      #else
      (const_cast<
          Bound::UnsignedShortArray_slice*> (
      #endif
          _tao_aggregate.unsigned_short_array
        )
    );
  Bound::LongArray_forany _tao_aggregate_long_array
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Bound::LongArray_slice*) (
      #else
      (const_cast<
          Bound::LongArray_slice*> (
      #endif
          _tao_aggregate.long_array
        )
    );
  Bound::UnsignedLongArray_forany _tao_aggregate_unsigned_long_array
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Bound::UnsignedLongArray_slice*) (
      #else
      (const_cast<
          Bound::UnsignedLongArray_slice*> (
      #endif
          _tao_aggregate.unsigned_long_array
        )
    );
  Bound::LongLongArray_forany _tao_aggregate_long_long_array
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Bound::LongLongArray_slice*) (
      #else
      (const_cast<
          Bound::LongLongArray_slice*> (
      #endif
          _tao_aggregate.long_long_array
        )
    );
  Bound::UnsignedLongLongArray_forany _tao_aggregate_unsigned_long_long_array
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Bound::UnsignedLongLongArray_slice*) (
      #else
      (const_cast<
          Bound::UnsignedLongLongArray_slice*> (
      #endif
          _tao_aggregate.unsigned_long_long_array
        )
    );
  Bound::CharArray_forany _tao_aggregate_char_array
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Bound::CharArray_slice*) (
      #else
      (const_cast<
          Bound::CharArray_slice*> (
      #endif
          _tao_aggregate.char_array
        )
    );
  Bound::WCharArray_forany _tao_aggregate_wchar_array
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Bound::WCharArray_slice*) (
      #else
      (const_cast<
          Bound::WCharArray_slice*> (
      #endif
          _tao_aggregate.wchar_array
        )
    );
  Bound::FloatArray_forany _tao_aggregate_float_array
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Bound::FloatArray_slice*) (
      #else
      (const_cast<
          Bound::FloatArray_slice*> (
      #endif
          _tao_aggregate.float_array
        )
    );
  Bound::DoubleArray_forany _tao_aggregate_double_array
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Bound::DoubleArray_slice*) (
      #else
      (const_cast<
          Bound::DoubleArray_slice*> (
      #endif
          _tao_aggregate.double_array
        )
    );
  Bound::LongDoubleArray_forany _tao_aggregate_long_double_array
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Bound::LongDoubleArray_slice*) (
      #else
      (const_cast<
          Bound::LongDoubleArray_slice*> (
      #endif
          _tao_aggregate.long_double_array
        )
    );
  Bound::BooleanArray_forany _tao_aggregate_boolean_array
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Bound::BooleanArray_slice*) (
      #else
      (const_cast<
          Bound::BooleanArray_slice*> (
      #endif
          _tao_aggregate.boolean_array
        )
    );
  Bound::OctetArray_forany _tao_aggregate_octet_array
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Bound::OctetArray_slice*) (
      #else
      (const_cast<
          Bound::OctetArray_slice*> (
      #endif
          _tao_aggregate.octet_array
        )
    );
  Bound::EnumTypeArray_forany _tao_aggregate_enum_array
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Bound::EnumTypeArray_slice*) (
      #else
      (const_cast<
          Bound::EnumTypeArray_slice*> (
      #endif
          _tao_aggregate.enum_array
        )
    );
  return
    (strm << _tao_aggregate_short_array) &&
    (strm << _tao_aggregate_unsigned_short_array) &&
    (strm << _tao_aggregate_long_array) &&
    (strm << _tao_aggregate_unsigned_long_array) &&
    (strm << _tao_aggregate_long_long_array) &&
    (strm << _tao_aggregate_unsigned_long_long_array) &&
    (strm << _tao_aggregate_char_array) &&
    (strm << _tao_aggregate_wchar_array) &&
    (strm << _tao_aggregate_float_array) &&
    (strm << _tao_aggregate_double_array) &&
    (strm << _tao_aggregate_long_double_array) &&
    (strm << _tao_aggregate_boolean_array) &&
    (strm << _tao_aggregate_octet_array) &&
    (strm << _tao_aggregate_enum_array);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Bound::SimpleBoundedArrayMessage &_tao_aggregate)
{
  Bound::ShortArray_forany _tao_aggregate_short_array
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Bound::ShortArray_slice*) (
      #else
      (const_cast<
          Bound::ShortArray_slice*> (
      #endif
          _tao_aggregate.short_array
        )
    );
  Bound::UnsignedShortArray_forany _tao_aggregate_unsigned_short_array
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Bound::UnsignedShortArray_slice*) (
      #else
      (const_cast<
          Bound::UnsignedShortArray_slice*> (
      #endif
          _tao_aggregate.unsigned_short_array
        )
    );
  Bound::LongArray_forany _tao_aggregate_long_array
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Bound::LongArray_slice*) (
      #else
      (const_cast<
          Bound::LongArray_slice*> (
      #endif
          _tao_aggregate.long_array
        )
    );
  Bound::UnsignedLongArray_forany _tao_aggregate_unsigned_long_array
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Bound::UnsignedLongArray_slice*) (
      #else
      (const_cast<
          Bound::UnsignedLongArray_slice*> (
      #endif
          _tao_aggregate.unsigned_long_array
        )
    );
  Bound::LongLongArray_forany _tao_aggregate_long_long_array
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Bound::LongLongArray_slice*) (
      #else
      (const_cast<
          Bound::LongLongArray_slice*> (
      #endif
          _tao_aggregate.long_long_array
        )
    );
  Bound::UnsignedLongLongArray_forany _tao_aggregate_unsigned_long_long_array
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Bound::UnsignedLongLongArray_slice*) (
      #else
      (const_cast<
          Bound::UnsignedLongLongArray_slice*> (
      #endif
          _tao_aggregate.unsigned_long_long_array
        )
    );
  Bound::CharArray_forany _tao_aggregate_char_array
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Bound::CharArray_slice*) (
      #else
      (const_cast<
          Bound::CharArray_slice*> (
      #endif
          _tao_aggregate.char_array
        )
    );
  Bound::WCharArray_forany _tao_aggregate_wchar_array
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Bound::WCharArray_slice*) (
      #else
      (const_cast<
          Bound::WCharArray_slice*> (
      #endif
          _tao_aggregate.wchar_array
        )
    );
  Bound::FloatArray_forany _tao_aggregate_float_array
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Bound::FloatArray_slice*) (
      #else
      (const_cast<
          Bound::FloatArray_slice*> (
      #endif
          _tao_aggregate.float_array
        )
    );
  Bound::DoubleArray_forany _tao_aggregate_double_array
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Bound::DoubleArray_slice*) (
      #else
      (const_cast<
          Bound::DoubleArray_slice*> (
      #endif
          _tao_aggregate.double_array
        )
    );
  Bound::LongDoubleArray_forany _tao_aggregate_long_double_array
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Bound::LongDoubleArray_slice*) (
      #else
      (const_cast<
          Bound::LongDoubleArray_slice*> (
      #endif
          _tao_aggregate.long_double_array
        )
    );
  Bound::BooleanArray_forany _tao_aggregate_boolean_array
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Bound::BooleanArray_slice*) (
      #else
      (const_cast<
          Bound::BooleanArray_slice*> (
      #endif
          _tao_aggregate.boolean_array
        )
    );
  Bound::OctetArray_forany _tao_aggregate_octet_array
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Bound::OctetArray_slice*) (
      #else
      (const_cast<
          Bound::OctetArray_slice*> (
      #endif
          _tao_aggregate.octet_array
        )
    );
  Bound::EnumTypeArray_forany _tao_aggregate_enum_array
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Bound::EnumTypeArray_slice*) (
      #else
      (const_cast<
          Bound::EnumTypeArray_slice*> (
      #endif
          _tao_aggregate.enum_array
        )
    );
  return
    (strm >> _tao_aggregate_short_array) &&
    (strm >> _tao_aggregate_unsigned_short_array) &&
    (strm >> _tao_aggregate_long_array) &&
    (strm >> _tao_aggregate_unsigned_long_array) &&
    (strm >> _tao_aggregate_long_long_array) &&
    (strm >> _tao_aggregate_unsigned_long_long_array) &&
    (strm >> _tao_aggregate_char_array) &&
    (strm >> _tao_aggregate_wchar_array) &&
    (strm >> _tao_aggregate_float_array) &&
    (strm >> _tao_aggregate_double_array) &&
    (strm >> _tao_aggregate_long_double_array) &&
    (strm >> _tao_aggregate_boolean_array) &&
    (strm >> _tao_aggregate_octet_array) &&
    (strm >> _tao_aggregate_enum_array);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:166


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Bound::StringArray_forany &_tao_array)
{
  CORBA::Boolean _tao_marshal_flag = true;
  
  for ( ::CORBA::ULong i0 = 0; i0 < 10 && _tao_marshal_flag; ++i0)
    {
      _tao_marshal_flag = (strm << _tao_array [i0].in ());
    }

  return _tao_marshal_flag;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Bound::StringArray_forany &_tao_array)
{
  CORBA::Boolean _tao_marshal_flag = true;
  
  for ( ::CORBA::ULong i0 = 0; i0 < 10 && _tao_marshal_flag; ++i0)
    {
      _tao_marshal_flag = (strm >> _tao_array [i0].out ());
    }

  return _tao_marshal_flag;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Bound::StringArrayMessage &_tao_aggregate)
{
  Bound::StringArray_forany _tao_aggregate_string_array
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Bound::StringArray_slice*) (
      #else
      (const_cast<
          Bound::StringArray_slice*> (
      #endif
          _tao_aggregate.string_array
        )
    );
  return
    (strm << _tao_aggregate_string_array);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Bound::StringArrayMessage &_tao_aggregate)
{
  Bound::StringArray_forany _tao_aggregate_string_array
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Bound::StringArray_slice*) (
      #else
      (const_cast<
          Bound::StringArray_slice*> (
      #endif
          _tao_aggregate.string_array
        )
    );
  return
    (strm >> _tao_aggregate_string_array);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:166


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Bound::WStringArray_forany &_tao_array)
{
  CORBA::Boolean _tao_marshal_flag = true;
  
  for ( ::CORBA::ULong i0 = 0; i0 < 10 && _tao_marshal_flag; ++i0)
    {
      _tao_marshal_flag = (strm << _tao_array [i0].in ());
    }

  return _tao_marshal_flag;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Bound::WStringArray_forany &_tao_array)
{
  CORBA::Boolean _tao_marshal_flag = true;
  
  for ( ::CORBA::ULong i0 = 0; i0 < 10 && _tao_marshal_flag; ++i0)
    {
      _tao_marshal_flag = (strm >> _tao_array [i0].out ());
    }

  return _tao_marshal_flag;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Bound::WStringArrayMessage &_tao_aggregate)
{
  Bound::WStringArray_forany _tao_aggregate_wstring_array
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Bound::WStringArray_slice*) (
      #else
      (const_cast<
          Bound::WStringArray_slice*> (
      #endif
          _tao_aggregate.wstring_array
        )
    );
  return
    (strm << _tao_aggregate_wstring_array);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Bound::WStringArrayMessage &_tao_aggregate)
{
  Bound::WStringArray_forany _tao_aggregate_wstring_array
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Bound::WStringArray_slice*) (
      #else
      (const_cast<
          Bound::WStringArray_slice*> (
      #endif
          _tao_aggregate.wstring_array
        )
    );
  return
    (strm >> _tao_aggregate_wstring_array);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Bound::Nest1 &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.long_field) &&
    (strm << _tao_aggregate.short_field);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Bound::Nest1 &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.long_field) &&
    (strm >> _tao_aggregate.short_field);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Bound::Nest2 &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.nest1_field) &&
    (strm << _tao_aggregate.float_field);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Bound::Nest2 &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.nest1_field) &&
    (strm >> _tao_aggregate.float_field);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Bound::BoundedNestedMessage &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.nest2_field);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Bound::BoundedNestedMessage &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.nest2_field);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Bound::Nest3 &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.long_field) &&
    (strm << _tao_aggregate.short_field) &&
    (strm << _tao_aggregate.string_field.in ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Bound::Nest3 &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.long_field) &&
    (strm >> _tao_aggregate.short_field) &&
    (strm >> _tao_aggregate.string_field.out ());
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Bound::Nest4 &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.nest3_field) &&
    (strm << _tao_aggregate.float_field);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Bound::Nest4 &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.nest3_field) &&
    (strm >> _tao_aggregate.float_field);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Bound::UnboundedNestedMessage &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.nest4_field);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Bound::UnboundedNestedMessage &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.nest4_field);
}

TAO_END_VERSIONED_NAMESPACE_DECL



