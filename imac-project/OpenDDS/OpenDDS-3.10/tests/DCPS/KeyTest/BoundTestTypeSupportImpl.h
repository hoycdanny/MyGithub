/* -*- C++ -*- */
/* Generated by /Users/yc/MyGithub/imac-project/OpenDDS/OpenDDS-3.10/bin/opendds_idl version 3.10 (ACE version 6.2a_p11) running on input file BoundTest.idl */
#ifndef OPENDDS_IDL_GENERATED_BOUNDTESTTYPESUPPORTIMPL_H_IH7TKS
#define OPENDDS_IDL_GENERATED_BOUNDTESTTYPESUPPORTIMPL_H_IH7TKS
#include "BoundTestC.h"
#include "dds/DCPS/Definitions.h"
#include "BoundTestTypeSupportC.h"
#include "dds/DCPS/Serializer.h"
#include "dds/DCPS/TypeSupportImpl.h"
#include "tao/FloatSeqC.h"
#include "tao/StringSeqC.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: FloatSeq */


/* End TYPEDEF: FloatSeq */

/* End MODULE: CORBA */


/* Begin MODULE: Bound */



/* Begin ENUM: EnumType */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::EnumType& enumval);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::EnumType& enumval);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

extern const char* gen_Bound_EnumType_names[];
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End ENUM: EnumType */


/* Begin STRUCT: SimpleBoundedMessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::SimpleBoundedMessage& stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::SimpleBoundedMessage& stru);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::SimpleBoundedMessage& stru);

KeyTest_Export
size_t gen_max_marshaled_size(const Bound::SimpleBoundedMessage& stru, bool align);

KeyTest_Export
size_t gen_max_marshaled_size(KeyOnly<const Bound::SimpleBoundedMessage> stru, bool align);

KeyTest_Export
void gen_find_size(KeyOnly<const Bound::SimpleBoundedMessage> stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, KeyOnly<const Bound::SimpleBoundedMessage> stru);

KeyTest_Export
bool operator>>(Serializer& strm, KeyOnly<Bound::SimpleBoundedMessage> stru);

template <>
struct MarshalTraits<Bound::SimpleBoundedMessage> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Bound {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct KeyTest_Export SimpleBoundedMessage_OpenDDS_KeyLessThan {
  bool operator()(const Bound::SimpleBoundedMessage&, const Bound::SimpleBoundedMessage&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Bound {
class SimpleBoundedMessageTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Bound::SimpleBoundedMessage> {
  typedef Bound::SimpleBoundedMessage MessageType;
  typedef Bound::SimpleBoundedMessageSeq MessageSequenceType;
  typedef Bound::SimpleBoundedMessageTypeSupport TypeSupportType;
  typedef Bound::SimpleBoundedMessageTypeSupportImpl TypeSupportTypeImpl;
  typedef Bound::SimpleBoundedMessageDataWriter DataWriterType;
  typedef Bound::SimpleBoundedMessageDataReader DataReaderType;
  typedef Bound::SimpleBoundedMessage_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Bound::SimpleBoundedMessage"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Bound {
class KeyTest_Export SimpleBoundedMessageTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<SimpleBoundedMessageTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<SimpleBoundedMessage> TraitsType;
  typedef SimpleBoundedMessageTypeSupport TypeSupportType;
  typedef SimpleBoundedMessageTypeSupport::_var_type _var_type;
  typedef SimpleBoundedMessageTypeSupport::_ptr_type _ptr_type;

  SimpleBoundedMessageTypeSupportImpl() {}
  virtual ~SimpleBoundedMessageTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static SimpleBoundedMessageTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

class MetaStruct;

template<typename T>
const MetaStruct& getMetaStruct();

template<>
KeyTest_Export
const MetaStruct& getMetaStruct<Bound::SimpleBoundedMessage>();
KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::SimpleBoundedMessage*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SimpleBoundedMessage */


/* Begin STRUCT: StringMessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::StringMessage& stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::StringMessage& stru);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::StringMessage& stru);

KeyTest_Export
size_t gen_max_marshaled_size(const Bound::StringMessage& stru, bool align);

KeyTest_Export
size_t gen_max_marshaled_size(KeyOnly<const Bound::StringMessage> stru, bool align);

KeyTest_Export
void gen_find_size(KeyOnly<const Bound::StringMessage> stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, KeyOnly<const Bound::StringMessage> stru);

KeyTest_Export
bool operator>>(Serializer& strm, KeyOnly<Bound::StringMessage> stru);

template <>
struct MarshalTraits<Bound::StringMessage> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Bound {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct KeyTest_Export StringMessage_OpenDDS_KeyLessThan {
  bool operator()(const Bound::StringMessage&, const Bound::StringMessage&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Bound {
class StringMessageTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Bound::StringMessage> {
  typedef Bound::StringMessage MessageType;
  typedef Bound::StringMessageSeq MessageSequenceType;
  typedef Bound::StringMessageTypeSupport TypeSupportType;
  typedef Bound::StringMessageTypeSupportImpl TypeSupportTypeImpl;
  typedef Bound::StringMessageDataWriter DataWriterType;
  typedef Bound::StringMessageDataReader DataReaderType;
  typedef Bound::StringMessage_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Bound::StringMessage"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Bound {
class KeyTest_Export StringMessageTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<StringMessageTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<StringMessage> TraitsType;
  typedef StringMessageTypeSupport TypeSupportType;
  typedef StringMessageTypeSupport::_var_type _var_type;
  typedef StringMessageTypeSupport::_ptr_type _ptr_type;

  StringMessageTypeSupportImpl() {}
  virtual ~StringMessageTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static StringMessageTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
KeyTest_Export
const MetaStruct& getMetaStruct<Bound::StringMessage>();
KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::StringMessage*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StringMessage */


/* Begin STRUCT: WStringMessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::WStringMessage& stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::WStringMessage& stru);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::WStringMessage& stru);

KeyTest_Export
size_t gen_max_marshaled_size(const Bound::WStringMessage& stru, bool align);

KeyTest_Export
size_t gen_max_marshaled_size(KeyOnly<const Bound::WStringMessage> stru, bool align);

KeyTest_Export
void gen_find_size(KeyOnly<const Bound::WStringMessage> stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, KeyOnly<const Bound::WStringMessage> stru);

KeyTest_Export
bool operator>>(Serializer& strm, KeyOnly<Bound::WStringMessage> stru);

template <>
struct MarshalTraits<Bound::WStringMessage> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Bound {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct KeyTest_Export WStringMessage_OpenDDS_KeyLessThan {
  bool operator()(const Bound::WStringMessage&, const Bound::WStringMessage&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Bound {
class WStringMessageTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Bound::WStringMessage> {
  typedef Bound::WStringMessage MessageType;
  typedef Bound::WStringMessageSeq MessageSequenceType;
  typedef Bound::WStringMessageTypeSupport TypeSupportType;
  typedef Bound::WStringMessageTypeSupportImpl TypeSupportTypeImpl;
  typedef Bound::WStringMessageDataWriter DataWriterType;
  typedef Bound::WStringMessageDataReader DataReaderType;
  typedef Bound::WStringMessage_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Bound::WStringMessage"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Bound {
class KeyTest_Export WStringMessageTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<WStringMessageTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<WStringMessage> TraitsType;
  typedef WStringMessageTypeSupport TypeSupportType;
  typedef WStringMessageTypeSupport::_var_type _var_type;
  typedef WStringMessageTypeSupport::_ptr_type _ptr_type;

  WStringMessageTypeSupportImpl() {}
  virtual ~WStringMessageTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static WStringMessageTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
KeyTest_Export
const MetaStruct& getMetaStruct<Bound::WStringMessage>();
KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::WStringMessage*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: WStringMessage */


/* Begin TYPEDEF: ShortArray */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::ShortArray_forany& arr, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::ShortArray_forany& arr);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::ShortArray_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::ShortArray_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: ShortArray */


/* Begin TYPEDEF: UnsignedShortArray */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::UnsignedShortArray_forany& arr, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::UnsignedShortArray_forany& arr);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::UnsignedShortArray_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::UnsignedShortArray_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: UnsignedShortArray */


/* Begin TYPEDEF: LongArray */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::LongArray_forany& arr, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::LongArray_forany& arr);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::LongArray_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::LongArray_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: LongArray */


/* Begin TYPEDEF: UnsignedLongArray */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::UnsignedLongArray_forany& arr, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::UnsignedLongArray_forany& arr);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::UnsignedLongArray_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::UnsignedLongArray_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: UnsignedLongArray */


/* Begin TYPEDEF: LongLongArray */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::LongLongArray_forany& arr, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::LongLongArray_forany& arr);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::LongLongArray_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::LongLongArray_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: LongLongArray */


/* Begin TYPEDEF: UnsignedLongLongArray */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::UnsignedLongLongArray_forany& arr, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::UnsignedLongLongArray_forany& arr);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::UnsignedLongLongArray_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::UnsignedLongLongArray_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: UnsignedLongLongArray */


/* Begin TYPEDEF: CharArray */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::CharArray_forany& arr, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::CharArray_forany& arr);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::CharArray_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::CharArray_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: CharArray */


/* Begin TYPEDEF: WCharArray */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::WCharArray_forany& arr, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::WCharArray_forany& arr);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::WCharArray_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::WCharArray_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: WCharArray */


/* Begin TYPEDEF: FloatArray */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::FloatArray_forany& arr, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::FloatArray_forany& arr);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::FloatArray_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::FloatArray_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: FloatArray */


/* Begin TYPEDEF: DoubleArray */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::DoubleArray_forany& arr, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::DoubleArray_forany& arr);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::DoubleArray_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::DoubleArray_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: DoubleArray */


/* Begin TYPEDEF: LongDoubleArray */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::LongDoubleArray_forany& arr, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::LongDoubleArray_forany& arr);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::LongDoubleArray_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::LongDoubleArray_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: LongDoubleArray */


/* Begin TYPEDEF: BooleanArray */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::BooleanArray_forany& arr, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::BooleanArray_forany& arr);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::BooleanArray_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::BooleanArray_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: BooleanArray */


/* Begin TYPEDEF: OctetArray */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::OctetArray_forany& arr, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::OctetArray_forany& arr);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::OctetArray_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::OctetArray_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: OctetArray */


/* Begin TYPEDEF: EnumTypeArray */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::EnumTypeArray_forany& arr, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::EnumTypeArray_forany& arr);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::EnumTypeArray_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::EnumTypeArray_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: EnumTypeArray */


/* Begin STRUCT: SimpleBoundedArrayMessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::SimpleBoundedArrayMessage& stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::SimpleBoundedArrayMessage& stru);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::SimpleBoundedArrayMessage& stru);

KeyTest_Export
size_t gen_max_marshaled_size(const Bound::SimpleBoundedArrayMessage& stru, bool align);

KeyTest_Export
size_t gen_max_marshaled_size(KeyOnly<const Bound::SimpleBoundedArrayMessage> stru, bool align);

KeyTest_Export
void gen_find_size(KeyOnly<const Bound::SimpleBoundedArrayMessage> stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, KeyOnly<const Bound::SimpleBoundedArrayMessage> stru);

KeyTest_Export
bool operator>>(Serializer& strm, KeyOnly<Bound::SimpleBoundedArrayMessage> stru);

template <>
struct MarshalTraits<Bound::SimpleBoundedArrayMessage> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Bound {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct KeyTest_Export SimpleBoundedArrayMessage_OpenDDS_KeyLessThan {
  bool operator()(const Bound::SimpleBoundedArrayMessage&, const Bound::SimpleBoundedArrayMessage&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Bound {
class SimpleBoundedArrayMessageTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Bound::SimpleBoundedArrayMessage> {
  typedef Bound::SimpleBoundedArrayMessage MessageType;
  typedef Bound::SimpleBoundedArrayMessageSeq MessageSequenceType;
  typedef Bound::SimpleBoundedArrayMessageTypeSupport TypeSupportType;
  typedef Bound::SimpleBoundedArrayMessageTypeSupportImpl TypeSupportTypeImpl;
  typedef Bound::SimpleBoundedArrayMessageDataWriter DataWriterType;
  typedef Bound::SimpleBoundedArrayMessageDataReader DataReaderType;
  typedef Bound::SimpleBoundedArrayMessage_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Bound::SimpleBoundedArrayMessage"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Bound {
class KeyTest_Export SimpleBoundedArrayMessageTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<SimpleBoundedArrayMessageTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<SimpleBoundedArrayMessage> TraitsType;
  typedef SimpleBoundedArrayMessageTypeSupport TypeSupportType;
  typedef SimpleBoundedArrayMessageTypeSupport::_var_type _var_type;
  typedef SimpleBoundedArrayMessageTypeSupport::_ptr_type _ptr_type;

  SimpleBoundedArrayMessageTypeSupportImpl() {}
  virtual ~SimpleBoundedArrayMessageTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static SimpleBoundedArrayMessageTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
KeyTest_Export
const MetaStruct& getMetaStruct<Bound::SimpleBoundedArrayMessage>();
KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::SimpleBoundedArrayMessage*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SimpleBoundedArrayMessage */


/* Begin TYPEDEF: StringArray */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::StringArray_forany& arr, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::StringArray_forany& arr);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::StringArray_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::StringArray_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: StringArray */


/* Begin STRUCT: StringArrayMessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::StringArrayMessage& stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::StringArrayMessage& stru);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::StringArrayMessage& stru);

KeyTest_Export
size_t gen_max_marshaled_size(const Bound::StringArrayMessage& stru, bool align);

KeyTest_Export
size_t gen_max_marshaled_size(KeyOnly<const Bound::StringArrayMessage> stru, bool align);

KeyTest_Export
void gen_find_size(KeyOnly<const Bound::StringArrayMessage> stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, KeyOnly<const Bound::StringArrayMessage> stru);

KeyTest_Export
bool operator>>(Serializer& strm, KeyOnly<Bound::StringArrayMessage> stru);

template <>
struct MarshalTraits<Bound::StringArrayMessage> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Bound {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct KeyTest_Export StringArrayMessage_OpenDDS_KeyLessThan {
  bool operator()(const Bound::StringArrayMessage&, const Bound::StringArrayMessage&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Bound {
class StringArrayMessageTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Bound::StringArrayMessage> {
  typedef Bound::StringArrayMessage MessageType;
  typedef Bound::StringArrayMessageSeq MessageSequenceType;
  typedef Bound::StringArrayMessageTypeSupport TypeSupportType;
  typedef Bound::StringArrayMessageTypeSupportImpl TypeSupportTypeImpl;
  typedef Bound::StringArrayMessageDataWriter DataWriterType;
  typedef Bound::StringArrayMessageDataReader DataReaderType;
  typedef Bound::StringArrayMessage_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Bound::StringArrayMessage"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Bound {
class KeyTest_Export StringArrayMessageTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<StringArrayMessageTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<StringArrayMessage> TraitsType;
  typedef StringArrayMessageTypeSupport TypeSupportType;
  typedef StringArrayMessageTypeSupport::_var_type _var_type;
  typedef StringArrayMessageTypeSupport::_ptr_type _ptr_type;

  StringArrayMessageTypeSupportImpl() {}
  virtual ~StringArrayMessageTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static StringArrayMessageTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
KeyTest_Export
const MetaStruct& getMetaStruct<Bound::StringArrayMessage>();
KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::StringArrayMessage*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StringArrayMessage */


/* Begin TYPEDEF: WStringArray */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::WStringArray_forany& arr, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::WStringArray_forany& arr);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::WStringArray_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::WStringArray_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: WStringArray */


/* Begin STRUCT: WStringArrayMessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::WStringArrayMessage& stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::WStringArrayMessage& stru);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::WStringArrayMessage& stru);

KeyTest_Export
size_t gen_max_marshaled_size(const Bound::WStringArrayMessage& stru, bool align);

KeyTest_Export
size_t gen_max_marshaled_size(KeyOnly<const Bound::WStringArrayMessage> stru, bool align);

KeyTest_Export
void gen_find_size(KeyOnly<const Bound::WStringArrayMessage> stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, KeyOnly<const Bound::WStringArrayMessage> stru);

KeyTest_Export
bool operator>>(Serializer& strm, KeyOnly<Bound::WStringArrayMessage> stru);

template <>
struct MarshalTraits<Bound::WStringArrayMessage> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Bound {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct KeyTest_Export WStringArrayMessage_OpenDDS_KeyLessThan {
  bool operator()(const Bound::WStringArrayMessage&, const Bound::WStringArrayMessage&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Bound {
class WStringArrayMessageTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Bound::WStringArrayMessage> {
  typedef Bound::WStringArrayMessage MessageType;
  typedef Bound::WStringArrayMessageSeq MessageSequenceType;
  typedef Bound::WStringArrayMessageTypeSupport TypeSupportType;
  typedef Bound::WStringArrayMessageTypeSupportImpl TypeSupportTypeImpl;
  typedef Bound::WStringArrayMessageDataWriter DataWriterType;
  typedef Bound::WStringArrayMessageDataReader DataReaderType;
  typedef Bound::WStringArrayMessage_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Bound::WStringArrayMessage"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Bound {
class KeyTest_Export WStringArrayMessageTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<WStringArrayMessageTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<WStringArrayMessage> TraitsType;
  typedef WStringArrayMessageTypeSupport TypeSupportType;
  typedef WStringArrayMessageTypeSupport::_var_type _var_type;
  typedef WStringArrayMessageTypeSupport::_ptr_type _ptr_type;

  WStringArrayMessageTypeSupportImpl() {}
  virtual ~WStringArrayMessageTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static WStringArrayMessageTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
KeyTest_Export
const MetaStruct& getMetaStruct<Bound::WStringArrayMessage>();
KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::WStringArrayMessage*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: WStringArrayMessage */


/* Begin STRUCT: Nest1 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::Nest1& stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::Nest1& stru);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::Nest1& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
KeyTest_Export
const MetaStruct& getMetaStruct<Bound::Nest1>();
KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::Nest1*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Nest1 */


/* Begin STRUCT: Nest2 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::Nest2& stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::Nest2& stru);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::Nest2& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
KeyTest_Export
const MetaStruct& getMetaStruct<Bound::Nest2>();
KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::Nest2*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Nest2 */


/* Begin STRUCT: BoundedNestedMessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::BoundedNestedMessage& stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::BoundedNestedMessage& stru);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::BoundedNestedMessage& stru);

KeyTest_Export
size_t gen_max_marshaled_size(const Bound::BoundedNestedMessage& stru, bool align);

KeyTest_Export
size_t gen_max_marshaled_size(KeyOnly<const Bound::BoundedNestedMessage> stru, bool align);

KeyTest_Export
void gen_find_size(KeyOnly<const Bound::BoundedNestedMessage> stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, KeyOnly<const Bound::BoundedNestedMessage> stru);

KeyTest_Export
bool operator>>(Serializer& strm, KeyOnly<Bound::BoundedNestedMessage> stru);

template <>
struct MarshalTraits<Bound::BoundedNestedMessage> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Bound {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct KeyTest_Export BoundedNestedMessage_OpenDDS_KeyLessThan {
  bool operator()(const Bound::BoundedNestedMessage&, const Bound::BoundedNestedMessage&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Bound {
class BoundedNestedMessageTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Bound::BoundedNestedMessage> {
  typedef Bound::BoundedNestedMessage MessageType;
  typedef Bound::BoundedNestedMessageSeq MessageSequenceType;
  typedef Bound::BoundedNestedMessageTypeSupport TypeSupportType;
  typedef Bound::BoundedNestedMessageTypeSupportImpl TypeSupportTypeImpl;
  typedef Bound::BoundedNestedMessageDataWriter DataWriterType;
  typedef Bound::BoundedNestedMessageDataReader DataReaderType;
  typedef Bound::BoundedNestedMessage_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Bound::BoundedNestedMessage"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Bound {
class KeyTest_Export BoundedNestedMessageTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<BoundedNestedMessageTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<BoundedNestedMessage> TraitsType;
  typedef BoundedNestedMessageTypeSupport TypeSupportType;
  typedef BoundedNestedMessageTypeSupport::_var_type _var_type;
  typedef BoundedNestedMessageTypeSupport::_ptr_type _ptr_type;

  BoundedNestedMessageTypeSupportImpl() {}
  virtual ~BoundedNestedMessageTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static BoundedNestedMessageTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
KeyTest_Export
const MetaStruct& getMetaStruct<Bound::BoundedNestedMessage>();
KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::BoundedNestedMessage*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: BoundedNestedMessage */


/* Begin STRUCT: Nest3 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::Nest3& stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::Nest3& stru);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::Nest3& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
KeyTest_Export
const MetaStruct& getMetaStruct<Bound::Nest3>();
KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::Nest3*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Nest3 */


/* Begin STRUCT: Nest4 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::Nest4& stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::Nest4& stru);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::Nest4& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
KeyTest_Export
const MetaStruct& getMetaStruct<Bound::Nest4>();
KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::Nest4*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Nest4 */


/* Begin STRUCT: UnboundedNestedMessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

KeyTest_Export
void gen_find_size(const Bound::UnboundedNestedMessage& stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, const Bound::UnboundedNestedMessage& stru);

KeyTest_Export
bool operator>>(Serializer& strm, Bound::UnboundedNestedMessage& stru);

KeyTest_Export
size_t gen_max_marshaled_size(const Bound::UnboundedNestedMessage& stru, bool align);

KeyTest_Export
size_t gen_max_marshaled_size(KeyOnly<const Bound::UnboundedNestedMessage> stru, bool align);

KeyTest_Export
void gen_find_size(KeyOnly<const Bound::UnboundedNestedMessage> stru, size_t& size, size_t& padding);

KeyTest_Export
bool operator<<(Serializer& strm, KeyOnly<const Bound::UnboundedNestedMessage> stru);

KeyTest_Export
bool operator>>(Serializer& strm, KeyOnly<Bound::UnboundedNestedMessage> stru);

template <>
struct MarshalTraits<Bound::UnboundedNestedMessage> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Bound {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct KeyTest_Export UnboundedNestedMessage_OpenDDS_KeyLessThan {
  bool operator()(const Bound::UnboundedNestedMessage&, const Bound::UnboundedNestedMessage&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Bound {
class UnboundedNestedMessageTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Bound::UnboundedNestedMessage> {
  typedef Bound::UnboundedNestedMessage MessageType;
  typedef Bound::UnboundedNestedMessageSeq MessageSequenceType;
  typedef Bound::UnboundedNestedMessageTypeSupport TypeSupportType;
  typedef Bound::UnboundedNestedMessageTypeSupportImpl TypeSupportTypeImpl;
  typedef Bound::UnboundedNestedMessageDataWriter DataWriterType;
  typedef Bound::UnboundedNestedMessageDataReader DataReaderType;
  typedef Bound::UnboundedNestedMessage_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Bound::UnboundedNestedMessage"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Bound {
class KeyTest_Export UnboundedNestedMessageTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<UnboundedNestedMessageTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<UnboundedNestedMessage> TraitsType;
  typedef UnboundedNestedMessageTypeSupport TypeSupportType;
  typedef UnboundedNestedMessageTypeSupport::_var_type _var_type;
  typedef UnboundedNestedMessageTypeSupport::_ptr_type _ptr_type;

  UnboundedNestedMessageTypeSupportImpl() {}
  virtual ~UnboundedNestedMessageTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static UnboundedNestedMessageTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
KeyTest_Export
const MetaStruct& getMetaStruct<Bound::UnboundedNestedMessage>();
KeyTest_Export
void gen_skip_over(Serializer& ser, Bound::UnboundedNestedMessage*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: UnboundedNestedMessage */

/* End MODULE: Bound */
#endif /* OPENDDS_IDL_GENERATED_BOUNDTESTTYPESUPPORTIMPL_H_IH7TKS */
