/* Generated by /Users/yc/MyGithub/imac-project/OpenDDS/OpenDDS-3.10/bin/opendds_idl version 3.10 (ACE version 6.2a_p11) running on input file BoundTest2.idl */
#ifndef OPENDDS_IDL_GENERATED_BOUNDTEST2TYPESUPPORT_IDL_LRFLLR
#define OPENDDS_IDL_GENERATED_BOUNDTEST2TYPESUPPORT_IDL_LRFLLR
#define __OPENDDS_IDL_HAS_FIXED
#include "BoundTest2.idl"

#include "dds/DdsDcpsInfrastructure.idl"
#include "dds/DdsDcpsPublication.idl"
#include "dds/DdsDcpsSubscriptionExt.idl"
#include "dds/DdsDcpsTopic.idl"
#include "dds/DdsDcpsTypeSupportExt.idl"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: FloatSeq */


/* End TYPEDEF: FloatSeq */

/* End MODULE: CORBA */


/* Begin MODULE: Bound */



/* Begin TYPEDEF: BoundedFloatSeq */


/* End TYPEDEF: BoundedFloatSeq */


/* Begin STRUCT: BoundedSequenceOfBoundedMessage */

module Bound {
#pragma DCPS_SUPPORT_ZERO_COPY_READ
#pragma DCPS_GEN_ZERO_COPY_READ

#if !defined (__TAO_IDL) || (__TAO_IDL >= 0x060101)
#pragma DCPS_DATA_SEQUENCE_TYPE "Bound::BoundedSequenceOfBoundedMessageSeq"
typedef sequence<Bound::BoundedSequenceOfBoundedMessage> BoundedSequenceOfBoundedMessageSeq;
#else
native BoundedSequenceOfBoundedMessageSeq;
#endif

/** Support topic registration for BoundedSequenceOfBoundedMessage data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
local interface BoundedSequenceOfBoundedMessageTypeSupport : OpenDDS::DCPS::TypeSupport {
};

/** DataWriter interface for BoundedSequenceOfBoundedMessage data type.
 *
 * See the DDS specifications, OMG formal/04-12-02 and formal/07-01-01,
 * for a description of this interface.
 */
local interface BoundedSequenceOfBoundedMessageDataWriter : ::DDS::DataWriter {
    ::DDS::InstanceHandle_t register_instance(
                in Bound::BoundedSequenceOfBoundedMessage instance);

    ::DDS::InstanceHandle_t register_instance_w_timestamp(
                in Bound::BoundedSequenceOfBoundedMessage instance,
                in ::DDS::Time_t timestamp);

    ::DDS::ReturnCode_t unregister_instance(
                in Bound::BoundedSequenceOfBoundedMessage instance,
                in ::DDS::InstanceHandle_t handle);

    ::DDS::ReturnCode_t unregister_instance_w_timestamp(
                in Bound::BoundedSequenceOfBoundedMessage instance,
                in ::DDS::InstanceHandle_t handle,
                in ::DDS::Time_t timestamp);

    //WARNING: If the handle is non-nil and the instance is not registered
    //         then this operation may cause an access violation.
    //         This lack of safety helps performance.
    ::DDS::ReturnCode_t write(
                in Bound::BoundedSequenceOfBoundedMessage instance_data,
                in ::DDS::InstanceHandle_t handle);

    //WARNING: If the handle is non-nil and the instance is not registered
    //         then this operation may cause an access violation.
    //         This lack of safety helps performance.
    ::DDS::ReturnCode_t write_w_timestamp(
                in Bound::BoundedSequenceOfBoundedMessage instance_data,
                in ::DDS::InstanceHandle_t handle,
                in ::DDS::Time_t source_timestamp);

    ::DDS::ReturnCode_t dispose(
                in Bound::BoundedSequenceOfBoundedMessage instance_data,
                in ::DDS::InstanceHandle_t instance_handle);

    ::DDS::ReturnCode_t dispose_w_timestamp(
                in Bound::BoundedSequenceOfBoundedMessage instance_data,
                in ::DDS::InstanceHandle_t instance_handle,
                in ::DDS::Time_t source_timestamp);

    ::DDS::ReturnCode_t get_key_value(
                inout Bound::BoundedSequenceOfBoundedMessage key_holder,
                in ::DDS::InstanceHandle_t handle);

    ::DDS::InstanceHandle_t lookup_instance(
                in Bound::BoundedSequenceOfBoundedMessage instance_data);
};

/** DataReader interface for BoundedSequenceOfBoundedMessage data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
local interface BoundedSequenceOfBoundedMessageDataReader : OpenDDS::DCPS::DataReaderEx {
    ::DDS::ReturnCode_t read(
                inout BoundedSequenceOfBoundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t take(
                inout BoundedSequenceOfBoundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t read_w_condition(
                inout BoundedSequenceOfBoundedMessageSeq data_values,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t take_w_condition(
                inout BoundedSequenceOfBoundedMessageSeq data_values,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t read_next_sample(
                inout Bound::BoundedSequenceOfBoundedMessage received_data,
                inout ::DDS::SampleInfo sample_info);

    ::DDS::ReturnCode_t take_next_sample(
                inout Bound::BoundedSequenceOfBoundedMessage received_data,
                inout ::DDS::SampleInfo sample_info);

    ::DDS::ReturnCode_t read_instance(
                inout BoundedSequenceOfBoundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t take_instance(
                inout BoundedSequenceOfBoundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t read_instance_w_condition(
                inout BoundedSequenceOfBoundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t take_instance_w_condition(
                inout BoundedSequenceOfBoundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t read_next_instance(
                inout BoundedSequenceOfBoundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t take_next_instance(
                inout BoundedSequenceOfBoundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t read_next_instance_w_condition(
                inout BoundedSequenceOfBoundedMessageSeq data_values,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::InstanceHandle_t previous_handle,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t take_next_instance_w_condition(
                inout BoundedSequenceOfBoundedMessageSeq data_values,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::InstanceHandle_t previous_handle,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t return_loan(
                inout BoundedSequenceOfBoundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq);

    ::DDS::ReturnCode_t get_key_value(
                inout Bound::BoundedSequenceOfBoundedMessage key_holder,
                in ::DDS::InstanceHandle_t handle);

    ::DDS::InstanceHandle_t lookup_instance(
                in Bound::BoundedSequenceOfBoundedMessage instance_data);
};
};

/* End STRUCT: BoundedSequenceOfBoundedMessage */


/* Begin TYPEDEF: UnboundedFloatSeq */


/* End TYPEDEF: UnboundedFloatSeq */


/* Begin STRUCT: UnboundedSequenceOfBoundedMessage */

module Bound {
#pragma DCPS_SUPPORT_ZERO_COPY_READ
#pragma DCPS_GEN_ZERO_COPY_READ

#if !defined (__TAO_IDL) || (__TAO_IDL >= 0x060101)
#pragma DCPS_DATA_SEQUENCE_TYPE "Bound::UnboundedSequenceOfBoundedMessageSeq"
typedef sequence<Bound::UnboundedSequenceOfBoundedMessage> UnboundedSequenceOfBoundedMessageSeq;
#else
native UnboundedSequenceOfBoundedMessageSeq;
#endif

/** Support topic registration for UnboundedSequenceOfBoundedMessage data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
local interface UnboundedSequenceOfBoundedMessageTypeSupport : OpenDDS::DCPS::TypeSupport {
};

/** DataWriter interface for UnboundedSequenceOfBoundedMessage data type.
 *
 * See the DDS specifications, OMG formal/04-12-02 and formal/07-01-01,
 * for a description of this interface.
 */
local interface UnboundedSequenceOfBoundedMessageDataWriter : ::DDS::DataWriter {
    ::DDS::InstanceHandle_t register_instance(
                in Bound::UnboundedSequenceOfBoundedMessage instance);

    ::DDS::InstanceHandle_t register_instance_w_timestamp(
                in Bound::UnboundedSequenceOfBoundedMessage instance,
                in ::DDS::Time_t timestamp);

    ::DDS::ReturnCode_t unregister_instance(
                in Bound::UnboundedSequenceOfBoundedMessage instance,
                in ::DDS::InstanceHandle_t handle);

    ::DDS::ReturnCode_t unregister_instance_w_timestamp(
                in Bound::UnboundedSequenceOfBoundedMessage instance,
                in ::DDS::InstanceHandle_t handle,
                in ::DDS::Time_t timestamp);

    //WARNING: If the handle is non-nil and the instance is not registered
    //         then this operation may cause an access violation.
    //         This lack of safety helps performance.
    ::DDS::ReturnCode_t write(
                in Bound::UnboundedSequenceOfBoundedMessage instance_data,
                in ::DDS::InstanceHandle_t handle);

    //WARNING: If the handle is non-nil and the instance is not registered
    //         then this operation may cause an access violation.
    //         This lack of safety helps performance.
    ::DDS::ReturnCode_t write_w_timestamp(
                in Bound::UnboundedSequenceOfBoundedMessage instance_data,
                in ::DDS::InstanceHandle_t handle,
                in ::DDS::Time_t source_timestamp);

    ::DDS::ReturnCode_t dispose(
                in Bound::UnboundedSequenceOfBoundedMessage instance_data,
                in ::DDS::InstanceHandle_t instance_handle);

    ::DDS::ReturnCode_t dispose_w_timestamp(
                in Bound::UnboundedSequenceOfBoundedMessage instance_data,
                in ::DDS::InstanceHandle_t instance_handle,
                in ::DDS::Time_t source_timestamp);

    ::DDS::ReturnCode_t get_key_value(
                inout Bound::UnboundedSequenceOfBoundedMessage key_holder,
                in ::DDS::InstanceHandle_t handle);

    ::DDS::InstanceHandle_t lookup_instance(
                in Bound::UnboundedSequenceOfBoundedMessage instance_data);
};

/** DataReader interface for UnboundedSequenceOfBoundedMessage data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
local interface UnboundedSequenceOfBoundedMessageDataReader : OpenDDS::DCPS::DataReaderEx {
    ::DDS::ReturnCode_t read(
                inout UnboundedSequenceOfBoundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t take(
                inout UnboundedSequenceOfBoundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t read_w_condition(
                inout UnboundedSequenceOfBoundedMessageSeq data_values,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t take_w_condition(
                inout UnboundedSequenceOfBoundedMessageSeq data_values,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t read_next_sample(
                inout Bound::UnboundedSequenceOfBoundedMessage received_data,
                inout ::DDS::SampleInfo sample_info);

    ::DDS::ReturnCode_t take_next_sample(
                inout Bound::UnboundedSequenceOfBoundedMessage received_data,
                inout ::DDS::SampleInfo sample_info);

    ::DDS::ReturnCode_t read_instance(
                inout UnboundedSequenceOfBoundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t take_instance(
                inout UnboundedSequenceOfBoundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t read_instance_w_condition(
                inout UnboundedSequenceOfBoundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t take_instance_w_condition(
                inout UnboundedSequenceOfBoundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t read_next_instance(
                inout UnboundedSequenceOfBoundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t take_next_instance(
                inout UnboundedSequenceOfBoundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t read_next_instance_w_condition(
                inout UnboundedSequenceOfBoundedMessageSeq data_values,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::InstanceHandle_t previous_handle,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t take_next_instance_w_condition(
                inout UnboundedSequenceOfBoundedMessageSeq data_values,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::InstanceHandle_t previous_handle,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t return_loan(
                inout UnboundedSequenceOfBoundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq);

    ::DDS::ReturnCode_t get_key_value(
                inout Bound::UnboundedSequenceOfBoundedMessage key_holder,
                in ::DDS::InstanceHandle_t handle);

    ::DDS::InstanceHandle_t lookup_instance(
                in Bound::UnboundedSequenceOfBoundedMessage instance_data);
};
};

/* End STRUCT: UnboundedSequenceOfBoundedMessage */


/* Begin TYPEDEF: BoundedStringSeq */


/* End TYPEDEF: BoundedStringSeq */


/* Begin STRUCT: BoundedSequenceOfUnboundedMessage */

module Bound {
#pragma DCPS_SUPPORT_ZERO_COPY_READ
#pragma DCPS_GEN_ZERO_COPY_READ

#if !defined (__TAO_IDL) || (__TAO_IDL >= 0x060101)
#pragma DCPS_DATA_SEQUENCE_TYPE "Bound::BoundedSequenceOfUnboundedMessageSeq"
typedef sequence<Bound::BoundedSequenceOfUnboundedMessage> BoundedSequenceOfUnboundedMessageSeq;
#else
native BoundedSequenceOfUnboundedMessageSeq;
#endif

/** Support topic registration for BoundedSequenceOfUnboundedMessage data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
local interface BoundedSequenceOfUnboundedMessageTypeSupport : OpenDDS::DCPS::TypeSupport {
};

/** DataWriter interface for BoundedSequenceOfUnboundedMessage data type.
 *
 * See the DDS specifications, OMG formal/04-12-02 and formal/07-01-01,
 * for a description of this interface.
 */
local interface BoundedSequenceOfUnboundedMessageDataWriter : ::DDS::DataWriter {
    ::DDS::InstanceHandle_t register_instance(
                in Bound::BoundedSequenceOfUnboundedMessage instance);

    ::DDS::InstanceHandle_t register_instance_w_timestamp(
                in Bound::BoundedSequenceOfUnboundedMessage instance,
                in ::DDS::Time_t timestamp);

    ::DDS::ReturnCode_t unregister_instance(
                in Bound::BoundedSequenceOfUnboundedMessage instance,
                in ::DDS::InstanceHandle_t handle);

    ::DDS::ReturnCode_t unregister_instance_w_timestamp(
                in Bound::BoundedSequenceOfUnboundedMessage instance,
                in ::DDS::InstanceHandle_t handle,
                in ::DDS::Time_t timestamp);

    //WARNING: If the handle is non-nil and the instance is not registered
    //         then this operation may cause an access violation.
    //         This lack of safety helps performance.
    ::DDS::ReturnCode_t write(
                in Bound::BoundedSequenceOfUnboundedMessage instance_data,
                in ::DDS::InstanceHandle_t handle);

    //WARNING: If the handle is non-nil and the instance is not registered
    //         then this operation may cause an access violation.
    //         This lack of safety helps performance.
    ::DDS::ReturnCode_t write_w_timestamp(
                in Bound::BoundedSequenceOfUnboundedMessage instance_data,
                in ::DDS::InstanceHandle_t handle,
                in ::DDS::Time_t source_timestamp);

    ::DDS::ReturnCode_t dispose(
                in Bound::BoundedSequenceOfUnboundedMessage instance_data,
                in ::DDS::InstanceHandle_t instance_handle);

    ::DDS::ReturnCode_t dispose_w_timestamp(
                in Bound::BoundedSequenceOfUnboundedMessage instance_data,
                in ::DDS::InstanceHandle_t instance_handle,
                in ::DDS::Time_t source_timestamp);

    ::DDS::ReturnCode_t get_key_value(
                inout Bound::BoundedSequenceOfUnboundedMessage key_holder,
                in ::DDS::InstanceHandle_t handle);

    ::DDS::InstanceHandle_t lookup_instance(
                in Bound::BoundedSequenceOfUnboundedMessage instance_data);
};

/** DataReader interface for BoundedSequenceOfUnboundedMessage data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
local interface BoundedSequenceOfUnboundedMessageDataReader : OpenDDS::DCPS::DataReaderEx {
    ::DDS::ReturnCode_t read(
                inout BoundedSequenceOfUnboundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t take(
                inout BoundedSequenceOfUnboundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t read_w_condition(
                inout BoundedSequenceOfUnboundedMessageSeq data_values,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t take_w_condition(
                inout BoundedSequenceOfUnboundedMessageSeq data_values,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t read_next_sample(
                inout Bound::BoundedSequenceOfUnboundedMessage received_data,
                inout ::DDS::SampleInfo sample_info);

    ::DDS::ReturnCode_t take_next_sample(
                inout Bound::BoundedSequenceOfUnboundedMessage received_data,
                inout ::DDS::SampleInfo sample_info);

    ::DDS::ReturnCode_t read_instance(
                inout BoundedSequenceOfUnboundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t take_instance(
                inout BoundedSequenceOfUnboundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t read_instance_w_condition(
                inout BoundedSequenceOfUnboundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t take_instance_w_condition(
                inout BoundedSequenceOfUnboundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t read_next_instance(
                inout BoundedSequenceOfUnboundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t take_next_instance(
                inout BoundedSequenceOfUnboundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t read_next_instance_w_condition(
                inout BoundedSequenceOfUnboundedMessageSeq data_values,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::InstanceHandle_t previous_handle,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t take_next_instance_w_condition(
                inout BoundedSequenceOfUnboundedMessageSeq data_values,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::InstanceHandle_t previous_handle,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t return_loan(
                inout BoundedSequenceOfUnboundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq);

    ::DDS::ReturnCode_t get_key_value(
                inout Bound::BoundedSequenceOfUnboundedMessage key_holder,
                in ::DDS::InstanceHandle_t handle);

    ::DDS::InstanceHandle_t lookup_instance(
                in Bound::BoundedSequenceOfUnboundedMessage instance_data);
};
};

/* End STRUCT: BoundedSequenceOfUnboundedMessage */


/* Begin TYPEDEF: UnboundedStringSeq */


/* End TYPEDEF: UnboundedStringSeq */


/* Begin STRUCT: UnboundedSequenceOfUnboundedMessage */

module Bound {
#pragma DCPS_SUPPORT_ZERO_COPY_READ
#pragma DCPS_GEN_ZERO_COPY_READ

#if !defined (__TAO_IDL) || (__TAO_IDL >= 0x060101)
#pragma DCPS_DATA_SEQUENCE_TYPE "Bound::UnboundedSequenceOfUnboundedMessageSeq"
typedef sequence<Bound::UnboundedSequenceOfUnboundedMessage> UnboundedSequenceOfUnboundedMessageSeq;
#else
native UnboundedSequenceOfUnboundedMessageSeq;
#endif

/** Support topic registration for UnboundedSequenceOfUnboundedMessage data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
local interface UnboundedSequenceOfUnboundedMessageTypeSupport : OpenDDS::DCPS::TypeSupport {
};

/** DataWriter interface for UnboundedSequenceOfUnboundedMessage data type.
 *
 * See the DDS specifications, OMG formal/04-12-02 and formal/07-01-01,
 * for a description of this interface.
 */
local interface UnboundedSequenceOfUnboundedMessageDataWriter : ::DDS::DataWriter {
    ::DDS::InstanceHandle_t register_instance(
                in Bound::UnboundedSequenceOfUnboundedMessage instance);

    ::DDS::InstanceHandle_t register_instance_w_timestamp(
                in Bound::UnboundedSequenceOfUnboundedMessage instance,
                in ::DDS::Time_t timestamp);

    ::DDS::ReturnCode_t unregister_instance(
                in Bound::UnboundedSequenceOfUnboundedMessage instance,
                in ::DDS::InstanceHandle_t handle);

    ::DDS::ReturnCode_t unregister_instance_w_timestamp(
                in Bound::UnboundedSequenceOfUnboundedMessage instance,
                in ::DDS::InstanceHandle_t handle,
                in ::DDS::Time_t timestamp);

    //WARNING: If the handle is non-nil and the instance is not registered
    //         then this operation may cause an access violation.
    //         This lack of safety helps performance.
    ::DDS::ReturnCode_t write(
                in Bound::UnboundedSequenceOfUnboundedMessage instance_data,
                in ::DDS::InstanceHandle_t handle);

    //WARNING: If the handle is non-nil and the instance is not registered
    //         then this operation may cause an access violation.
    //         This lack of safety helps performance.
    ::DDS::ReturnCode_t write_w_timestamp(
                in Bound::UnboundedSequenceOfUnboundedMessage instance_data,
                in ::DDS::InstanceHandle_t handle,
                in ::DDS::Time_t source_timestamp);

    ::DDS::ReturnCode_t dispose(
                in Bound::UnboundedSequenceOfUnboundedMessage instance_data,
                in ::DDS::InstanceHandle_t instance_handle);

    ::DDS::ReturnCode_t dispose_w_timestamp(
                in Bound::UnboundedSequenceOfUnboundedMessage instance_data,
                in ::DDS::InstanceHandle_t instance_handle,
                in ::DDS::Time_t source_timestamp);

    ::DDS::ReturnCode_t get_key_value(
                inout Bound::UnboundedSequenceOfUnboundedMessage key_holder,
                in ::DDS::InstanceHandle_t handle);

    ::DDS::InstanceHandle_t lookup_instance(
                in Bound::UnboundedSequenceOfUnboundedMessage instance_data);
};

/** DataReader interface for UnboundedSequenceOfUnboundedMessage data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
local interface UnboundedSequenceOfUnboundedMessageDataReader : OpenDDS::DCPS::DataReaderEx {
    ::DDS::ReturnCode_t read(
                inout UnboundedSequenceOfUnboundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t take(
                inout UnboundedSequenceOfUnboundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t read_w_condition(
                inout UnboundedSequenceOfUnboundedMessageSeq data_values,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t take_w_condition(
                inout UnboundedSequenceOfUnboundedMessageSeq data_values,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t read_next_sample(
                inout Bound::UnboundedSequenceOfUnboundedMessage received_data,
                inout ::DDS::SampleInfo sample_info);

    ::DDS::ReturnCode_t take_next_sample(
                inout Bound::UnboundedSequenceOfUnboundedMessage received_data,
                inout ::DDS::SampleInfo sample_info);

    ::DDS::ReturnCode_t read_instance(
                inout UnboundedSequenceOfUnboundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t take_instance(
                inout UnboundedSequenceOfUnboundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t read_instance_w_condition(
                inout UnboundedSequenceOfUnboundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t take_instance_w_condition(
                inout UnboundedSequenceOfUnboundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t read_next_instance(
                inout UnboundedSequenceOfUnboundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t take_next_instance(
                inout UnboundedSequenceOfUnboundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t read_next_instance_w_condition(
                inout UnboundedSequenceOfUnboundedMessageSeq data_values,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::InstanceHandle_t previous_handle,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t take_next_instance_w_condition(
                inout UnboundedSequenceOfUnboundedMessageSeq data_values,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::InstanceHandle_t previous_handle,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t return_loan(
                inout UnboundedSequenceOfUnboundedMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq);

    ::DDS::ReturnCode_t get_key_value(
                inout Bound::UnboundedSequenceOfUnboundedMessage key_holder,
                in ::DDS::InstanceHandle_t handle);

    ::DDS::InstanceHandle_t lookup_instance(
                in Bound::UnboundedSequenceOfUnboundedMessage instance_data);
};
};

/* End STRUCT: UnboundedSequenceOfUnboundedMessage */


/* Begin UNION: BoundedUnion */


/* End UNION: BoundedUnion */


/* Begin STRUCT: BoundedUnionMessage */

module Bound {
#pragma DCPS_SUPPORT_ZERO_COPY_READ
#pragma DCPS_GEN_ZERO_COPY_READ

#if !defined (__TAO_IDL) || (__TAO_IDL >= 0x060101)
#pragma DCPS_DATA_SEQUENCE_TYPE "Bound::BoundedUnionMessageSeq"
typedef sequence<Bound::BoundedUnionMessage> BoundedUnionMessageSeq;
#else
native BoundedUnionMessageSeq;
#endif

/** Support topic registration for BoundedUnionMessage data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
local interface BoundedUnionMessageTypeSupport : OpenDDS::DCPS::TypeSupport {
};

/** DataWriter interface for BoundedUnionMessage data type.
 *
 * See the DDS specifications, OMG formal/04-12-02 and formal/07-01-01,
 * for a description of this interface.
 */
local interface BoundedUnionMessageDataWriter : ::DDS::DataWriter {
    ::DDS::InstanceHandle_t register_instance(
                in Bound::BoundedUnionMessage instance);

    ::DDS::InstanceHandle_t register_instance_w_timestamp(
                in Bound::BoundedUnionMessage instance,
                in ::DDS::Time_t timestamp);

    ::DDS::ReturnCode_t unregister_instance(
                in Bound::BoundedUnionMessage instance,
                in ::DDS::InstanceHandle_t handle);

    ::DDS::ReturnCode_t unregister_instance_w_timestamp(
                in Bound::BoundedUnionMessage instance,
                in ::DDS::InstanceHandle_t handle,
                in ::DDS::Time_t timestamp);

    //WARNING: If the handle is non-nil and the instance is not registered
    //         then this operation may cause an access violation.
    //         This lack of safety helps performance.
    ::DDS::ReturnCode_t write(
                in Bound::BoundedUnionMessage instance_data,
                in ::DDS::InstanceHandle_t handle);

    //WARNING: If the handle is non-nil and the instance is not registered
    //         then this operation may cause an access violation.
    //         This lack of safety helps performance.
    ::DDS::ReturnCode_t write_w_timestamp(
                in Bound::BoundedUnionMessage instance_data,
                in ::DDS::InstanceHandle_t handle,
                in ::DDS::Time_t source_timestamp);

    ::DDS::ReturnCode_t dispose(
                in Bound::BoundedUnionMessage instance_data,
                in ::DDS::InstanceHandle_t instance_handle);

    ::DDS::ReturnCode_t dispose_w_timestamp(
                in Bound::BoundedUnionMessage instance_data,
                in ::DDS::InstanceHandle_t instance_handle,
                in ::DDS::Time_t source_timestamp);

    ::DDS::ReturnCode_t get_key_value(
                inout Bound::BoundedUnionMessage key_holder,
                in ::DDS::InstanceHandle_t handle);

    ::DDS::InstanceHandle_t lookup_instance(
                in Bound::BoundedUnionMessage instance_data);
};

/** DataReader interface for BoundedUnionMessage data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
local interface BoundedUnionMessageDataReader : OpenDDS::DCPS::DataReaderEx {
    ::DDS::ReturnCode_t read(
                inout BoundedUnionMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t take(
                inout BoundedUnionMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t read_w_condition(
                inout BoundedUnionMessageSeq data_values,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t take_w_condition(
                inout BoundedUnionMessageSeq data_values,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t read_next_sample(
                inout Bound::BoundedUnionMessage received_data,
                inout ::DDS::SampleInfo sample_info);

    ::DDS::ReturnCode_t take_next_sample(
                inout Bound::BoundedUnionMessage received_data,
                inout ::DDS::SampleInfo sample_info);

    ::DDS::ReturnCode_t read_instance(
                inout BoundedUnionMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t take_instance(
                inout BoundedUnionMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t read_instance_w_condition(
                inout BoundedUnionMessageSeq received_data,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t take_instance_w_condition(
                inout BoundedUnionMessageSeq received_data,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t read_next_instance(
                inout BoundedUnionMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t take_next_instance(
                inout BoundedUnionMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t read_next_instance_w_condition(
                inout BoundedUnionMessageSeq data_values,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::InstanceHandle_t previous_handle,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t take_next_instance_w_condition(
                inout BoundedUnionMessageSeq data_values,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::InstanceHandle_t previous_handle,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t return_loan(
                inout BoundedUnionMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq);

    ::DDS::ReturnCode_t get_key_value(
                inout Bound::BoundedUnionMessage key_holder,
                in ::DDS::InstanceHandle_t handle);

    ::DDS::InstanceHandle_t lookup_instance(
                in Bound::BoundedUnionMessage instance_data);
};
};

/* End STRUCT: BoundedUnionMessage */


/* Begin UNION: UnboundedUnion */


/* End UNION: UnboundedUnion */


/* Begin STRUCT: UnboundedUnionMessage */

module Bound {
#pragma DCPS_SUPPORT_ZERO_COPY_READ
#pragma DCPS_GEN_ZERO_COPY_READ

#if !defined (__TAO_IDL) || (__TAO_IDL >= 0x060101)
#pragma DCPS_DATA_SEQUENCE_TYPE "Bound::UnboundedUnionMessageSeq"
typedef sequence<Bound::UnboundedUnionMessage> UnboundedUnionMessageSeq;
#else
native UnboundedUnionMessageSeq;
#endif

/** Support topic registration for UnboundedUnionMessage data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
local interface UnboundedUnionMessageTypeSupport : OpenDDS::DCPS::TypeSupport {
};

/** DataWriter interface for UnboundedUnionMessage data type.
 *
 * See the DDS specifications, OMG formal/04-12-02 and formal/07-01-01,
 * for a description of this interface.
 */
local interface UnboundedUnionMessageDataWriter : ::DDS::DataWriter {
    ::DDS::InstanceHandle_t register_instance(
                in Bound::UnboundedUnionMessage instance);

    ::DDS::InstanceHandle_t register_instance_w_timestamp(
                in Bound::UnboundedUnionMessage instance,
                in ::DDS::Time_t timestamp);

    ::DDS::ReturnCode_t unregister_instance(
                in Bound::UnboundedUnionMessage instance,
                in ::DDS::InstanceHandle_t handle);

    ::DDS::ReturnCode_t unregister_instance_w_timestamp(
                in Bound::UnboundedUnionMessage instance,
                in ::DDS::InstanceHandle_t handle,
                in ::DDS::Time_t timestamp);

    //WARNING: If the handle is non-nil and the instance is not registered
    //         then this operation may cause an access violation.
    //         This lack of safety helps performance.
    ::DDS::ReturnCode_t write(
                in Bound::UnboundedUnionMessage instance_data,
                in ::DDS::InstanceHandle_t handle);

    //WARNING: If the handle is non-nil and the instance is not registered
    //         then this operation may cause an access violation.
    //         This lack of safety helps performance.
    ::DDS::ReturnCode_t write_w_timestamp(
                in Bound::UnboundedUnionMessage instance_data,
                in ::DDS::InstanceHandle_t handle,
                in ::DDS::Time_t source_timestamp);

    ::DDS::ReturnCode_t dispose(
                in Bound::UnboundedUnionMessage instance_data,
                in ::DDS::InstanceHandle_t instance_handle);

    ::DDS::ReturnCode_t dispose_w_timestamp(
                in Bound::UnboundedUnionMessage instance_data,
                in ::DDS::InstanceHandle_t instance_handle,
                in ::DDS::Time_t source_timestamp);

    ::DDS::ReturnCode_t get_key_value(
                inout Bound::UnboundedUnionMessage key_holder,
                in ::DDS::InstanceHandle_t handle);

    ::DDS::InstanceHandle_t lookup_instance(
                in Bound::UnboundedUnionMessage instance_data);
};

/** DataReader interface for UnboundedUnionMessage data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
local interface UnboundedUnionMessageDataReader : OpenDDS::DCPS::DataReaderEx {
    ::DDS::ReturnCode_t read(
                inout UnboundedUnionMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t take(
                inout UnboundedUnionMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t read_w_condition(
                inout UnboundedUnionMessageSeq data_values,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t take_w_condition(
                inout UnboundedUnionMessageSeq data_values,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t read_next_sample(
                inout Bound::UnboundedUnionMessage received_data,
                inout ::DDS::SampleInfo sample_info);

    ::DDS::ReturnCode_t take_next_sample(
                inout Bound::UnboundedUnionMessage received_data,
                inout ::DDS::SampleInfo sample_info);

    ::DDS::ReturnCode_t read_instance(
                inout UnboundedUnionMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t take_instance(
                inout UnboundedUnionMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t read_instance_w_condition(
                inout UnboundedUnionMessageSeq received_data,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t take_instance_w_condition(
                inout UnboundedUnionMessageSeq received_data,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t read_next_instance(
                inout UnboundedUnionMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t take_next_instance(
                inout UnboundedUnionMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t read_next_instance_w_condition(
                inout UnboundedUnionMessageSeq data_values,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::InstanceHandle_t previous_handle,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t take_next_instance_w_condition(
                inout UnboundedUnionMessageSeq data_values,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::InstanceHandle_t previous_handle,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t return_loan(
                inout UnboundedUnionMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq);

    ::DDS::ReturnCode_t get_key_value(
                inout Bound::UnboundedUnionMessage key_holder,
                in ::DDS::InstanceHandle_t handle);

    ::DDS::InstanceHandle_t lookup_instance(
                in Bound::UnboundedUnionMessage instance_data);
};
};

/* End STRUCT: UnboundedUnionMessage */


/* Begin STRUCT-FWD: RecursiveMessage */


/* End STRUCT-FWD: RecursiveMessage */


/* Begin TYPEDEF: SingleMessageSeq */


/* End TYPEDEF: SingleMessageSeq */


/* Begin UNION: NestedMessageUnion */


/* End UNION: NestedMessageUnion */


/* Begin STRUCT: RecursiveMessage */

module Bound {
#pragma DCPS_SUPPORT_ZERO_COPY_READ
#pragma DCPS_GEN_ZERO_COPY_READ

#if !defined (__TAO_IDL) || (__TAO_IDL >= 0x060101)
#pragma DCPS_DATA_SEQUENCE_TYPE "Bound::RecursiveMessageSeq"
typedef sequence<Bound::RecursiveMessage> RecursiveMessageSeq;
#else
native RecursiveMessageSeq;
#endif

/** Support topic registration for RecursiveMessage data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
local interface RecursiveMessageTypeSupport : OpenDDS::DCPS::TypeSupport {
};

/** DataWriter interface for RecursiveMessage data type.
 *
 * See the DDS specifications, OMG formal/04-12-02 and formal/07-01-01,
 * for a description of this interface.
 */
local interface RecursiveMessageDataWriter : ::DDS::DataWriter {
    ::DDS::InstanceHandle_t register_instance(
                in Bound::RecursiveMessage instance);

    ::DDS::InstanceHandle_t register_instance_w_timestamp(
                in Bound::RecursiveMessage instance,
                in ::DDS::Time_t timestamp);

    ::DDS::ReturnCode_t unregister_instance(
                in Bound::RecursiveMessage instance,
                in ::DDS::InstanceHandle_t handle);

    ::DDS::ReturnCode_t unregister_instance_w_timestamp(
                in Bound::RecursiveMessage instance,
                in ::DDS::InstanceHandle_t handle,
                in ::DDS::Time_t timestamp);

    //WARNING: If the handle is non-nil and the instance is not registered
    //         then this operation may cause an access violation.
    //         This lack of safety helps performance.
    ::DDS::ReturnCode_t write(
                in Bound::RecursiveMessage instance_data,
                in ::DDS::InstanceHandle_t handle);

    //WARNING: If the handle is non-nil and the instance is not registered
    //         then this operation may cause an access violation.
    //         This lack of safety helps performance.
    ::DDS::ReturnCode_t write_w_timestamp(
                in Bound::RecursiveMessage instance_data,
                in ::DDS::InstanceHandle_t handle,
                in ::DDS::Time_t source_timestamp);

    ::DDS::ReturnCode_t dispose(
                in Bound::RecursiveMessage instance_data,
                in ::DDS::InstanceHandle_t instance_handle);

    ::DDS::ReturnCode_t dispose_w_timestamp(
                in Bound::RecursiveMessage instance_data,
                in ::DDS::InstanceHandle_t instance_handle,
                in ::DDS::Time_t source_timestamp);

    ::DDS::ReturnCode_t get_key_value(
                inout Bound::RecursiveMessage key_holder,
                in ::DDS::InstanceHandle_t handle);

    ::DDS::InstanceHandle_t lookup_instance(
                in Bound::RecursiveMessage instance_data);
};

/** DataReader interface for RecursiveMessage data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
local interface RecursiveMessageDataReader : OpenDDS::DCPS::DataReaderEx {
    ::DDS::ReturnCode_t read(
                inout RecursiveMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t take(
                inout RecursiveMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t read_w_condition(
                inout RecursiveMessageSeq data_values,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t take_w_condition(
                inout RecursiveMessageSeq data_values,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t read_next_sample(
                inout Bound::RecursiveMessage received_data,
                inout ::DDS::SampleInfo sample_info);

    ::DDS::ReturnCode_t take_next_sample(
                inout Bound::RecursiveMessage received_data,
                inout ::DDS::SampleInfo sample_info);

    ::DDS::ReturnCode_t read_instance(
                inout RecursiveMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t take_instance(
                inout RecursiveMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t read_instance_w_condition(
                inout RecursiveMessageSeq received_data,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t take_instance_w_condition(
                inout RecursiveMessageSeq received_data,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t read_next_instance(
                inout RecursiveMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t take_next_instance(
                inout RecursiveMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq,
                in long max_samples,
                in ::DDS::InstanceHandle_t a_handle,
                in ::DDS::SampleStateMask sample_states,
                in ::DDS::ViewStateMask view_states,
                in ::DDS::InstanceStateMask instance_states);

    ::DDS::ReturnCode_t read_next_instance_w_condition(
                inout RecursiveMessageSeq data_values,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::InstanceHandle_t previous_handle,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t take_next_instance_w_condition(
                inout RecursiveMessageSeq data_values,
                inout ::DDS::SampleInfoSeq sample_infos,
                in long max_samples,
                in ::DDS::InstanceHandle_t previous_handle,
                in ::DDS::ReadCondition a_condition);

    ::DDS::ReturnCode_t return_loan(
                inout RecursiveMessageSeq received_data,
                inout ::DDS::SampleInfoSeq info_seq);

    ::DDS::ReturnCode_t get_key_value(
                inout Bound::RecursiveMessage key_holder,
                in ::DDS::InstanceHandle_t handle);

    ::DDS::InstanceHandle_t lookup_instance(
                in Bound::RecursiveMessage instance_data);
};
};

/* End STRUCT: RecursiveMessage */

/* End MODULE: Bound */
#endif /* OPENDDS_IDL_GENERATED_BOUNDTEST2TYPESUPPORT_IDL_LRFLLR */
