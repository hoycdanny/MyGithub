// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.2a_p11
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// be/be_codegen.cpp:152

#ifndef _TAO_IDL_MULTITOPICTESTTYPESUPPORTC_N9ZLDK_H_
#define _TAO_IDL_MULTITOPICTESTTYPESUPPORTC_N9ZLDK_H_

#include /**/ "ace/pre.h"


#include /**/ "ace/config-all.h"

#if !defined (ACE_LACKS_PRAGMA_ONCE)
# pragma once
#endif /* ACE_LACKS_PRAGMA_ONCE */


#include "tao/ORB.h"
#include "tao/SystemException.h"
#include "tao/Basic_Types.h"
#include "tao/ORB_Constants.h"
#include "dds/DCPS/ZeroCopyInfoSeq_T.h"
#include "dds/DCPS/ZeroCopySeq_T.h"
#include "tao/Object.h"
#include "tao/String_Manager_T.h"
#include "tao/Sequence_T.h"
#include "tao/Objref_VarOut_T.h"
#include "tao/Seq_Var_T.h"
#include "tao/Seq_Out_T.h"
#include "tao/Arg_Traits_T.h"
#include "tao/Basic_Arguments.h"
#include "tao/Special_Basic_Arguments.h"
#include "tao/Any_Insert_Policy_T.h"
#include "tao/Fixed_Size_Argument_T.h"
#include "tao/Var_Size_Argument_T.h"
#include /**/ "tao/Version.h"
#include /**/ "tao/Versioned_Namespace.h"

#include "MultiTopicTestC.h"
#include "dds/DdsDcpsInfrastructureC.h"
#include "dds/DdsDcpsPublicationC.h"
#include "dds/DdsDcpsSubscriptionExtC.h"
#include "dds/DdsDcpsTopicC.h"
#include "dds/DdsDcpsTypeSupportExtC.h"

#if TAO_MAJOR_VERSION != 2 || TAO_MINOR_VERSION != 2 || TAO_BETA_VERSION != 0
#error This file should be regenerated with TAO_IDL
#endif

#if defined (TAO_EXPORT_MACRO)
#undef TAO_EXPORT_MACRO
#endif
#define TAO_EXPORT_MACRO 

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_ch.cpp:102

typedef ::TAO::DCPS::ZeroCopyDataSeq< LocationInfo, DCPS_ZERO_COPY_SEQ_DEFAULT_SIZE> LocationInfoSeq;


// TAO_IDL - Generated from
// be/be_interface.cpp:751

#if !defined (_LOCATIONINFOTYPESUPPORT__VAR_OUT_CH_)
#define _LOCATIONINFOTYPESUPPORT__VAR_OUT_CH_

class LocationInfoTypeSupport;
typedef LocationInfoTypeSupport *LocationInfoTypeSupport_ptr;

typedef
  TAO_Objref_Var_T<
      LocationInfoTypeSupport
    >
  LocationInfoTypeSupport_var;

typedef
  TAO_Objref_Out_T<
      LocationInfoTypeSupport
    >
  LocationInfoTypeSupport_out;

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ch.cpp:43

class  LocationInfoTypeSupport
  : public virtual ::OpenDDS::DCPS::TypeSupport

{
public:

  // TAO_IDL - Generated from
  // be/be_type.cpp:307

  typedef LocationInfoTypeSupport_ptr _ptr_type;
  typedef LocationInfoTypeSupport_var _var_type;
  typedef LocationInfoTypeSupport_out _out_type;

  // The static operations.
  static LocationInfoTypeSupport_ptr _duplicate (LocationInfoTypeSupport_ptr obj);

  static void _tao_release (LocationInfoTypeSupport_ptr obj);

  static LocationInfoTypeSupport_ptr _narrow (::CORBA::Object_ptr obj);
  static LocationInfoTypeSupport_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
  static LocationInfoTypeSupport_ptr _nil (void);

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:140

  virtual ::CORBA::Boolean _is_a (const char *type_id);
  virtual const char* _interface_repository_id (void) const;
  virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);

protected:
  // Abstract or local interface only.
  LocationInfoTypeSupport (void);

  

  virtual ~LocationInfoTypeSupport (void);

private:
  // Private and unimplemented for concrete interfaces.
  LocationInfoTypeSupport (const LocationInfoTypeSupport &);

  void operator= (const LocationInfoTypeSupport &);
};

// TAO_IDL - Generated from
// be/be_interface.cpp:751

#if !defined (_LOCATIONINFODATAWRITER__VAR_OUT_CH_)
#define _LOCATIONINFODATAWRITER__VAR_OUT_CH_

class LocationInfoDataWriter;
typedef LocationInfoDataWriter *LocationInfoDataWriter_ptr;

typedef
  TAO_Objref_Var_T<
      LocationInfoDataWriter
    >
  LocationInfoDataWriter_var;

typedef
  TAO_Objref_Out_T<
      LocationInfoDataWriter
    >
  LocationInfoDataWriter_out;

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ch.cpp:43

class  LocationInfoDataWriter
  : public virtual ::DDS::DataWriter

{
public:

  // TAO_IDL - Generated from
  // be/be_type.cpp:307

  typedef LocationInfoDataWriter_ptr _ptr_type;
  typedef LocationInfoDataWriter_var _var_type;
  typedef LocationInfoDataWriter_out _out_type;

  // The static operations.
  static LocationInfoDataWriter_ptr _duplicate (LocationInfoDataWriter_ptr obj);

  static void _tao_release (LocationInfoDataWriter_ptr obj);

  static LocationInfoDataWriter_ptr _narrow (::CORBA::Object_ptr obj);
  static LocationInfoDataWriter_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
  static LocationInfoDataWriter_ptr _nil (void);

  virtual ::DDS::InstanceHandle_t register_instance (
    const ::LocationInfo & instance) = 0;

  virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
    const ::LocationInfo & instance,
    const ::DDS::Time_t & timestamp) = 0;

  virtual ::DDS::ReturnCode_t unregister_instance (
    const ::LocationInfo & instance,
    ::DDS::InstanceHandle_t handle) = 0;

  virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
    const ::LocationInfo & instance,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & timestamp) = 0;

  virtual ::DDS::ReturnCode_t write (
    const ::LocationInfo & instance_data,
    ::DDS::InstanceHandle_t handle) = 0;

  virtual ::DDS::ReturnCode_t write_w_timestamp (
    const ::LocationInfo & instance_data,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & source_timestamp) = 0;

  virtual ::DDS::ReturnCode_t dispose (
    const ::LocationInfo & instance_data,
    ::DDS::InstanceHandle_t instance_handle) = 0;

  virtual ::DDS::ReturnCode_t dispose_w_timestamp (
    const ::LocationInfo & instance_data,
    ::DDS::InstanceHandle_t instance_handle,
    const ::DDS::Time_t & source_timestamp) = 0;

  virtual ::DDS::ReturnCode_t get_key_value (
    ::LocationInfo & key_holder,
    ::DDS::InstanceHandle_t handle) = 0;

  virtual ::DDS::InstanceHandle_t lookup_instance (
    const ::LocationInfo & instance_data) = 0;

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:140

  virtual ::CORBA::Boolean _is_a (const char *type_id);
  virtual const char* _interface_repository_id (void) const;
  virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);

protected:
  // Abstract or local interface only.
  LocationInfoDataWriter (void);

  

  virtual ~LocationInfoDataWriter (void);

private:
  // Private and unimplemented for concrete interfaces.
  LocationInfoDataWriter (const LocationInfoDataWriter &);

  void operator= (const LocationInfoDataWriter &);
};

// TAO_IDL - Generated from
// be/be_interface.cpp:751

#if !defined (_LOCATIONINFODATAREADER__VAR_OUT_CH_)
#define _LOCATIONINFODATAREADER__VAR_OUT_CH_

class LocationInfoDataReader;
typedef LocationInfoDataReader *LocationInfoDataReader_ptr;

typedef
  TAO_Objref_Var_T<
      LocationInfoDataReader
    >
  LocationInfoDataReader_var;

typedef
  TAO_Objref_Out_T<
      LocationInfoDataReader
    >
  LocationInfoDataReader_out;

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ch.cpp:43

class  LocationInfoDataReader
  : public virtual ::OpenDDS::DCPS::DataReaderEx

{
public:

  // TAO_IDL - Generated from
  // be/be_type.cpp:307

  typedef LocationInfoDataReader_ptr _ptr_type;
  typedef LocationInfoDataReader_var _var_type;
  typedef LocationInfoDataReader_out _out_type;

  // The static operations.
  static LocationInfoDataReader_ptr _duplicate (LocationInfoDataReader_ptr obj);

  static void _tao_release (LocationInfoDataReader_ptr obj);

  static LocationInfoDataReader_ptr _narrow (::CORBA::Object_ptr obj);
  static LocationInfoDataReader_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
  static LocationInfoDataReader_ptr _nil (void);

  virtual ::DDS::ReturnCode_t read (
    ::LocationInfoSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states) = 0;

  virtual ::DDS::ReturnCode_t take (
    ::LocationInfoSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states) = 0;

  virtual ::DDS::ReturnCode_t read_w_condition (
    ::LocationInfoSeq & data_values,
    ::DDS::SampleInfoSeq & sample_infos,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition) = 0;

  virtual ::DDS::ReturnCode_t take_w_condition (
    ::LocationInfoSeq & data_values,
    ::DDS::SampleInfoSeq & sample_infos,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition) = 0;

  virtual ::DDS::ReturnCode_t read_next_sample (
    ::LocationInfo & received_data,
    ::DDS::SampleInfo & sample_info) = 0;

  virtual ::DDS::ReturnCode_t take_next_sample (
    ::LocationInfo & received_data,
    ::DDS::SampleInfo & sample_info) = 0;

  virtual ::DDS::ReturnCode_t read_instance (
    ::LocationInfoSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states) = 0;

  virtual ::DDS::ReturnCode_t take_instance (
    ::LocationInfoSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states) = 0;

  virtual ::DDS::ReturnCode_t read_instance_w_condition (
    ::LocationInfoSeq & received_data,
    ::DDS::SampleInfoSeq & sample_infos,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition) = 0;

  virtual ::DDS::ReturnCode_t take_instance_w_condition (
    ::LocationInfoSeq & received_data,
    ::DDS::SampleInfoSeq & sample_infos,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition) = 0;

  virtual ::DDS::ReturnCode_t read_next_instance (
    ::LocationInfoSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states) = 0;

  virtual ::DDS::ReturnCode_t take_next_instance (
    ::LocationInfoSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states) = 0;

  virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
    ::LocationInfoSeq & data_values,
    ::DDS::SampleInfoSeq & sample_infos,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t previous_handle,
    ::DDS::ReadCondition_ptr a_condition) = 0;

  virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
    ::LocationInfoSeq & data_values,
    ::DDS::SampleInfoSeq & sample_infos,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t previous_handle,
    ::DDS::ReadCondition_ptr a_condition) = 0;

  virtual ::DDS::ReturnCode_t return_loan (
    ::LocationInfoSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq) = 0;

  virtual ::DDS::ReturnCode_t get_key_value (
    ::LocationInfo & key_holder,
    ::DDS::InstanceHandle_t handle) = 0;

  virtual ::DDS::InstanceHandle_t lookup_instance (
    const ::LocationInfo & instance_data) = 0;

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:140

  virtual ::CORBA::Boolean _is_a (const char *type_id);
  virtual const char* _interface_repository_id (void) const;
  virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);

protected:
  // Abstract or local interface only.
  LocationInfoDataReader (void);

  

  virtual ~LocationInfoDataReader (void);

private:
  // Private and unimplemented for concrete interfaces.
  LocationInfoDataReader (const LocationInfoDataReader &);

  void operator= (const LocationInfoDataReader &);
};

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_ch.cpp:102

typedef ::TAO::DCPS::ZeroCopyDataSeq< PlanInfo, DCPS_ZERO_COPY_SEQ_DEFAULT_SIZE> PlanInfoSeq;


// TAO_IDL - Generated from
// be/be_interface.cpp:751

#if !defined (_PLANINFOTYPESUPPORT__VAR_OUT_CH_)
#define _PLANINFOTYPESUPPORT__VAR_OUT_CH_

class PlanInfoTypeSupport;
typedef PlanInfoTypeSupport *PlanInfoTypeSupport_ptr;

typedef
  TAO_Objref_Var_T<
      PlanInfoTypeSupport
    >
  PlanInfoTypeSupport_var;

typedef
  TAO_Objref_Out_T<
      PlanInfoTypeSupport
    >
  PlanInfoTypeSupport_out;

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ch.cpp:43

class  PlanInfoTypeSupport
  : public virtual ::OpenDDS::DCPS::TypeSupport

{
public:

  // TAO_IDL - Generated from
  // be/be_type.cpp:307

  typedef PlanInfoTypeSupport_ptr _ptr_type;
  typedef PlanInfoTypeSupport_var _var_type;
  typedef PlanInfoTypeSupport_out _out_type;

  // The static operations.
  static PlanInfoTypeSupport_ptr _duplicate (PlanInfoTypeSupport_ptr obj);

  static void _tao_release (PlanInfoTypeSupport_ptr obj);

  static PlanInfoTypeSupport_ptr _narrow (::CORBA::Object_ptr obj);
  static PlanInfoTypeSupport_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
  static PlanInfoTypeSupport_ptr _nil (void);

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:140

  virtual ::CORBA::Boolean _is_a (const char *type_id);
  virtual const char* _interface_repository_id (void) const;
  virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);

protected:
  // Abstract or local interface only.
  PlanInfoTypeSupport (void);

  

  virtual ~PlanInfoTypeSupport (void);

private:
  // Private and unimplemented for concrete interfaces.
  PlanInfoTypeSupport (const PlanInfoTypeSupport &);

  void operator= (const PlanInfoTypeSupport &);
};

// TAO_IDL - Generated from
// be/be_interface.cpp:751

#if !defined (_PLANINFODATAWRITER__VAR_OUT_CH_)
#define _PLANINFODATAWRITER__VAR_OUT_CH_

class PlanInfoDataWriter;
typedef PlanInfoDataWriter *PlanInfoDataWriter_ptr;

typedef
  TAO_Objref_Var_T<
      PlanInfoDataWriter
    >
  PlanInfoDataWriter_var;

typedef
  TAO_Objref_Out_T<
      PlanInfoDataWriter
    >
  PlanInfoDataWriter_out;

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ch.cpp:43

class  PlanInfoDataWriter
  : public virtual ::DDS::DataWriter

{
public:

  // TAO_IDL - Generated from
  // be/be_type.cpp:307

  typedef PlanInfoDataWriter_ptr _ptr_type;
  typedef PlanInfoDataWriter_var _var_type;
  typedef PlanInfoDataWriter_out _out_type;

  // The static operations.
  static PlanInfoDataWriter_ptr _duplicate (PlanInfoDataWriter_ptr obj);

  static void _tao_release (PlanInfoDataWriter_ptr obj);

  static PlanInfoDataWriter_ptr _narrow (::CORBA::Object_ptr obj);
  static PlanInfoDataWriter_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
  static PlanInfoDataWriter_ptr _nil (void);

  virtual ::DDS::InstanceHandle_t register_instance (
    const ::PlanInfo & instance) = 0;

  virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
    const ::PlanInfo & instance,
    const ::DDS::Time_t & timestamp) = 0;

  virtual ::DDS::ReturnCode_t unregister_instance (
    const ::PlanInfo & instance,
    ::DDS::InstanceHandle_t handle) = 0;

  virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
    const ::PlanInfo & instance,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & timestamp) = 0;

  virtual ::DDS::ReturnCode_t write (
    const ::PlanInfo & instance_data,
    ::DDS::InstanceHandle_t handle) = 0;

  virtual ::DDS::ReturnCode_t write_w_timestamp (
    const ::PlanInfo & instance_data,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & source_timestamp) = 0;

  virtual ::DDS::ReturnCode_t dispose (
    const ::PlanInfo & instance_data,
    ::DDS::InstanceHandle_t instance_handle) = 0;

  virtual ::DDS::ReturnCode_t dispose_w_timestamp (
    const ::PlanInfo & instance_data,
    ::DDS::InstanceHandle_t instance_handle,
    const ::DDS::Time_t & source_timestamp) = 0;

  virtual ::DDS::ReturnCode_t get_key_value (
    ::PlanInfo & key_holder,
    ::DDS::InstanceHandle_t handle) = 0;

  virtual ::DDS::InstanceHandle_t lookup_instance (
    const ::PlanInfo & instance_data) = 0;

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:140

  virtual ::CORBA::Boolean _is_a (const char *type_id);
  virtual const char* _interface_repository_id (void) const;
  virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);

protected:
  // Abstract or local interface only.
  PlanInfoDataWriter (void);

  

  virtual ~PlanInfoDataWriter (void);

private:
  // Private and unimplemented for concrete interfaces.
  PlanInfoDataWriter (const PlanInfoDataWriter &);

  void operator= (const PlanInfoDataWriter &);
};

// TAO_IDL - Generated from
// be/be_interface.cpp:751

#if !defined (_PLANINFODATAREADER__VAR_OUT_CH_)
#define _PLANINFODATAREADER__VAR_OUT_CH_

class PlanInfoDataReader;
typedef PlanInfoDataReader *PlanInfoDataReader_ptr;

typedef
  TAO_Objref_Var_T<
      PlanInfoDataReader
    >
  PlanInfoDataReader_var;

typedef
  TAO_Objref_Out_T<
      PlanInfoDataReader
    >
  PlanInfoDataReader_out;

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ch.cpp:43

class  PlanInfoDataReader
  : public virtual ::OpenDDS::DCPS::DataReaderEx

{
public:

  // TAO_IDL - Generated from
  // be/be_type.cpp:307

  typedef PlanInfoDataReader_ptr _ptr_type;
  typedef PlanInfoDataReader_var _var_type;
  typedef PlanInfoDataReader_out _out_type;

  // The static operations.
  static PlanInfoDataReader_ptr _duplicate (PlanInfoDataReader_ptr obj);

  static void _tao_release (PlanInfoDataReader_ptr obj);

  static PlanInfoDataReader_ptr _narrow (::CORBA::Object_ptr obj);
  static PlanInfoDataReader_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
  static PlanInfoDataReader_ptr _nil (void);

  virtual ::DDS::ReturnCode_t read (
    ::PlanInfoSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states) = 0;

  virtual ::DDS::ReturnCode_t take (
    ::PlanInfoSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states) = 0;

  virtual ::DDS::ReturnCode_t read_w_condition (
    ::PlanInfoSeq & data_values,
    ::DDS::SampleInfoSeq & sample_infos,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition) = 0;

  virtual ::DDS::ReturnCode_t take_w_condition (
    ::PlanInfoSeq & data_values,
    ::DDS::SampleInfoSeq & sample_infos,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition) = 0;

  virtual ::DDS::ReturnCode_t read_next_sample (
    ::PlanInfo & received_data,
    ::DDS::SampleInfo & sample_info) = 0;

  virtual ::DDS::ReturnCode_t take_next_sample (
    ::PlanInfo & received_data,
    ::DDS::SampleInfo & sample_info) = 0;

  virtual ::DDS::ReturnCode_t read_instance (
    ::PlanInfoSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states) = 0;

  virtual ::DDS::ReturnCode_t take_instance (
    ::PlanInfoSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states) = 0;

  virtual ::DDS::ReturnCode_t read_instance_w_condition (
    ::PlanInfoSeq & received_data,
    ::DDS::SampleInfoSeq & sample_infos,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition) = 0;

  virtual ::DDS::ReturnCode_t take_instance_w_condition (
    ::PlanInfoSeq & received_data,
    ::DDS::SampleInfoSeq & sample_infos,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition) = 0;

  virtual ::DDS::ReturnCode_t read_next_instance (
    ::PlanInfoSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states) = 0;

  virtual ::DDS::ReturnCode_t take_next_instance (
    ::PlanInfoSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states) = 0;

  virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
    ::PlanInfoSeq & data_values,
    ::DDS::SampleInfoSeq & sample_infos,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t previous_handle,
    ::DDS::ReadCondition_ptr a_condition) = 0;

  virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
    ::PlanInfoSeq & data_values,
    ::DDS::SampleInfoSeq & sample_infos,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t previous_handle,
    ::DDS::ReadCondition_ptr a_condition) = 0;

  virtual ::DDS::ReturnCode_t return_loan (
    ::PlanInfoSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq) = 0;

  virtual ::DDS::ReturnCode_t get_key_value (
    ::PlanInfo & key_holder,
    ::DDS::InstanceHandle_t handle) = 0;

  virtual ::DDS::InstanceHandle_t lookup_instance (
    const ::PlanInfo & instance_data) = 0;

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:140

  virtual ::CORBA::Boolean _is_a (const char *type_id);
  virtual const char* _interface_repository_id (void) const;
  virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);

protected:
  // Abstract or local interface only.
  PlanInfoDataReader (void);

  

  virtual ~PlanInfoDataReader (void);

private:
  // Private and unimplemented for concrete interfaces.
  PlanInfoDataReader (const PlanInfoDataReader &);

  void operator= (const PlanInfoDataReader &);
};

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_ch.cpp:102

typedef ::TAO::DCPS::ZeroCopyDataSeq< MoreInfo, DCPS_ZERO_COPY_SEQ_DEFAULT_SIZE> MoreInfoSeq;


// TAO_IDL - Generated from
// be/be_interface.cpp:751

#if !defined (_MOREINFOTYPESUPPORT__VAR_OUT_CH_)
#define _MOREINFOTYPESUPPORT__VAR_OUT_CH_

class MoreInfoTypeSupport;
typedef MoreInfoTypeSupport *MoreInfoTypeSupport_ptr;

typedef
  TAO_Objref_Var_T<
      MoreInfoTypeSupport
    >
  MoreInfoTypeSupport_var;

typedef
  TAO_Objref_Out_T<
      MoreInfoTypeSupport
    >
  MoreInfoTypeSupport_out;

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ch.cpp:43

class  MoreInfoTypeSupport
  : public virtual ::OpenDDS::DCPS::TypeSupport

{
public:

  // TAO_IDL - Generated from
  // be/be_type.cpp:307

  typedef MoreInfoTypeSupport_ptr _ptr_type;
  typedef MoreInfoTypeSupport_var _var_type;
  typedef MoreInfoTypeSupport_out _out_type;

  // The static operations.
  static MoreInfoTypeSupport_ptr _duplicate (MoreInfoTypeSupport_ptr obj);

  static void _tao_release (MoreInfoTypeSupport_ptr obj);

  static MoreInfoTypeSupport_ptr _narrow (::CORBA::Object_ptr obj);
  static MoreInfoTypeSupport_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
  static MoreInfoTypeSupport_ptr _nil (void);

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:140

  virtual ::CORBA::Boolean _is_a (const char *type_id);
  virtual const char* _interface_repository_id (void) const;
  virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);

protected:
  // Abstract or local interface only.
  MoreInfoTypeSupport (void);

  

  virtual ~MoreInfoTypeSupport (void);

private:
  // Private and unimplemented for concrete interfaces.
  MoreInfoTypeSupport (const MoreInfoTypeSupport &);

  void operator= (const MoreInfoTypeSupport &);
};

// TAO_IDL - Generated from
// be/be_interface.cpp:751

#if !defined (_MOREINFODATAWRITER__VAR_OUT_CH_)
#define _MOREINFODATAWRITER__VAR_OUT_CH_

class MoreInfoDataWriter;
typedef MoreInfoDataWriter *MoreInfoDataWriter_ptr;

typedef
  TAO_Objref_Var_T<
      MoreInfoDataWriter
    >
  MoreInfoDataWriter_var;

typedef
  TAO_Objref_Out_T<
      MoreInfoDataWriter
    >
  MoreInfoDataWriter_out;

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ch.cpp:43

class  MoreInfoDataWriter
  : public virtual ::DDS::DataWriter

{
public:

  // TAO_IDL - Generated from
  // be/be_type.cpp:307

  typedef MoreInfoDataWriter_ptr _ptr_type;
  typedef MoreInfoDataWriter_var _var_type;
  typedef MoreInfoDataWriter_out _out_type;

  // The static operations.
  static MoreInfoDataWriter_ptr _duplicate (MoreInfoDataWriter_ptr obj);

  static void _tao_release (MoreInfoDataWriter_ptr obj);

  static MoreInfoDataWriter_ptr _narrow (::CORBA::Object_ptr obj);
  static MoreInfoDataWriter_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
  static MoreInfoDataWriter_ptr _nil (void);

  virtual ::DDS::InstanceHandle_t register_instance (
    const ::MoreInfo & instance) = 0;

  virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
    const ::MoreInfo & instance,
    const ::DDS::Time_t & timestamp) = 0;

  virtual ::DDS::ReturnCode_t unregister_instance (
    const ::MoreInfo & instance,
    ::DDS::InstanceHandle_t handle) = 0;

  virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
    const ::MoreInfo & instance,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & timestamp) = 0;

  virtual ::DDS::ReturnCode_t write (
    const ::MoreInfo & instance_data,
    ::DDS::InstanceHandle_t handle) = 0;

  virtual ::DDS::ReturnCode_t write_w_timestamp (
    const ::MoreInfo & instance_data,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & source_timestamp) = 0;

  virtual ::DDS::ReturnCode_t dispose (
    const ::MoreInfo & instance_data,
    ::DDS::InstanceHandle_t instance_handle) = 0;

  virtual ::DDS::ReturnCode_t dispose_w_timestamp (
    const ::MoreInfo & instance_data,
    ::DDS::InstanceHandle_t instance_handle,
    const ::DDS::Time_t & source_timestamp) = 0;

  virtual ::DDS::ReturnCode_t get_key_value (
    ::MoreInfo & key_holder,
    ::DDS::InstanceHandle_t handle) = 0;

  virtual ::DDS::InstanceHandle_t lookup_instance (
    const ::MoreInfo & instance_data) = 0;

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:140

  virtual ::CORBA::Boolean _is_a (const char *type_id);
  virtual const char* _interface_repository_id (void) const;
  virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);

protected:
  // Abstract or local interface only.
  MoreInfoDataWriter (void);

  

  virtual ~MoreInfoDataWriter (void);

private:
  // Private and unimplemented for concrete interfaces.
  MoreInfoDataWriter (const MoreInfoDataWriter &);

  void operator= (const MoreInfoDataWriter &);
};

// TAO_IDL - Generated from
// be/be_interface.cpp:751

#if !defined (_MOREINFODATAREADER__VAR_OUT_CH_)
#define _MOREINFODATAREADER__VAR_OUT_CH_

class MoreInfoDataReader;
typedef MoreInfoDataReader *MoreInfoDataReader_ptr;

typedef
  TAO_Objref_Var_T<
      MoreInfoDataReader
    >
  MoreInfoDataReader_var;

typedef
  TAO_Objref_Out_T<
      MoreInfoDataReader
    >
  MoreInfoDataReader_out;

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ch.cpp:43

class  MoreInfoDataReader
  : public virtual ::OpenDDS::DCPS::DataReaderEx

{
public:

  // TAO_IDL - Generated from
  // be/be_type.cpp:307

  typedef MoreInfoDataReader_ptr _ptr_type;
  typedef MoreInfoDataReader_var _var_type;
  typedef MoreInfoDataReader_out _out_type;

  // The static operations.
  static MoreInfoDataReader_ptr _duplicate (MoreInfoDataReader_ptr obj);

  static void _tao_release (MoreInfoDataReader_ptr obj);

  static MoreInfoDataReader_ptr _narrow (::CORBA::Object_ptr obj);
  static MoreInfoDataReader_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
  static MoreInfoDataReader_ptr _nil (void);

  virtual ::DDS::ReturnCode_t read (
    ::MoreInfoSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states) = 0;

  virtual ::DDS::ReturnCode_t take (
    ::MoreInfoSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states) = 0;

  virtual ::DDS::ReturnCode_t read_w_condition (
    ::MoreInfoSeq & data_values,
    ::DDS::SampleInfoSeq & sample_infos,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition) = 0;

  virtual ::DDS::ReturnCode_t take_w_condition (
    ::MoreInfoSeq & data_values,
    ::DDS::SampleInfoSeq & sample_infos,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition) = 0;

  virtual ::DDS::ReturnCode_t read_next_sample (
    ::MoreInfo & received_data,
    ::DDS::SampleInfo & sample_info) = 0;

  virtual ::DDS::ReturnCode_t take_next_sample (
    ::MoreInfo & received_data,
    ::DDS::SampleInfo & sample_info) = 0;

  virtual ::DDS::ReturnCode_t read_instance (
    ::MoreInfoSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states) = 0;

  virtual ::DDS::ReturnCode_t take_instance (
    ::MoreInfoSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states) = 0;

  virtual ::DDS::ReturnCode_t read_instance_w_condition (
    ::MoreInfoSeq & received_data,
    ::DDS::SampleInfoSeq & sample_infos,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition) = 0;

  virtual ::DDS::ReturnCode_t take_instance_w_condition (
    ::MoreInfoSeq & received_data,
    ::DDS::SampleInfoSeq & sample_infos,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition) = 0;

  virtual ::DDS::ReturnCode_t read_next_instance (
    ::MoreInfoSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states) = 0;

  virtual ::DDS::ReturnCode_t take_next_instance (
    ::MoreInfoSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states) = 0;

  virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
    ::MoreInfoSeq & data_values,
    ::DDS::SampleInfoSeq & sample_infos,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t previous_handle,
    ::DDS::ReadCondition_ptr a_condition) = 0;

  virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
    ::MoreInfoSeq & data_values,
    ::DDS::SampleInfoSeq & sample_infos,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t previous_handle,
    ::DDS::ReadCondition_ptr a_condition) = 0;

  virtual ::DDS::ReturnCode_t return_loan (
    ::MoreInfoSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq) = 0;

  virtual ::DDS::ReturnCode_t get_key_value (
    ::MoreInfo & key_holder,
    ::DDS::InstanceHandle_t handle) = 0;

  virtual ::DDS::InstanceHandle_t lookup_instance (
    const ::MoreInfo & instance_data) = 0;

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:140

  virtual ::CORBA::Boolean _is_a (const char *type_id);
  virtual const char* _interface_repository_id (void) const;
  virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);

protected:
  // Abstract or local interface only.
  MoreInfoDataReader (void);

  

  virtual ~MoreInfoDataReader (void);

private:
  // Private and unimplemented for concrete interfaces.
  MoreInfoDataReader (const MoreInfoDataReader &);

  void operator= (const MoreInfoDataReader &);
};

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_ch.cpp:102

typedef ::TAO::DCPS::ZeroCopyDataSeq< UnrelatedInfo, DCPS_ZERO_COPY_SEQ_DEFAULT_SIZE> UnrelatedInfoSeq;


// TAO_IDL - Generated from
// be/be_interface.cpp:751

#if !defined (_UNRELATEDINFOTYPESUPPORT__VAR_OUT_CH_)
#define _UNRELATEDINFOTYPESUPPORT__VAR_OUT_CH_

class UnrelatedInfoTypeSupport;
typedef UnrelatedInfoTypeSupport *UnrelatedInfoTypeSupport_ptr;

typedef
  TAO_Objref_Var_T<
      UnrelatedInfoTypeSupport
    >
  UnrelatedInfoTypeSupport_var;

typedef
  TAO_Objref_Out_T<
      UnrelatedInfoTypeSupport
    >
  UnrelatedInfoTypeSupport_out;

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ch.cpp:43

class  UnrelatedInfoTypeSupport
  : public virtual ::OpenDDS::DCPS::TypeSupport

{
public:

  // TAO_IDL - Generated from
  // be/be_type.cpp:307

  typedef UnrelatedInfoTypeSupport_ptr _ptr_type;
  typedef UnrelatedInfoTypeSupport_var _var_type;
  typedef UnrelatedInfoTypeSupport_out _out_type;

  // The static operations.
  static UnrelatedInfoTypeSupport_ptr _duplicate (UnrelatedInfoTypeSupport_ptr obj);

  static void _tao_release (UnrelatedInfoTypeSupport_ptr obj);

  static UnrelatedInfoTypeSupport_ptr _narrow (::CORBA::Object_ptr obj);
  static UnrelatedInfoTypeSupport_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
  static UnrelatedInfoTypeSupport_ptr _nil (void);

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:140

  virtual ::CORBA::Boolean _is_a (const char *type_id);
  virtual const char* _interface_repository_id (void) const;
  virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);

protected:
  // Abstract or local interface only.
  UnrelatedInfoTypeSupport (void);

  

  virtual ~UnrelatedInfoTypeSupport (void);

private:
  // Private and unimplemented for concrete interfaces.
  UnrelatedInfoTypeSupport (const UnrelatedInfoTypeSupport &);

  void operator= (const UnrelatedInfoTypeSupport &);
};

// TAO_IDL - Generated from
// be/be_interface.cpp:751

#if !defined (_UNRELATEDINFODATAWRITER__VAR_OUT_CH_)
#define _UNRELATEDINFODATAWRITER__VAR_OUT_CH_

class UnrelatedInfoDataWriter;
typedef UnrelatedInfoDataWriter *UnrelatedInfoDataWriter_ptr;

typedef
  TAO_Objref_Var_T<
      UnrelatedInfoDataWriter
    >
  UnrelatedInfoDataWriter_var;

typedef
  TAO_Objref_Out_T<
      UnrelatedInfoDataWriter
    >
  UnrelatedInfoDataWriter_out;

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ch.cpp:43

class  UnrelatedInfoDataWriter
  : public virtual ::DDS::DataWriter

{
public:

  // TAO_IDL - Generated from
  // be/be_type.cpp:307

  typedef UnrelatedInfoDataWriter_ptr _ptr_type;
  typedef UnrelatedInfoDataWriter_var _var_type;
  typedef UnrelatedInfoDataWriter_out _out_type;

  // The static operations.
  static UnrelatedInfoDataWriter_ptr _duplicate (UnrelatedInfoDataWriter_ptr obj);

  static void _tao_release (UnrelatedInfoDataWriter_ptr obj);

  static UnrelatedInfoDataWriter_ptr _narrow (::CORBA::Object_ptr obj);
  static UnrelatedInfoDataWriter_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
  static UnrelatedInfoDataWriter_ptr _nil (void);

  virtual ::DDS::InstanceHandle_t register_instance (
    const ::UnrelatedInfo & instance) = 0;

  virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
    const ::UnrelatedInfo & instance,
    const ::DDS::Time_t & timestamp) = 0;

  virtual ::DDS::ReturnCode_t unregister_instance (
    const ::UnrelatedInfo & instance,
    ::DDS::InstanceHandle_t handle) = 0;

  virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
    const ::UnrelatedInfo & instance,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & timestamp) = 0;

  virtual ::DDS::ReturnCode_t write (
    const ::UnrelatedInfo & instance_data,
    ::DDS::InstanceHandle_t handle) = 0;

  virtual ::DDS::ReturnCode_t write_w_timestamp (
    const ::UnrelatedInfo & instance_data,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & source_timestamp) = 0;

  virtual ::DDS::ReturnCode_t dispose (
    const ::UnrelatedInfo & instance_data,
    ::DDS::InstanceHandle_t instance_handle) = 0;

  virtual ::DDS::ReturnCode_t dispose_w_timestamp (
    const ::UnrelatedInfo & instance_data,
    ::DDS::InstanceHandle_t instance_handle,
    const ::DDS::Time_t & source_timestamp) = 0;

  virtual ::DDS::ReturnCode_t get_key_value (
    ::UnrelatedInfo & key_holder,
    ::DDS::InstanceHandle_t handle) = 0;

  virtual ::DDS::InstanceHandle_t lookup_instance (
    const ::UnrelatedInfo & instance_data) = 0;

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:140

  virtual ::CORBA::Boolean _is_a (const char *type_id);
  virtual const char* _interface_repository_id (void) const;
  virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);

protected:
  // Abstract or local interface only.
  UnrelatedInfoDataWriter (void);

  

  virtual ~UnrelatedInfoDataWriter (void);

private:
  // Private and unimplemented for concrete interfaces.
  UnrelatedInfoDataWriter (const UnrelatedInfoDataWriter &);

  void operator= (const UnrelatedInfoDataWriter &);
};

// TAO_IDL - Generated from
// be/be_interface.cpp:751

#if !defined (_UNRELATEDINFODATAREADER__VAR_OUT_CH_)
#define _UNRELATEDINFODATAREADER__VAR_OUT_CH_

class UnrelatedInfoDataReader;
typedef UnrelatedInfoDataReader *UnrelatedInfoDataReader_ptr;

typedef
  TAO_Objref_Var_T<
      UnrelatedInfoDataReader
    >
  UnrelatedInfoDataReader_var;

typedef
  TAO_Objref_Out_T<
      UnrelatedInfoDataReader
    >
  UnrelatedInfoDataReader_out;

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ch.cpp:43

class  UnrelatedInfoDataReader
  : public virtual ::OpenDDS::DCPS::DataReaderEx

{
public:

  // TAO_IDL - Generated from
  // be/be_type.cpp:307

  typedef UnrelatedInfoDataReader_ptr _ptr_type;
  typedef UnrelatedInfoDataReader_var _var_type;
  typedef UnrelatedInfoDataReader_out _out_type;

  // The static operations.
  static UnrelatedInfoDataReader_ptr _duplicate (UnrelatedInfoDataReader_ptr obj);

  static void _tao_release (UnrelatedInfoDataReader_ptr obj);

  static UnrelatedInfoDataReader_ptr _narrow (::CORBA::Object_ptr obj);
  static UnrelatedInfoDataReader_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
  static UnrelatedInfoDataReader_ptr _nil (void);

  virtual ::DDS::ReturnCode_t read (
    ::UnrelatedInfoSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states) = 0;

  virtual ::DDS::ReturnCode_t take (
    ::UnrelatedInfoSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states) = 0;

  virtual ::DDS::ReturnCode_t read_w_condition (
    ::UnrelatedInfoSeq & data_values,
    ::DDS::SampleInfoSeq & sample_infos,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition) = 0;

  virtual ::DDS::ReturnCode_t take_w_condition (
    ::UnrelatedInfoSeq & data_values,
    ::DDS::SampleInfoSeq & sample_infos,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition) = 0;

  virtual ::DDS::ReturnCode_t read_next_sample (
    ::UnrelatedInfo & received_data,
    ::DDS::SampleInfo & sample_info) = 0;

  virtual ::DDS::ReturnCode_t take_next_sample (
    ::UnrelatedInfo & received_data,
    ::DDS::SampleInfo & sample_info) = 0;

  virtual ::DDS::ReturnCode_t read_instance (
    ::UnrelatedInfoSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states) = 0;

  virtual ::DDS::ReturnCode_t take_instance (
    ::UnrelatedInfoSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states) = 0;

  virtual ::DDS::ReturnCode_t read_instance_w_condition (
    ::UnrelatedInfoSeq & received_data,
    ::DDS::SampleInfoSeq & sample_infos,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition) = 0;

  virtual ::DDS::ReturnCode_t take_instance_w_condition (
    ::UnrelatedInfoSeq & received_data,
    ::DDS::SampleInfoSeq & sample_infos,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition) = 0;

  virtual ::DDS::ReturnCode_t read_next_instance (
    ::UnrelatedInfoSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states) = 0;

  virtual ::DDS::ReturnCode_t take_next_instance (
    ::UnrelatedInfoSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states) = 0;

  virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
    ::UnrelatedInfoSeq & data_values,
    ::DDS::SampleInfoSeq & sample_infos,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t previous_handle,
    ::DDS::ReadCondition_ptr a_condition) = 0;

  virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
    ::UnrelatedInfoSeq & data_values,
    ::DDS::SampleInfoSeq & sample_infos,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t previous_handle,
    ::DDS::ReadCondition_ptr a_condition) = 0;

  virtual ::DDS::ReturnCode_t return_loan (
    ::UnrelatedInfoSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq) = 0;

  virtual ::DDS::ReturnCode_t get_key_value (
    ::UnrelatedInfo & key_holder,
    ::DDS::InstanceHandle_t handle) = 0;

  virtual ::DDS::InstanceHandle_t lookup_instance (
    const ::UnrelatedInfo & instance_data) = 0;

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:140

  virtual ::CORBA::Boolean _is_a (const char *type_id);
  virtual const char* _interface_repository_id (void) const;
  virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);

protected:
  // Abstract or local interface only.
  UnrelatedInfoDataReader (void);

  

  virtual ~UnrelatedInfoDataReader (void);

private:
  // Private and unimplemented for concrete interfaces.
  UnrelatedInfoDataReader (const UnrelatedInfoDataReader &);

  void operator= (const UnrelatedInfoDataReader &);
};

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_ch.cpp:102

typedef ::TAO::DCPS::ZeroCopyDataSeq< Resulting, DCPS_ZERO_COPY_SEQ_DEFAULT_SIZE> ResultingSeq;


// TAO_IDL - Generated from
// be/be_interface.cpp:751

#if !defined (_RESULTINGTYPESUPPORT__VAR_OUT_CH_)
#define _RESULTINGTYPESUPPORT__VAR_OUT_CH_

class ResultingTypeSupport;
typedef ResultingTypeSupport *ResultingTypeSupport_ptr;

typedef
  TAO_Objref_Var_T<
      ResultingTypeSupport
    >
  ResultingTypeSupport_var;

typedef
  TAO_Objref_Out_T<
      ResultingTypeSupport
    >
  ResultingTypeSupport_out;

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ch.cpp:43

class  ResultingTypeSupport
  : public virtual ::OpenDDS::DCPS::TypeSupport

{
public:

  // TAO_IDL - Generated from
  // be/be_type.cpp:307

  typedef ResultingTypeSupport_ptr _ptr_type;
  typedef ResultingTypeSupport_var _var_type;
  typedef ResultingTypeSupport_out _out_type;

  // The static operations.
  static ResultingTypeSupport_ptr _duplicate (ResultingTypeSupport_ptr obj);

  static void _tao_release (ResultingTypeSupport_ptr obj);

  static ResultingTypeSupport_ptr _narrow (::CORBA::Object_ptr obj);
  static ResultingTypeSupport_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
  static ResultingTypeSupport_ptr _nil (void);

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:140

  virtual ::CORBA::Boolean _is_a (const char *type_id);
  virtual const char* _interface_repository_id (void) const;
  virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);

protected:
  // Abstract or local interface only.
  ResultingTypeSupport (void);

  

  virtual ~ResultingTypeSupport (void);

private:
  // Private and unimplemented for concrete interfaces.
  ResultingTypeSupport (const ResultingTypeSupport &);

  void operator= (const ResultingTypeSupport &);
};

// TAO_IDL - Generated from
// be/be_interface.cpp:751

#if !defined (_RESULTINGDATAWRITER__VAR_OUT_CH_)
#define _RESULTINGDATAWRITER__VAR_OUT_CH_

class ResultingDataWriter;
typedef ResultingDataWriter *ResultingDataWriter_ptr;

typedef
  TAO_Objref_Var_T<
      ResultingDataWriter
    >
  ResultingDataWriter_var;

typedef
  TAO_Objref_Out_T<
      ResultingDataWriter
    >
  ResultingDataWriter_out;

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ch.cpp:43

class  ResultingDataWriter
  : public virtual ::DDS::DataWriter

{
public:

  // TAO_IDL - Generated from
  // be/be_type.cpp:307

  typedef ResultingDataWriter_ptr _ptr_type;
  typedef ResultingDataWriter_var _var_type;
  typedef ResultingDataWriter_out _out_type;

  // The static operations.
  static ResultingDataWriter_ptr _duplicate (ResultingDataWriter_ptr obj);

  static void _tao_release (ResultingDataWriter_ptr obj);

  static ResultingDataWriter_ptr _narrow (::CORBA::Object_ptr obj);
  static ResultingDataWriter_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
  static ResultingDataWriter_ptr _nil (void);

  virtual ::DDS::InstanceHandle_t register_instance (
    const ::Resulting & instance) = 0;

  virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
    const ::Resulting & instance,
    const ::DDS::Time_t & timestamp) = 0;

  virtual ::DDS::ReturnCode_t unregister_instance (
    const ::Resulting & instance,
    ::DDS::InstanceHandle_t handle) = 0;

  virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
    const ::Resulting & instance,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & timestamp) = 0;

  virtual ::DDS::ReturnCode_t write (
    const ::Resulting & instance_data,
    ::DDS::InstanceHandle_t handle) = 0;

  virtual ::DDS::ReturnCode_t write_w_timestamp (
    const ::Resulting & instance_data,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & source_timestamp) = 0;

  virtual ::DDS::ReturnCode_t dispose (
    const ::Resulting & instance_data,
    ::DDS::InstanceHandle_t instance_handle) = 0;

  virtual ::DDS::ReturnCode_t dispose_w_timestamp (
    const ::Resulting & instance_data,
    ::DDS::InstanceHandle_t instance_handle,
    const ::DDS::Time_t & source_timestamp) = 0;

  virtual ::DDS::ReturnCode_t get_key_value (
    ::Resulting & key_holder,
    ::DDS::InstanceHandle_t handle) = 0;

  virtual ::DDS::InstanceHandle_t lookup_instance (
    const ::Resulting & instance_data) = 0;

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:140

  virtual ::CORBA::Boolean _is_a (const char *type_id);
  virtual const char* _interface_repository_id (void) const;
  virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);

protected:
  // Abstract or local interface only.
  ResultingDataWriter (void);

  

  virtual ~ResultingDataWriter (void);

private:
  // Private and unimplemented for concrete interfaces.
  ResultingDataWriter (const ResultingDataWriter &);

  void operator= (const ResultingDataWriter &);
};

// TAO_IDL - Generated from
// be/be_interface.cpp:751

#if !defined (_RESULTINGDATAREADER__VAR_OUT_CH_)
#define _RESULTINGDATAREADER__VAR_OUT_CH_

class ResultingDataReader;
typedef ResultingDataReader *ResultingDataReader_ptr;

typedef
  TAO_Objref_Var_T<
      ResultingDataReader
    >
  ResultingDataReader_var;

typedef
  TAO_Objref_Out_T<
      ResultingDataReader
    >
  ResultingDataReader_out;

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ch.cpp:43

class  ResultingDataReader
  : public virtual ::OpenDDS::DCPS::DataReaderEx

{
public:

  // TAO_IDL - Generated from
  // be/be_type.cpp:307

  typedef ResultingDataReader_ptr _ptr_type;
  typedef ResultingDataReader_var _var_type;
  typedef ResultingDataReader_out _out_type;

  // The static operations.
  static ResultingDataReader_ptr _duplicate (ResultingDataReader_ptr obj);

  static void _tao_release (ResultingDataReader_ptr obj);

  static ResultingDataReader_ptr _narrow (::CORBA::Object_ptr obj);
  static ResultingDataReader_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
  static ResultingDataReader_ptr _nil (void);

  virtual ::DDS::ReturnCode_t read (
    ::ResultingSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states) = 0;

  virtual ::DDS::ReturnCode_t take (
    ::ResultingSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states) = 0;

  virtual ::DDS::ReturnCode_t read_w_condition (
    ::ResultingSeq & data_values,
    ::DDS::SampleInfoSeq & sample_infos,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition) = 0;

  virtual ::DDS::ReturnCode_t take_w_condition (
    ::ResultingSeq & data_values,
    ::DDS::SampleInfoSeq & sample_infos,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition) = 0;

  virtual ::DDS::ReturnCode_t read_next_sample (
    ::Resulting & received_data,
    ::DDS::SampleInfo & sample_info) = 0;

  virtual ::DDS::ReturnCode_t take_next_sample (
    ::Resulting & received_data,
    ::DDS::SampleInfo & sample_info) = 0;

  virtual ::DDS::ReturnCode_t read_instance (
    ::ResultingSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states) = 0;

  virtual ::DDS::ReturnCode_t take_instance (
    ::ResultingSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states) = 0;

  virtual ::DDS::ReturnCode_t read_instance_w_condition (
    ::ResultingSeq & received_data,
    ::DDS::SampleInfoSeq & sample_infos,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition) = 0;

  virtual ::DDS::ReturnCode_t take_instance_w_condition (
    ::ResultingSeq & received_data,
    ::DDS::SampleInfoSeq & sample_infos,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition) = 0;

  virtual ::DDS::ReturnCode_t read_next_instance (
    ::ResultingSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states) = 0;

  virtual ::DDS::ReturnCode_t take_next_instance (
    ::ResultingSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states) = 0;

  virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
    ::ResultingSeq & data_values,
    ::DDS::SampleInfoSeq & sample_infos,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t previous_handle,
    ::DDS::ReadCondition_ptr a_condition) = 0;

  virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
    ::ResultingSeq & data_values,
    ::DDS::SampleInfoSeq & sample_infos,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t previous_handle,
    ::DDS::ReadCondition_ptr a_condition) = 0;

  virtual ::DDS::ReturnCode_t return_loan (
    ::ResultingSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq) = 0;

  virtual ::DDS::ReturnCode_t get_key_value (
    ::Resulting & key_holder,
    ::DDS::InstanceHandle_t handle) = 0;

  virtual ::DDS::InstanceHandle_t lookup_instance (
    const ::Resulting & instance_data) = 0;

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:140

  virtual ::CORBA::Boolean _is_a (const char *type_id);
  virtual const char* _interface_repository_id (void) const;
  virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);

protected:
  // Abstract or local interface only.
  ResultingDataReader (void);

  

  virtual ~ResultingDataReader (void);

private:
  // Private and unimplemented for concrete interfaces.
  ResultingDataReader (const ResultingDataReader &);

  void operator= (const ResultingDataReader &);
};

// TAO_IDL - Generated from
// be/be_visitor_arg_traits.cpp:68

TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Arg traits specializations.
namespace TAO
{
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_traits.cpp:62

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations.
namespace TAO
{

#if !defined (_LOCATIONINFOTYPESUPPORT__TRAITS_)
#define _LOCATIONINFOTYPESUPPORT__TRAITS_

  template<>
  struct  Objref_Traits< ::LocationInfoTypeSupport>
  {
    static ::LocationInfoTypeSupport_ptr duplicate (
        ::LocationInfoTypeSupport_ptr p);
    static void release (
        ::LocationInfoTypeSupport_ptr p);
    static ::LocationInfoTypeSupport_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::LocationInfoTypeSupport_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_LOCATIONINFODATAWRITER__TRAITS_)
#define _LOCATIONINFODATAWRITER__TRAITS_

  template<>
  struct  Objref_Traits< ::LocationInfoDataWriter>
  {
    static ::LocationInfoDataWriter_ptr duplicate (
        ::LocationInfoDataWriter_ptr p);
    static void release (
        ::LocationInfoDataWriter_ptr p);
    static ::LocationInfoDataWriter_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::LocationInfoDataWriter_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_LOCATIONINFODATAREADER__TRAITS_)
#define _LOCATIONINFODATAREADER__TRAITS_

  template<>
  struct  Objref_Traits< ::LocationInfoDataReader>
  {
    static ::LocationInfoDataReader_ptr duplicate (
        ::LocationInfoDataReader_ptr p);
    static void release (
        ::LocationInfoDataReader_ptr p);
    static ::LocationInfoDataReader_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::LocationInfoDataReader_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_PLANINFOTYPESUPPORT__TRAITS_)
#define _PLANINFOTYPESUPPORT__TRAITS_

  template<>
  struct  Objref_Traits< ::PlanInfoTypeSupport>
  {
    static ::PlanInfoTypeSupport_ptr duplicate (
        ::PlanInfoTypeSupport_ptr p);
    static void release (
        ::PlanInfoTypeSupport_ptr p);
    static ::PlanInfoTypeSupport_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::PlanInfoTypeSupport_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_PLANINFODATAWRITER__TRAITS_)
#define _PLANINFODATAWRITER__TRAITS_

  template<>
  struct  Objref_Traits< ::PlanInfoDataWriter>
  {
    static ::PlanInfoDataWriter_ptr duplicate (
        ::PlanInfoDataWriter_ptr p);
    static void release (
        ::PlanInfoDataWriter_ptr p);
    static ::PlanInfoDataWriter_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::PlanInfoDataWriter_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_PLANINFODATAREADER__TRAITS_)
#define _PLANINFODATAREADER__TRAITS_

  template<>
  struct  Objref_Traits< ::PlanInfoDataReader>
  {
    static ::PlanInfoDataReader_ptr duplicate (
        ::PlanInfoDataReader_ptr p);
    static void release (
        ::PlanInfoDataReader_ptr p);
    static ::PlanInfoDataReader_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::PlanInfoDataReader_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_MOREINFOTYPESUPPORT__TRAITS_)
#define _MOREINFOTYPESUPPORT__TRAITS_

  template<>
  struct  Objref_Traits< ::MoreInfoTypeSupport>
  {
    static ::MoreInfoTypeSupport_ptr duplicate (
        ::MoreInfoTypeSupport_ptr p);
    static void release (
        ::MoreInfoTypeSupport_ptr p);
    static ::MoreInfoTypeSupport_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::MoreInfoTypeSupport_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_MOREINFODATAWRITER__TRAITS_)
#define _MOREINFODATAWRITER__TRAITS_

  template<>
  struct  Objref_Traits< ::MoreInfoDataWriter>
  {
    static ::MoreInfoDataWriter_ptr duplicate (
        ::MoreInfoDataWriter_ptr p);
    static void release (
        ::MoreInfoDataWriter_ptr p);
    static ::MoreInfoDataWriter_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::MoreInfoDataWriter_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_MOREINFODATAREADER__TRAITS_)
#define _MOREINFODATAREADER__TRAITS_

  template<>
  struct  Objref_Traits< ::MoreInfoDataReader>
  {
    static ::MoreInfoDataReader_ptr duplicate (
        ::MoreInfoDataReader_ptr p);
    static void release (
        ::MoreInfoDataReader_ptr p);
    static ::MoreInfoDataReader_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::MoreInfoDataReader_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_UNRELATEDINFOTYPESUPPORT__TRAITS_)
#define _UNRELATEDINFOTYPESUPPORT__TRAITS_

  template<>
  struct  Objref_Traits< ::UnrelatedInfoTypeSupport>
  {
    static ::UnrelatedInfoTypeSupport_ptr duplicate (
        ::UnrelatedInfoTypeSupport_ptr p);
    static void release (
        ::UnrelatedInfoTypeSupport_ptr p);
    static ::UnrelatedInfoTypeSupport_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::UnrelatedInfoTypeSupport_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_UNRELATEDINFODATAWRITER__TRAITS_)
#define _UNRELATEDINFODATAWRITER__TRAITS_

  template<>
  struct  Objref_Traits< ::UnrelatedInfoDataWriter>
  {
    static ::UnrelatedInfoDataWriter_ptr duplicate (
        ::UnrelatedInfoDataWriter_ptr p);
    static void release (
        ::UnrelatedInfoDataWriter_ptr p);
    static ::UnrelatedInfoDataWriter_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::UnrelatedInfoDataWriter_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_UNRELATEDINFODATAREADER__TRAITS_)
#define _UNRELATEDINFODATAREADER__TRAITS_

  template<>
  struct  Objref_Traits< ::UnrelatedInfoDataReader>
  {
    static ::UnrelatedInfoDataReader_ptr duplicate (
        ::UnrelatedInfoDataReader_ptr p);
    static void release (
        ::UnrelatedInfoDataReader_ptr p);
    static ::UnrelatedInfoDataReader_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::UnrelatedInfoDataReader_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_RESULTINGTYPESUPPORT__TRAITS_)
#define _RESULTINGTYPESUPPORT__TRAITS_

  template<>
  struct  Objref_Traits< ::ResultingTypeSupport>
  {
    static ::ResultingTypeSupport_ptr duplicate (
        ::ResultingTypeSupport_ptr p);
    static void release (
        ::ResultingTypeSupport_ptr p);
    static ::ResultingTypeSupport_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::ResultingTypeSupport_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_RESULTINGDATAWRITER__TRAITS_)
#define _RESULTINGDATAWRITER__TRAITS_

  template<>
  struct  Objref_Traits< ::ResultingDataWriter>
  {
    static ::ResultingDataWriter_ptr duplicate (
        ::ResultingDataWriter_ptr p);
    static void release (
        ::ResultingDataWriter_ptr p);
    static ::ResultingDataWriter_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::ResultingDataWriter_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_RESULTINGDATAREADER__TRAITS_)
#define _RESULTINGDATAREADER__TRAITS_

  template<>
  struct  Objref_Traits< ::ResultingDataReader>
  {
    static ::ResultingDataReader_ptr duplicate (
        ::ResultingDataReader_ptr p);
    static void release (
        ::ResultingDataReader_ptr p);
    static ::ResultingDataReader_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::ResultingDataReader_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_codegen.cpp:1703
#if defined (__ACE_INLINE__)
#include "MultiTopicTestTypeSupportC.inl"
#endif /* defined INLINE */

#include /**/ "ace/post.h"

#endif /* ifndef */

