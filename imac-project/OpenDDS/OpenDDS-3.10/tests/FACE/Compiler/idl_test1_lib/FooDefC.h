/* -*- C++ -*- */
/* Generated by /Users/yc/MyGithub/imac-project/OpenDDS/OpenDDS-3.10/bin/opendds_idl version 3.10 (ACE version 6.2a_p11) running on input file ../../../DCPS/Compiler/idl_test1_lib/FooDef.idl */
#ifndef OPENDDS_IDL_GENERATED_FOODEFC_H_3FWEKY
#define OPENDDS_IDL_GENERATED_FOODEFC_H_3FWEKY
#include <tao/orbconf.h>
#include <tao/Basic_Types.h>
#include <ace/CDR_Stream.h>
#include <tao/Array_VarOut_T.h>
#include <tao/Seq_Out_T.h>
#include <tao/VarOut_T.h>
#include "FACE/Sequence.h"
#include "FACE/SequenceVar.h"
#include "FACE/StringManager.h"
#include "FACE/types.hpp"
#include "dds/DCPS/SafetyProfilePool.h"
#include "foolib_export.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: ShortSeq */


/* End TYPEDEF: ShortSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */

/* End MODULE: CORBA */


/* Begin CONST: tao_version */

const ::FACE::UnsignedLong tao_version = 393728u;

/* End CONST: tao_version */


/* Begin CONST: dds_version */

const ::FACE::UnsignedLong dds_version = 200704u;

/* End CONST: dds_version */


/* Begin MODULE: Xyz */



/* Begin CONST: c0 */

namespace Xyz {
const ::FACE::Octet c0 = 42;
}

/* End CONST: c0 */


/* Begin CONST: c1 */

namespace Xyz {
const ::FACE::Char c1 = 'a';
}

/* End CONST: c1 */


/* Begin CONST: c2 */

namespace Xyz {
const ::FACE::WChar c2 = L'b';
}

/* End CONST: c2 */


/* Begin CONST: c3 */

namespace Xyz {
const ::FACE::Short c3 = -1000;
}

/* End CONST: c3 */


/* Begin CONST: c4 */

namespace Xyz {
const ::FACE::UnsignedShort c4 = 1000u;
}

/* End CONST: c4 */


/* Begin CONST: c5 */

namespace Xyz {
const ::FACE::Long c5 = -200000;
}

/* End CONST: c5 */


/* Begin CONST: c6 */

namespace Xyz {
const ::FACE::UnsignedLong c6 = 200000u;
}

/* End CONST: c6 */


/* Begin CONST: c7 */

namespace Xyz {
const ::FACE::LongLong c7 = -8000000000LL;
}

/* End CONST: c7 */


/* Begin CONST: c8 */

namespace Xyz {
const ::FACE::UnsignedLongLong c8 = 8000000000ULL;
}

/* End CONST: c8 */


/* Begin CONST: c9 */

namespace Xyz {
const ::FACE::Boolean c9 = true;
}

/* End CONST: c9 */


/* Begin CONST: c10 */

namespace Xyz {
const ::FACE::Float c10 = 3.1416f;
}

/* End CONST: c10 */


/* Begin CONST: c11 */

namespace Xyz {
const ::FACE::Double c11 = 2.17;
}

/* End CONST: c11 */


/* Begin CONST: c13 */

namespace Xyz {
const ::FACE::Char* const c13 = "Hello, \"world\".";
}

/* End CONST: c13 */


/* Begin TYPEDEF: ArrayOfShorts */

namespace Xyz {
typedef ::FACE::Short ArrayOfShorts[5];
typedef ::FACE::Short ArrayOfShorts_slice;
struct ArrayOfShorts_tag {};
typedef ::TAO_FixedArray_Var_T<ArrayOfShorts, ArrayOfShorts_slice, ArrayOfShorts_tag> ArrayOfShorts_var;
typedef ArrayOfShorts ArrayOfShorts_out;
typedef ::TAO_Array_Forany_T<ArrayOfShorts, ArrayOfShorts_slice, ArrayOfShorts_tag> ArrayOfShorts_forany;

FooLib_Export ArrayOfShorts_slice* ArrayOfShorts_alloc();
FooLib_Export void ArrayOfShorts_init_i(::FACE::Short* begin);
FooLib_Export void ArrayOfShorts_fini_i(::FACE::Short* begin);
FooLib_Export void ArrayOfShorts_free(ArrayOfShorts_slice* slice);
FooLib_Export ArrayOfShorts_slice* ArrayOfShorts_dup(const ArrayOfShorts_slice* slice);
FooLib_Export void ArrayOfShorts_copy(ArrayOfShorts_slice* dst, const ArrayOfShorts_slice* src);

inline ACE_CDR::Boolean operator<<(ACE_OutputCDR &, const ArrayOfShorts_forany&) { return true; }

inline ACE_CDR::Boolean operator>>(ACE_InputCDR &, ArrayOfShorts_forany&) { return true; }

}
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace TAO {
template <>
struct FooLib_Export Array_Traits<Xyz::ArrayOfShorts_forany>
{
  static void free(Xyz::ArrayOfShorts_slice* slice)
  {
    Xyz::ArrayOfShorts_free(slice);
  }

  static Xyz::ArrayOfShorts_slice* dup(const Xyz::ArrayOfShorts_slice* slice)
  {
    return Xyz::ArrayOfShorts_dup(slice);
  }

  static void copy(Xyz::ArrayOfShorts_slice* dst, const Xyz::ArrayOfShorts_slice* src)
  {
    Xyz::ArrayOfShorts_copy(dst, src);
  }

  static Xyz::ArrayOfShorts_slice* alloc()
  {
    return Xyz::ArrayOfShorts_alloc();
  }

  static void zero(Xyz::ArrayOfShorts_slice* slice)
  {
    Xyz::ArrayOfShorts_fini_i(slice);
    Xyz::ArrayOfShorts_init_i(slice);
  }
  static void construct(Xyz::ArrayOfShorts_slice* slice)
  {
    Xyz::ArrayOfShorts_init_i(slice);
  }
  static void destroy(Xyz::ArrayOfShorts_slice* slice)
  {
    Xyz::ArrayOfShorts_fini_i(slice);
  }
};
}
TAO_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ArrayOfShorts */


/* Begin TYPEDEF: ArrayOfShorts2 */

namespace Xyz {
typedef ::FACE::Short ArrayOfShorts2[3];
typedef ::FACE::Short ArrayOfShorts2_slice;
struct ArrayOfShorts2_tag {};
typedef ::TAO_FixedArray_Var_T<ArrayOfShorts2, ArrayOfShorts2_slice, ArrayOfShorts2_tag> ArrayOfShorts2_var;
typedef ArrayOfShorts2 ArrayOfShorts2_out;
typedef ::TAO_Array_Forany_T<ArrayOfShorts2, ArrayOfShorts2_slice, ArrayOfShorts2_tag> ArrayOfShorts2_forany;

FooLib_Export ArrayOfShorts2_slice* ArrayOfShorts2_alloc();
FooLib_Export void ArrayOfShorts2_init_i(::FACE::Short* begin);
FooLib_Export void ArrayOfShorts2_fini_i(::FACE::Short* begin);
FooLib_Export void ArrayOfShorts2_free(ArrayOfShorts2_slice* slice);
FooLib_Export ArrayOfShorts2_slice* ArrayOfShorts2_dup(const ArrayOfShorts2_slice* slice);
FooLib_Export void ArrayOfShorts2_copy(ArrayOfShorts2_slice* dst, const ArrayOfShorts2_slice* src);

inline ACE_CDR::Boolean operator<<(ACE_OutputCDR &, const ArrayOfShorts2_forany&) { return true; }

inline ACE_CDR::Boolean operator>>(ACE_InputCDR &, ArrayOfShorts2_forany&) { return true; }

}
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace TAO {
template <>
struct FooLib_Export Array_Traits<Xyz::ArrayOfShorts2_forany>
{
  static void free(Xyz::ArrayOfShorts2_slice* slice)
  {
    Xyz::ArrayOfShorts2_free(slice);
  }

  static Xyz::ArrayOfShorts2_slice* dup(const Xyz::ArrayOfShorts2_slice* slice)
  {
    return Xyz::ArrayOfShorts2_dup(slice);
  }

  static void copy(Xyz::ArrayOfShorts2_slice* dst, const Xyz::ArrayOfShorts2_slice* src)
  {
    Xyz::ArrayOfShorts2_copy(dst, src);
  }

  static Xyz::ArrayOfShorts2_slice* alloc()
  {
    return Xyz::ArrayOfShorts2_alloc();
  }

  static void zero(Xyz::ArrayOfShorts2_slice* slice)
  {
    Xyz::ArrayOfShorts2_fini_i(slice);
    Xyz::ArrayOfShorts2_init_i(slice);
  }
  static void construct(Xyz::ArrayOfShorts2_slice* slice)
  {
    Xyz::ArrayOfShorts2_init_i(slice);
  }
  static void destroy(Xyz::ArrayOfShorts2_slice* slice)
  {
    Xyz::ArrayOfShorts2_fini_i(slice);
  }
};
}
TAO_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ArrayOfShorts2 */


/* Begin TYPEDEF: MultiDimArray */

namespace Xyz {
typedef ::OpenDDS::FaceTypes::String_mgr MultiDimArray[2][3][4][5];
typedef ::OpenDDS::FaceTypes::String_mgr MultiDimArray_slice[3][4][5];
struct MultiDimArray_tag {};
typedef ::TAO_VarArray_Var_T<MultiDimArray, MultiDimArray_slice, MultiDimArray_tag> MultiDimArray_var;
typedef ::TAO_Array_Out_T<MultiDimArray, MultiDimArray_var, MultiDimArray_slice, MultiDimArray_tag> MultiDimArray_out;
typedef ::TAO_Array_Forany_T<MultiDimArray, MultiDimArray_slice, MultiDimArray_tag> MultiDimArray_forany;

FooLib_Export MultiDimArray_slice* MultiDimArray_alloc();
FooLib_Export void MultiDimArray_init_i(::OpenDDS::FaceTypes::String_mgr* begin);
FooLib_Export void MultiDimArray_fini_i(::OpenDDS::FaceTypes::String_mgr* begin);
FooLib_Export void MultiDimArray_free(MultiDimArray_slice* slice);
FooLib_Export MultiDimArray_slice* MultiDimArray_dup(const MultiDimArray_slice* slice);
FooLib_Export void MultiDimArray_copy(MultiDimArray_slice* dst, const MultiDimArray_slice* src);

inline ACE_CDR::Boolean operator<<(ACE_OutputCDR &, const MultiDimArray_forany&) { return true; }

inline ACE_CDR::Boolean operator>>(ACE_InputCDR &, MultiDimArray_forany&) { return true; }

}
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace TAO {
template <>
struct FooLib_Export Array_Traits<Xyz::MultiDimArray_forany>
{
  static void free(Xyz::MultiDimArray_slice* slice)
  {
    Xyz::MultiDimArray_free(slice);
  }

  static Xyz::MultiDimArray_slice* dup(const Xyz::MultiDimArray_slice* slice)
  {
    return Xyz::MultiDimArray_dup(slice);
  }

  static void copy(Xyz::MultiDimArray_slice* dst, const Xyz::MultiDimArray_slice* src)
  {
    Xyz::MultiDimArray_copy(dst, src);
  }

  static Xyz::MultiDimArray_slice* alloc()
  {
    return Xyz::MultiDimArray_alloc();
  }

  static void zero(Xyz::MultiDimArray_slice* slice)
  {
    Xyz::MultiDimArray_fini_i(slice[0][0][0]);
    Xyz::MultiDimArray_init_i(slice[0][0][0]);
  }
  static void construct(Xyz::MultiDimArray_slice* slice)
  {
    Xyz::MultiDimArray_init_i(slice[0][0][0]);
  }
  static void destroy(Xyz::MultiDimArray_slice* slice)
  {
    Xyz::MultiDimArray_fini_i(slice[0][0][0]);
  }
};
}
TAO_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: MultiDimArray */


/* Begin STRUCT: StructOfMultiDimArray */

namespace Xyz {
struct StructOfMultiDimArray;
typedef ::TAO_Var_Var_T<StructOfMultiDimArray> StructOfMultiDimArray_var;
typedef ::TAO_Out_T<StructOfMultiDimArray> StructOfMultiDimArray_out;

struct FooLib_Export StructOfMultiDimArray
{
  typedef StructOfMultiDimArray_var _var_type;
  typedef StructOfMultiDimArray_out _out_type;

  Xyz::MultiDimArray mda;

  bool operator==(const StructOfMultiDimArray& rhs) const;
  bool operator!=(const StructOfMultiDimArray& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
};

FooLib_Export void swap(StructOfMultiDimArray& lhs, StructOfMultiDimArray& rhs);

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const StructOfMultiDimArray& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, StructOfMultiDimArray& x);

}

/* End STRUCT: StructOfMultiDimArray */


/* Begin TYPEDEF: ArrayOfArrayOfShorts2 */

namespace Xyz {
typedef Xyz::ArrayOfShorts2 ArrayOfArrayOfShorts2[3];
typedef Xyz::ArrayOfShorts2 ArrayOfArrayOfShorts2_slice;
struct ArrayOfArrayOfShorts2_tag {};
typedef ::TAO_FixedArray_Var_T<ArrayOfArrayOfShorts2, ArrayOfArrayOfShorts2_slice, ArrayOfArrayOfShorts2_tag> ArrayOfArrayOfShorts2_var;
typedef ArrayOfArrayOfShorts2 ArrayOfArrayOfShorts2_out;
typedef ::TAO_Array_Forany_T<ArrayOfArrayOfShorts2, ArrayOfArrayOfShorts2_slice, ArrayOfArrayOfShorts2_tag> ArrayOfArrayOfShorts2_forany;

FooLib_Export ArrayOfArrayOfShorts2_slice* ArrayOfArrayOfShorts2_alloc();
FooLib_Export void ArrayOfArrayOfShorts2_init_i(Xyz::ArrayOfShorts2* begin);
FooLib_Export void ArrayOfArrayOfShorts2_fini_i(Xyz::ArrayOfShorts2* begin);
FooLib_Export void ArrayOfArrayOfShorts2_free(ArrayOfArrayOfShorts2_slice* slice);
FooLib_Export ArrayOfArrayOfShorts2_slice* ArrayOfArrayOfShorts2_dup(const ArrayOfArrayOfShorts2_slice* slice);
FooLib_Export void ArrayOfArrayOfShorts2_copy(ArrayOfArrayOfShorts2_slice* dst, const ArrayOfArrayOfShorts2_slice* src);

inline ACE_CDR::Boolean operator<<(ACE_OutputCDR &, const ArrayOfArrayOfShorts2_forany&) { return true; }

inline ACE_CDR::Boolean operator>>(ACE_InputCDR &, ArrayOfArrayOfShorts2_forany&) { return true; }

}
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace TAO {
template <>
struct FooLib_Export Array_Traits<Xyz::ArrayOfArrayOfShorts2_forany>
{
  static void free(Xyz::ArrayOfArrayOfShorts2_slice* slice)
  {
    Xyz::ArrayOfArrayOfShorts2_free(slice);
  }

  static Xyz::ArrayOfArrayOfShorts2_slice* dup(const Xyz::ArrayOfArrayOfShorts2_slice* slice)
  {
    return Xyz::ArrayOfArrayOfShorts2_dup(slice);
  }

  static void copy(Xyz::ArrayOfArrayOfShorts2_slice* dst, const Xyz::ArrayOfArrayOfShorts2_slice* src)
  {
    Xyz::ArrayOfArrayOfShorts2_copy(dst, src);
  }

  static Xyz::ArrayOfArrayOfShorts2_slice* alloc()
  {
    return Xyz::ArrayOfArrayOfShorts2_alloc();
  }

  static void zero(Xyz::ArrayOfArrayOfShorts2_slice* slice)
  {
    Xyz::ArrayOfArrayOfShorts2_fini_i(slice);
    Xyz::ArrayOfArrayOfShorts2_init_i(slice);
  }
  static void construct(Xyz::ArrayOfArrayOfShorts2_slice* slice)
  {
    Xyz::ArrayOfArrayOfShorts2_init_i(slice);
  }
  static void destroy(Xyz::ArrayOfArrayOfShorts2_slice* slice)
  {
    Xyz::ArrayOfArrayOfShorts2_fini_i(slice);
  }
};
}
TAO_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ArrayOfArrayOfShorts2 */


/* Begin STRUCT: StructOfArrayOfArrayOfShorts2 */

namespace Xyz {
struct StructOfArrayOfArrayOfShorts2;
typedef ::TAO_Fixed_Var_T<StructOfArrayOfArrayOfShorts2> StructOfArrayOfArrayOfShorts2_var;
typedef StructOfArrayOfArrayOfShorts2& StructOfArrayOfArrayOfShorts2_out;

struct FooLib_Export StructOfArrayOfArrayOfShorts2
{
  typedef StructOfArrayOfArrayOfShorts2_var _var_type;
  typedef StructOfArrayOfArrayOfShorts2_out _out_type;

  Xyz::ArrayOfArrayOfShorts2 f1;

  bool operator==(const StructOfArrayOfArrayOfShorts2& rhs) const;
  bool operator!=(const StructOfArrayOfArrayOfShorts2& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
};

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const StructOfArrayOfArrayOfShorts2& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, StructOfArrayOfArrayOfShorts2& x);

}

/* End STRUCT: StructOfArrayOfArrayOfShorts2 */


/* Begin ENUM: ColorX */

namespace Xyz {
enum ColorX {
  redx,
  greenx,
  bluex
};

typedef ColorX& ColorX_out;
}

/* End ENUM: ColorX */


/* Begin CONST: c15 */

namespace Xyz {
const Xyz::ColorX c15 = greenx;
}

/* End CONST: c15 */


/* Begin TYPEDEF: UShortSeq */

namespace Xyz {
class UShortSeq;
typedef ::OpenDDS::FaceTypes::SequenceVar<UShortSeq> UShortSeq_var;
typedef ::TAO_Seq_Out_T<UShortSeq> UShortSeq_out;

class FooLib_Export UShortSeq : public ::OpenDDS::FaceTypes::Sequence< ::FACE::UnsignedShort, ::OpenDDS::FaceTypes::Bounded<3> > {
public:
  typedef UShortSeq_var _var_type;
  typedef UShortSeq_out _out_type;

  UShortSeq() {}
  UShortSeq(const UShortSeq& seq) : ::OpenDDS::FaceTypes::Sequence< ::FACE::UnsignedShort, ::OpenDDS::FaceTypes::Bounded<3> >(seq) {}
  friend void swap(UShortSeq& a, UShortSeq& b) { a.swap(b); }
  UShortSeq& operator=(const UShortSeq& rhs)
  {
    UShortSeq tmp(rhs);
    swap(tmp);
    return *this;
  }
  UShortSeq(::FACE::UnsignedLong length, ::FACE::UnsignedShort* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< ::FACE::UnsignedShort, ::OpenDDS::FaceTypes::Bounded<3> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const UShortSeq&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, UShortSeq&) { return true; }

}

/* End TYPEDEF: UShortSeq */


/* Begin TYPEDEF: ArrayOfShortsSeq */

namespace Xyz {
class ArrayOfShortsSeq;
typedef ::OpenDDS::FaceTypes::SequenceVar<ArrayOfShortsSeq> ArrayOfShortsSeq_var;
typedef ::TAO_Seq_Out_T<ArrayOfShortsSeq> ArrayOfShortsSeq_out;

class FooLib_Export ArrayOfShortsSeq : public ::OpenDDS::FaceTypes::Sequence< Xyz::ArrayOfShorts, ::OpenDDS::FaceTypes::Unbounded, ::OpenDDS::FaceTypes::ArrayEltPolicy<Xyz::ArrayOfShorts_forany> > {
public:
  typedef ArrayOfShortsSeq_var _var_type;
  typedef ArrayOfShortsSeq_out _out_type;

  ArrayOfShortsSeq() {}
  ArrayOfShortsSeq(const ArrayOfShortsSeq& seq) : ::OpenDDS::FaceTypes::Sequence< Xyz::ArrayOfShorts, ::OpenDDS::FaceTypes::Unbounded, ::OpenDDS::FaceTypes::ArrayEltPolicy<Xyz::ArrayOfShorts_forany> >(seq) {}
  friend void swap(ArrayOfShortsSeq& a, ArrayOfShortsSeq& b) { a.swap(b); }
  ArrayOfShortsSeq& operator=(const ArrayOfShortsSeq& rhs)
  {
    ArrayOfShortsSeq tmp(rhs);
    swap(tmp);
    return *this;
  }
  ArrayOfShortsSeq(::FACE::UnsignedLong maximum)
    : ::OpenDDS::FaceTypes::Sequence< Xyz::ArrayOfShorts, ::OpenDDS::FaceTypes::Unbounded, ::OpenDDS::FaceTypes::ArrayEltPolicy<Xyz::ArrayOfShorts_forany> >(maximum, 0u, 0, true) {}
  ArrayOfShortsSeq(::FACE::UnsignedLong maximum, ::FACE::UnsignedLong length, Xyz::ArrayOfShorts* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< Xyz::ArrayOfShorts, ::OpenDDS::FaceTypes::Unbounded, ::OpenDDS::FaceTypes::ArrayEltPolicy<Xyz::ArrayOfShorts_forany> >(maximum, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const ArrayOfShortsSeq&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, ArrayOfShortsSeq&) { return true; }

}

/* End TYPEDEF: ArrayOfShortsSeq */


/* Begin TYPEDEF: ShortSeq */

namespace Xyz {
class ShortSeq;
typedef ::OpenDDS::FaceTypes::SequenceVar<ShortSeq> ShortSeq_var;
typedef ::TAO_Seq_Out_T<ShortSeq> ShortSeq_out;

class FooLib_Export ShortSeq : public ::OpenDDS::FaceTypes::Sequence< ::FACE::Short, ::OpenDDS::FaceTypes::Unbounded > {
public:
  typedef ShortSeq_var _var_type;
  typedef ShortSeq_out _out_type;

  ShortSeq() {}
  ShortSeq(const ShortSeq& seq) : ::OpenDDS::FaceTypes::Sequence< ::FACE::Short, ::OpenDDS::FaceTypes::Unbounded >(seq) {}
  friend void swap(ShortSeq& a, ShortSeq& b) { a.swap(b); }
  ShortSeq& operator=(const ShortSeq& rhs)
  {
    ShortSeq tmp(rhs);
    swap(tmp);
    return *this;
  }
  ShortSeq(::FACE::UnsignedLong maximum)
    : ::OpenDDS::FaceTypes::Sequence< ::FACE::Short, ::OpenDDS::FaceTypes::Unbounded >(maximum, 0u, 0, true) {}
  ShortSeq(::FACE::UnsignedLong maximum, ::FACE::UnsignedLong length, ::FACE::Short* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< ::FACE::Short, ::OpenDDS::FaceTypes::Unbounded >(maximum, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const ShortSeq&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, ShortSeq&) { return true; }

}

/* End TYPEDEF: ShortSeq */


/* Begin STRUCT: AStruct */

namespace Xyz {
struct AStruct;
typedef ::TAO_Var_Var_T<AStruct> AStruct_var;
typedef ::TAO_Out_T<AStruct> AStruct_out;

struct FooLib_Export AStruct
{
  typedef AStruct_var _var_type;
  typedef AStruct_out _out_type;

  ::FACE::Long v1;
  Xyz::ShortSeq v2s;

  bool operator==(const AStruct& rhs) const;
  bool operator!=(const AStruct& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
};

FooLib_Export void swap(AStruct& lhs, AStruct& rhs);

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const AStruct& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, AStruct& x);

}

/* End STRUCT: AStruct */


/* Begin TYPEDEF: ArrayOfAStruct */

namespace Xyz {
typedef Xyz::AStruct ArrayOfAStruct[3];
typedef Xyz::AStruct ArrayOfAStruct_slice;
struct ArrayOfAStruct_tag {};
typedef ::TAO_VarArray_Var_T<ArrayOfAStruct, ArrayOfAStruct_slice, ArrayOfAStruct_tag> ArrayOfAStruct_var;
typedef ::TAO_Array_Out_T<ArrayOfAStruct, ArrayOfAStruct_var, ArrayOfAStruct_slice, ArrayOfAStruct_tag> ArrayOfAStruct_out;
typedef ::TAO_Array_Forany_T<ArrayOfAStruct, ArrayOfAStruct_slice, ArrayOfAStruct_tag> ArrayOfAStruct_forany;

FooLib_Export ArrayOfAStruct_slice* ArrayOfAStruct_alloc();
FooLib_Export void ArrayOfAStruct_init_i(Xyz::AStruct* begin);
FooLib_Export void ArrayOfAStruct_fini_i(Xyz::AStruct* begin);
FooLib_Export void ArrayOfAStruct_free(ArrayOfAStruct_slice* slice);
FooLib_Export ArrayOfAStruct_slice* ArrayOfAStruct_dup(const ArrayOfAStruct_slice* slice);
FooLib_Export void ArrayOfAStruct_copy(ArrayOfAStruct_slice* dst, const ArrayOfAStruct_slice* src);

inline ACE_CDR::Boolean operator<<(ACE_OutputCDR &, const ArrayOfAStruct_forany&) { return true; }

inline ACE_CDR::Boolean operator>>(ACE_InputCDR &, ArrayOfAStruct_forany&) { return true; }

}
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace TAO {
template <>
struct FooLib_Export Array_Traits<Xyz::ArrayOfAStruct_forany>
{
  static void free(Xyz::ArrayOfAStruct_slice* slice)
  {
    Xyz::ArrayOfAStruct_free(slice);
  }

  static Xyz::ArrayOfAStruct_slice* dup(const Xyz::ArrayOfAStruct_slice* slice)
  {
    return Xyz::ArrayOfAStruct_dup(slice);
  }

  static void copy(Xyz::ArrayOfAStruct_slice* dst, const Xyz::ArrayOfAStruct_slice* src)
  {
    Xyz::ArrayOfAStruct_copy(dst, src);
  }

  static Xyz::ArrayOfAStruct_slice* alloc()
  {
    return Xyz::ArrayOfAStruct_alloc();
  }

  static void zero(Xyz::ArrayOfAStruct_slice* slice)
  {
    Xyz::ArrayOfAStruct_fini_i(slice);
    Xyz::ArrayOfAStruct_init_i(slice);
  }
  static void construct(Xyz::ArrayOfAStruct_slice* slice)
  {
    Xyz::ArrayOfAStruct_init_i(slice);
  }
  static void destroy(Xyz::ArrayOfAStruct_slice* slice)
  {
    Xyz::ArrayOfAStruct_fini_i(slice);
  }
};
}
TAO_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ArrayOfAStruct */


/* Begin STRUCT: StructContainingArrayOfAStruct */

namespace Xyz {
struct StructContainingArrayOfAStruct;
typedef ::TAO_Var_Var_T<StructContainingArrayOfAStruct> StructContainingArrayOfAStruct_var;
typedef ::TAO_Out_T<StructContainingArrayOfAStruct> StructContainingArrayOfAStruct_out;

struct FooLib_Export StructContainingArrayOfAStruct
{
  typedef StructContainingArrayOfAStruct_var _var_type;
  typedef StructContainingArrayOfAStruct_out _out_type;

  Xyz::ArrayOfAStruct f1;

  bool operator==(const StructContainingArrayOfAStruct& rhs) const;
  bool operator!=(const StructContainingArrayOfAStruct& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
};

FooLib_Export void swap(StructContainingArrayOfAStruct& lhs, StructContainingArrayOfAStruct& rhs);

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const StructContainingArrayOfAStruct& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, StructContainingArrayOfAStruct& x);

}

/* End STRUCT: StructContainingArrayOfAStruct */


/* Begin UNION: AUnion */

namespace Xyz {
class AUnion;
typedef ::TAO_Var_Var_T<AUnion> AUnion_var;
typedef ::TAO_Out_T<AUnion> AUnion_out;

class FooLib_Export AUnion 
{
 public:
  typedef AUnion_var _var_type;
  typedef AUnion_out _out_type;
  AUnion();
  AUnion(const AUnion&);
  ~AUnion() { _reset(); };
  AUnion& operator=(const AUnion&);
  void _d(Xyz::ColorX d) { _discriminator = d; }
  Xyz::ColorX _d() const { return _discriminator; }
  void rsv (::FACE::Char* x) {
    _reset();
    this->_u.rsv = x;
    _discriminator = Xyz::redx;
  }
  void rsv (const ::FACE::Char* x) {
    _reset();
    this->_u.rsv = ::CORBA::string_dup(x);
    _discriminator = Xyz::redx;
  }
  void rsv (const ::FACE::String_var& x) {
    _reset();
    this->_u.rsv = ::CORBA::string_dup(x.in());
    _discriminator = Xyz::redx;
  }
  const ::FACE::Char* rsv () const {
    return this->_u.rsv;
  }
  void gsv (const Xyz::AStruct& x) {
    _reset();
    this->_u.gsv = new Xyz::AStruct(x);
    _discriminator = Xyz::greenx;
  }
  const Xyz::AStruct& gsv () const {
    return *this->_u.gsv;
  }
  Xyz::AStruct& gsv () {
    return *this->_u.gsv;
  }
  void usv (::FACE::UnsignedShort x) {
    _reset();
    this->_u.usv = x;
    _discriminator = Xyz::bluex;
  }
  ::FACE::UnsignedShort usv () const {
    return this->_u.usv;
  }
  bool operator==(const AUnion& rhs) const;
  bool operator!=(const AUnion& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
 private:
  Xyz::ColorX _discriminator;
  union {
    ::FACE::Char* rsv;
    Xyz::AStruct* gsv;
    ::FACE::UnsignedShort usv;
  } _u;
  void _reset();
};

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const AUnion& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, AUnion& x);

}

/* End UNION: AUnion */


/* Begin STRUCT: StructAUnion */

namespace Xyz {
struct StructAUnion;
typedef ::TAO_Var_Var_T<StructAUnion> StructAUnion_var;
typedef ::TAO_Out_T<StructAUnion> StructAUnion_out;

struct FooLib_Export StructAUnion
{
  typedef StructAUnion_var _var_type;
  typedef StructAUnion_out _out_type;

  Xyz::AUnion sau_f1;

  bool operator==(const StructAUnion& rhs) const;
  bool operator!=(const StructAUnion& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
};

FooLib_Export void swap(StructAUnion& lhs, StructAUnion& rhs);

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const StructAUnion& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, StructAUnion& x);

}

/* End STRUCT: StructAUnion */


/* Begin TYPEDEF: AUnionSeq */

namespace Xyz {
class AUnionSeq;
typedef ::OpenDDS::FaceTypes::SequenceVar<AUnionSeq> AUnionSeq_var;
typedef ::TAO_Seq_Out_T<AUnionSeq> AUnionSeq_out;

class FooLib_Export AUnionSeq : public ::OpenDDS::FaceTypes::Sequence< Xyz::AUnion, ::OpenDDS::FaceTypes::Bounded<3>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::AUnion> > {
public:
  typedef AUnionSeq_var _var_type;
  typedef AUnionSeq_out _out_type;

  AUnionSeq() {}
  AUnionSeq(const AUnionSeq& seq) : ::OpenDDS::FaceTypes::Sequence< Xyz::AUnion, ::OpenDDS::FaceTypes::Bounded<3>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::AUnion> >(seq) {}
  friend void swap(AUnionSeq& a, AUnionSeq& b) { a.swap(b); }
  AUnionSeq& operator=(const AUnionSeq& rhs)
  {
    AUnionSeq tmp(rhs);
    swap(tmp);
    return *this;
  }
  AUnionSeq(::FACE::UnsignedLong length, Xyz::AUnion* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< Xyz::AUnion, ::OpenDDS::FaceTypes::Bounded<3>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::AUnion> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const AUnionSeq&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, AUnionSeq&) { return true; }

}

/* End TYPEDEF: AUnionSeq */


/* Begin TYPEDEF: AcharSeq */

namespace Xyz {
class AcharSeq;
typedef ::OpenDDS::FaceTypes::SequenceVar<AcharSeq> AcharSeq_var;
typedef ::TAO_Seq_Out_T<AcharSeq> AcharSeq_out;

class FooLib_Export AcharSeq : public ::OpenDDS::FaceTypes::Sequence< ::FACE::Char, ::OpenDDS::FaceTypes::Bounded<2> > {
public:
  typedef AcharSeq_var _var_type;
  typedef AcharSeq_out _out_type;

  AcharSeq() {}
  AcharSeq(const AcharSeq& seq) : ::OpenDDS::FaceTypes::Sequence< ::FACE::Char, ::OpenDDS::FaceTypes::Bounded<2> >(seq) {}
  friend void swap(AcharSeq& a, AcharSeq& b) { a.swap(b); }
  AcharSeq& operator=(const AcharSeq& rhs)
  {
    AcharSeq tmp(rhs);
    swap(tmp);
    return *this;
  }
  AcharSeq(::FACE::UnsignedLong length, ::FACE::Char* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< ::FACE::Char, ::OpenDDS::FaceTypes::Bounded<2> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const AcharSeq&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, AcharSeq&) { return true; }

}

/* End TYPEDEF: AcharSeq */


/* Begin TYPEDEF: AStringSeq */

namespace Xyz {
class AStringSeq;
typedef ::OpenDDS::FaceTypes::SequenceVar<AStringSeq> AStringSeq_var;
typedef ::TAO_Seq_Out_T<AStringSeq> AStringSeq_out;

class FooLib_Export AStringSeq : public ::OpenDDS::FaceTypes::Sequence< ::FACE::Char*, ::OpenDDS::FaceTypes::Bounded<4>, ::OpenDDS::FaceTypes::StringEltPolicy< ::FACE::Char> > {
public:
  typedef AStringSeq_var _var_type;
  typedef AStringSeq_out _out_type;

  AStringSeq() {}
  AStringSeq(const AStringSeq& seq) : ::OpenDDS::FaceTypes::Sequence< ::FACE::Char*, ::OpenDDS::FaceTypes::Bounded<4>, ::OpenDDS::FaceTypes::StringEltPolicy< ::FACE::Char> >(seq) {}
  friend void swap(AStringSeq& a, AStringSeq& b) { a.swap(b); }
  AStringSeq& operator=(const AStringSeq& rhs)
  {
    AStringSeq tmp(rhs);
    swap(tmp);
    return *this;
  }
  AStringSeq(::FACE::UnsignedLong length, ::FACE::Char** data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< ::FACE::Char*, ::OpenDDS::FaceTypes::Bounded<4>, ::OpenDDS::FaceTypes::StringEltPolicy< ::FACE::Char> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const AStringSeq&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, AStringSeq&) { return true; }

}

/* End TYPEDEF: AStringSeq */


/* Begin TYPEDEF: AcharSeqSeq */

namespace Xyz {
class AcharSeqSeq;
typedef ::OpenDDS::FaceTypes::SequenceVar<AcharSeqSeq> AcharSeqSeq_var;
typedef ::TAO_Seq_Out_T<AcharSeqSeq> AcharSeqSeq_out;

class FooLib_Export AcharSeqSeq : public ::OpenDDS::FaceTypes::Sequence< Xyz::AcharSeq, ::OpenDDS::FaceTypes::Unbounded, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::AcharSeq> > {
public:
  typedef AcharSeqSeq_var _var_type;
  typedef AcharSeqSeq_out _out_type;

  AcharSeqSeq() {}
  AcharSeqSeq(const AcharSeqSeq& seq) : ::OpenDDS::FaceTypes::Sequence< Xyz::AcharSeq, ::OpenDDS::FaceTypes::Unbounded, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::AcharSeq> >(seq) {}
  friend void swap(AcharSeqSeq& a, AcharSeqSeq& b) { a.swap(b); }
  AcharSeqSeq& operator=(const AcharSeqSeq& rhs)
  {
    AcharSeqSeq tmp(rhs);
    swap(tmp);
    return *this;
  }
  AcharSeqSeq(::FACE::UnsignedLong maximum)
    : ::OpenDDS::FaceTypes::Sequence< Xyz::AcharSeq, ::OpenDDS::FaceTypes::Unbounded, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::AcharSeq> >(maximum, 0u, 0, true) {}
  AcharSeqSeq(::FACE::UnsignedLong maximum, ::FACE::UnsignedLong length, Xyz::AcharSeq* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< Xyz::AcharSeq, ::OpenDDS::FaceTypes::Unbounded, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::AcharSeq> >(maximum, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const AcharSeqSeq&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, AcharSeqSeq&) { return true; }

}

/* End TYPEDEF: AcharSeqSeq */


/* Begin TYPEDEF: MyChar */

namespace Xyz {
typedef ::FACE::Char MyChar;
typedef ::FACE::Char_out MyChar_out;
}

/* End TYPEDEF: MyChar */


/* Begin TYPEDEF: AMyCharSeq */

namespace Xyz {
class AMyCharSeq;
typedef ::OpenDDS::FaceTypes::SequenceVar<AMyCharSeq> AMyCharSeq_var;
typedef ::TAO_Seq_Out_T<AMyCharSeq> AMyCharSeq_out;

class FooLib_Export AMyCharSeq : public ::OpenDDS::FaceTypes::Sequence< Xyz::MyChar, ::OpenDDS::FaceTypes::Bounded<5> > {
public:
  typedef AMyCharSeq_var _var_type;
  typedef AMyCharSeq_out _out_type;

  AMyCharSeq() {}
  AMyCharSeq(const AMyCharSeq& seq) : ::OpenDDS::FaceTypes::Sequence< Xyz::MyChar, ::OpenDDS::FaceTypes::Bounded<5> >(seq) {}
  friend void swap(AMyCharSeq& a, AMyCharSeq& b) { a.swap(b); }
  AMyCharSeq& operator=(const AMyCharSeq& rhs)
  {
    AMyCharSeq tmp(rhs);
    swap(tmp);
    return *this;
  }
  AMyCharSeq(::FACE::UnsignedLong length, Xyz::MyChar* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< Xyz::MyChar, ::OpenDDS::FaceTypes::Bounded<5> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const AMyCharSeq&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, AMyCharSeq&) { return true; }

}

/* End TYPEDEF: AMyCharSeq */


/* Begin TYPEDEF: BoundedString */

namespace Xyz {
typedef ::FACE::Char* BoundedString;
typedef ::FACE::String_var BoundedString_var;
typedef ::FACE::String_out BoundedString_out;
}

/* End TYPEDEF: BoundedString */


/* Begin TYPEDEF: UnboundedSeqOfBoundedString */

namespace Xyz {
class UnboundedSeqOfBoundedString;
typedef ::OpenDDS::FaceTypes::SequenceVar<UnboundedSeqOfBoundedString> UnboundedSeqOfBoundedString_var;
typedef ::TAO_Seq_Out_T<UnboundedSeqOfBoundedString> UnboundedSeqOfBoundedString_out;

class FooLib_Export UnboundedSeqOfBoundedString : public ::OpenDDS::FaceTypes::Sequence< Xyz::BoundedString, ::OpenDDS::FaceTypes::Unbounded, ::OpenDDS::FaceTypes::StringEltPolicy< ::FACE::Char> > {
public:
  typedef UnboundedSeqOfBoundedString_var _var_type;
  typedef UnboundedSeqOfBoundedString_out _out_type;

  UnboundedSeqOfBoundedString() {}
  UnboundedSeqOfBoundedString(const UnboundedSeqOfBoundedString& seq) : ::OpenDDS::FaceTypes::Sequence< Xyz::BoundedString, ::OpenDDS::FaceTypes::Unbounded, ::OpenDDS::FaceTypes::StringEltPolicy< ::FACE::Char> >(seq) {}
  friend void swap(UnboundedSeqOfBoundedString& a, UnboundedSeqOfBoundedString& b) { a.swap(b); }
  UnboundedSeqOfBoundedString& operator=(const UnboundedSeqOfBoundedString& rhs)
  {
    UnboundedSeqOfBoundedString tmp(rhs);
    swap(tmp);
    return *this;
  }
  UnboundedSeqOfBoundedString(::FACE::UnsignedLong maximum)
    : ::OpenDDS::FaceTypes::Sequence< Xyz::BoundedString, ::OpenDDS::FaceTypes::Unbounded, ::OpenDDS::FaceTypes::StringEltPolicy< ::FACE::Char> >(maximum, 0u, 0, true) {}
  UnboundedSeqOfBoundedString(::FACE::UnsignedLong maximum, ::FACE::UnsignedLong length, Xyz::BoundedString* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< Xyz::BoundedString, ::OpenDDS::FaceTypes::Unbounded, ::OpenDDS::FaceTypes::StringEltPolicy< ::FACE::Char> >(maximum, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const UnboundedSeqOfBoundedString&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, UnboundedSeqOfBoundedString&) { return true; }

}

/* End TYPEDEF: UnboundedSeqOfBoundedString */


/* Begin TYPEDEF: BoundedSeqOfBoundedString */

namespace Xyz {
class BoundedSeqOfBoundedString;
typedef ::OpenDDS::FaceTypes::SequenceVar<BoundedSeqOfBoundedString> BoundedSeqOfBoundedString_var;
typedef ::TAO_Seq_Out_T<BoundedSeqOfBoundedString> BoundedSeqOfBoundedString_out;

class FooLib_Export BoundedSeqOfBoundedString : public ::OpenDDS::FaceTypes::Sequence< Xyz::BoundedString, ::OpenDDS::FaceTypes::Bounded<10>, ::OpenDDS::FaceTypes::StringEltPolicy< ::FACE::Char> > {
public:
  typedef BoundedSeqOfBoundedString_var _var_type;
  typedef BoundedSeqOfBoundedString_out _out_type;

  BoundedSeqOfBoundedString() {}
  BoundedSeqOfBoundedString(const BoundedSeqOfBoundedString& seq) : ::OpenDDS::FaceTypes::Sequence< Xyz::BoundedString, ::OpenDDS::FaceTypes::Bounded<10>, ::OpenDDS::FaceTypes::StringEltPolicy< ::FACE::Char> >(seq) {}
  friend void swap(BoundedSeqOfBoundedString& a, BoundedSeqOfBoundedString& b) { a.swap(b); }
  BoundedSeqOfBoundedString& operator=(const BoundedSeqOfBoundedString& rhs)
  {
    BoundedSeqOfBoundedString tmp(rhs);
    swap(tmp);
    return *this;
  }
  BoundedSeqOfBoundedString(::FACE::UnsignedLong length, Xyz::BoundedString* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< Xyz::BoundedString, ::OpenDDS::FaceTypes::Bounded<10>, ::OpenDDS::FaceTypes::StringEltPolicy< ::FACE::Char> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const BoundedSeqOfBoundedString&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, BoundedSeqOfBoundedString&) { return true; }

}

/* End TYPEDEF: BoundedSeqOfBoundedString */


/* Begin TYPEDEF: UnboundedSeqOfUnboundedString */

namespace Xyz {
class UnboundedSeqOfUnboundedString;
typedef ::OpenDDS::FaceTypes::SequenceVar<UnboundedSeqOfUnboundedString> UnboundedSeqOfUnboundedString_var;
typedef ::TAO_Seq_Out_T<UnboundedSeqOfUnboundedString> UnboundedSeqOfUnboundedString_out;

class FooLib_Export UnboundedSeqOfUnboundedString : public ::OpenDDS::FaceTypes::Sequence< ::FACE::Char*, ::OpenDDS::FaceTypes::Unbounded, ::OpenDDS::FaceTypes::StringEltPolicy< ::FACE::Char> > {
public:
  typedef UnboundedSeqOfUnboundedString_var _var_type;
  typedef UnboundedSeqOfUnboundedString_out _out_type;

  UnboundedSeqOfUnboundedString() {}
  UnboundedSeqOfUnboundedString(const UnboundedSeqOfUnboundedString& seq) : ::OpenDDS::FaceTypes::Sequence< ::FACE::Char*, ::OpenDDS::FaceTypes::Unbounded, ::OpenDDS::FaceTypes::StringEltPolicy< ::FACE::Char> >(seq) {}
  friend void swap(UnboundedSeqOfUnboundedString& a, UnboundedSeqOfUnboundedString& b) { a.swap(b); }
  UnboundedSeqOfUnboundedString& operator=(const UnboundedSeqOfUnboundedString& rhs)
  {
    UnboundedSeqOfUnboundedString tmp(rhs);
    swap(tmp);
    return *this;
  }
  UnboundedSeqOfUnboundedString(::FACE::UnsignedLong maximum)
    : ::OpenDDS::FaceTypes::Sequence< ::FACE::Char*, ::OpenDDS::FaceTypes::Unbounded, ::OpenDDS::FaceTypes::StringEltPolicy< ::FACE::Char> >(maximum, 0u, 0, true) {}
  UnboundedSeqOfUnboundedString(::FACE::UnsignedLong maximum, ::FACE::UnsignedLong length, ::FACE::Char** data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< ::FACE::Char*, ::OpenDDS::FaceTypes::Unbounded, ::OpenDDS::FaceTypes::StringEltPolicy< ::FACE::Char> >(maximum, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const UnboundedSeqOfUnboundedString&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, UnboundedSeqOfUnboundedString&) { return true; }

}

/* End TYPEDEF: UnboundedSeqOfUnboundedString */


/* Begin TYPEDEF: AStructSeqX */

namespace Xyz {
class AStructSeqX;
typedef ::OpenDDS::FaceTypes::SequenceVar<AStructSeqX> AStructSeqX_var;
typedef ::TAO_Seq_Out_T<AStructSeqX> AStructSeqX_out;

class FooLib_Export AStructSeqX : public ::OpenDDS::FaceTypes::Sequence< Xyz::AStruct, ::OpenDDS::FaceTypes::Bounded<3>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::AStruct> > {
public:
  typedef AStructSeqX_var _var_type;
  typedef AStructSeqX_out _out_type;

  AStructSeqX() {}
  AStructSeqX(const AStructSeqX& seq) : ::OpenDDS::FaceTypes::Sequence< Xyz::AStruct, ::OpenDDS::FaceTypes::Bounded<3>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::AStruct> >(seq) {}
  friend void swap(AStructSeqX& a, AStructSeqX& b) { a.swap(b); }
  AStructSeqX& operator=(const AStructSeqX& rhs)
  {
    AStructSeqX tmp(rhs);
    swap(tmp);
    return *this;
  }
  AStructSeqX(::FACE::UnsignedLong length, Xyz::AStruct* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< Xyz::AStruct, ::OpenDDS::FaceTypes::Bounded<3>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::AStruct> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const AStructSeqX&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, AStructSeqX&) { return true; }

}

/* End TYPEDEF: AStructSeqX */


/* Begin TYPEDEF: ArrayOfAStructSeq */

namespace Xyz {
typedef Xyz::AStructSeqX ArrayOfAStructSeq[3];
typedef Xyz::AStructSeqX ArrayOfAStructSeq_slice;
struct ArrayOfAStructSeq_tag {};
typedef ::TAO_VarArray_Var_T<ArrayOfAStructSeq, ArrayOfAStructSeq_slice, ArrayOfAStructSeq_tag> ArrayOfAStructSeq_var;
typedef ::TAO_Array_Out_T<ArrayOfAStructSeq, ArrayOfAStructSeq_var, ArrayOfAStructSeq_slice, ArrayOfAStructSeq_tag> ArrayOfAStructSeq_out;
typedef ::TAO_Array_Forany_T<ArrayOfAStructSeq, ArrayOfAStructSeq_slice, ArrayOfAStructSeq_tag> ArrayOfAStructSeq_forany;

FooLib_Export ArrayOfAStructSeq_slice* ArrayOfAStructSeq_alloc();
FooLib_Export void ArrayOfAStructSeq_init_i(Xyz::AStructSeqX* begin);
FooLib_Export void ArrayOfAStructSeq_fini_i(Xyz::AStructSeqX* begin);
FooLib_Export void ArrayOfAStructSeq_free(ArrayOfAStructSeq_slice* slice);
FooLib_Export ArrayOfAStructSeq_slice* ArrayOfAStructSeq_dup(const ArrayOfAStructSeq_slice* slice);
FooLib_Export void ArrayOfAStructSeq_copy(ArrayOfAStructSeq_slice* dst, const ArrayOfAStructSeq_slice* src);

inline ACE_CDR::Boolean operator<<(ACE_OutputCDR &, const ArrayOfAStructSeq_forany&) { return true; }

inline ACE_CDR::Boolean operator>>(ACE_InputCDR &, ArrayOfAStructSeq_forany&) { return true; }

}
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace TAO {
template <>
struct FooLib_Export Array_Traits<Xyz::ArrayOfAStructSeq_forany>
{
  static void free(Xyz::ArrayOfAStructSeq_slice* slice)
  {
    Xyz::ArrayOfAStructSeq_free(slice);
  }

  static Xyz::ArrayOfAStructSeq_slice* dup(const Xyz::ArrayOfAStructSeq_slice* slice)
  {
    return Xyz::ArrayOfAStructSeq_dup(slice);
  }

  static void copy(Xyz::ArrayOfAStructSeq_slice* dst, const Xyz::ArrayOfAStructSeq_slice* src)
  {
    Xyz::ArrayOfAStructSeq_copy(dst, src);
  }

  static Xyz::ArrayOfAStructSeq_slice* alloc()
  {
    return Xyz::ArrayOfAStructSeq_alloc();
  }

  static void zero(Xyz::ArrayOfAStructSeq_slice* slice)
  {
    Xyz::ArrayOfAStructSeq_fini_i(slice);
    Xyz::ArrayOfAStructSeq_init_i(slice);
  }
  static void construct(Xyz::ArrayOfAStructSeq_slice* slice)
  {
    Xyz::ArrayOfAStructSeq_init_i(slice);
  }
  static void destroy(Xyz::ArrayOfAStructSeq_slice* slice)
  {
    Xyz::ArrayOfAStructSeq_fini_i(slice);
  }
};
}
TAO_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ArrayOfAStructSeq */


/* Begin STRUCT: StructContainingArrayOfAStructSeq */

namespace Xyz {
struct StructContainingArrayOfAStructSeq;
typedef ::TAO_Var_Var_T<StructContainingArrayOfAStructSeq> StructContainingArrayOfAStructSeq_var;
typedef ::TAO_Out_T<StructContainingArrayOfAStructSeq> StructContainingArrayOfAStructSeq_out;

struct FooLib_Export StructContainingArrayOfAStructSeq
{
  typedef StructContainingArrayOfAStructSeq_var _var_type;
  typedef StructContainingArrayOfAStructSeq_out _out_type;

  Xyz::ArrayOfAStructSeq f1;

  bool operator==(const StructContainingArrayOfAStructSeq& rhs) const;
  bool operator!=(const StructContainingArrayOfAStructSeq& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
};

FooLib_Export void swap(StructContainingArrayOfAStructSeq& lhs, StructContainingArrayOfAStructSeq& rhs);

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const StructContainingArrayOfAStructSeq& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, StructContainingArrayOfAStructSeq& x);

}

/* End STRUCT: StructContainingArrayOfAStructSeq */


/* Begin TYPEDEF: OctetArray */

namespace Xyz {
typedef ::FACE::Octet OctetArray[3];
typedef ::FACE::Octet OctetArray_slice;
struct OctetArray_tag {};
typedef ::TAO_FixedArray_Var_T<OctetArray, OctetArray_slice, OctetArray_tag> OctetArray_var;
typedef OctetArray OctetArray_out;
typedef ::TAO_Array_Forany_T<OctetArray, OctetArray_slice, OctetArray_tag> OctetArray_forany;

FooLib_Export OctetArray_slice* OctetArray_alloc();
FooLib_Export void OctetArray_init_i(::FACE::Octet* begin);
FooLib_Export void OctetArray_fini_i(::FACE::Octet* begin);
FooLib_Export void OctetArray_free(OctetArray_slice* slice);
FooLib_Export OctetArray_slice* OctetArray_dup(const OctetArray_slice* slice);
FooLib_Export void OctetArray_copy(OctetArray_slice* dst, const OctetArray_slice* src);

inline ACE_CDR::Boolean operator<<(ACE_OutputCDR &, const OctetArray_forany&) { return true; }

inline ACE_CDR::Boolean operator>>(ACE_InputCDR &, OctetArray_forany&) { return true; }

}
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace TAO {
template <>
struct FooLib_Export Array_Traits<Xyz::OctetArray_forany>
{
  static void free(Xyz::OctetArray_slice* slice)
  {
    Xyz::OctetArray_free(slice);
  }

  static Xyz::OctetArray_slice* dup(const Xyz::OctetArray_slice* slice)
  {
    return Xyz::OctetArray_dup(slice);
  }

  static void copy(Xyz::OctetArray_slice* dst, const Xyz::OctetArray_slice* src)
  {
    Xyz::OctetArray_copy(dst, src);
  }

  static Xyz::OctetArray_slice* alloc()
  {
    return Xyz::OctetArray_alloc();
  }

  static void zero(Xyz::OctetArray_slice* slice)
  {
    Xyz::OctetArray_fini_i(slice);
    Xyz::OctetArray_init_i(slice);
  }
  static void construct(Xyz::OctetArray_slice* slice)
  {
    Xyz::OctetArray_init_i(slice);
  }
  static void destroy(Xyz::OctetArray_slice* slice)
  {
    Xyz::OctetArray_fini_i(slice);
  }
};
}
TAO_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: OctetArray */


/* Begin STRUCT: Foo */

namespace Xyz {
struct Foo;
typedef ::TAO_Var_Var_T<Foo> Foo_var;
typedef ::TAO_Out_T<Foo> Foo_out;

struct FooLib_Export Foo
{
  typedef Foo_var _var_type;
  typedef Foo_out _out_type;

  ::FACE::Long key;
  ::FACE::Octet octer;
  Xyz::ColorX xcolor;
  Xyz::OctetArray ooo;
  Xyz::UShortSeq ushrtseq;
  Xyz::AStruct thestruct;
  Xyz::AStructSeqX theStructSeq;
  ::OpenDDS::FaceTypes::String_mgr theString;
  Xyz::ArrayOfAStruct structArray;
  ::FACE::Float x;
  ::FACE::Float y;
  Xyz::AUnion theUnion;

  bool operator==(const Foo& rhs) const;
  bool operator!=(const Foo& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
};

FooLib_Export void swap(Foo& lhs, Foo& rhs);

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const Foo& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, Foo& x);

}

/* End STRUCT: Foo */


/* Begin ENUM: TestEnum */

namespace Xyz {
enum TestEnum {
  TE_1,
  TE_2
};

typedef TestEnum& TestEnum_out;
}

/* End ENUM: TestEnum */


/* Begin TYPEDEF: TypedefTestEnum */

namespace Xyz {
typedef Xyz::TestEnum TypedefTestEnum;
typedef Xyz::TestEnum_out TypedefTestEnum_out;
}

/* End TYPEDEF: TypedefTestEnum */


/* Begin STRUCT: StructWithTypedefedEnum */

namespace Xyz {
struct StructWithTypedefedEnum;
typedef ::TAO_Fixed_Var_T<StructWithTypedefedEnum> StructWithTypedefedEnum_var;
typedef StructWithTypedefedEnum& StructWithTypedefedEnum_out;

struct FooLib_Export StructWithTypedefedEnum
{
  typedef StructWithTypedefedEnum_var _var_type;
  typedef StructWithTypedefedEnum_out _out_type;

  Xyz::TypedefTestEnum tte;

  bool operator==(const StructWithTypedefedEnum& rhs) const;
  bool operator!=(const StructWithTypedefedEnum& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
};

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const StructWithTypedefedEnum& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, StructWithTypedefedEnum& x);

}

/* End STRUCT: StructWithTypedefedEnum */


/* Begin UNION: TestUnion */

namespace Xyz {
class TestUnion;
typedef ::TAO_Fixed_Var_T<TestUnion> TestUnion_var;
typedef TestUnion& TestUnion_out;

class FooLib_Export TestUnion 
{
 public:
  typedef TestUnion_var _var_type;
  typedef TestUnion_out _out_type;
  TestUnion();
  TestUnion(const TestUnion&);
  ~TestUnion() { _reset(); };
  TestUnion& operator=(const TestUnion&);
  void _d(CORBA::Boolean d) { _discriminator = d; }
  CORBA::Boolean _d() const { return _discriminator; }
  void te (Xyz::TestEnum x) {
    _reset();
    this->_u.te = x;
    _discriminator = false;
  }
  Xyz::TestEnum te () const {
    return this->_u.te;
  }
  void swte (const Xyz::StructWithTypedefedEnum& x) {
    _reset();
    this->_u.swte = new Xyz::StructWithTypedefedEnum(x);
    _discriminator = true;
  }
  const Xyz::StructWithTypedefedEnum& swte () const {
    return *this->_u.swte;
  }
  Xyz::StructWithTypedefedEnum& swte () {
    return *this->_u.swte;
  }
  bool operator==(const TestUnion& rhs) const;
  bool operator!=(const TestUnion& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
 private:
  CORBA::Boolean _discriminator;
  union {
    Xyz::TestEnum te;
    Xyz::StructWithTypedefedEnum* swte;
  } _u;
  void _reset();
};

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const TestUnion& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, TestUnion& x);

}

/* End UNION: TestUnion */

/* End MODULE: Xyz */


/* Begin MODULE: N1 */



/* Begin STRUCT-FWD: FwdDeclStruct */

namespace N1 {
struct FwdDeclStruct;
/* Unknown size */
typedef ::TAO_Fixed_Var_T<FwdDeclStruct> FwdDeclStruct_var;
typedef FwdDeclStruct& FwdDeclStruct_out;
}

/* End STRUCT-FWD: FwdDeclStruct */

/* End MODULE: N1 */


/* Begin MODULE: N1 */



/* Begin TYPEDEF: FwdDeclSameNamespaceStructs */

namespace N1 {
class FwdDeclSameNamespaceStructs;
typedef ::OpenDDS::FaceTypes::SequenceVar<FwdDeclSameNamespaceStructs> FwdDeclSameNamespaceStructs_var;
typedef ::TAO_Seq_Out_T<FwdDeclSameNamespaceStructs> FwdDeclSameNamespaceStructs_out;

class FooLib_Export FwdDeclSameNamespaceStructs : public ::OpenDDS::FaceTypes::Sequence< N1::FwdDeclStruct, ::OpenDDS::FaceTypes::Unbounded > {
public:
  typedef FwdDeclSameNamespaceStructs_var _var_type;
  typedef FwdDeclSameNamespaceStructs_out _out_type;

  FwdDeclSameNamespaceStructs() {}
  FwdDeclSameNamespaceStructs(const FwdDeclSameNamespaceStructs& seq) : ::OpenDDS::FaceTypes::Sequence< N1::FwdDeclStruct, ::OpenDDS::FaceTypes::Unbounded >(seq) {}
  friend void swap(FwdDeclSameNamespaceStructs& a, FwdDeclSameNamespaceStructs& b) { a.swap(b); }
  FwdDeclSameNamespaceStructs& operator=(const FwdDeclSameNamespaceStructs& rhs)
  {
    FwdDeclSameNamespaceStructs tmp(rhs);
    swap(tmp);
    return *this;
  }
  FwdDeclSameNamespaceStructs(::FACE::UnsignedLong maximum)
    : ::OpenDDS::FaceTypes::Sequence< N1::FwdDeclStruct, ::OpenDDS::FaceTypes::Unbounded >(maximum, 0u, 0, true) {}
  FwdDeclSameNamespaceStructs(::FACE::UnsignedLong maximum, ::FACE::UnsignedLong length, N1::FwdDeclStruct* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< N1::FwdDeclStruct, ::OpenDDS::FaceTypes::Unbounded >(maximum, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const FwdDeclSameNamespaceStructs&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, FwdDeclSameNamespaceStructs&) { return true; }

}

/* End TYPEDEF: FwdDeclSameNamespaceStructs */

/* End MODULE: N1 */


/* Begin MODULE: N2 */



/* Begin TYPEDEF: FwdDeclDiffNamespaceStructs */

namespace N2 {
class FwdDeclDiffNamespaceStructs;
typedef ::OpenDDS::FaceTypes::SequenceVar<FwdDeclDiffNamespaceStructs> FwdDeclDiffNamespaceStructs_var;
typedef ::TAO_Seq_Out_T<FwdDeclDiffNamespaceStructs> FwdDeclDiffNamespaceStructs_out;

class FooLib_Export FwdDeclDiffNamespaceStructs : public ::OpenDDS::FaceTypes::Sequence< N1::FwdDeclStruct, ::OpenDDS::FaceTypes::Unbounded > {
public:
  typedef FwdDeclDiffNamespaceStructs_var _var_type;
  typedef FwdDeclDiffNamespaceStructs_out _out_type;

  FwdDeclDiffNamespaceStructs() {}
  FwdDeclDiffNamespaceStructs(const FwdDeclDiffNamespaceStructs& seq) : ::OpenDDS::FaceTypes::Sequence< N1::FwdDeclStruct, ::OpenDDS::FaceTypes::Unbounded >(seq) {}
  friend void swap(FwdDeclDiffNamespaceStructs& a, FwdDeclDiffNamespaceStructs& b) { a.swap(b); }
  FwdDeclDiffNamespaceStructs& operator=(const FwdDeclDiffNamespaceStructs& rhs)
  {
    FwdDeclDiffNamespaceStructs tmp(rhs);
    swap(tmp);
    return *this;
  }
  FwdDeclDiffNamespaceStructs(::FACE::UnsignedLong maximum)
    : ::OpenDDS::FaceTypes::Sequence< N1::FwdDeclStruct, ::OpenDDS::FaceTypes::Unbounded >(maximum, 0u, 0, true) {}
  FwdDeclDiffNamespaceStructs(::FACE::UnsignedLong maximum, ::FACE::UnsignedLong length, N1::FwdDeclStruct* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< N1::FwdDeclStruct, ::OpenDDS::FaceTypes::Unbounded >(maximum, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const FwdDeclDiffNamespaceStructs&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, FwdDeclDiffNamespaceStructs&) { return true; }

}

/* End TYPEDEF: FwdDeclDiffNamespaceStructs */

/* End MODULE: N2 */


/* Begin MODULE: N1 */



/* Begin STRUCT: FwdDeclStruct */

namespace N1 {
struct FwdDeclStruct;
typedef ::TAO_Fixed_Var_T<FwdDeclStruct> FwdDeclStruct_var;
typedef FwdDeclStruct& FwdDeclStruct_out;

struct FooLib_Export FwdDeclStruct
{
  typedef FwdDeclStruct_var _var_type;
  typedef FwdDeclStruct_out _out_type;

  ::FACE::Long v1;

  bool operator==(const FwdDeclStruct& rhs) const;
  bool operator!=(const FwdDeclStruct& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
};

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const FwdDeclStruct& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, FwdDeclStruct& x);

}

/* End STRUCT: FwdDeclStruct */

/* End MODULE: N1 */


/* Begin MODULE: N1 */



/* Begin TYPEDEF: FwdDeclSameNamespaceAfterDefStructs */

namespace N1 {
class FwdDeclSameNamespaceAfterDefStructs;
typedef ::OpenDDS::FaceTypes::SequenceVar<FwdDeclSameNamespaceAfterDefStructs> FwdDeclSameNamespaceAfterDefStructs_var;
typedef ::TAO_Seq_Out_T<FwdDeclSameNamespaceAfterDefStructs> FwdDeclSameNamespaceAfterDefStructs_out;

class FooLib_Export FwdDeclSameNamespaceAfterDefStructs : public ::OpenDDS::FaceTypes::Sequence< N1::FwdDeclStruct, ::OpenDDS::FaceTypes::Unbounded > {
public:
  typedef FwdDeclSameNamespaceAfterDefStructs_var _var_type;
  typedef FwdDeclSameNamespaceAfterDefStructs_out _out_type;

  FwdDeclSameNamespaceAfterDefStructs() {}
  FwdDeclSameNamespaceAfterDefStructs(const FwdDeclSameNamespaceAfterDefStructs& seq) : ::OpenDDS::FaceTypes::Sequence< N1::FwdDeclStruct, ::OpenDDS::FaceTypes::Unbounded >(seq) {}
  friend void swap(FwdDeclSameNamespaceAfterDefStructs& a, FwdDeclSameNamespaceAfterDefStructs& b) { a.swap(b); }
  FwdDeclSameNamespaceAfterDefStructs& operator=(const FwdDeclSameNamespaceAfterDefStructs& rhs)
  {
    FwdDeclSameNamespaceAfterDefStructs tmp(rhs);
    swap(tmp);
    return *this;
  }
  FwdDeclSameNamespaceAfterDefStructs(::FACE::UnsignedLong maximum)
    : ::OpenDDS::FaceTypes::Sequence< N1::FwdDeclStruct, ::OpenDDS::FaceTypes::Unbounded >(maximum, 0u, 0, true) {}
  FwdDeclSameNamespaceAfterDefStructs(::FACE::UnsignedLong maximum, ::FACE::UnsignedLong length, N1::FwdDeclStruct* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< N1::FwdDeclStruct, ::OpenDDS::FaceTypes::Unbounded >(maximum, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const FwdDeclSameNamespaceAfterDefStructs&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, FwdDeclSameNamespaceAfterDefStructs&) { return true; }

}

/* End TYPEDEF: FwdDeclSameNamespaceAfterDefStructs */

/* End MODULE: N1 */


/* Begin STRUCT: Bar */

struct Bar;
typedef ::TAO_Fixed_Var_T<Bar> Bar_var;
typedef Bar& Bar_out;

struct FooLib_Export Bar
{
  typedef Bar_var _var_type;
  typedef Bar_out _out_type;

  ::FACE::UnsignedLong data;

  bool operator==(const Bar& rhs) const;
  bool operator!=(const Bar& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
};

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const Bar& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, Bar& x);


/* End STRUCT: Bar */
#endif /* OPENDDS_IDL_GENERATED_FOODEFC_H_3FWEKY */
