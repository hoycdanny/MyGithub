/* -*- C++ -*- */
/* Generated by /Users/yc/MyGithub/imac-project/OpenDDS/OpenDDS-3.10/bin/opendds_idl version 3.10 (ACE version 6.2a_p11) running on input file Fixed.idl */
#ifndef OPENDDS_IDL_GENERATED_FIXEDC_H_QYOS4O
#define OPENDDS_IDL_GENERATED_FIXEDC_H_QYOS4O
#include <tao/orbconf.h>
#include <tao/Basic_Types.h>
#include <ace/CDR_Stream.h>
#include <tao/Array_VarOut_T.h>
#include <tao/Seq_Out_T.h>
#include <tao/VarOut_T.h>
#include "FACE/Fixed.h"
#include "FACE/Sequence.h"
#include "FACE/SequenceVar.h"
#include "FACE/StringManager.h"
#include "FACE/types.hpp"
#include "dds/DCPS/SafetyProfilePool.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: M1 */



/* Begin CONST: f1 */

namespace M1 {
const ::OpenDDS::FaceTypes::Fixed f1 = "81745891278902314890.23";
}

/* End CONST: f1 */


/* Begin TYPEDEF: Myfixed */

namespace M1 {
typedef ::OpenDDS::FaceTypes::Fixed_T<22u, 2u> Myfixed;
typedef Myfixed& Myfixed_out;
}

/* End TYPEDEF: Myfixed */


/* Begin TYPEDEF: FixedArray */

namespace M1 {
typedef M1::Myfixed FixedArray[3];
typedef M1::Myfixed FixedArray_slice;
struct FixedArray_tag {};
typedef ::TAO_FixedArray_Var_T<FixedArray, FixedArray_slice, FixedArray_tag> FixedArray_var;
typedef FixedArray FixedArray_out;
typedef ::TAO_Array_Forany_T<FixedArray, FixedArray_slice, FixedArray_tag> FixedArray_forany;

FixedArray_slice* FixedArray_alloc();
void FixedArray_init_i(M1::Myfixed* begin);
void FixedArray_fini_i(M1::Myfixed* begin);
void FixedArray_free(FixedArray_slice* slice);
FixedArray_slice* FixedArray_dup(const FixedArray_slice* slice);
void FixedArray_copy(FixedArray_slice* dst, const FixedArray_slice* src);

inline ACE_CDR::Boolean operator<<(ACE_OutputCDR &, const FixedArray_forany&) { return true; }

inline ACE_CDR::Boolean operator>>(ACE_InputCDR &, FixedArray_forany&) { return true; }

}
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace TAO {
template <>
struct Array_Traits<M1::FixedArray_forany>
{
  static void free(M1::FixedArray_slice* slice)
  {
    M1::FixedArray_free(slice);
  }

  static M1::FixedArray_slice* dup(const M1::FixedArray_slice* slice)
  {
    return M1::FixedArray_dup(slice);
  }

  static void copy(M1::FixedArray_slice* dst, const M1::FixedArray_slice* src)
  {
    M1::FixedArray_copy(dst, src);
  }

  static M1::FixedArray_slice* alloc()
  {
    return M1::FixedArray_alloc();
  }

  static void zero(M1::FixedArray_slice* slice)
  {
    M1::FixedArray_fini_i(slice);
    M1::FixedArray_init_i(slice);
  }
  static void construct(M1::FixedArray_slice* slice)
  {
    M1::FixedArray_init_i(slice);
  }
  static void destroy(M1::FixedArray_slice* slice)
  {
    M1::FixedArray_fini_i(slice);
  }
};
}
TAO_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: FixedArray */


/* Begin TYPEDEF: FixedSeq */

namespace M1 {
class FixedSeq;
typedef ::OpenDDS::FaceTypes::SequenceVar<FixedSeq> FixedSeq_var;
typedef ::TAO_Seq_Out_T<FixedSeq> FixedSeq_out;

class FixedSeq : public ::OpenDDS::FaceTypes::Sequence< M1::Myfixed, ::OpenDDS::FaceTypes::Unbounded > {
public:
  typedef FixedSeq_var _var_type;
  typedef FixedSeq_out _out_type;

  FixedSeq() {}
  FixedSeq(const FixedSeq& seq) : ::OpenDDS::FaceTypes::Sequence< M1::Myfixed, ::OpenDDS::FaceTypes::Unbounded >(seq) {}
  friend void swap(FixedSeq& a, FixedSeq& b) { a.swap(b); }
  FixedSeq& operator=(const FixedSeq& rhs)
  {
    FixedSeq tmp(rhs);
    swap(tmp);
    return *this;
  }
  FixedSeq(::FACE::UnsignedLong maximum)
    : ::OpenDDS::FaceTypes::Sequence< M1::Myfixed, ::OpenDDS::FaceTypes::Unbounded >(maximum, 0u, 0, true) {}
  FixedSeq(::FACE::UnsignedLong maximum, ::FACE::UnsignedLong length, M1::Myfixed* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< M1::Myfixed, ::OpenDDS::FaceTypes::Unbounded >(maximum, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const FixedSeq&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, FixedSeq&) { return true; }

}

/* End TYPEDEF: FixedSeq */


/* Begin STRUCT: S1 */

namespace M1 {
struct S1;
typedef ::TAO_Var_Var_T<S1> S1_var;
typedef ::TAO_Out_T<S1> S1_out;

struct S1
{
  typedef S1_var _var_type;
  typedef S1_out _out_type;

  ::FACE::UnsignedLong key;
  M1::Myfixed amount;
  M1::FixedArray vec;
  M1::FixedSeq lst;

  bool operator==(const S1& rhs) const;
  bool operator!=(const S1& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
};

void swap(S1& lhs, S1& rhs);

ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const S1& x);

ACE_CDR::Boolean operator>> (ACE_InputCDR& os, S1& x);

}

/* End STRUCT: S1 */

/* End MODULE: M1 */
#endif /* OPENDDS_IDL_GENERATED_FIXEDC_H_QYOS4O */
