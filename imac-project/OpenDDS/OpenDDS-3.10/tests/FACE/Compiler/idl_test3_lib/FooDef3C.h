/* -*- C++ -*- */
/* Generated by /Users/yc/MyGithub/imac-project/OpenDDS/OpenDDS-3.10/bin/opendds_idl version 3.10 (ACE version 6.2a_p11) running on input file ../../../DCPS/Compiler/idl_test3_lib/FooDef3.idl */
#ifndef OPENDDS_IDL_GENERATED_FOODEF3C_H_GIEDVF
#define OPENDDS_IDL_GENERATED_FOODEF3C_H_GIEDVF
#include <tao/orbconf.h>
#include <tao/Basic_Types.h>
#include <ace/CDR_Stream.h>
#include <tao/Seq_Out_T.h>
#include <tao/VarOut_T.h>
#include "FACE/Sequence.h"
#include "FACE/SequenceVar.h"
#include "FACE/StringManager.h"
#include "FACE/types.hpp"
#include "SharedTypesC.h"
#include "foolib_export.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: Xyz */



/* Begin ENUM: AnEnum */


/* End ENUM: AnEnum */


/* Begin TYPEDEF: SeqOfBoolean */


/* End TYPEDEF: SeqOfBoolean */


/* Begin TYPEDEF: SeqOfString */


/* End TYPEDEF: SeqOfString */


/* Begin TYPEDEF: SeqOfChar */


/* End TYPEDEF: SeqOfChar */


/* Begin TYPEDEF: SeqOfOctet */


/* End TYPEDEF: SeqOfOctet */


/* Begin TYPEDEF: SeqOfLong */


/* End TYPEDEF: SeqOfLong */


/* Begin TYPEDEF: SeqOfAnEnum */


/* End TYPEDEF: SeqOfAnEnum */


/* Begin TYPEDEF: ArrayOfBoolean */


/* End TYPEDEF: ArrayOfBoolean */


/* Begin TYPEDEF: ArrayOfString */


/* End TYPEDEF: ArrayOfString */


/* Begin TYPEDEF: ArrayOfChar */


/* End TYPEDEF: ArrayOfChar */


/* Begin TYPEDEF: ArrayOfOctet */


/* End TYPEDEF: ArrayOfOctet */


/* Begin TYPEDEF: ArrayOfLong */


/* End TYPEDEF: ArrayOfLong */


/* Begin TYPEDEF: ArrayOfAnEnum */


/* End TYPEDEF: ArrayOfAnEnum */


/* Begin TYPEDEF: ArrayOfSeqOfBoolean */


/* End TYPEDEF: ArrayOfSeqOfBoolean */


/* Begin TYPEDEF: ArrayOfSeqOfString */


/* End TYPEDEF: ArrayOfSeqOfString */


/* Begin TYPEDEF: ArrayOfSeqOfChar */


/* End TYPEDEF: ArrayOfSeqOfChar */


/* Begin TYPEDEF: ArrayOfSeqOfOctet */


/* End TYPEDEF: ArrayOfSeqOfOctet */


/* Begin TYPEDEF: ArrayOfSeqOfLong */


/* End TYPEDEF: ArrayOfSeqOfLong */


/* Begin TYPEDEF: ArrayOfSeqOfAnEnum */


/* End TYPEDEF: ArrayOfSeqOfAnEnum */

/* End MODULE: Xyz */


/* Begin MODULE: Xyz */



/* Begin TYPEDEF: SeqOfBoolean2 */

namespace Xyz {
class SeqOfBoolean2;
typedef ::OpenDDS::FaceTypes::SequenceVar<SeqOfBoolean2> SeqOfBoolean2_var;
typedef ::TAO_Seq_Out_T<SeqOfBoolean2> SeqOfBoolean2_out;

class FooLib_Export SeqOfBoolean2 : public ::OpenDDS::FaceTypes::Sequence< ::FACE::Boolean, ::OpenDDS::FaceTypes::Bounded<3> > {
public:
  typedef SeqOfBoolean2_var _var_type;
  typedef SeqOfBoolean2_out _out_type;

  SeqOfBoolean2() {}
  SeqOfBoolean2(const SeqOfBoolean2& seq) : ::OpenDDS::FaceTypes::Sequence< ::FACE::Boolean, ::OpenDDS::FaceTypes::Bounded<3> >(seq) {}
  friend void swap(SeqOfBoolean2& a, SeqOfBoolean2& b) { a.swap(b); }
  SeqOfBoolean2& operator=(const SeqOfBoolean2& rhs)
  {
    SeqOfBoolean2 tmp(rhs);
    swap(tmp);
    return *this;
  }
  SeqOfBoolean2(::FACE::UnsignedLong length, ::FACE::Boolean* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< ::FACE::Boolean, ::OpenDDS::FaceTypes::Bounded<3> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const SeqOfBoolean2&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, SeqOfBoolean2&) { return true; }

}

/* End TYPEDEF: SeqOfBoolean2 */


/* Begin TYPEDEF: SeqOfString2 */

namespace Xyz {
class SeqOfString2;
typedef ::OpenDDS::FaceTypes::SequenceVar<SeqOfString2> SeqOfString2_var;
typedef ::TAO_Seq_Out_T<SeqOfString2> SeqOfString2_out;

class FooLib_Export SeqOfString2 : public ::OpenDDS::FaceTypes::Sequence< ::FACE::Char*, ::OpenDDS::FaceTypes::Bounded<3>, ::OpenDDS::FaceTypes::StringEltPolicy< ::FACE::Char> > {
public:
  typedef SeqOfString2_var _var_type;
  typedef SeqOfString2_out _out_type;

  SeqOfString2() {}
  SeqOfString2(const SeqOfString2& seq) : ::OpenDDS::FaceTypes::Sequence< ::FACE::Char*, ::OpenDDS::FaceTypes::Bounded<3>, ::OpenDDS::FaceTypes::StringEltPolicy< ::FACE::Char> >(seq) {}
  friend void swap(SeqOfString2& a, SeqOfString2& b) { a.swap(b); }
  SeqOfString2& operator=(const SeqOfString2& rhs)
  {
    SeqOfString2 tmp(rhs);
    swap(tmp);
    return *this;
  }
  SeqOfString2(::FACE::UnsignedLong length, ::FACE::Char** data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< ::FACE::Char*, ::OpenDDS::FaceTypes::Bounded<3>, ::OpenDDS::FaceTypes::StringEltPolicy< ::FACE::Char> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const SeqOfString2&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, SeqOfString2&) { return true; }

}

/* End TYPEDEF: SeqOfString2 */


/* Begin TYPEDEF: SeqOfChar2 */

namespace Xyz {
class SeqOfChar2;
typedef ::OpenDDS::FaceTypes::SequenceVar<SeqOfChar2> SeqOfChar2_var;
typedef ::TAO_Seq_Out_T<SeqOfChar2> SeqOfChar2_out;

class FooLib_Export SeqOfChar2 : public ::OpenDDS::FaceTypes::Sequence< ::FACE::Char, ::OpenDDS::FaceTypes::Bounded<3> > {
public:
  typedef SeqOfChar2_var _var_type;
  typedef SeqOfChar2_out _out_type;

  SeqOfChar2() {}
  SeqOfChar2(const SeqOfChar2& seq) : ::OpenDDS::FaceTypes::Sequence< ::FACE::Char, ::OpenDDS::FaceTypes::Bounded<3> >(seq) {}
  friend void swap(SeqOfChar2& a, SeqOfChar2& b) { a.swap(b); }
  SeqOfChar2& operator=(const SeqOfChar2& rhs)
  {
    SeqOfChar2 tmp(rhs);
    swap(tmp);
    return *this;
  }
  SeqOfChar2(::FACE::UnsignedLong length, ::FACE::Char* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< ::FACE::Char, ::OpenDDS::FaceTypes::Bounded<3> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const SeqOfChar2&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, SeqOfChar2&) { return true; }

}

/* End TYPEDEF: SeqOfChar2 */


/* Begin TYPEDEF: SeqOfOctet2 */

namespace Xyz {
class SeqOfOctet2;
typedef ::OpenDDS::FaceTypes::SequenceVar<SeqOfOctet2> SeqOfOctet2_var;
typedef ::TAO_Seq_Out_T<SeqOfOctet2> SeqOfOctet2_out;

class FooLib_Export SeqOfOctet2 : public ::OpenDDS::FaceTypes::Sequence< ::FACE::Octet, ::OpenDDS::FaceTypes::Bounded<3> > {
public:
  typedef SeqOfOctet2_var _var_type;
  typedef SeqOfOctet2_out _out_type;

  SeqOfOctet2() {}
  SeqOfOctet2(const SeqOfOctet2& seq) : ::OpenDDS::FaceTypes::Sequence< ::FACE::Octet, ::OpenDDS::FaceTypes::Bounded<3> >(seq) {}
  friend void swap(SeqOfOctet2& a, SeqOfOctet2& b) { a.swap(b); }
  SeqOfOctet2& operator=(const SeqOfOctet2& rhs)
  {
    SeqOfOctet2 tmp(rhs);
    swap(tmp);
    return *this;
  }
  SeqOfOctet2(::FACE::UnsignedLong length, ::FACE::Octet* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< ::FACE::Octet, ::OpenDDS::FaceTypes::Bounded<3> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const SeqOfOctet2&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, SeqOfOctet2&) { return true; }

}

/* End TYPEDEF: SeqOfOctet2 */


/* Begin TYPEDEF: SeqOfLong2 */

namespace Xyz {
class SeqOfLong2;
typedef ::OpenDDS::FaceTypes::SequenceVar<SeqOfLong2> SeqOfLong2_var;
typedef ::TAO_Seq_Out_T<SeqOfLong2> SeqOfLong2_out;

class FooLib_Export SeqOfLong2 : public ::OpenDDS::FaceTypes::Sequence< ::FACE::Long, ::OpenDDS::FaceTypes::Bounded<3> > {
public:
  typedef SeqOfLong2_var _var_type;
  typedef SeqOfLong2_out _out_type;

  SeqOfLong2() {}
  SeqOfLong2(const SeqOfLong2& seq) : ::OpenDDS::FaceTypes::Sequence< ::FACE::Long, ::OpenDDS::FaceTypes::Bounded<3> >(seq) {}
  friend void swap(SeqOfLong2& a, SeqOfLong2& b) { a.swap(b); }
  SeqOfLong2& operator=(const SeqOfLong2& rhs)
  {
    SeqOfLong2 tmp(rhs);
    swap(tmp);
    return *this;
  }
  SeqOfLong2(::FACE::UnsignedLong length, ::FACE::Long* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< ::FACE::Long, ::OpenDDS::FaceTypes::Bounded<3> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const SeqOfLong2&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, SeqOfLong2&) { return true; }

}

/* End TYPEDEF: SeqOfLong2 */


/* Begin TYPEDEF: SeqOfAnEnum2 */

namespace Xyz {
class SeqOfAnEnum2;
typedef ::OpenDDS::FaceTypes::SequenceVar<SeqOfAnEnum2> SeqOfAnEnum2_var;
typedef ::TAO_Seq_Out_T<SeqOfAnEnum2> SeqOfAnEnum2_out;

class FooLib_Export SeqOfAnEnum2 : public ::OpenDDS::FaceTypes::Sequence< Xyz::AnEnum, ::OpenDDS::FaceTypes::Bounded<3> > {
public:
  typedef SeqOfAnEnum2_var _var_type;
  typedef SeqOfAnEnum2_out _out_type;

  SeqOfAnEnum2() {}
  SeqOfAnEnum2(const SeqOfAnEnum2& seq) : ::OpenDDS::FaceTypes::Sequence< Xyz::AnEnum, ::OpenDDS::FaceTypes::Bounded<3> >(seq) {}
  friend void swap(SeqOfAnEnum2& a, SeqOfAnEnum2& b) { a.swap(b); }
  SeqOfAnEnum2& operator=(const SeqOfAnEnum2& rhs)
  {
    SeqOfAnEnum2 tmp(rhs);
    swap(tmp);
    return *this;
  }
  SeqOfAnEnum2(::FACE::UnsignedLong length, Xyz::AnEnum* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< Xyz::AnEnum, ::OpenDDS::FaceTypes::Bounded<3> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const SeqOfAnEnum2&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, SeqOfAnEnum2&) { return true; }

}

/* End TYPEDEF: SeqOfAnEnum2 */


/* Begin STRUCT: SimpleStruct */

namespace Xyz {
struct SimpleStruct;
typedef ::TAO_Var_Var_T<SimpleStruct> SimpleStruct_var;
typedef ::TAO_Out_T<SimpleStruct> SimpleStruct_out;

struct FooLib_Export SimpleStruct
{
  typedef SimpleStruct_var _var_type;
  typedef SimpleStruct_out _out_type;

  ::FACE::Long simple;
  Xyz::SeqOfLong ss1;

  bool operator==(const SimpleStruct& rhs) const;
  bool operator!=(const SimpleStruct& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
};

FooLib_Export void swap(SimpleStruct& lhs, SimpleStruct& rhs);

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const SimpleStruct& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, SimpleStruct& x);

}

/* End STRUCT: SimpleStruct */


/* Begin STRUCT: StructOfArrayOfSeqOfBoolean */

namespace Xyz {
struct StructOfArrayOfSeqOfBoolean;
typedef ::TAO_Var_Var_T<StructOfArrayOfSeqOfBoolean> StructOfArrayOfSeqOfBoolean_var;
typedef ::TAO_Out_T<StructOfArrayOfSeqOfBoolean> StructOfArrayOfSeqOfBoolean_out;

struct FooLib_Export StructOfArrayOfSeqOfBoolean
{
  typedef StructOfArrayOfSeqOfBoolean_var _var_type;
  typedef StructOfArrayOfSeqOfBoolean_out _out_type;

  Xyz::ArrayOfSeqOfBoolean f;

  bool operator==(const StructOfArrayOfSeqOfBoolean& rhs) const;
  bool operator!=(const StructOfArrayOfSeqOfBoolean& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
};

FooLib_Export void swap(StructOfArrayOfSeqOfBoolean& lhs, StructOfArrayOfSeqOfBoolean& rhs);

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const StructOfArrayOfSeqOfBoolean& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, StructOfArrayOfSeqOfBoolean& x);

}

/* End STRUCT: StructOfArrayOfSeqOfBoolean */


/* Begin STRUCT: StructOfArrayOfSeqOfString */

namespace Xyz {
struct StructOfArrayOfSeqOfString;
typedef ::TAO_Var_Var_T<StructOfArrayOfSeqOfString> StructOfArrayOfSeqOfString_var;
typedef ::TAO_Out_T<StructOfArrayOfSeqOfString> StructOfArrayOfSeqOfString_out;

struct FooLib_Export StructOfArrayOfSeqOfString
{
  typedef StructOfArrayOfSeqOfString_var _var_type;
  typedef StructOfArrayOfSeqOfString_out _out_type;

  Xyz::ArrayOfSeqOfString f;

  bool operator==(const StructOfArrayOfSeqOfString& rhs) const;
  bool operator!=(const StructOfArrayOfSeqOfString& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
};

FooLib_Export void swap(StructOfArrayOfSeqOfString& lhs, StructOfArrayOfSeqOfString& rhs);

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const StructOfArrayOfSeqOfString& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, StructOfArrayOfSeqOfString& x);

}

/* End STRUCT: StructOfArrayOfSeqOfString */


/* Begin STRUCT: StructOfArrayOfSeqOfChar */

namespace Xyz {
struct StructOfArrayOfSeqOfChar;
typedef ::TAO_Var_Var_T<StructOfArrayOfSeqOfChar> StructOfArrayOfSeqOfChar_var;
typedef ::TAO_Out_T<StructOfArrayOfSeqOfChar> StructOfArrayOfSeqOfChar_out;

struct FooLib_Export StructOfArrayOfSeqOfChar
{
  typedef StructOfArrayOfSeqOfChar_var _var_type;
  typedef StructOfArrayOfSeqOfChar_out _out_type;

  Xyz::ArrayOfSeqOfChar f;

  bool operator==(const StructOfArrayOfSeqOfChar& rhs) const;
  bool operator!=(const StructOfArrayOfSeqOfChar& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
};

FooLib_Export void swap(StructOfArrayOfSeqOfChar& lhs, StructOfArrayOfSeqOfChar& rhs);

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const StructOfArrayOfSeqOfChar& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, StructOfArrayOfSeqOfChar& x);

}

/* End STRUCT: StructOfArrayOfSeqOfChar */


/* Begin STRUCT: StructOfArrayOfSeqOfOctet */

namespace Xyz {
struct StructOfArrayOfSeqOfOctet;
typedef ::TAO_Var_Var_T<StructOfArrayOfSeqOfOctet> StructOfArrayOfSeqOfOctet_var;
typedef ::TAO_Out_T<StructOfArrayOfSeqOfOctet> StructOfArrayOfSeqOfOctet_out;

struct FooLib_Export StructOfArrayOfSeqOfOctet
{
  typedef StructOfArrayOfSeqOfOctet_var _var_type;
  typedef StructOfArrayOfSeqOfOctet_out _out_type;

  Xyz::ArrayOfSeqOfOctet f;

  bool operator==(const StructOfArrayOfSeqOfOctet& rhs) const;
  bool operator!=(const StructOfArrayOfSeqOfOctet& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
};

FooLib_Export void swap(StructOfArrayOfSeqOfOctet& lhs, StructOfArrayOfSeqOfOctet& rhs);

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const StructOfArrayOfSeqOfOctet& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, StructOfArrayOfSeqOfOctet& x);

}

/* End STRUCT: StructOfArrayOfSeqOfOctet */


/* Begin STRUCT: StructOfArrayOfSeqOfLong */

namespace Xyz {
struct StructOfArrayOfSeqOfLong;
typedef ::TAO_Var_Var_T<StructOfArrayOfSeqOfLong> StructOfArrayOfSeqOfLong_var;
typedef ::TAO_Out_T<StructOfArrayOfSeqOfLong> StructOfArrayOfSeqOfLong_out;

struct FooLib_Export StructOfArrayOfSeqOfLong
{
  typedef StructOfArrayOfSeqOfLong_var _var_type;
  typedef StructOfArrayOfSeqOfLong_out _out_type;

  Xyz::ArrayOfSeqOfLong f;

  bool operator==(const StructOfArrayOfSeqOfLong& rhs) const;
  bool operator!=(const StructOfArrayOfSeqOfLong& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
};

FooLib_Export void swap(StructOfArrayOfSeqOfLong& lhs, StructOfArrayOfSeqOfLong& rhs);

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const StructOfArrayOfSeqOfLong& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, StructOfArrayOfSeqOfLong& x);

}

/* End STRUCT: StructOfArrayOfSeqOfLong */


/* Begin STRUCT: StructOfArrayOfSeqOfAnEnum */

namespace Xyz {
struct StructOfArrayOfSeqOfAnEnum;
typedef ::TAO_Var_Var_T<StructOfArrayOfSeqOfAnEnum> StructOfArrayOfSeqOfAnEnum_var;
typedef ::TAO_Out_T<StructOfArrayOfSeqOfAnEnum> StructOfArrayOfSeqOfAnEnum_out;

struct FooLib_Export StructOfArrayOfSeqOfAnEnum
{
  typedef StructOfArrayOfSeqOfAnEnum_var _var_type;
  typedef StructOfArrayOfSeqOfAnEnum_out _out_type;

  Xyz::ArrayOfSeqOfAnEnum f;

  bool operator==(const StructOfArrayOfSeqOfAnEnum& rhs) const;
  bool operator!=(const StructOfArrayOfSeqOfAnEnum& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
};

FooLib_Export void swap(StructOfArrayOfSeqOfAnEnum& lhs, StructOfArrayOfSeqOfAnEnum& rhs);

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const StructOfArrayOfSeqOfAnEnum& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, StructOfArrayOfSeqOfAnEnum& x);

}

/* End STRUCT: StructOfArrayOfSeqOfAnEnum */

/* End MODULE: Xyz */
#endif /* OPENDDS_IDL_GENERATED_FOODEF3C_H_GIEDVF */
