/* Generated by /Users/yc/MyGithub/imac-project/OpenDDS/OpenDDS-3.10/bin/opendds_idl version 3.10 (ACE version 6.2a_p11) running on input file ../../../DCPS/Compiler/idl_test3_lib/FooDef3.idl */
#include "FooDef3TypeSupportImpl.h"

#include <algorithm>
#include <cstring>
#include <stdexcept>
#include "dds/DCPS/BuiltInTopicUtils.h"
#include "dds/DCPS/ContentFilteredTopicImpl.h"
#include "dds/DCPS/DataReaderImpl_T.h"
#include "dds/DCPS/DataWriterImpl_T.h"
#include "dds/DCPS/FilterEvaluator.h"
#include "dds/DCPS/MultiTopicDataReader_T.h"
#include "dds/DCPS/PoolAllocator.h"
#include "dds/DCPS/PublicationInstance.h"
#include "dds/DCPS/PublisherImpl.h"
#include "dds/DCPS/Qos_Helper.h"
#include "dds/DCPS/RakeData.h"
#include "dds/DCPS/RakeResults_T.h"
#include "dds/DCPS/ReceivedDataElementList.h"
#include "dds/DCPS/Registered_Data_Types.h"
#include "dds/DCPS/Service_Participant.h"
#include "dds/DCPS/SubscriberImpl.h"
#include "dds/DCPS/Util.h"
#include "dds/DCPS/debug.h"
#include "dds/DdsDcpsDomainC.h"
#include "SharedTypesTypeSupportImpl.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: Xyz */



/* Begin ENUM: AnEnum */


/* End ENUM: AnEnum */


/* Begin TYPEDEF: SeqOfBoolean */


/* End TYPEDEF: SeqOfBoolean */


/* Begin TYPEDEF: SeqOfString */


/* End TYPEDEF: SeqOfString */


/* Begin TYPEDEF: SeqOfChar */


/* End TYPEDEF: SeqOfChar */


/* Begin TYPEDEF: SeqOfOctet */


/* End TYPEDEF: SeqOfOctet */


/* Begin TYPEDEF: SeqOfLong */


/* End TYPEDEF: SeqOfLong */


/* Begin TYPEDEF: SeqOfAnEnum */


/* End TYPEDEF: SeqOfAnEnum */


/* Begin TYPEDEF: ArrayOfBoolean */


/* End TYPEDEF: ArrayOfBoolean */


/* Begin TYPEDEF: ArrayOfString */


/* End TYPEDEF: ArrayOfString */


/* Begin TYPEDEF: ArrayOfChar */


/* End TYPEDEF: ArrayOfChar */


/* Begin TYPEDEF: ArrayOfOctet */


/* End TYPEDEF: ArrayOfOctet */


/* Begin TYPEDEF: ArrayOfLong */


/* End TYPEDEF: ArrayOfLong */


/* Begin TYPEDEF: ArrayOfAnEnum */


/* End TYPEDEF: ArrayOfAnEnum */


/* Begin TYPEDEF: ArrayOfSeqOfBoolean */


/* End TYPEDEF: ArrayOfSeqOfBoolean */


/* Begin TYPEDEF: ArrayOfSeqOfString */


/* End TYPEDEF: ArrayOfSeqOfString */


/* Begin TYPEDEF: ArrayOfSeqOfChar */


/* End TYPEDEF: ArrayOfSeqOfChar */


/* Begin TYPEDEF: ArrayOfSeqOfOctet */


/* End TYPEDEF: ArrayOfSeqOfOctet */


/* Begin TYPEDEF: ArrayOfSeqOfLong */


/* End TYPEDEF: ArrayOfSeqOfLong */


/* Begin TYPEDEF: ArrayOfSeqOfAnEnum */


/* End TYPEDEF: ArrayOfSeqOfAnEnum */

/* End MODULE: Xyz */


/* Begin MODULE: Xyz */



/* Begin TYPEDEF: SeqOfBoolean2 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::SeqOfBoolean2& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  size += seq.length() * max_marshaled_size_boolean();
}

bool operator<<(Serializer& strm, const Xyz::SeqOfBoolean2& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  return strm.write_boolean_array(seq.get_buffer(), length);
}

bool operator>>(Serializer& strm, Xyz::SeqOfBoolean2& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > seq.maximum()) {
    return false;
  }
  seq.length(length);
  if (length == 0) {
    return true;
  }
  return strm.read_boolean_array(seq.get_buffer(), length);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::SeqOfBoolean2*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  ser.skip(length, 1);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfBoolean2 */


/* Begin TYPEDEF: SeqOfString2 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::SeqOfString2& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    find_size_ulong(size, padding);
    if (seq[i]) {
      size += ACE_OS::strlen(seq[i]) + 1;
    }
  }
}

bool operator<<(Serializer& strm, const Xyz::SeqOfString2& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::SeqOfString2& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > seq.maximum()) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::SeqOfString2*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    ACE_CDR::ULong strlength;
    ser >> strlength;
    ser.skip(strlength);
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfString2 */


/* Begin TYPEDEF: SeqOfChar2 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::SeqOfChar2& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  size += seq.length() * max_marshaled_size_char();
}

bool operator<<(Serializer& strm, const Xyz::SeqOfChar2& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  return strm.write_char_array(seq.get_buffer(), length);
}

bool operator>>(Serializer& strm, Xyz::SeqOfChar2& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > seq.maximum()) {
    return false;
  }
  seq.length(length);
  if (length == 0) {
    return true;
  }
  return strm.read_char_array(seq.get_buffer(), length);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::SeqOfChar2*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  ser.skip(length, 1);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfChar2 */


/* Begin TYPEDEF: SeqOfOctet2 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::SeqOfOctet2& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  size += seq.length() * max_marshaled_size_octet();
}

bool operator<<(Serializer& strm, const Xyz::SeqOfOctet2& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  return strm.write_octet_array(seq.get_buffer(), length);
}

bool operator>>(Serializer& strm, Xyz::SeqOfOctet2& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > seq.maximum()) {
    return false;
  }
  seq.length(length);
  if (length == 0) {
    return true;
  }
  return strm.read_octet_array(seq.get_buffer(), length);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::SeqOfOctet2*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  ser.skip(length, 1);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfOctet2 */


/* Begin TYPEDEF: SeqOfLong2 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::SeqOfLong2& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  size += seq.length() * gen_max_marshaled_size(CORBA::Long());
}

bool operator<<(Serializer& strm, const Xyz::SeqOfLong2& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  return strm.write_long_array(seq.get_buffer(), length);
}

bool operator>>(Serializer& strm, Xyz::SeqOfLong2& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > seq.maximum()) {
    return false;
  }
  seq.length(length);
  if (length == 0) {
    return true;
  }
  return strm.read_long_array(seq.get_buffer(), length);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::SeqOfLong2*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  ser.skip(length, 4);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfLong2 */


/* Begin TYPEDEF: SeqOfAnEnum2 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::SeqOfAnEnum2& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  size += seq.length() * max_marshaled_size_ulong();
}

bool operator<<(Serializer& strm, const Xyz::SeqOfAnEnum2& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::SeqOfAnEnum2& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > seq.maximum()) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::SeqOfAnEnum2*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  ser.skip(length, 4);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfAnEnum2 */


/* Begin STRUCT: SimpleStruct */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::SimpleStruct& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.simple);
  gen_find_size(stru.ss1, size, padding);
}

bool operator<<(Serializer& strm, const Xyz::SimpleStruct& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.simple)
    && (strm << stru.ss1);
}

bool operator>>(Serializer& strm, Xyz::SimpleStruct& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.simple)
    && (strm >> stru.ss1);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Xyz::SimpleStruct> : MetaStruct {
  typedef Xyz::SimpleStruct T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Xyz::SimpleStruct& typed = *static_cast<const Xyz::SimpleStruct*>(stru);
    if (std::strcmp(field, "simple") == 0) {
      return typed.simple;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::SimpleStruct)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "simple") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'simple' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    gen_skip_over(ser, static_cast<Xyz::SeqOfLong*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Xyz::SimpleStruct");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "simple") == 0) {
      return make_field_cmp(&T::simple, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::SimpleStruct)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"simple", "ss1", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "simple") == 0) {
      return &static_cast<const T*>(stru)->simple;
    }
    if (std::strcmp(field, "ss1") == 0) {
      return &static_cast<const T*>(stru)->ss1;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::SimpleStruct)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "simple") == 0) {
      static_cast<T*>(lhs)->simple = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ss1") == 0) {
      static_cast<T*>(lhs)->ss1 = *static_cast<const Xyz::SeqOfLong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::SimpleStruct)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "simple") == 0) {
      return static_cast<const T*>(lhs)->simple == static_cast<const T*>(rhs)->simple;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::SimpleStruct)");
  }
};

template<>
const MetaStruct& getMetaStruct<Xyz::SimpleStruct>()
{
  static MetaStructImpl<Xyz::SimpleStruct> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Xyz::SimpleStruct*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Xyz::SimpleStruct>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
bool SimpleStruct::operator==(const SimpleStruct& rhs) const
{
  if (simple != rhs.simple) {
    return false;
  }
  if (ss1 != rhs.ss1) {
    return false;
  }
  return true;
}

void swap(SimpleStruct& lhs, SimpleStruct& rhs)
{
  using std::swap;
  swap(lhs.simple, rhs.simple);
  swap(lhs.ss1, rhs.ss1);
}

ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const SimpleStruct&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, SimpleStruct&) { return true; }

}

/* End STRUCT: SimpleStruct */


/* Begin STRUCT: StructOfArrayOfSeqOfBoolean */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::StructOfArrayOfSeqOfBoolean& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  Xyz::ArrayOfSeqOfBoolean_forany stru_f(const_cast<Xyz::ArrayOfSeqOfBoolean_slice*>(stru.f));
  gen_find_size(stru_f, size, padding);
}

bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfSeqOfBoolean& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfSeqOfBoolean_forany stru_f(const_cast<Xyz::ArrayOfSeqOfBoolean_slice*>(stru.f));
  return (strm << stru_f);
}

bool operator>>(Serializer& strm, Xyz::StructOfArrayOfSeqOfBoolean& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfSeqOfBoolean_forany stru_f(const_cast<Xyz::ArrayOfSeqOfBoolean_slice*>(stru.f));
  return (strm >> stru_f);
}

size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfSeqOfBoolean& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return align ? 70 : 60;
}

size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfSeqOfBoolean> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfSeqOfBoolean> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfSeqOfBoolean> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfSeqOfBoolean> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
::DDS::DataWriter_ptr StructOfArrayOfSeqOfBooleanTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<StructOfArrayOfSeqOfBoolean> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr StructOfArrayOfSeqOfBooleanTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfSeqOfBoolean> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr StructOfArrayOfSeqOfBooleanTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfSeqOfBoolean> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<StructOfArrayOfSeqOfBoolean, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& StructOfArrayOfSeqOfBooleanTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<StructOfArrayOfSeqOfBoolean>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool StructOfArrayOfSeqOfBooleanTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* StructOfArrayOfSeqOfBooleanTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
StructOfArrayOfSeqOfBooleanTypeSupport::_ptr_type StructOfArrayOfSeqOfBooleanTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Xyz::StructOfArrayOfSeqOfBoolean> : MetaStruct {
  typedef Xyz::StructOfArrayOfSeqOfBoolean T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Xyz::StructOfArrayOfSeqOfBoolean& typed = *static_cast<const Xyz::StructOfArrayOfSeqOfBoolean*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfSeqOfBoolean)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfSeqOfBoolean_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Xyz::StructOfArrayOfSeqOfBoolean");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfSeqOfBoolean)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"f", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "f") == 0) {
      return &static_cast<const T*>(stru)->f;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfSeqOfBoolean)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "f") == 0) {
      Xyz::ArrayOfSeqOfBoolean* lhsArr = &static_cast<T*>(lhs)->f;
      const Xyz::ArrayOfSeqOfBoolean* rhsArr = static_cast<const Xyz::ArrayOfSeqOfBoolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 6; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfSeqOfBoolean)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfSeqOfBoolean)");
  }
};

template<>
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfSeqOfBoolean>()
{
  static MetaStructImpl<Xyz::StructOfArrayOfSeqOfBoolean> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfSeqOfBoolean*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Xyz::StructOfArrayOfSeqOfBoolean>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
bool StructOfArrayOfSeqOfBoolean::operator==(const StructOfArrayOfSeqOfBoolean& rhs) const
{
  for (int i0 = 0; i0 < 6; ++i0) {
    if (f[i0] != rhs.f[i0]) {
      return false;
    }
  }
  return true;
}

void swap(StructOfArrayOfSeqOfBoolean& lhs, StructOfArrayOfSeqOfBoolean& rhs)
{
  using std::swap;
  std::swap_ranges(lhs.f, lhs.f + 6, rhs.f);
}

ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const StructOfArrayOfSeqOfBoolean&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, StructOfArrayOfSeqOfBoolean&) { return true; }

}

/* End STRUCT: StructOfArrayOfSeqOfBoolean */


/* Begin STRUCT: StructOfArrayOfSeqOfString */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::StructOfArrayOfSeqOfString& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  Xyz::ArrayOfSeqOfString_forany stru_f(const_cast<Xyz::ArrayOfSeqOfString_slice*>(stru.f));
  gen_find_size(stru_f, size, padding);
}

bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfSeqOfString& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfSeqOfString_forany stru_f(const_cast<Xyz::ArrayOfSeqOfString_slice*>(stru.f));
  return (strm << stru_f);
}

bool operator>>(Serializer& strm, Xyz::StructOfArrayOfSeqOfString& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfSeqOfString_forany stru_f(const_cast<Xyz::ArrayOfSeqOfString_slice*>(stru.f));
  return (strm >> stru_f);
}

size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfSeqOfString& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfSeqOfString> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfSeqOfString> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfSeqOfString> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfSeqOfString> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
::DDS::DataWriter_ptr StructOfArrayOfSeqOfStringTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<StructOfArrayOfSeqOfString> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr StructOfArrayOfSeqOfStringTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfSeqOfString> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr StructOfArrayOfSeqOfStringTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfSeqOfString> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<StructOfArrayOfSeqOfString, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& StructOfArrayOfSeqOfStringTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<StructOfArrayOfSeqOfString>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool StructOfArrayOfSeqOfStringTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* StructOfArrayOfSeqOfStringTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
StructOfArrayOfSeqOfStringTypeSupport::_ptr_type StructOfArrayOfSeqOfStringTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Xyz::StructOfArrayOfSeqOfString> : MetaStruct {
  typedef Xyz::StructOfArrayOfSeqOfString T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Xyz::StructOfArrayOfSeqOfString& typed = *static_cast<const Xyz::StructOfArrayOfSeqOfString*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfSeqOfString)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfSeqOfString_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Xyz::StructOfArrayOfSeqOfString");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfSeqOfString)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"f", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "f") == 0) {
      return &static_cast<const T*>(stru)->f;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfSeqOfString)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "f") == 0) {
      Xyz::ArrayOfSeqOfString* lhsArr = &static_cast<T*>(lhs)->f;
      const Xyz::ArrayOfSeqOfString* rhsArr = static_cast<const Xyz::ArrayOfSeqOfString*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 6; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfSeqOfString)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfSeqOfString)");
  }
};

template<>
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfSeqOfString>()
{
  static MetaStructImpl<Xyz::StructOfArrayOfSeqOfString> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfSeqOfString*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Xyz::StructOfArrayOfSeqOfString>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
bool StructOfArrayOfSeqOfString::operator==(const StructOfArrayOfSeqOfString& rhs) const
{
  for (int i0 = 0; i0 < 6; ++i0) {
    if (f[i0] != rhs.f[i0]) {
      return false;
    }
  }
  return true;
}

void swap(StructOfArrayOfSeqOfString& lhs, StructOfArrayOfSeqOfString& rhs)
{
  using std::swap;
  std::swap_ranges(lhs.f, lhs.f + 6, rhs.f);
}

ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const StructOfArrayOfSeqOfString&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, StructOfArrayOfSeqOfString&) { return true; }

}

/* End STRUCT: StructOfArrayOfSeqOfString */


/* Begin STRUCT: StructOfArrayOfSeqOfChar */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::StructOfArrayOfSeqOfChar& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  Xyz::ArrayOfSeqOfChar_forany stru_f(const_cast<Xyz::ArrayOfSeqOfChar_slice*>(stru.f));
  gen_find_size(stru_f, size, padding);
}

bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfSeqOfChar& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfSeqOfChar_forany stru_f(const_cast<Xyz::ArrayOfSeqOfChar_slice*>(stru.f));
  return (strm << stru_f);
}

bool operator>>(Serializer& strm, Xyz::StructOfArrayOfSeqOfChar& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfSeqOfChar_forany stru_f(const_cast<Xyz::ArrayOfSeqOfChar_slice*>(stru.f));
  return (strm >> stru_f);
}

size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfSeqOfChar& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return align ? 70 : 60;
}

size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfSeqOfChar> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfSeqOfChar> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfSeqOfChar> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfSeqOfChar> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
::DDS::DataWriter_ptr StructOfArrayOfSeqOfCharTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<StructOfArrayOfSeqOfChar> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr StructOfArrayOfSeqOfCharTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfSeqOfChar> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr StructOfArrayOfSeqOfCharTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfSeqOfChar> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<StructOfArrayOfSeqOfChar, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& StructOfArrayOfSeqOfCharTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<StructOfArrayOfSeqOfChar>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool StructOfArrayOfSeqOfCharTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* StructOfArrayOfSeqOfCharTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
StructOfArrayOfSeqOfCharTypeSupport::_ptr_type StructOfArrayOfSeqOfCharTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Xyz::StructOfArrayOfSeqOfChar> : MetaStruct {
  typedef Xyz::StructOfArrayOfSeqOfChar T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Xyz::StructOfArrayOfSeqOfChar& typed = *static_cast<const Xyz::StructOfArrayOfSeqOfChar*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfSeqOfChar)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfSeqOfChar_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Xyz::StructOfArrayOfSeqOfChar");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfSeqOfChar)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"f", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "f") == 0) {
      return &static_cast<const T*>(stru)->f;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfSeqOfChar)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "f") == 0) {
      Xyz::ArrayOfSeqOfChar* lhsArr = &static_cast<T*>(lhs)->f;
      const Xyz::ArrayOfSeqOfChar* rhsArr = static_cast<const Xyz::ArrayOfSeqOfChar*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 6; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfSeqOfChar)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfSeqOfChar)");
  }
};

template<>
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfSeqOfChar>()
{
  static MetaStructImpl<Xyz::StructOfArrayOfSeqOfChar> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfSeqOfChar*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Xyz::StructOfArrayOfSeqOfChar>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
bool StructOfArrayOfSeqOfChar::operator==(const StructOfArrayOfSeqOfChar& rhs) const
{
  for (int i0 = 0; i0 < 6; ++i0) {
    if (f[i0] != rhs.f[i0]) {
      return false;
    }
  }
  return true;
}

void swap(StructOfArrayOfSeqOfChar& lhs, StructOfArrayOfSeqOfChar& rhs)
{
  using std::swap;
  std::swap_ranges(lhs.f, lhs.f + 6, rhs.f);
}

ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const StructOfArrayOfSeqOfChar&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, StructOfArrayOfSeqOfChar&) { return true; }

}

/* End STRUCT: StructOfArrayOfSeqOfChar */


/* Begin STRUCT: StructOfArrayOfSeqOfOctet */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::StructOfArrayOfSeqOfOctet& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  Xyz::ArrayOfSeqOfOctet_forany stru_f(const_cast<Xyz::ArrayOfSeqOfOctet_slice*>(stru.f));
  gen_find_size(stru_f, size, padding);
}

bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfSeqOfOctet& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfSeqOfOctet_forany stru_f(const_cast<Xyz::ArrayOfSeqOfOctet_slice*>(stru.f));
  return (strm << stru_f);
}

bool operator>>(Serializer& strm, Xyz::StructOfArrayOfSeqOfOctet& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfSeqOfOctet_forany stru_f(const_cast<Xyz::ArrayOfSeqOfOctet_slice*>(stru.f));
  return (strm >> stru_f);
}

size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfSeqOfOctet& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return align ? 70 : 60;
}

size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfSeqOfOctet> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfSeqOfOctet> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfSeqOfOctet> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfSeqOfOctet> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
::DDS::DataWriter_ptr StructOfArrayOfSeqOfOctetTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<StructOfArrayOfSeqOfOctet> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr StructOfArrayOfSeqOfOctetTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfSeqOfOctet> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr StructOfArrayOfSeqOfOctetTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfSeqOfOctet> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<StructOfArrayOfSeqOfOctet, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& StructOfArrayOfSeqOfOctetTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<StructOfArrayOfSeqOfOctet>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool StructOfArrayOfSeqOfOctetTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* StructOfArrayOfSeqOfOctetTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
StructOfArrayOfSeqOfOctetTypeSupport::_ptr_type StructOfArrayOfSeqOfOctetTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Xyz::StructOfArrayOfSeqOfOctet> : MetaStruct {
  typedef Xyz::StructOfArrayOfSeqOfOctet T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Xyz::StructOfArrayOfSeqOfOctet& typed = *static_cast<const Xyz::StructOfArrayOfSeqOfOctet*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfSeqOfOctet)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfSeqOfOctet_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Xyz::StructOfArrayOfSeqOfOctet");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfSeqOfOctet)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"f", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "f") == 0) {
      return &static_cast<const T*>(stru)->f;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfSeqOfOctet)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "f") == 0) {
      Xyz::ArrayOfSeqOfOctet* lhsArr = &static_cast<T*>(lhs)->f;
      const Xyz::ArrayOfSeqOfOctet* rhsArr = static_cast<const Xyz::ArrayOfSeqOfOctet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 6; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfSeqOfOctet)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfSeqOfOctet)");
  }
};

template<>
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfSeqOfOctet>()
{
  static MetaStructImpl<Xyz::StructOfArrayOfSeqOfOctet> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfSeqOfOctet*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Xyz::StructOfArrayOfSeqOfOctet>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
bool StructOfArrayOfSeqOfOctet::operator==(const StructOfArrayOfSeqOfOctet& rhs) const
{
  for (int i0 = 0; i0 < 6; ++i0) {
    if (f[i0] != rhs.f[i0]) {
      return false;
    }
  }
  return true;
}

void swap(StructOfArrayOfSeqOfOctet& lhs, StructOfArrayOfSeqOfOctet& rhs)
{
  using std::swap;
  std::swap_ranges(lhs.f, lhs.f + 6, rhs.f);
}

ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const StructOfArrayOfSeqOfOctet&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, StructOfArrayOfSeqOfOctet&) { return true; }

}

/* End STRUCT: StructOfArrayOfSeqOfOctet */


/* Begin STRUCT: StructOfArrayOfSeqOfLong */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::StructOfArrayOfSeqOfLong& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  Xyz::ArrayOfSeqOfLong_forany stru_f(const_cast<Xyz::ArrayOfSeqOfLong_slice*>(stru.f));
  gen_find_size(stru_f, size, padding);
}

bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfSeqOfLong& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfSeqOfLong_forany stru_f(const_cast<Xyz::ArrayOfSeqOfLong_slice*>(stru.f));
  return (strm << stru_f);
}

bool operator>>(Serializer& strm, Xyz::StructOfArrayOfSeqOfLong& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfSeqOfLong_forany stru_f(const_cast<Xyz::ArrayOfSeqOfLong_slice*>(stru.f));
  return (strm >> stru_f);
}

size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfSeqOfLong& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 168;
}

size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfSeqOfLong> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfSeqOfLong> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfSeqOfLong> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfSeqOfLong> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
::DDS::DataWriter_ptr StructOfArrayOfSeqOfLongTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<StructOfArrayOfSeqOfLong> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr StructOfArrayOfSeqOfLongTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfSeqOfLong> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr StructOfArrayOfSeqOfLongTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfSeqOfLong> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<StructOfArrayOfSeqOfLong, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& StructOfArrayOfSeqOfLongTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<StructOfArrayOfSeqOfLong>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool StructOfArrayOfSeqOfLongTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* StructOfArrayOfSeqOfLongTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
StructOfArrayOfSeqOfLongTypeSupport::_ptr_type StructOfArrayOfSeqOfLongTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Xyz::StructOfArrayOfSeqOfLong> : MetaStruct {
  typedef Xyz::StructOfArrayOfSeqOfLong T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Xyz::StructOfArrayOfSeqOfLong& typed = *static_cast<const Xyz::StructOfArrayOfSeqOfLong*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfSeqOfLong)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfSeqOfLong_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Xyz::StructOfArrayOfSeqOfLong");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfSeqOfLong)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"f", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "f") == 0) {
      return &static_cast<const T*>(stru)->f;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfSeqOfLong)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "f") == 0) {
      Xyz::ArrayOfSeqOfLong* lhsArr = &static_cast<T*>(lhs)->f;
      const Xyz::ArrayOfSeqOfLong* rhsArr = static_cast<const Xyz::ArrayOfSeqOfLong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 6; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfSeqOfLong)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfSeqOfLong)");
  }
};

template<>
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfSeqOfLong>()
{
  static MetaStructImpl<Xyz::StructOfArrayOfSeqOfLong> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfSeqOfLong*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Xyz::StructOfArrayOfSeqOfLong>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
bool StructOfArrayOfSeqOfLong::operator==(const StructOfArrayOfSeqOfLong& rhs) const
{
  for (int i0 = 0; i0 < 6; ++i0) {
    if (f[i0] != rhs.f[i0]) {
      return false;
    }
  }
  return true;
}

void swap(StructOfArrayOfSeqOfLong& lhs, StructOfArrayOfSeqOfLong& rhs)
{
  using std::swap;
  std::swap_ranges(lhs.f, lhs.f + 6, rhs.f);
}

ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const StructOfArrayOfSeqOfLong&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, StructOfArrayOfSeqOfLong&) { return true; }

}

/* End STRUCT: StructOfArrayOfSeqOfLong */


/* Begin STRUCT: StructOfArrayOfSeqOfAnEnum */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::StructOfArrayOfSeqOfAnEnum& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  Xyz::ArrayOfSeqOfAnEnum_forany stru_f(const_cast<Xyz::ArrayOfSeqOfAnEnum_slice*>(stru.f));
  gen_find_size(stru_f, size, padding);
}

bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfSeqOfAnEnum& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfSeqOfAnEnum_forany stru_f(const_cast<Xyz::ArrayOfSeqOfAnEnum_slice*>(stru.f));
  return (strm << stru_f);
}

bool operator>>(Serializer& strm, Xyz::StructOfArrayOfSeqOfAnEnum& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfSeqOfAnEnum_forany stru_f(const_cast<Xyz::ArrayOfSeqOfAnEnum_slice*>(stru.f));
  return (strm >> stru_f);
}

size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfSeqOfAnEnum& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfSeqOfAnEnum> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfSeqOfAnEnum> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfSeqOfAnEnum> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfSeqOfAnEnum> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
::DDS::DataWriter_ptr StructOfArrayOfSeqOfAnEnumTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<StructOfArrayOfSeqOfAnEnum> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr StructOfArrayOfSeqOfAnEnumTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfSeqOfAnEnum> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr StructOfArrayOfSeqOfAnEnumTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfSeqOfAnEnum> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<StructOfArrayOfSeqOfAnEnum, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& StructOfArrayOfSeqOfAnEnumTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<StructOfArrayOfSeqOfAnEnum>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool StructOfArrayOfSeqOfAnEnumTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* StructOfArrayOfSeqOfAnEnumTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
StructOfArrayOfSeqOfAnEnumTypeSupport::_ptr_type StructOfArrayOfSeqOfAnEnumTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Xyz::StructOfArrayOfSeqOfAnEnum> : MetaStruct {
  typedef Xyz::StructOfArrayOfSeqOfAnEnum T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Xyz::StructOfArrayOfSeqOfAnEnum& typed = *static_cast<const Xyz::StructOfArrayOfSeqOfAnEnum*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfSeqOfAnEnum)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfSeqOfAnEnum_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Xyz::StructOfArrayOfSeqOfAnEnum");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfSeqOfAnEnum)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"f", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "f") == 0) {
      return &static_cast<const T*>(stru)->f;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfSeqOfAnEnum)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "f") == 0) {
      Xyz::ArrayOfSeqOfAnEnum* lhsArr = &static_cast<T*>(lhs)->f;
      const Xyz::ArrayOfSeqOfAnEnum* rhsArr = static_cast<const Xyz::ArrayOfSeqOfAnEnum*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 6; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfSeqOfAnEnum)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfSeqOfAnEnum)");
  }
};

template<>
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfSeqOfAnEnum>()
{
  static MetaStructImpl<Xyz::StructOfArrayOfSeqOfAnEnum> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfSeqOfAnEnum*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Xyz::StructOfArrayOfSeqOfAnEnum>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
bool StructOfArrayOfSeqOfAnEnum::operator==(const StructOfArrayOfSeqOfAnEnum& rhs) const
{
  for (int i0 = 0; i0 < 6; ++i0) {
    if (f[i0] != rhs.f[i0]) {
      return false;
    }
  }
  return true;
}

void swap(StructOfArrayOfSeqOfAnEnum& lhs, StructOfArrayOfSeqOfAnEnum& rhs)
{
  using std::swap;
  std::swap_ranges(lhs.f, lhs.f + 6, rhs.f);
}

ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const StructOfArrayOfSeqOfAnEnum&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, StructOfArrayOfSeqOfAnEnum&) { return true; }

}

/* End STRUCT: StructOfArrayOfSeqOfAnEnum */

/* End MODULE: Xyz */
