/* Generated by /Users/yc/MyGithub/imac-project/OpenDDS/OpenDDS-3.10/bin/opendds_idl version 3.10 (ACE version 6.2a_p11) running on input file ../../../DCPS/Compiler/idl_test3_lib/FooDef.idl */
#include "FooDefTypeSupportImpl.h"

#include <algorithm>
#include <cstring>
#include <stdexcept>
#include "dds/DCPS/BuiltInTopicUtils.h"
#include "dds/DCPS/ContentFilteredTopicImpl.h"
#include "dds/DCPS/DataReaderImpl_T.h"
#include "dds/DCPS/DataWriterImpl_T.h"
#include "dds/DCPS/FilterEvaluator.h"
#include "dds/DCPS/MultiTopicDataReader_T.h"
#include "dds/DCPS/PoolAllocator.h"
#include "dds/DCPS/PublicationInstance.h"
#include "dds/DCPS/PublisherImpl.h"
#include "dds/DCPS/Qos_Helper.h"
#include "dds/DCPS/RakeData.h"
#include "dds/DCPS/RakeResults_T.h"
#include "dds/DCPS/ReceivedDataElementList.h"
#include "dds/DCPS/Registered_Data_Types.h"
#include "dds/DCPS/Service_Participant.h"
#include "dds/DCPS/SubscriberImpl.h"
#include "dds/DCPS/Util.h"
#include "dds/DCPS/debug.h"
#include "dds/DdsDcpsDomainC.h"
#include "SharedTypesTypeSupportImpl.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: Xyz */



/* Begin ENUM: AnEnum */


/* End ENUM: AnEnum */


/* Begin TYPEDEF: SeqOfBoolean */


/* End TYPEDEF: SeqOfBoolean */


/* Begin TYPEDEF: SeqOfString */


/* End TYPEDEF: SeqOfString */


/* Begin TYPEDEF: SeqOfChar */


/* End TYPEDEF: SeqOfChar */


/* Begin TYPEDEF: SeqOfOctet */


/* End TYPEDEF: SeqOfOctet */


/* Begin TYPEDEF: SeqOfLong */


/* End TYPEDEF: SeqOfLong */


/* Begin TYPEDEF: SeqOfAnEnum */


/* End TYPEDEF: SeqOfAnEnum */


/* Begin TYPEDEF: ArrayOfBoolean */


/* End TYPEDEF: ArrayOfBoolean */


/* Begin TYPEDEF: ArrayOfString */


/* End TYPEDEF: ArrayOfString */


/* Begin TYPEDEF: ArrayOfChar */


/* End TYPEDEF: ArrayOfChar */


/* Begin TYPEDEF: ArrayOfOctet */


/* End TYPEDEF: ArrayOfOctet */


/* Begin TYPEDEF: ArrayOfLong */


/* End TYPEDEF: ArrayOfLong */


/* Begin TYPEDEF: ArrayOfAnEnum */


/* End TYPEDEF: ArrayOfAnEnum */


/* Begin TYPEDEF: ArrayOfSeqOfBoolean */


/* End TYPEDEF: ArrayOfSeqOfBoolean */


/* Begin TYPEDEF: ArrayOfSeqOfString */


/* End TYPEDEF: ArrayOfSeqOfString */


/* Begin TYPEDEF: ArrayOfSeqOfChar */


/* End TYPEDEF: ArrayOfSeqOfChar */


/* Begin TYPEDEF: ArrayOfSeqOfOctet */


/* End TYPEDEF: ArrayOfSeqOfOctet */


/* Begin TYPEDEF: ArrayOfSeqOfLong */


/* End TYPEDEF: ArrayOfSeqOfLong */


/* Begin TYPEDEF: ArrayOfSeqOfAnEnum */


/* End TYPEDEF: ArrayOfSeqOfAnEnum */

/* End MODULE: Xyz */


/* Begin MODULE: Xyz */



/* Begin TYPEDEF: SeqOfArrayOfBoolean */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::SeqOfArrayOfBoolean& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    Xyz::ArrayOfBoolean_var tmp_var = Xyz::ArrayOfBoolean_dup(seq[i]);
    Xyz::ArrayOfBoolean_forany tmp = tmp_var.inout();
    gen_find_size(tmp, size, padding);
  }
}

bool operator<<(Serializer& strm, const Xyz::SeqOfArrayOfBoolean& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    Xyz::ArrayOfBoolean_var tmp_var = Xyz::ArrayOfBoolean_dup(seq[i]);
    Xyz::ArrayOfBoolean_forany tmp = tmp_var.inout();
    if (!(strm << tmp)) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::SeqOfArrayOfBoolean& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > seq.maximum()) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    Xyz::ArrayOfBoolean_var tmp = Xyz::ArrayOfBoolean_alloc();
    Xyz::ArrayOfBoolean_forany fa = tmp.inout();
    if (!(strm >> fa)) {
      return false;
    }
    Xyz::ArrayOfBoolean_copy(seq[i], tmp.in());
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::SeqOfArrayOfBoolean*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfBoolean_forany*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfArrayOfBoolean */


/* Begin TYPEDEF: SeqOfArrayOfString */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::SeqOfArrayOfString& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    Xyz::ArrayOfString_var tmp_var = Xyz::ArrayOfString_dup(seq[i]);
    Xyz::ArrayOfString_forany tmp = tmp_var.inout();
    gen_find_size(tmp, size, padding);
  }
}

bool operator<<(Serializer& strm, const Xyz::SeqOfArrayOfString& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    Xyz::ArrayOfString_var tmp_var = Xyz::ArrayOfString_dup(seq[i]);
    Xyz::ArrayOfString_forany tmp = tmp_var.inout();
    if (!(strm << tmp)) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::SeqOfArrayOfString& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > seq.maximum()) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    Xyz::ArrayOfString_var tmp = Xyz::ArrayOfString_alloc();
    Xyz::ArrayOfString_forany fa = tmp.inout();
    if (!(strm >> fa)) {
      return false;
    }
    Xyz::ArrayOfString_copy(seq[i], tmp.in());
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::SeqOfArrayOfString*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfString_forany*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfArrayOfString */


/* Begin TYPEDEF: SeqOfArrayOfChar */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::SeqOfArrayOfChar& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    Xyz::ArrayOfChar_var tmp_var = Xyz::ArrayOfChar_dup(seq[i]);
    Xyz::ArrayOfChar_forany tmp = tmp_var.inout();
    gen_find_size(tmp, size, padding);
  }
}

bool operator<<(Serializer& strm, const Xyz::SeqOfArrayOfChar& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    Xyz::ArrayOfChar_var tmp_var = Xyz::ArrayOfChar_dup(seq[i]);
    Xyz::ArrayOfChar_forany tmp = tmp_var.inout();
    if (!(strm << tmp)) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::SeqOfArrayOfChar& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > seq.maximum()) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    Xyz::ArrayOfChar_var tmp = Xyz::ArrayOfChar_alloc();
    Xyz::ArrayOfChar_forany fa = tmp.inout();
    if (!(strm >> fa)) {
      return false;
    }
    Xyz::ArrayOfChar_copy(seq[i], tmp.in());
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::SeqOfArrayOfChar*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfChar_forany*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfArrayOfChar */


/* Begin TYPEDEF: SeqOfArrayOfOctet */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::SeqOfArrayOfOctet& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    Xyz::ArrayOfOctet_var tmp_var = Xyz::ArrayOfOctet_dup(seq[i]);
    Xyz::ArrayOfOctet_forany tmp = tmp_var.inout();
    gen_find_size(tmp, size, padding);
  }
}

bool operator<<(Serializer& strm, const Xyz::SeqOfArrayOfOctet& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    Xyz::ArrayOfOctet_var tmp_var = Xyz::ArrayOfOctet_dup(seq[i]);
    Xyz::ArrayOfOctet_forany tmp = tmp_var.inout();
    if (!(strm << tmp)) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::SeqOfArrayOfOctet& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > seq.maximum()) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    Xyz::ArrayOfOctet_var tmp = Xyz::ArrayOfOctet_alloc();
    Xyz::ArrayOfOctet_forany fa = tmp.inout();
    if (!(strm >> fa)) {
      return false;
    }
    Xyz::ArrayOfOctet_copy(seq[i], tmp.in());
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::SeqOfArrayOfOctet*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfOctet_forany*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfArrayOfOctet */


/* Begin TYPEDEF: SeqOfArrayOfLong */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::SeqOfArrayOfLong& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    Xyz::ArrayOfLong_var tmp_var = Xyz::ArrayOfLong_dup(seq[i]);
    Xyz::ArrayOfLong_forany tmp = tmp_var.inout();
    gen_find_size(tmp, size, padding);
  }
}

bool operator<<(Serializer& strm, const Xyz::SeqOfArrayOfLong& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    Xyz::ArrayOfLong_var tmp_var = Xyz::ArrayOfLong_dup(seq[i]);
    Xyz::ArrayOfLong_forany tmp = tmp_var.inout();
    if (!(strm << tmp)) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::SeqOfArrayOfLong& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > seq.maximum()) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    Xyz::ArrayOfLong_var tmp = Xyz::ArrayOfLong_alloc();
    Xyz::ArrayOfLong_forany fa = tmp.inout();
    if (!(strm >> fa)) {
      return false;
    }
    Xyz::ArrayOfLong_copy(seq[i], tmp.in());
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::SeqOfArrayOfLong*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfLong_forany*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfArrayOfLong */


/* Begin TYPEDEF: SeqOfArrayOfAnEnum */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::SeqOfArrayOfAnEnum& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    Xyz::ArrayOfAnEnum_var tmp_var = Xyz::ArrayOfAnEnum_dup(seq[i]);
    Xyz::ArrayOfAnEnum_forany tmp = tmp_var.inout();
    gen_find_size(tmp, size, padding);
  }
}

bool operator<<(Serializer& strm, const Xyz::SeqOfArrayOfAnEnum& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    Xyz::ArrayOfAnEnum_var tmp_var = Xyz::ArrayOfAnEnum_dup(seq[i]);
    Xyz::ArrayOfAnEnum_forany tmp = tmp_var.inout();
    if (!(strm << tmp)) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::SeqOfArrayOfAnEnum& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > seq.maximum()) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    Xyz::ArrayOfAnEnum_var tmp = Xyz::ArrayOfAnEnum_alloc();
    Xyz::ArrayOfAnEnum_forany fa = tmp.inout();
    if (!(strm >> fa)) {
      return false;
    }
    Xyz::ArrayOfAnEnum_copy(seq[i], tmp.in());
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::SeqOfArrayOfAnEnum*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfAnEnum_forany*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfArrayOfAnEnum */


/* Begin TYPEDEF: ArrayOfArrayOfBoolean */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::ArrayOfArrayOfBoolean_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  for (CORBA::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfBoolean_var tmp_var = Xyz::ArrayOfBoolean_dup(arr[i0]);
    Xyz::ArrayOfBoolean_forany tmp = tmp_var.inout();
    gen_find_size(tmp, size, padding);
  }
}

bool operator<<(Serializer& strm, const Xyz::ArrayOfArrayOfBoolean_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfBoolean_var tmp_var = Xyz::ArrayOfBoolean_dup(arr[i0]);
    Xyz::ArrayOfBoolean_forany tmp = tmp_var.inout();
    if (!(strm << tmp)) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::ArrayOfArrayOfBoolean_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfBoolean_var tmp = Xyz::ArrayOfBoolean_alloc();
    Xyz::ArrayOfBoolean_forany fa = tmp.inout();
    if (!(strm >> fa)) {
      return false;
    }
    Xyz::ArrayOfBoolean_copy(arr[i0], tmp.in());
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::ArrayOfArrayOfBoolean_forany*)
{
  ACE_UNUSED_ARG(ser);
  for (ACE_CDR::ULong i = 0; i < 7; ++i) {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfBoolean_forany*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
ArrayOfArrayOfBoolean_slice* ArrayOfArrayOfBoolean_alloc()
{
  void* const raw = ACE_Allocator::instance()->malloc(sizeof(ArrayOfArrayOfBoolean));
  ArrayOfArrayOfBoolean_slice* const slice = static_cast<ArrayOfArrayOfBoolean_slice*>(raw);
  ArrayOfArrayOfBoolean_init_i(slice);
  return slice;
}

void ArrayOfArrayOfBoolean_init_i(Xyz::ArrayOfBoolean* begin)
{
  for (ACE_CDR::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfBoolean_init_i(begin[i0]);
  }
}

void ArrayOfArrayOfBoolean_fini_i(Xyz::ArrayOfBoolean* begin)
{
  for (ACE_CDR::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfBoolean_fini_i(begin[i0]);
  }
}

void ArrayOfArrayOfBoolean_free(ArrayOfArrayOfBoolean_slice* slice)
{
  if (!slice) return;
  ArrayOfArrayOfBoolean_fini_i(slice);
  ACE_Allocator::instance()->free(slice);
}

ArrayOfArrayOfBoolean_slice* ArrayOfArrayOfBoolean_dup(const ArrayOfArrayOfBoolean_slice* slice)
{
  ArrayOfArrayOfBoolean_slice* const arr = ArrayOfArrayOfBoolean_alloc();
  if (arr) ArrayOfArrayOfBoolean_copy(arr, slice);
  return arr;
}

void ArrayOfArrayOfBoolean_copy(ArrayOfArrayOfBoolean_slice* dst, const ArrayOfArrayOfBoolean_slice* src)
{
  if (!src || !dst) return;
  for (ACE_CDR::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfBoolean_copy(dst[i0], src[i0]);
  }
}

}

/* End TYPEDEF: ArrayOfArrayOfBoolean */


/* Begin TYPEDEF: ArrayOfArrayOfString */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::ArrayOfArrayOfString_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  for (CORBA::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfString_var tmp_var = Xyz::ArrayOfString_dup(arr[i0]);
    Xyz::ArrayOfString_forany tmp = tmp_var.inout();
    gen_find_size(tmp, size, padding);
  }
}

bool operator<<(Serializer& strm, const Xyz::ArrayOfArrayOfString_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfString_var tmp_var = Xyz::ArrayOfString_dup(arr[i0]);
    Xyz::ArrayOfString_forany tmp = tmp_var.inout();
    if (!(strm << tmp)) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::ArrayOfArrayOfString_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfString_var tmp = Xyz::ArrayOfString_alloc();
    Xyz::ArrayOfString_forany fa = tmp.inout();
    if (!(strm >> fa)) {
      return false;
    }
    Xyz::ArrayOfString_copy(arr[i0], tmp.in());
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::ArrayOfArrayOfString_forany*)
{
  ACE_UNUSED_ARG(ser);
  for (ACE_CDR::ULong i = 0; i < 7; ++i) {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfString_forany*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
ArrayOfArrayOfString_slice* ArrayOfArrayOfString_alloc()
{
  void* const raw = ACE_Allocator::instance()->malloc(sizeof(ArrayOfArrayOfString));
  ArrayOfArrayOfString_slice* const slice = static_cast<ArrayOfArrayOfString_slice*>(raw);
  ArrayOfArrayOfString_init_i(slice);
  return slice;
}

void ArrayOfArrayOfString_init_i(Xyz::ArrayOfString* begin)
{
  for (ACE_CDR::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfString_init_i(begin[i0]);
  }
}

void ArrayOfArrayOfString_fini_i(Xyz::ArrayOfString* begin)
{
  for (ACE_CDR::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfString_fini_i(begin[i0]);
  }
}

void ArrayOfArrayOfString_free(ArrayOfArrayOfString_slice* slice)
{
  if (!slice) return;
  ArrayOfArrayOfString_fini_i(slice);
  ACE_Allocator::instance()->free(slice);
}

ArrayOfArrayOfString_slice* ArrayOfArrayOfString_dup(const ArrayOfArrayOfString_slice* slice)
{
  ArrayOfArrayOfString_slice* const arr = ArrayOfArrayOfString_alloc();
  if (arr) ArrayOfArrayOfString_copy(arr, slice);
  return arr;
}

void ArrayOfArrayOfString_copy(ArrayOfArrayOfString_slice* dst, const ArrayOfArrayOfString_slice* src)
{
  if (!src || !dst) return;
  for (ACE_CDR::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfString_copy(dst[i0], src[i0]);
  }
}

}

/* End TYPEDEF: ArrayOfArrayOfString */


/* Begin TYPEDEF: ArrayOfArrayOfChar */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::ArrayOfArrayOfChar_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  for (CORBA::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfChar_var tmp_var = Xyz::ArrayOfChar_dup(arr[i0]);
    Xyz::ArrayOfChar_forany tmp = tmp_var.inout();
    gen_find_size(tmp, size, padding);
  }
}

bool operator<<(Serializer& strm, const Xyz::ArrayOfArrayOfChar_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfChar_var tmp_var = Xyz::ArrayOfChar_dup(arr[i0]);
    Xyz::ArrayOfChar_forany tmp = tmp_var.inout();
    if (!(strm << tmp)) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::ArrayOfArrayOfChar_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfChar_var tmp = Xyz::ArrayOfChar_alloc();
    Xyz::ArrayOfChar_forany fa = tmp.inout();
    if (!(strm >> fa)) {
      return false;
    }
    Xyz::ArrayOfChar_copy(arr[i0], tmp.in());
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::ArrayOfArrayOfChar_forany*)
{
  ACE_UNUSED_ARG(ser);
  for (ACE_CDR::ULong i = 0; i < 7; ++i) {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfChar_forany*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
ArrayOfArrayOfChar_slice* ArrayOfArrayOfChar_alloc()
{
  void* const raw = ACE_Allocator::instance()->malloc(sizeof(ArrayOfArrayOfChar));
  ArrayOfArrayOfChar_slice* const slice = static_cast<ArrayOfArrayOfChar_slice*>(raw);
  ArrayOfArrayOfChar_init_i(slice);
  return slice;
}

void ArrayOfArrayOfChar_init_i(Xyz::ArrayOfChar* begin)
{
  for (ACE_CDR::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfChar_init_i(begin[i0]);
  }
}

void ArrayOfArrayOfChar_fini_i(Xyz::ArrayOfChar* begin)
{
  for (ACE_CDR::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfChar_fini_i(begin[i0]);
  }
}

void ArrayOfArrayOfChar_free(ArrayOfArrayOfChar_slice* slice)
{
  if (!slice) return;
  ArrayOfArrayOfChar_fini_i(slice);
  ACE_Allocator::instance()->free(slice);
}

ArrayOfArrayOfChar_slice* ArrayOfArrayOfChar_dup(const ArrayOfArrayOfChar_slice* slice)
{
  ArrayOfArrayOfChar_slice* const arr = ArrayOfArrayOfChar_alloc();
  if (arr) ArrayOfArrayOfChar_copy(arr, slice);
  return arr;
}

void ArrayOfArrayOfChar_copy(ArrayOfArrayOfChar_slice* dst, const ArrayOfArrayOfChar_slice* src)
{
  if (!src || !dst) return;
  for (ACE_CDR::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfChar_copy(dst[i0], src[i0]);
  }
}

}

/* End TYPEDEF: ArrayOfArrayOfChar */


/* Begin TYPEDEF: ArrayOfArrayOfOctet */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::ArrayOfArrayOfOctet_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  for (CORBA::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfOctet_var tmp_var = Xyz::ArrayOfOctet_dup(arr[i0]);
    Xyz::ArrayOfOctet_forany tmp = tmp_var.inout();
    gen_find_size(tmp, size, padding);
  }
}

bool operator<<(Serializer& strm, const Xyz::ArrayOfArrayOfOctet_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfOctet_var tmp_var = Xyz::ArrayOfOctet_dup(arr[i0]);
    Xyz::ArrayOfOctet_forany tmp = tmp_var.inout();
    if (!(strm << tmp)) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::ArrayOfArrayOfOctet_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfOctet_var tmp = Xyz::ArrayOfOctet_alloc();
    Xyz::ArrayOfOctet_forany fa = tmp.inout();
    if (!(strm >> fa)) {
      return false;
    }
    Xyz::ArrayOfOctet_copy(arr[i0], tmp.in());
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::ArrayOfArrayOfOctet_forany*)
{
  ACE_UNUSED_ARG(ser);
  for (ACE_CDR::ULong i = 0; i < 7; ++i) {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfOctet_forany*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
ArrayOfArrayOfOctet_slice* ArrayOfArrayOfOctet_alloc()
{
  void* const raw = ACE_Allocator::instance()->malloc(sizeof(ArrayOfArrayOfOctet));
  ArrayOfArrayOfOctet_slice* const slice = static_cast<ArrayOfArrayOfOctet_slice*>(raw);
  ArrayOfArrayOfOctet_init_i(slice);
  return slice;
}

void ArrayOfArrayOfOctet_init_i(Xyz::ArrayOfOctet* begin)
{
  for (ACE_CDR::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfOctet_init_i(begin[i0]);
  }
}

void ArrayOfArrayOfOctet_fini_i(Xyz::ArrayOfOctet* begin)
{
  for (ACE_CDR::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfOctet_fini_i(begin[i0]);
  }
}

void ArrayOfArrayOfOctet_free(ArrayOfArrayOfOctet_slice* slice)
{
  if (!slice) return;
  ArrayOfArrayOfOctet_fini_i(slice);
  ACE_Allocator::instance()->free(slice);
}

ArrayOfArrayOfOctet_slice* ArrayOfArrayOfOctet_dup(const ArrayOfArrayOfOctet_slice* slice)
{
  ArrayOfArrayOfOctet_slice* const arr = ArrayOfArrayOfOctet_alloc();
  if (arr) ArrayOfArrayOfOctet_copy(arr, slice);
  return arr;
}

void ArrayOfArrayOfOctet_copy(ArrayOfArrayOfOctet_slice* dst, const ArrayOfArrayOfOctet_slice* src)
{
  if (!src || !dst) return;
  for (ACE_CDR::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfOctet_copy(dst[i0], src[i0]);
  }
}

}

/* End TYPEDEF: ArrayOfArrayOfOctet */


/* Begin TYPEDEF: ArrayOfArrayOfLong */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::ArrayOfArrayOfLong_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  for (CORBA::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfLong_var tmp_var = Xyz::ArrayOfLong_dup(arr[i0]);
    Xyz::ArrayOfLong_forany tmp = tmp_var.inout();
    gen_find_size(tmp, size, padding);
  }
}

bool operator<<(Serializer& strm, const Xyz::ArrayOfArrayOfLong_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfLong_var tmp_var = Xyz::ArrayOfLong_dup(arr[i0]);
    Xyz::ArrayOfLong_forany tmp = tmp_var.inout();
    if (!(strm << tmp)) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::ArrayOfArrayOfLong_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfLong_var tmp = Xyz::ArrayOfLong_alloc();
    Xyz::ArrayOfLong_forany fa = tmp.inout();
    if (!(strm >> fa)) {
      return false;
    }
    Xyz::ArrayOfLong_copy(arr[i0], tmp.in());
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::ArrayOfArrayOfLong_forany*)
{
  ACE_UNUSED_ARG(ser);
  for (ACE_CDR::ULong i = 0; i < 7; ++i) {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfLong_forany*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
ArrayOfArrayOfLong_slice* ArrayOfArrayOfLong_alloc()
{
  void* const raw = ACE_Allocator::instance()->malloc(sizeof(ArrayOfArrayOfLong));
  ArrayOfArrayOfLong_slice* const slice = static_cast<ArrayOfArrayOfLong_slice*>(raw);
  ArrayOfArrayOfLong_init_i(slice);
  return slice;
}

void ArrayOfArrayOfLong_init_i(Xyz::ArrayOfLong* begin)
{
  for (ACE_CDR::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfLong_init_i(begin[i0]);
  }
}

void ArrayOfArrayOfLong_fini_i(Xyz::ArrayOfLong* begin)
{
  for (ACE_CDR::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfLong_fini_i(begin[i0]);
  }
}

void ArrayOfArrayOfLong_free(ArrayOfArrayOfLong_slice* slice)
{
  if (!slice) return;
  ArrayOfArrayOfLong_fini_i(slice);
  ACE_Allocator::instance()->free(slice);
}

ArrayOfArrayOfLong_slice* ArrayOfArrayOfLong_dup(const ArrayOfArrayOfLong_slice* slice)
{
  ArrayOfArrayOfLong_slice* const arr = ArrayOfArrayOfLong_alloc();
  if (arr) ArrayOfArrayOfLong_copy(arr, slice);
  return arr;
}

void ArrayOfArrayOfLong_copy(ArrayOfArrayOfLong_slice* dst, const ArrayOfArrayOfLong_slice* src)
{
  if (!src || !dst) return;
  for (ACE_CDR::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfLong_copy(dst[i0], src[i0]);
  }
}

}

/* End TYPEDEF: ArrayOfArrayOfLong */


/* Begin TYPEDEF: ArrayOfArrayOfAnEnum */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::ArrayOfArrayOfAnEnum_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  for (CORBA::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfAnEnum_var tmp_var = Xyz::ArrayOfAnEnum_dup(arr[i0]);
    Xyz::ArrayOfAnEnum_forany tmp = tmp_var.inout();
    gen_find_size(tmp, size, padding);
  }
}

bool operator<<(Serializer& strm, const Xyz::ArrayOfArrayOfAnEnum_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfAnEnum_var tmp_var = Xyz::ArrayOfAnEnum_dup(arr[i0]);
    Xyz::ArrayOfAnEnum_forany tmp = tmp_var.inout();
    if (!(strm << tmp)) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::ArrayOfArrayOfAnEnum_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfAnEnum_var tmp = Xyz::ArrayOfAnEnum_alloc();
    Xyz::ArrayOfAnEnum_forany fa = tmp.inout();
    if (!(strm >> fa)) {
      return false;
    }
    Xyz::ArrayOfAnEnum_copy(arr[i0], tmp.in());
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::ArrayOfArrayOfAnEnum_forany*)
{
  ACE_UNUSED_ARG(ser);
  for (ACE_CDR::ULong i = 0; i < 7; ++i) {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfAnEnum_forany*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
ArrayOfArrayOfAnEnum_slice* ArrayOfArrayOfAnEnum_alloc()
{
  void* const raw = ACE_Allocator::instance()->malloc(sizeof(ArrayOfArrayOfAnEnum));
  ArrayOfArrayOfAnEnum_slice* const slice = static_cast<ArrayOfArrayOfAnEnum_slice*>(raw);
  ArrayOfArrayOfAnEnum_init_i(slice);
  return slice;
}

void ArrayOfArrayOfAnEnum_init_i(Xyz::ArrayOfAnEnum* begin)
{
  for (ACE_CDR::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfAnEnum_init_i(begin[i0]);
  }
}

void ArrayOfArrayOfAnEnum_fini_i(Xyz::ArrayOfAnEnum* begin)
{
  for (ACE_CDR::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfAnEnum_fini_i(begin[i0]);
  }
}

void ArrayOfArrayOfAnEnum_free(ArrayOfArrayOfAnEnum_slice* slice)
{
  if (!slice) return;
  ArrayOfArrayOfAnEnum_fini_i(slice);
  ACE_Allocator::instance()->free(slice);
}

ArrayOfArrayOfAnEnum_slice* ArrayOfArrayOfAnEnum_dup(const ArrayOfArrayOfAnEnum_slice* slice)
{
  ArrayOfArrayOfAnEnum_slice* const arr = ArrayOfArrayOfAnEnum_alloc();
  if (arr) ArrayOfArrayOfAnEnum_copy(arr, slice);
  return arr;
}

void ArrayOfArrayOfAnEnum_copy(ArrayOfArrayOfAnEnum_slice* dst, const ArrayOfArrayOfAnEnum_slice* src)
{
  if (!src || !dst) return;
  for (ACE_CDR::ULong i0 = 0; i0 < 7; ++i0) {
    Xyz::ArrayOfAnEnum_copy(dst[i0], src[i0]);
  }
}

}

/* End TYPEDEF: ArrayOfArrayOfAnEnum */


/* Begin STRUCT: StructOfArrayOfArrayOfBoolean */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::StructOfArrayOfArrayOfBoolean& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  Xyz::ArrayOfArrayOfBoolean_forany stru_f(const_cast<Xyz::ArrayOfArrayOfBoolean_slice*>(stru.f));
  gen_find_size(stru_f, size, padding);
}

bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfArrayOfBoolean& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfArrayOfBoolean_forany stru_f(const_cast<Xyz::ArrayOfArrayOfBoolean_slice*>(stru.f));
  return (strm << stru_f);
}

bool operator>>(Serializer& strm, Xyz::StructOfArrayOfArrayOfBoolean& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfArrayOfBoolean_forany stru_f(const_cast<Xyz::ArrayOfArrayOfBoolean_slice*>(stru.f));
  return (strm >> stru_f);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Xyz::StructOfArrayOfArrayOfBoolean> : MetaStruct {
  typedef Xyz::StructOfArrayOfArrayOfBoolean T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Xyz::StructOfArrayOfArrayOfBoolean& typed = *static_cast<const Xyz::StructOfArrayOfArrayOfBoolean*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfArrayOfBoolean)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfArrayOfBoolean_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Xyz::StructOfArrayOfArrayOfBoolean");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfArrayOfBoolean)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"f", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "f") == 0) {
      return &static_cast<const T*>(stru)->f;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfArrayOfBoolean)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "f") == 0) {
      Xyz::ArrayOfArrayOfBoolean* lhsArr = &static_cast<T*>(lhs)->f;
      const Xyz::ArrayOfArrayOfBoolean* rhsArr = static_cast<const Xyz::ArrayOfArrayOfBoolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      Xyz::ArrayOfArrayOfBoolean_forany rhsForany(const_cast<Xyz::ArrayOfArrayOfBoolean_slice*>(*rhsArr));
      size_t size = 0, padding = 0;
      gen_find_size(rhsForany, size, padding);
      ACE_Message_Block mb(size);
      Serializer ser_out(&mb);
      ser_out << rhsForany;
      Xyz::ArrayOfArrayOfBoolean_forany lhsForany(*lhsArr);
      Serializer ser_in(&mb);
      ser_in >> lhsForany;
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfArrayOfBoolean)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfArrayOfBoolean)");
  }
};

template<>
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfArrayOfBoolean>()
{
  static MetaStructImpl<Xyz::StructOfArrayOfArrayOfBoolean> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfArrayOfBoolean*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Xyz::StructOfArrayOfArrayOfBoolean>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
bool StructOfArrayOfArrayOfBoolean::operator==(const StructOfArrayOfArrayOfBoolean& rhs) const
{
  for (int i0 = 0; i0 < 7; ++i0) {
    for (int i1 = 0; i1 < 5; ++i1) {
      if (f[i0][i1] != rhs.f[i0][i1]) {
        return false;
      }
    }
  }
  return true;
}

ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const StructOfArrayOfArrayOfBoolean&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, StructOfArrayOfArrayOfBoolean&) { return true; }

}

/* End STRUCT: StructOfArrayOfArrayOfBoolean */


/* Begin STRUCT: StructOfArrayOfArrayOfString */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::StructOfArrayOfArrayOfString& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  Xyz::ArrayOfArrayOfString_forany stru_f(const_cast<Xyz::ArrayOfArrayOfString_slice*>(stru.f));
  gen_find_size(stru_f, size, padding);
}

bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfArrayOfString& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfArrayOfString_forany stru_f(const_cast<Xyz::ArrayOfArrayOfString_slice*>(stru.f));
  return (strm << stru_f);
}

bool operator>>(Serializer& strm, Xyz::StructOfArrayOfArrayOfString& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfArrayOfString_forany stru_f(const_cast<Xyz::ArrayOfArrayOfString_slice*>(stru.f));
  return (strm >> stru_f);
}

size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfArrayOfString& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 420;
}

size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfArrayOfString> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfArrayOfString> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfArrayOfString> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfArrayOfString> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
::DDS::DataWriter_ptr StructOfArrayOfArrayOfStringTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<StructOfArrayOfArrayOfString> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr StructOfArrayOfArrayOfStringTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfArrayOfString> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr StructOfArrayOfArrayOfStringTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfArrayOfString> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<StructOfArrayOfArrayOfString, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& StructOfArrayOfArrayOfStringTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<StructOfArrayOfArrayOfString>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool StructOfArrayOfArrayOfStringTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* StructOfArrayOfArrayOfStringTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
StructOfArrayOfArrayOfStringTypeSupport::_ptr_type StructOfArrayOfArrayOfStringTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Xyz::StructOfArrayOfArrayOfString> : MetaStruct {
  typedef Xyz::StructOfArrayOfArrayOfString T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Xyz::StructOfArrayOfArrayOfString& typed = *static_cast<const Xyz::StructOfArrayOfArrayOfString*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfArrayOfString)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfArrayOfString_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Xyz::StructOfArrayOfArrayOfString");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfArrayOfString)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"f", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "f") == 0) {
      return &static_cast<const T*>(stru)->f;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfArrayOfString)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "f") == 0) {
      Xyz::ArrayOfArrayOfString* lhsArr = &static_cast<T*>(lhs)->f;
      const Xyz::ArrayOfArrayOfString* rhsArr = static_cast<const Xyz::ArrayOfArrayOfString*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      Xyz::ArrayOfArrayOfString_forany rhsForany(const_cast<Xyz::ArrayOfArrayOfString_slice*>(*rhsArr));
      size_t size = 0, padding = 0;
      gen_find_size(rhsForany, size, padding);
      ACE_Message_Block mb(size);
      Serializer ser_out(&mb);
      ser_out << rhsForany;
      Xyz::ArrayOfArrayOfString_forany lhsForany(*lhsArr);
      Serializer ser_in(&mb);
      ser_in >> lhsForany;
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfArrayOfString)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfArrayOfString)");
  }
};

template<>
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfArrayOfString>()
{
  static MetaStructImpl<Xyz::StructOfArrayOfArrayOfString> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfArrayOfString*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Xyz::StructOfArrayOfArrayOfString>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
bool StructOfArrayOfArrayOfString::operator==(const StructOfArrayOfArrayOfString& rhs) const
{
  for (int i0 = 0; i0 < 7; ++i0) {
    for (int i1 = 0; i1 < 5; ++i1) {
      if (f[i0][i1] != rhs.f[i0][i1]) {
        return false;
      }
    }
  }
  return true;
}

void swap(StructOfArrayOfArrayOfString& lhs, StructOfArrayOfArrayOfString& rhs)
{
  using std::swap;
  std::swap_ranges(lhs.f[0], lhs.f[0] + 35, rhs.f[0]);
}

ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const StructOfArrayOfArrayOfString&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, StructOfArrayOfArrayOfString&) { return true; }

}

/* End STRUCT: StructOfArrayOfArrayOfString */


/* Begin STRUCT: StructOfArrayOfArrayOfChar */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::StructOfArrayOfArrayOfChar& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  Xyz::ArrayOfArrayOfChar_forany stru_f(const_cast<Xyz::ArrayOfArrayOfChar_slice*>(stru.f));
  gen_find_size(stru_f, size, padding);
}

bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfArrayOfChar& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfArrayOfChar_forany stru_f(const_cast<Xyz::ArrayOfArrayOfChar_slice*>(stru.f));
  return (strm << stru_f);
}

bool operator>>(Serializer& strm, Xyz::StructOfArrayOfArrayOfChar& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfArrayOfChar_forany stru_f(const_cast<Xyz::ArrayOfArrayOfChar_slice*>(stru.f));
  return (strm >> stru_f);
}

size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfArrayOfChar& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 35;
}

size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfArrayOfChar> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfArrayOfChar> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfArrayOfChar> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfArrayOfChar> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
::DDS::DataWriter_ptr StructOfArrayOfArrayOfCharTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<StructOfArrayOfArrayOfChar> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr StructOfArrayOfArrayOfCharTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfArrayOfChar> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr StructOfArrayOfArrayOfCharTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfArrayOfChar> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<StructOfArrayOfArrayOfChar, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& StructOfArrayOfArrayOfCharTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<StructOfArrayOfArrayOfChar>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool StructOfArrayOfArrayOfCharTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* StructOfArrayOfArrayOfCharTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
StructOfArrayOfArrayOfCharTypeSupport::_ptr_type StructOfArrayOfArrayOfCharTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Xyz::StructOfArrayOfArrayOfChar> : MetaStruct {
  typedef Xyz::StructOfArrayOfArrayOfChar T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Xyz::StructOfArrayOfArrayOfChar& typed = *static_cast<const Xyz::StructOfArrayOfArrayOfChar*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfArrayOfChar)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfArrayOfChar_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Xyz::StructOfArrayOfArrayOfChar");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfArrayOfChar)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"f", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "f") == 0) {
      return &static_cast<const T*>(stru)->f;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfArrayOfChar)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "f") == 0) {
      Xyz::ArrayOfArrayOfChar* lhsArr = &static_cast<T*>(lhs)->f;
      const Xyz::ArrayOfArrayOfChar* rhsArr = static_cast<const Xyz::ArrayOfArrayOfChar*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      Xyz::ArrayOfArrayOfChar_forany rhsForany(const_cast<Xyz::ArrayOfArrayOfChar_slice*>(*rhsArr));
      size_t size = 0, padding = 0;
      gen_find_size(rhsForany, size, padding);
      ACE_Message_Block mb(size);
      Serializer ser_out(&mb);
      ser_out << rhsForany;
      Xyz::ArrayOfArrayOfChar_forany lhsForany(*lhsArr);
      Serializer ser_in(&mb);
      ser_in >> lhsForany;
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfArrayOfChar)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfArrayOfChar)");
  }
};

template<>
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfArrayOfChar>()
{
  static MetaStructImpl<Xyz::StructOfArrayOfArrayOfChar> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfArrayOfChar*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Xyz::StructOfArrayOfArrayOfChar>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
bool StructOfArrayOfArrayOfChar::operator==(const StructOfArrayOfArrayOfChar& rhs) const
{
  for (int i0 = 0; i0 < 7; ++i0) {
    for (int i1 = 0; i1 < 5; ++i1) {
      if (f[i0][i1] != rhs.f[i0][i1]) {
        return false;
      }
    }
  }
  return true;
}

ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const StructOfArrayOfArrayOfChar&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, StructOfArrayOfArrayOfChar&) { return true; }

}

/* End STRUCT: StructOfArrayOfArrayOfChar */


/* Begin STRUCT: StructOfArrayOfArrayOfOctet */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::StructOfArrayOfArrayOfOctet& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  Xyz::ArrayOfArrayOfOctet_forany stru_f(const_cast<Xyz::ArrayOfArrayOfOctet_slice*>(stru.f));
  gen_find_size(stru_f, size, padding);
}

bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfArrayOfOctet& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfArrayOfOctet_forany stru_f(const_cast<Xyz::ArrayOfArrayOfOctet_slice*>(stru.f));
  return (strm << stru_f);
}

bool operator>>(Serializer& strm, Xyz::StructOfArrayOfArrayOfOctet& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfArrayOfOctet_forany stru_f(const_cast<Xyz::ArrayOfArrayOfOctet_slice*>(stru.f));
  return (strm >> stru_f);
}

size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfArrayOfOctet& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 35;
}

size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfArrayOfOctet> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfArrayOfOctet> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfArrayOfOctet> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfArrayOfOctet> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
::DDS::DataWriter_ptr StructOfArrayOfArrayOfOctetTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<StructOfArrayOfArrayOfOctet> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr StructOfArrayOfArrayOfOctetTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfArrayOfOctet> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr StructOfArrayOfArrayOfOctetTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfArrayOfOctet> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<StructOfArrayOfArrayOfOctet, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& StructOfArrayOfArrayOfOctetTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<StructOfArrayOfArrayOfOctet>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool StructOfArrayOfArrayOfOctetTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* StructOfArrayOfArrayOfOctetTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
StructOfArrayOfArrayOfOctetTypeSupport::_ptr_type StructOfArrayOfArrayOfOctetTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Xyz::StructOfArrayOfArrayOfOctet> : MetaStruct {
  typedef Xyz::StructOfArrayOfArrayOfOctet T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Xyz::StructOfArrayOfArrayOfOctet& typed = *static_cast<const Xyz::StructOfArrayOfArrayOfOctet*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfArrayOfOctet)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfArrayOfOctet_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Xyz::StructOfArrayOfArrayOfOctet");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfArrayOfOctet)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"f", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "f") == 0) {
      return &static_cast<const T*>(stru)->f;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfArrayOfOctet)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "f") == 0) {
      Xyz::ArrayOfArrayOfOctet* lhsArr = &static_cast<T*>(lhs)->f;
      const Xyz::ArrayOfArrayOfOctet* rhsArr = static_cast<const Xyz::ArrayOfArrayOfOctet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      Xyz::ArrayOfArrayOfOctet_forany rhsForany(const_cast<Xyz::ArrayOfArrayOfOctet_slice*>(*rhsArr));
      size_t size = 0, padding = 0;
      gen_find_size(rhsForany, size, padding);
      ACE_Message_Block mb(size);
      Serializer ser_out(&mb);
      ser_out << rhsForany;
      Xyz::ArrayOfArrayOfOctet_forany lhsForany(*lhsArr);
      Serializer ser_in(&mb);
      ser_in >> lhsForany;
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfArrayOfOctet)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfArrayOfOctet)");
  }
};

template<>
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfArrayOfOctet>()
{
  static MetaStructImpl<Xyz::StructOfArrayOfArrayOfOctet> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfArrayOfOctet*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Xyz::StructOfArrayOfArrayOfOctet>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
bool StructOfArrayOfArrayOfOctet::operator==(const StructOfArrayOfArrayOfOctet& rhs) const
{
  for (int i0 = 0; i0 < 7; ++i0) {
    for (int i1 = 0; i1 < 5; ++i1) {
      if (f[i0][i1] != rhs.f[i0][i1]) {
        return false;
      }
    }
  }
  return true;
}

ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const StructOfArrayOfArrayOfOctet&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, StructOfArrayOfArrayOfOctet&) { return true; }

}

/* End STRUCT: StructOfArrayOfArrayOfOctet */


/* Begin STRUCT: StructOfArrayOfArrayOfLong */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::StructOfArrayOfArrayOfLong& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  Xyz::ArrayOfArrayOfLong_forany stru_f(const_cast<Xyz::ArrayOfArrayOfLong_slice*>(stru.f));
  gen_find_size(stru_f, size, padding);
}

bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfArrayOfLong& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfArrayOfLong_forany stru_f(const_cast<Xyz::ArrayOfArrayOfLong_slice*>(stru.f));
  return (strm << stru_f);
}

bool operator>>(Serializer& strm, Xyz::StructOfArrayOfArrayOfLong& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfArrayOfLong_forany stru_f(const_cast<Xyz::ArrayOfArrayOfLong_slice*>(stru.f));
  return (strm >> stru_f);
}

size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfArrayOfLong& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 140;
}

size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfArrayOfLong> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfArrayOfLong> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfArrayOfLong> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfArrayOfLong> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
::DDS::DataWriter_ptr StructOfArrayOfArrayOfLongTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<StructOfArrayOfArrayOfLong> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr StructOfArrayOfArrayOfLongTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfArrayOfLong> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr StructOfArrayOfArrayOfLongTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfArrayOfLong> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<StructOfArrayOfArrayOfLong, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& StructOfArrayOfArrayOfLongTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<StructOfArrayOfArrayOfLong>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool StructOfArrayOfArrayOfLongTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* StructOfArrayOfArrayOfLongTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
StructOfArrayOfArrayOfLongTypeSupport::_ptr_type StructOfArrayOfArrayOfLongTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Xyz::StructOfArrayOfArrayOfLong> : MetaStruct {
  typedef Xyz::StructOfArrayOfArrayOfLong T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Xyz::StructOfArrayOfArrayOfLong& typed = *static_cast<const Xyz::StructOfArrayOfArrayOfLong*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfArrayOfLong)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfArrayOfLong_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Xyz::StructOfArrayOfArrayOfLong");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfArrayOfLong)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"f", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "f") == 0) {
      return &static_cast<const T*>(stru)->f;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfArrayOfLong)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "f") == 0) {
      Xyz::ArrayOfArrayOfLong* lhsArr = &static_cast<T*>(lhs)->f;
      const Xyz::ArrayOfArrayOfLong* rhsArr = static_cast<const Xyz::ArrayOfArrayOfLong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      Xyz::ArrayOfArrayOfLong_forany rhsForany(const_cast<Xyz::ArrayOfArrayOfLong_slice*>(*rhsArr));
      size_t size = 0, padding = 0;
      gen_find_size(rhsForany, size, padding);
      ACE_Message_Block mb(size);
      Serializer ser_out(&mb);
      ser_out << rhsForany;
      Xyz::ArrayOfArrayOfLong_forany lhsForany(*lhsArr);
      Serializer ser_in(&mb);
      ser_in >> lhsForany;
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfArrayOfLong)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfArrayOfLong)");
  }
};

template<>
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfArrayOfLong>()
{
  static MetaStructImpl<Xyz::StructOfArrayOfArrayOfLong> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfArrayOfLong*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Xyz::StructOfArrayOfArrayOfLong>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
bool StructOfArrayOfArrayOfLong::operator==(const StructOfArrayOfArrayOfLong& rhs) const
{
  for (int i0 = 0; i0 < 7; ++i0) {
    for (int i1 = 0; i1 < 5; ++i1) {
      if (f[i0][i1] != rhs.f[i0][i1]) {
        return false;
      }
    }
  }
  return true;
}

ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const StructOfArrayOfArrayOfLong&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, StructOfArrayOfArrayOfLong&) { return true; }

}

/* End STRUCT: StructOfArrayOfArrayOfLong */


/* Begin STRUCT: StructOfArrayOfArrayOfAnEnum */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::StructOfArrayOfArrayOfAnEnum& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  Xyz::ArrayOfArrayOfAnEnum_forany stru_f(const_cast<Xyz::ArrayOfArrayOfAnEnum_slice*>(stru.f));
  gen_find_size(stru_f, size, padding);
}

bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfArrayOfAnEnum& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfArrayOfAnEnum_forany stru_f(const_cast<Xyz::ArrayOfArrayOfAnEnum_slice*>(stru.f));
  return (strm << stru_f);
}

bool operator>>(Serializer& strm, Xyz::StructOfArrayOfArrayOfAnEnum& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfArrayOfAnEnum_forany stru_f(const_cast<Xyz::ArrayOfArrayOfAnEnum_slice*>(stru.f));
  return (strm >> stru_f);
}

size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfArrayOfAnEnum& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 140;
}

size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfArrayOfAnEnum> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfArrayOfAnEnum> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfArrayOfAnEnum> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfArrayOfAnEnum> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
::DDS::DataWriter_ptr StructOfArrayOfArrayOfAnEnumTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<StructOfArrayOfArrayOfAnEnum> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr StructOfArrayOfArrayOfAnEnumTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfArrayOfAnEnum> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr StructOfArrayOfArrayOfAnEnumTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfArrayOfAnEnum> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<StructOfArrayOfArrayOfAnEnum, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& StructOfArrayOfArrayOfAnEnumTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<StructOfArrayOfArrayOfAnEnum>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool StructOfArrayOfArrayOfAnEnumTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* StructOfArrayOfArrayOfAnEnumTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
StructOfArrayOfArrayOfAnEnumTypeSupport::_ptr_type StructOfArrayOfArrayOfAnEnumTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Xyz::StructOfArrayOfArrayOfAnEnum> : MetaStruct {
  typedef Xyz::StructOfArrayOfArrayOfAnEnum T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Xyz::StructOfArrayOfArrayOfAnEnum& typed = *static_cast<const Xyz::StructOfArrayOfArrayOfAnEnum*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfArrayOfAnEnum)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfArrayOfAnEnum_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Xyz::StructOfArrayOfArrayOfAnEnum");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfArrayOfAnEnum)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"f", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "f") == 0) {
      return &static_cast<const T*>(stru)->f;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfArrayOfAnEnum)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "f") == 0) {
      Xyz::ArrayOfArrayOfAnEnum* lhsArr = &static_cast<T*>(lhs)->f;
      const Xyz::ArrayOfArrayOfAnEnum* rhsArr = static_cast<const Xyz::ArrayOfArrayOfAnEnum*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      Xyz::ArrayOfArrayOfAnEnum_forany rhsForany(const_cast<Xyz::ArrayOfArrayOfAnEnum_slice*>(*rhsArr));
      size_t size = 0, padding = 0;
      gen_find_size(rhsForany, size, padding);
      ACE_Message_Block mb(size);
      Serializer ser_out(&mb);
      ser_out << rhsForany;
      Xyz::ArrayOfArrayOfAnEnum_forany lhsForany(*lhsArr);
      Serializer ser_in(&mb);
      ser_in >> lhsForany;
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfArrayOfAnEnum)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfArrayOfAnEnum)");
  }
};

template<>
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfArrayOfAnEnum>()
{
  static MetaStructImpl<Xyz::StructOfArrayOfArrayOfAnEnum> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfArrayOfAnEnum*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Xyz::StructOfArrayOfArrayOfAnEnum>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
bool StructOfArrayOfArrayOfAnEnum::operator==(const StructOfArrayOfArrayOfAnEnum& rhs) const
{
  for (int i0 = 0; i0 < 7; ++i0) {
    for (int i1 = 0; i1 < 5; ++i1) {
      if (f[i0][i1] != rhs.f[i0][i1]) {
        return false;
      }
    }
  }
  return true;
}

ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const StructOfArrayOfArrayOfAnEnum&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, StructOfArrayOfArrayOfAnEnum&) { return true; }

}

/* End STRUCT: StructOfArrayOfArrayOfAnEnum */


/* Begin TYPEDEF: SeqOfSeqOfBoolean */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::SeqOfSeqOfBoolean& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const Xyz::SeqOfSeqOfBoolean& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::SeqOfSeqOfBoolean& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > seq.maximum()) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::SeqOfSeqOfBoolean*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<Xyz::SeqOfBoolean*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfSeqOfBoolean */


/* Begin TYPEDEF: SeqOfSeqOfString */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::SeqOfSeqOfString& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const Xyz::SeqOfSeqOfString& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::SeqOfSeqOfString& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > seq.maximum()) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::SeqOfSeqOfString*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<Xyz::SeqOfString*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfSeqOfString */


/* Begin TYPEDEF: SeqOfSeqOfChar */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::SeqOfSeqOfChar& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const Xyz::SeqOfSeqOfChar& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::SeqOfSeqOfChar& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > seq.maximum()) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::SeqOfSeqOfChar*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<Xyz::SeqOfChar*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfSeqOfChar */


/* Begin TYPEDEF: SeqOfSeqOfOctet */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::SeqOfSeqOfOctet& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const Xyz::SeqOfSeqOfOctet& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::SeqOfSeqOfOctet& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > seq.maximum()) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::SeqOfSeqOfOctet*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<Xyz::SeqOfOctet*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfSeqOfOctet */


/* Begin TYPEDEF: SeqOfSeqOfLong */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::SeqOfSeqOfLong& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const Xyz::SeqOfSeqOfLong& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::SeqOfSeqOfLong& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > seq.maximum()) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::SeqOfSeqOfLong*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<Xyz::SeqOfLong*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfSeqOfLong */


/* Begin TYPEDEF: SeqOfSeqOfAnEnum */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::SeqOfSeqOfAnEnum& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const Xyz::SeqOfSeqOfAnEnum& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::SeqOfSeqOfAnEnum& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > seq.maximum()) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::SeqOfSeqOfAnEnum*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<Xyz::SeqOfAnEnum*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfSeqOfAnEnum */


/* Begin TYPEDEF: OctetTypedef */


/* End TYPEDEF: OctetTypedef */


/* Begin STRUCT: StructOfSeqOfSeqOfLong */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::StructOfSeqOfSeqOfLong& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.field, size, padding);
}

bool operator<<(Serializer& strm, const Xyz::StructOfSeqOfSeqOfLong& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.field);
}

bool operator>>(Serializer& strm, Xyz::StructOfSeqOfSeqOfLong& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.field);
}

size_t gen_max_marshaled_size(const Xyz::StructOfSeqOfSeqOfLong& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 116;
}

size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfSeqOfSeqOfLong> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Xyz::StructOfSeqOfSeqOfLong> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfSeqOfSeqOfLong> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfSeqOfSeqOfLong> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
::DDS::DataWriter_ptr StructOfSeqOfSeqOfLongTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<StructOfSeqOfSeqOfLong> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr StructOfSeqOfSeqOfLongTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfSeqOfSeqOfLong> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr StructOfSeqOfSeqOfLongTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfSeqOfSeqOfLong> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<StructOfSeqOfSeqOfLong, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& StructOfSeqOfSeqOfLongTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<StructOfSeqOfSeqOfLong>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool StructOfSeqOfSeqOfLongTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* StructOfSeqOfSeqOfLongTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
StructOfSeqOfSeqOfLongTypeSupport::_ptr_type StructOfSeqOfSeqOfLongTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Xyz::StructOfSeqOfSeqOfLong> : MetaStruct {
  typedef Xyz::StructOfSeqOfSeqOfLong T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Xyz::StructOfSeqOfSeqOfLong& typed = *static_cast<const Xyz::StructOfSeqOfSeqOfLong*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfSeqOfLong)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<Xyz::SeqOfSeqOfLong*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Xyz::StructOfSeqOfSeqOfLong");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfSeqOfLong)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"field", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "field") == 0) {
      return &static_cast<const T*>(stru)->field;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfSeqOfLong)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "field") == 0) {
      static_cast<T*>(lhs)->field = *static_cast<const Xyz::SeqOfSeqOfLong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfSeqOfLong)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfSeqOfLong)");
  }
};

template<>
const MetaStruct& getMetaStruct<Xyz::StructOfSeqOfSeqOfLong>()
{
  static MetaStructImpl<Xyz::StructOfSeqOfSeqOfLong> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Xyz::StructOfSeqOfSeqOfLong*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Xyz::StructOfSeqOfSeqOfLong>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
bool StructOfSeqOfSeqOfLong::operator==(const StructOfSeqOfSeqOfLong& rhs) const
{
  if (field != rhs.field) {
    return false;
  }
  return true;
}

void swap(StructOfSeqOfSeqOfLong& lhs, StructOfSeqOfSeqOfLong& rhs)
{
  using std::swap;
  swap(lhs.field, rhs.field);
}

ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const StructOfSeqOfSeqOfLong&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, StructOfSeqOfSeqOfLong&) { return true; }

}

/* End STRUCT: StructOfSeqOfSeqOfLong */


/* Begin TYPEDEF: SevenStr */


/* End TYPEDEF: SevenStr */


/* Begin STRUCT: AStruct */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::AStruct& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  Xyz::ArrayOfBoolean_forany stru_f10(const_cast<Xyz::ArrayOfBoolean_slice*>(stru.f10));
  Xyz::ArrayOfString_forany stru_f11(const_cast<Xyz::ArrayOfString_slice*>(stru.f11));
  Xyz::ArrayOfChar_forany stru_f12(const_cast<Xyz::ArrayOfChar_slice*>(stru.f12));
  Xyz::ArrayOfOctet_forany stru_f13(const_cast<Xyz::ArrayOfOctet_slice*>(stru.f13));
  Xyz::ArrayOfLong_forany stru_f14(const_cast<Xyz::ArrayOfLong_slice*>(stru.f14));
  Xyz::ArrayOfAnEnum_forany stru_f15(const_cast<Xyz::ArrayOfAnEnum_slice*>(stru.f15));
  Xyz::ArrayOfSeqOfBoolean_forany stru_f30(const_cast<Xyz::ArrayOfSeqOfBoolean_slice*>(stru.f30));
  Xyz::ArrayOfSeqOfString_forany stru_f31(const_cast<Xyz::ArrayOfSeqOfString_slice*>(stru.f31));
  Xyz::ArrayOfSeqOfChar_forany stru_f32(const_cast<Xyz::ArrayOfSeqOfChar_slice*>(stru.f32));
  Xyz::ArrayOfSeqOfOctet_forany stru_f33(const_cast<Xyz::ArrayOfSeqOfOctet_slice*>(stru.f33));
  Xyz::ArrayOfSeqOfLong_forany stru_f34(const_cast<Xyz::ArrayOfSeqOfLong_slice*>(stru.f34));
  Xyz::ArrayOfSeqOfAnEnum_forany stru_f35(const_cast<Xyz::ArrayOfSeqOfAnEnum_slice*>(stru.f35));
  Xyz::ArrayOfArrayOfBoolean_forany stru_f50(const_cast<Xyz::ArrayOfArrayOfBoolean_slice*>(stru.f50));
  Xyz::ArrayOfArrayOfString_forany stru_f51(const_cast<Xyz::ArrayOfArrayOfString_slice*>(stru.f51));
  Xyz::ArrayOfArrayOfChar_forany stru_f52(const_cast<Xyz::ArrayOfArrayOfChar_slice*>(stru.f52));
  Xyz::ArrayOfArrayOfOctet_forany stru_f53(const_cast<Xyz::ArrayOfArrayOfOctet_slice*>(stru.f53));
  Xyz::ArrayOfArrayOfLong_forany stru_f54(const_cast<Xyz::ArrayOfArrayOfLong_slice*>(stru.f54));
  Xyz::ArrayOfArrayOfAnEnum_forany stru_f55(const_cast<Xyz::ArrayOfArrayOfAnEnum_slice*>(stru.f55));
  if ((size + padding) % 8) {
    padding += 8 - ((size + padding) % 8);
  }
  size += gen_max_marshaled_size(stru.f1);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.f2);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_boolean(stru.f3));
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.f4.in()) + 1;
  size += gen_max_marshaled_size(ACE_OutputCDR::from_char(stru.f5));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.f6));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.f6a));
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.f7);
  find_size_ulong(size, padding);
  gen_find_size(stru_f10, size, padding);
  gen_find_size(stru_f11, size, padding);
  gen_find_size(stru_f12, size, padding);
  gen_find_size(stru_f13, size, padding);
  gen_find_size(stru_f14, size, padding);
  gen_find_size(stru_f15, size, padding);
  gen_find_size(stru.f20, size, padding);
  gen_find_size(stru.f21, size, padding);
  gen_find_size(stru.f22, size, padding);
  gen_find_size(stru.f23, size, padding);
  gen_find_size(stru.f24, size, padding);
  gen_find_size(stru.f25, size, padding);
  gen_find_size(stru_f30, size, padding);
  gen_find_size(stru_f31, size, padding);
  gen_find_size(stru_f32, size, padding);
  gen_find_size(stru_f33, size, padding);
  gen_find_size(stru_f34, size, padding);
  gen_find_size(stru_f35, size, padding);
  gen_find_size(stru.f40, size, padding);
  gen_find_size(stru.f41, size, padding);
  gen_find_size(stru.f42, size, padding);
  gen_find_size(stru.f43, size, padding);
  gen_find_size(stru.f44, size, padding);
  gen_find_size(stru.f45, size, padding);
  gen_find_size(stru_f50, size, padding);
  gen_find_size(stru_f51, size, padding);
  gen_find_size(stru_f52, size, padding);
  gen_find_size(stru_f53, size, padding);
  gen_find_size(stru_f54, size, padding);
  gen_find_size(stru_f55, size, padding);
  gen_find_size(stru.f60, size, padding);
  gen_find_size(stru.f61, size, padding);
  gen_find_size(stru.f62, size, padding);
  gen_find_size(stru.f63, size, padding);
  gen_find_size(stru.f64, size, padding);
  gen_find_size(stru.f65, size, padding);
}

bool operator<<(Serializer& strm, const Xyz::AStruct& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfBoolean_forany stru_f10(const_cast<Xyz::ArrayOfBoolean_slice*>(stru.f10));
  Xyz::ArrayOfString_forany stru_f11(const_cast<Xyz::ArrayOfString_slice*>(stru.f11));
  Xyz::ArrayOfChar_forany stru_f12(const_cast<Xyz::ArrayOfChar_slice*>(stru.f12));
  Xyz::ArrayOfOctet_forany stru_f13(const_cast<Xyz::ArrayOfOctet_slice*>(stru.f13));
  Xyz::ArrayOfLong_forany stru_f14(const_cast<Xyz::ArrayOfLong_slice*>(stru.f14));
  Xyz::ArrayOfAnEnum_forany stru_f15(const_cast<Xyz::ArrayOfAnEnum_slice*>(stru.f15));
  Xyz::ArrayOfSeqOfBoolean_forany stru_f30(const_cast<Xyz::ArrayOfSeqOfBoolean_slice*>(stru.f30));
  Xyz::ArrayOfSeqOfString_forany stru_f31(const_cast<Xyz::ArrayOfSeqOfString_slice*>(stru.f31));
  Xyz::ArrayOfSeqOfChar_forany stru_f32(const_cast<Xyz::ArrayOfSeqOfChar_slice*>(stru.f32));
  Xyz::ArrayOfSeqOfOctet_forany stru_f33(const_cast<Xyz::ArrayOfSeqOfOctet_slice*>(stru.f33));
  Xyz::ArrayOfSeqOfLong_forany stru_f34(const_cast<Xyz::ArrayOfSeqOfLong_slice*>(stru.f34));
  Xyz::ArrayOfSeqOfAnEnum_forany stru_f35(const_cast<Xyz::ArrayOfSeqOfAnEnum_slice*>(stru.f35));
  Xyz::ArrayOfArrayOfBoolean_forany stru_f50(const_cast<Xyz::ArrayOfArrayOfBoolean_slice*>(stru.f50));
  Xyz::ArrayOfArrayOfString_forany stru_f51(const_cast<Xyz::ArrayOfArrayOfString_slice*>(stru.f51));
  Xyz::ArrayOfArrayOfChar_forany stru_f52(const_cast<Xyz::ArrayOfArrayOfChar_slice*>(stru.f52));
  Xyz::ArrayOfArrayOfOctet_forany stru_f53(const_cast<Xyz::ArrayOfArrayOfOctet_slice*>(stru.f53));
  Xyz::ArrayOfArrayOfLong_forany stru_f54(const_cast<Xyz::ArrayOfArrayOfLong_slice*>(stru.f54));
  Xyz::ArrayOfArrayOfAnEnum_forany stru_f55(const_cast<Xyz::ArrayOfArrayOfAnEnum_slice*>(stru.f55));
  return (strm << stru.f1)
    && (strm << stru.f2)
    && (strm << ACE_OutputCDR::from_boolean(stru.f3))
    && (strm << stru.f4.in())
    && (strm << ACE_OutputCDR::from_char(stru.f5))
    && (strm << ACE_OutputCDR::from_octet(stru.f6))
    && (strm << ACE_OutputCDR::from_octet(stru.f6a))
    && (strm << stru.f7)
    && (strm << stru.f8)
    && (strm << stru_f10)
    && (strm << stru_f11)
    && (strm << stru_f12)
    && (strm << stru_f13)
    && (strm << stru_f14)
    && (strm << stru_f15)
    && (strm << stru.f20)
    && (strm << stru.f21)
    && (strm << stru.f22)
    && (strm << stru.f23)
    && (strm << stru.f24)
    && (strm << stru.f25)
    && (strm << stru_f30)
    && (strm << stru_f31)
    && (strm << stru_f32)
    && (strm << stru_f33)
    && (strm << stru_f34)
    && (strm << stru_f35)
    && (strm << stru.f40)
    && (strm << stru.f41)
    && (strm << stru.f42)
    && (strm << stru.f43)
    && (strm << stru.f44)
    && (strm << stru.f45)
    && (strm << stru_f50)
    && (strm << stru_f51)
    && (strm << stru_f52)
    && (strm << stru_f53)
    && (strm << stru_f54)
    && (strm << stru_f55)
    && (strm << stru.f60)
    && (strm << stru.f61)
    && (strm << stru.f62)
    && (strm << stru.f63)
    && (strm << stru.f64)
    && (strm << stru.f65);
}

bool operator>>(Serializer& strm, Xyz::AStruct& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfBoolean_forany stru_f10(const_cast<Xyz::ArrayOfBoolean_slice*>(stru.f10));
  Xyz::ArrayOfString_forany stru_f11(const_cast<Xyz::ArrayOfString_slice*>(stru.f11));
  Xyz::ArrayOfChar_forany stru_f12(const_cast<Xyz::ArrayOfChar_slice*>(stru.f12));
  Xyz::ArrayOfOctet_forany stru_f13(const_cast<Xyz::ArrayOfOctet_slice*>(stru.f13));
  Xyz::ArrayOfLong_forany stru_f14(const_cast<Xyz::ArrayOfLong_slice*>(stru.f14));
  Xyz::ArrayOfAnEnum_forany stru_f15(const_cast<Xyz::ArrayOfAnEnum_slice*>(stru.f15));
  Xyz::ArrayOfSeqOfBoolean_forany stru_f30(const_cast<Xyz::ArrayOfSeqOfBoolean_slice*>(stru.f30));
  Xyz::ArrayOfSeqOfString_forany stru_f31(const_cast<Xyz::ArrayOfSeqOfString_slice*>(stru.f31));
  Xyz::ArrayOfSeqOfChar_forany stru_f32(const_cast<Xyz::ArrayOfSeqOfChar_slice*>(stru.f32));
  Xyz::ArrayOfSeqOfOctet_forany stru_f33(const_cast<Xyz::ArrayOfSeqOfOctet_slice*>(stru.f33));
  Xyz::ArrayOfSeqOfLong_forany stru_f34(const_cast<Xyz::ArrayOfSeqOfLong_slice*>(stru.f34));
  Xyz::ArrayOfSeqOfAnEnum_forany stru_f35(const_cast<Xyz::ArrayOfSeqOfAnEnum_slice*>(stru.f35));
  Xyz::ArrayOfArrayOfBoolean_forany stru_f50(const_cast<Xyz::ArrayOfArrayOfBoolean_slice*>(stru.f50));
  Xyz::ArrayOfArrayOfString_forany stru_f51(const_cast<Xyz::ArrayOfArrayOfString_slice*>(stru.f51));
  Xyz::ArrayOfArrayOfChar_forany stru_f52(const_cast<Xyz::ArrayOfArrayOfChar_slice*>(stru.f52));
  Xyz::ArrayOfArrayOfOctet_forany stru_f53(const_cast<Xyz::ArrayOfArrayOfOctet_slice*>(stru.f53));
  Xyz::ArrayOfArrayOfLong_forany stru_f54(const_cast<Xyz::ArrayOfArrayOfLong_slice*>(stru.f54));
  Xyz::ArrayOfArrayOfAnEnum_forany stru_f55(const_cast<Xyz::ArrayOfArrayOfAnEnum_slice*>(stru.f55));
  return (strm >> stru.f1)
    && (strm >> stru.f2)
    && (strm >> ACE_InputCDR::to_boolean(stru.f3))
    && (strm >> stru.f4.out())
    && (strm >> ACE_InputCDR::to_char(stru.f5))
    && (strm >> ACE_InputCDR::to_octet(stru.f6))
    && (strm >> ACE_InputCDR::to_octet(stru.f6a))
    && (strm >> stru.f7)
    && (strm >> stru.f8)
    && (strm >> stru_f10)
    && (strm >> stru_f11)
    && (strm >> stru_f12)
    && (strm >> stru_f13)
    && (strm >> stru_f14)
    && (strm >> stru_f15)
    && (strm >> stru.f20)
    && (strm >> stru.f21)
    && (strm >> stru.f22)
    && (strm >> stru.f23)
    && (strm >> stru.f24)
    && (strm >> stru.f25)
    && (strm >> stru_f30)
    && (strm >> stru_f31)
    && (strm >> stru_f32)
    && (strm >> stru_f33)
    && (strm >> stru_f34)
    && (strm >> stru_f35)
    && (strm >> stru.f40)
    && (strm >> stru.f41)
    && (strm >> stru.f42)
    && (strm >> stru.f43)
    && (strm >> stru.f44)
    && (strm >> stru.f45)
    && (strm >> stru_f50)
    && (strm >> stru_f51)
    && (strm >> stru_f52)
    && (strm >> stru_f53)
    && (strm >> stru_f54)
    && (strm >> stru_f55)
    && (strm >> stru.f60)
    && (strm >> stru.f61)
    && (strm >> stru.f62)
    && (strm >> stru.f63)
    && (strm >> stru.f64)
    && (strm >> stru.f65);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Xyz::AStruct> : MetaStruct {
  typedef Xyz::AStruct T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Xyz::AStruct& typed = *static_cast<const Xyz::AStruct*>(stru);
    if (std::strcmp(field, "f1") == 0) {
      return typed.f1;
    }
    if (std::strcmp(field, "f2") == 0) {
      return typed.f2;
    }
    if (std::strcmp(field, "f3") == 0) {
      return typed.f3;
    }
    if (std::strcmp(field, "f4") == 0) {
      return typed.f4.in();
    }
    if (std::strcmp(field, "f5") == 0) {
      return typed.f5;
    }
    if (std::strcmp(field, "f6") == 0) {
      return typed.f6;
    }
    if (std::strcmp(field, "f6a") == 0) {
      return typed.f6a;
    }
    if (std::strcmp(field, "f7") == 0) {
      return typed.f7;
    }
    if (std::strcmp(field, "f8") == 0) {
      return gen_Xyz_AnEnum_names[typed.f8];
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::AStruct)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "f1") == 0) {
      ACE_CDR::Double val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'f1' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 8);
    }
    if (std::strcmp(field, "f2") == 0) {
      ACE_CDR::Float val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'f2' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "f3") == 0) {
      ACE_CDR::Boolean val;
      if (!(ser >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'f3' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 1);
    }
    if (std::strcmp(field, "f4") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'f4' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'f4' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strcmp(field, "f5") == 0) {
      ACE_CDR::Char val;
      if (!(ser >> ACE_InputCDR::to_char(val))) {
        throw std::runtime_error("Field 'f5' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 1);
    }
    if (std::strcmp(field, "f6") == 0) {
      ACE_CDR::Octet val;
      if (!(ser >> ACE_InputCDR::to_octet(val))) {
        throw std::runtime_error("Field 'f6' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 1);
    }
    if (std::strcmp(field, "f6a") == 0) {
      ACE_CDR::Octet val;
      if (!(ser >> ACE_InputCDR::to_octet(val))) {
        throw std::runtime_error("Field 'f6a' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 1);
    }
    if (std::strcmp(field, "f7") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'f7' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "f8") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'f8' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    gen_skip_over(ser, static_cast<Xyz::ArrayOfBoolean_forany*>(0));
    gen_skip_over(ser, static_cast<Xyz::ArrayOfString_forany*>(0));
    gen_skip_over(ser, static_cast<Xyz::ArrayOfChar_forany*>(0));
    gen_skip_over(ser, static_cast<Xyz::ArrayOfOctet_forany*>(0));
    gen_skip_over(ser, static_cast<Xyz::ArrayOfLong_forany*>(0));
    gen_skip_over(ser, static_cast<Xyz::ArrayOfAnEnum_forany*>(0));
    gen_skip_over(ser, static_cast<Xyz::SeqOfBoolean*>(0));
    gen_skip_over(ser, static_cast<Xyz::SeqOfString*>(0));
    gen_skip_over(ser, static_cast<Xyz::SeqOfChar*>(0));
    gen_skip_over(ser, static_cast<Xyz::SeqOfOctet*>(0));
    gen_skip_over(ser, static_cast<Xyz::SeqOfLong*>(0));
    gen_skip_over(ser, static_cast<Xyz::SeqOfAnEnum*>(0));
    gen_skip_over(ser, static_cast<Xyz::ArrayOfSeqOfBoolean_forany*>(0));
    gen_skip_over(ser, static_cast<Xyz::ArrayOfSeqOfString_forany*>(0));
    gen_skip_over(ser, static_cast<Xyz::ArrayOfSeqOfChar_forany*>(0));
    gen_skip_over(ser, static_cast<Xyz::ArrayOfSeqOfOctet_forany*>(0));
    gen_skip_over(ser, static_cast<Xyz::ArrayOfSeqOfLong_forany*>(0));
    gen_skip_over(ser, static_cast<Xyz::ArrayOfSeqOfAnEnum_forany*>(0));
    gen_skip_over(ser, static_cast<Xyz::SeqOfArrayOfBoolean*>(0));
    gen_skip_over(ser, static_cast<Xyz::SeqOfArrayOfString*>(0));
    gen_skip_over(ser, static_cast<Xyz::SeqOfArrayOfChar*>(0));
    gen_skip_over(ser, static_cast<Xyz::SeqOfArrayOfOctet*>(0));
    gen_skip_over(ser, static_cast<Xyz::SeqOfArrayOfLong*>(0));
    gen_skip_over(ser, static_cast<Xyz::SeqOfArrayOfAnEnum*>(0));
    gen_skip_over(ser, static_cast<Xyz::ArrayOfArrayOfBoolean_forany*>(0));
    gen_skip_over(ser, static_cast<Xyz::ArrayOfArrayOfString_forany*>(0));
    gen_skip_over(ser, static_cast<Xyz::ArrayOfArrayOfChar_forany*>(0));
    gen_skip_over(ser, static_cast<Xyz::ArrayOfArrayOfOctet_forany*>(0));
    gen_skip_over(ser, static_cast<Xyz::ArrayOfArrayOfLong_forany*>(0));
    gen_skip_over(ser, static_cast<Xyz::ArrayOfArrayOfAnEnum_forany*>(0));
    gen_skip_over(ser, static_cast<Xyz::SeqOfSeqOfBoolean*>(0));
    gen_skip_over(ser, static_cast<Xyz::SeqOfSeqOfString*>(0));
    gen_skip_over(ser, static_cast<Xyz::SeqOfSeqOfChar*>(0));
    gen_skip_over(ser, static_cast<Xyz::SeqOfSeqOfOctet*>(0));
    gen_skip_over(ser, static_cast<Xyz::SeqOfSeqOfLong*>(0));
    gen_skip_over(ser, static_cast<Xyz::SeqOfSeqOfAnEnum*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Xyz::AStruct");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "f1") == 0) {
      return make_field_cmp(&T::f1, next);
    }
    if (std::strcmp(field, "f2") == 0) {
      return make_field_cmp(&T::f2, next);
    }
    if (std::strcmp(field, "f3") == 0) {
      return make_field_cmp(&T::f3, next);
    }
    if (std::strcmp(field, "f4") == 0) {
      return make_field_cmp(&T::f4, next);
    }
    if (std::strcmp(field, "f5") == 0) {
      return make_field_cmp(&T::f5, next);
    }
    if (std::strcmp(field, "f6") == 0) {
      return make_field_cmp(&T::f6, next);
    }
    if (std::strcmp(field, "f6a") == 0) {
      return make_field_cmp(&T::f6a, next);
    }
    if (std::strcmp(field, "f7") == 0) {
      return make_field_cmp(&T::f7, next);
    }
    if (std::strcmp(field, "f8") == 0) {
      return make_field_cmp(&T::f8, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::AStruct)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"f1", "f2", "f3", "f4", "f5", "f6", "f6a", "f7", "f8", "f10", "f11", "f12", "f13", "f14", "f15", "f20", "f21", "f22", "f23", "f24", "f25", "f30", "f31", "f32", "f33", "f34", "f35", "f40", "f41", "f42", "f43", "f44", "f45", "f50", "f51", "f52", "f53", "f54", "f55", "f60", "f61", "f62", "f63", "f64", "f65", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "f1") == 0) {
      return &static_cast<const T*>(stru)->f1;
    }
    if (std::strcmp(field, "f2") == 0) {
      return &static_cast<const T*>(stru)->f2;
    }
    if (std::strcmp(field, "f3") == 0) {
      return &static_cast<const T*>(stru)->f3;
    }
    if (std::strcmp(field, "f4") == 0) {
      return &static_cast<const T*>(stru)->f4;
    }
    if (std::strcmp(field, "f5") == 0) {
      return &static_cast<const T*>(stru)->f5;
    }
    if (std::strcmp(field, "f6") == 0) {
      return &static_cast<const T*>(stru)->f6;
    }
    if (std::strcmp(field, "f6a") == 0) {
      return &static_cast<const T*>(stru)->f6a;
    }
    if (std::strcmp(field, "f7") == 0) {
      return &static_cast<const T*>(stru)->f7;
    }
    if (std::strcmp(field, "f8") == 0) {
      return &static_cast<const T*>(stru)->f8;
    }
    if (std::strcmp(field, "f10") == 0) {
      return &static_cast<const T*>(stru)->f10;
    }
    if (std::strcmp(field, "f11") == 0) {
      return &static_cast<const T*>(stru)->f11;
    }
    if (std::strcmp(field, "f12") == 0) {
      return &static_cast<const T*>(stru)->f12;
    }
    if (std::strcmp(field, "f13") == 0) {
      return &static_cast<const T*>(stru)->f13;
    }
    if (std::strcmp(field, "f14") == 0) {
      return &static_cast<const T*>(stru)->f14;
    }
    if (std::strcmp(field, "f15") == 0) {
      return &static_cast<const T*>(stru)->f15;
    }
    if (std::strcmp(field, "f20") == 0) {
      return &static_cast<const T*>(stru)->f20;
    }
    if (std::strcmp(field, "f21") == 0) {
      return &static_cast<const T*>(stru)->f21;
    }
    if (std::strcmp(field, "f22") == 0) {
      return &static_cast<const T*>(stru)->f22;
    }
    if (std::strcmp(field, "f23") == 0) {
      return &static_cast<const T*>(stru)->f23;
    }
    if (std::strcmp(field, "f24") == 0) {
      return &static_cast<const T*>(stru)->f24;
    }
    if (std::strcmp(field, "f25") == 0) {
      return &static_cast<const T*>(stru)->f25;
    }
    if (std::strcmp(field, "f30") == 0) {
      return &static_cast<const T*>(stru)->f30;
    }
    if (std::strcmp(field, "f31") == 0) {
      return &static_cast<const T*>(stru)->f31;
    }
    if (std::strcmp(field, "f32") == 0) {
      return &static_cast<const T*>(stru)->f32;
    }
    if (std::strcmp(field, "f33") == 0) {
      return &static_cast<const T*>(stru)->f33;
    }
    if (std::strcmp(field, "f34") == 0) {
      return &static_cast<const T*>(stru)->f34;
    }
    if (std::strcmp(field, "f35") == 0) {
      return &static_cast<const T*>(stru)->f35;
    }
    if (std::strcmp(field, "f40") == 0) {
      return &static_cast<const T*>(stru)->f40;
    }
    if (std::strcmp(field, "f41") == 0) {
      return &static_cast<const T*>(stru)->f41;
    }
    if (std::strcmp(field, "f42") == 0) {
      return &static_cast<const T*>(stru)->f42;
    }
    if (std::strcmp(field, "f43") == 0) {
      return &static_cast<const T*>(stru)->f43;
    }
    if (std::strcmp(field, "f44") == 0) {
      return &static_cast<const T*>(stru)->f44;
    }
    if (std::strcmp(field, "f45") == 0) {
      return &static_cast<const T*>(stru)->f45;
    }
    if (std::strcmp(field, "f50") == 0) {
      return &static_cast<const T*>(stru)->f50;
    }
    if (std::strcmp(field, "f51") == 0) {
      return &static_cast<const T*>(stru)->f51;
    }
    if (std::strcmp(field, "f52") == 0) {
      return &static_cast<const T*>(stru)->f52;
    }
    if (std::strcmp(field, "f53") == 0) {
      return &static_cast<const T*>(stru)->f53;
    }
    if (std::strcmp(field, "f54") == 0) {
      return &static_cast<const T*>(stru)->f54;
    }
    if (std::strcmp(field, "f55") == 0) {
      return &static_cast<const T*>(stru)->f55;
    }
    if (std::strcmp(field, "f60") == 0) {
      return &static_cast<const T*>(stru)->f60;
    }
    if (std::strcmp(field, "f61") == 0) {
      return &static_cast<const T*>(stru)->f61;
    }
    if (std::strcmp(field, "f62") == 0) {
      return &static_cast<const T*>(stru)->f62;
    }
    if (std::strcmp(field, "f63") == 0) {
      return &static_cast<const T*>(stru)->f63;
    }
    if (std::strcmp(field, "f64") == 0) {
      return &static_cast<const T*>(stru)->f64;
    }
    if (std::strcmp(field, "f65") == 0) {
      return &static_cast<const T*>(stru)->f65;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::AStruct)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "f1") == 0) {
      static_cast<T*>(lhs)->f1 = *static_cast<const CORBA::Double*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "f2") == 0) {
      static_cast<T*>(lhs)->f2 = *static_cast<const CORBA::Float*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "f3") == 0) {
      static_cast<T*>(lhs)->f3 = *static_cast<const CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "f4") == 0) {
      static_cast<T*>(lhs)->f4 = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "f5") == 0) {
      static_cast<T*>(lhs)->f5 = *static_cast<const CORBA::Char*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "f6") == 0) {
      static_cast<T*>(lhs)->f6 = *static_cast<const CORBA::Octet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "f6a") == 0) {
      static_cast<T*>(lhs)->f6a = *static_cast<const Xyz::OctetTypedef*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "f7") == 0) {
      static_cast<T*>(lhs)->f7 = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "f8") == 0) {
      static_cast<T*>(lhs)->f8 = *static_cast<const Xyz::AnEnum*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "f10") == 0) {
      Xyz::ArrayOfBoolean* lhsArr = &static_cast<T*>(lhs)->f10;
      const Xyz::ArrayOfBoolean* rhsArr = static_cast<const Xyz::ArrayOfBoolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 5; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    if (std::strcmp(field, "f11") == 0) {
      Xyz::ArrayOfString* lhsArr = &static_cast<T*>(lhs)->f11;
      const Xyz::ArrayOfString* rhsArr = static_cast<const Xyz::ArrayOfString*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 5; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    if (std::strcmp(field, "f12") == 0) {
      Xyz::ArrayOfChar* lhsArr = &static_cast<T*>(lhs)->f12;
      const Xyz::ArrayOfChar* rhsArr = static_cast<const Xyz::ArrayOfChar*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 5; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    if (std::strcmp(field, "f13") == 0) {
      Xyz::ArrayOfOctet* lhsArr = &static_cast<T*>(lhs)->f13;
      const Xyz::ArrayOfOctet* rhsArr = static_cast<const Xyz::ArrayOfOctet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 5; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    if (std::strcmp(field, "f14") == 0) {
      Xyz::ArrayOfLong* lhsArr = &static_cast<T*>(lhs)->f14;
      const Xyz::ArrayOfLong* rhsArr = static_cast<const Xyz::ArrayOfLong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 5; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    if (std::strcmp(field, "f15") == 0) {
      Xyz::ArrayOfAnEnum* lhsArr = &static_cast<T*>(lhs)->f15;
      const Xyz::ArrayOfAnEnum* rhsArr = static_cast<const Xyz::ArrayOfAnEnum*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 5; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    if (std::strcmp(field, "f20") == 0) {
      static_cast<T*>(lhs)->f20 = *static_cast<const Xyz::SeqOfBoolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "f21") == 0) {
      static_cast<T*>(lhs)->f21 = *static_cast<const Xyz::SeqOfString*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "f22") == 0) {
      static_cast<T*>(lhs)->f22 = *static_cast<const Xyz::SeqOfChar*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "f23") == 0) {
      static_cast<T*>(lhs)->f23 = *static_cast<const Xyz::SeqOfOctet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "f24") == 0) {
      static_cast<T*>(lhs)->f24 = *static_cast<const Xyz::SeqOfLong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "f25") == 0) {
      static_cast<T*>(lhs)->f25 = *static_cast<const Xyz::SeqOfAnEnum*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "f30") == 0) {
      Xyz::ArrayOfSeqOfBoolean* lhsArr = &static_cast<T*>(lhs)->f30;
      const Xyz::ArrayOfSeqOfBoolean* rhsArr = static_cast<const Xyz::ArrayOfSeqOfBoolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 6; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    if (std::strcmp(field, "f31") == 0) {
      Xyz::ArrayOfSeqOfString* lhsArr = &static_cast<T*>(lhs)->f31;
      const Xyz::ArrayOfSeqOfString* rhsArr = static_cast<const Xyz::ArrayOfSeqOfString*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 6; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    if (std::strcmp(field, "f32") == 0) {
      Xyz::ArrayOfSeqOfChar* lhsArr = &static_cast<T*>(lhs)->f32;
      const Xyz::ArrayOfSeqOfChar* rhsArr = static_cast<const Xyz::ArrayOfSeqOfChar*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 6; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    if (std::strcmp(field, "f33") == 0) {
      Xyz::ArrayOfSeqOfOctet* lhsArr = &static_cast<T*>(lhs)->f33;
      const Xyz::ArrayOfSeqOfOctet* rhsArr = static_cast<const Xyz::ArrayOfSeqOfOctet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 6; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    if (std::strcmp(field, "f34") == 0) {
      Xyz::ArrayOfSeqOfLong* lhsArr = &static_cast<T*>(lhs)->f34;
      const Xyz::ArrayOfSeqOfLong* rhsArr = static_cast<const Xyz::ArrayOfSeqOfLong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 6; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    if (std::strcmp(field, "f35") == 0) {
      Xyz::ArrayOfSeqOfAnEnum* lhsArr = &static_cast<T*>(lhs)->f35;
      const Xyz::ArrayOfSeqOfAnEnum* rhsArr = static_cast<const Xyz::ArrayOfSeqOfAnEnum*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 6; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    if (std::strcmp(field, "f40") == 0) {
      static_cast<T*>(lhs)->f40 = *static_cast<const Xyz::SeqOfArrayOfBoolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "f41") == 0) {
      static_cast<T*>(lhs)->f41 = *static_cast<const Xyz::SeqOfArrayOfString*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "f42") == 0) {
      static_cast<T*>(lhs)->f42 = *static_cast<const Xyz::SeqOfArrayOfChar*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "f43") == 0) {
      static_cast<T*>(lhs)->f43 = *static_cast<const Xyz::SeqOfArrayOfOctet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "f44") == 0) {
      static_cast<T*>(lhs)->f44 = *static_cast<const Xyz::SeqOfArrayOfLong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "f45") == 0) {
      static_cast<T*>(lhs)->f45 = *static_cast<const Xyz::SeqOfArrayOfAnEnum*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "f50") == 0) {
      Xyz::ArrayOfArrayOfBoolean* lhsArr = &static_cast<T*>(lhs)->f50;
      const Xyz::ArrayOfArrayOfBoolean* rhsArr = static_cast<const Xyz::ArrayOfArrayOfBoolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      Xyz::ArrayOfArrayOfBoolean_forany rhsForany(const_cast<Xyz::ArrayOfArrayOfBoolean_slice*>(*rhsArr));
      size_t size = 0, padding = 0;
      gen_find_size(rhsForany, size, padding);
      ACE_Message_Block mb(size);
      Serializer ser_out(&mb);
      ser_out << rhsForany;
      Xyz::ArrayOfArrayOfBoolean_forany lhsForany(*lhsArr);
      Serializer ser_in(&mb);
      ser_in >> lhsForany;
      return;
    }
    if (std::strcmp(field, "f51") == 0) {
      Xyz::ArrayOfArrayOfString* lhsArr = &static_cast<T*>(lhs)->f51;
      const Xyz::ArrayOfArrayOfString* rhsArr = static_cast<const Xyz::ArrayOfArrayOfString*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      Xyz::ArrayOfArrayOfString_forany rhsForany(const_cast<Xyz::ArrayOfArrayOfString_slice*>(*rhsArr));
      size_t size = 0, padding = 0;
      gen_find_size(rhsForany, size, padding);
      ACE_Message_Block mb(size);
      Serializer ser_out(&mb);
      ser_out << rhsForany;
      Xyz::ArrayOfArrayOfString_forany lhsForany(*lhsArr);
      Serializer ser_in(&mb);
      ser_in >> lhsForany;
      return;
    }
    if (std::strcmp(field, "f52") == 0) {
      Xyz::ArrayOfArrayOfChar* lhsArr = &static_cast<T*>(lhs)->f52;
      const Xyz::ArrayOfArrayOfChar* rhsArr = static_cast<const Xyz::ArrayOfArrayOfChar*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      Xyz::ArrayOfArrayOfChar_forany rhsForany(const_cast<Xyz::ArrayOfArrayOfChar_slice*>(*rhsArr));
      size_t size = 0, padding = 0;
      gen_find_size(rhsForany, size, padding);
      ACE_Message_Block mb(size);
      Serializer ser_out(&mb);
      ser_out << rhsForany;
      Xyz::ArrayOfArrayOfChar_forany lhsForany(*lhsArr);
      Serializer ser_in(&mb);
      ser_in >> lhsForany;
      return;
    }
    if (std::strcmp(field, "f53") == 0) {
      Xyz::ArrayOfArrayOfOctet* lhsArr = &static_cast<T*>(lhs)->f53;
      const Xyz::ArrayOfArrayOfOctet* rhsArr = static_cast<const Xyz::ArrayOfArrayOfOctet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      Xyz::ArrayOfArrayOfOctet_forany rhsForany(const_cast<Xyz::ArrayOfArrayOfOctet_slice*>(*rhsArr));
      size_t size = 0, padding = 0;
      gen_find_size(rhsForany, size, padding);
      ACE_Message_Block mb(size);
      Serializer ser_out(&mb);
      ser_out << rhsForany;
      Xyz::ArrayOfArrayOfOctet_forany lhsForany(*lhsArr);
      Serializer ser_in(&mb);
      ser_in >> lhsForany;
      return;
    }
    if (std::strcmp(field, "f54") == 0) {
      Xyz::ArrayOfArrayOfLong* lhsArr = &static_cast<T*>(lhs)->f54;
      const Xyz::ArrayOfArrayOfLong* rhsArr = static_cast<const Xyz::ArrayOfArrayOfLong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      Xyz::ArrayOfArrayOfLong_forany rhsForany(const_cast<Xyz::ArrayOfArrayOfLong_slice*>(*rhsArr));
      size_t size = 0, padding = 0;
      gen_find_size(rhsForany, size, padding);
      ACE_Message_Block mb(size);
      Serializer ser_out(&mb);
      ser_out << rhsForany;
      Xyz::ArrayOfArrayOfLong_forany lhsForany(*lhsArr);
      Serializer ser_in(&mb);
      ser_in >> lhsForany;
      return;
    }
    if (std::strcmp(field, "f55") == 0) {
      Xyz::ArrayOfArrayOfAnEnum* lhsArr = &static_cast<T*>(lhs)->f55;
      const Xyz::ArrayOfArrayOfAnEnum* rhsArr = static_cast<const Xyz::ArrayOfArrayOfAnEnum*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      Xyz::ArrayOfArrayOfAnEnum_forany rhsForany(const_cast<Xyz::ArrayOfArrayOfAnEnum_slice*>(*rhsArr));
      size_t size = 0, padding = 0;
      gen_find_size(rhsForany, size, padding);
      ACE_Message_Block mb(size);
      Serializer ser_out(&mb);
      ser_out << rhsForany;
      Xyz::ArrayOfArrayOfAnEnum_forany lhsForany(*lhsArr);
      Serializer ser_in(&mb);
      ser_in >> lhsForany;
      return;
    }
    if (std::strcmp(field, "f60") == 0) {
      static_cast<T*>(lhs)->f60 = *static_cast<const Xyz::SeqOfSeqOfBoolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "f61") == 0) {
      static_cast<T*>(lhs)->f61 = *static_cast<const Xyz::SeqOfSeqOfString*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "f62") == 0) {
      static_cast<T*>(lhs)->f62 = *static_cast<const Xyz::SeqOfSeqOfChar*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "f63") == 0) {
      static_cast<T*>(lhs)->f63 = *static_cast<const Xyz::SeqOfSeqOfOctet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "f64") == 0) {
      static_cast<T*>(lhs)->f64 = *static_cast<const Xyz::SeqOfSeqOfLong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "f65") == 0) {
      static_cast<T*>(lhs)->f65 = *static_cast<const Xyz::SeqOfSeqOfAnEnum*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::AStruct)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "f1") == 0) {
      return static_cast<const T*>(lhs)->f1 == static_cast<const T*>(rhs)->f1;
    }
    if (std::strcmp(field, "f2") == 0) {
      return static_cast<const T*>(lhs)->f2 == static_cast<const T*>(rhs)->f2;
    }
    if (std::strcmp(field, "f3") == 0) {
      return static_cast<const T*>(lhs)->f3 == static_cast<const T*>(rhs)->f3;
    }
    if (std::strcmp(field, "f4") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->f4.in(), static_cast<const T*>(rhs)->f4.in());
    }
    if (std::strcmp(field, "f5") == 0) {
      return static_cast<const T*>(lhs)->f5 == static_cast<const T*>(rhs)->f5;
    }
    if (std::strcmp(field, "f6") == 0) {
      return static_cast<const T*>(lhs)->f6 == static_cast<const T*>(rhs)->f6;
    }
    if (std::strcmp(field, "f6a") == 0) {
      return static_cast<const T*>(lhs)->f6a == static_cast<const T*>(rhs)->f6a;
    }
    if (std::strcmp(field, "f7") == 0) {
      return static_cast<const T*>(lhs)->f7 == static_cast<const T*>(rhs)->f7;
    }
    if (std::strcmp(field, "f8") == 0) {
      return static_cast<const T*>(lhs)->f8 == static_cast<const T*>(rhs)->f8;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::AStruct)");
  }
};

template<>
const MetaStruct& getMetaStruct<Xyz::AStruct>()
{
  static MetaStructImpl<Xyz::AStruct> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Xyz::AStruct*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Xyz::AStruct>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
bool AStruct::operator==(const AStruct& rhs) const
{
  if (f1 != rhs.f1) {
    return false;
  }
  if (f2 != rhs.f2) {
    return false;
  }
  if (f3 != rhs.f3) {
    return false;
  }
  if (f4 != rhs.f4) {
    return false;
  }
  if (f5 != rhs.f5) {
    return false;
  }
  if (f6 != rhs.f6) {
    return false;
  }
  if (f6a != rhs.f6a) {
    return false;
  }
  if (f7 != rhs.f7) {
    return false;
  }
  if (f8 != rhs.f8) {
    return false;
  }
  for (int i0 = 0; i0 < 5; ++i0) {
    if (f10[i0] != rhs.f10[i0]) {
      return false;
    }
  }
  for (int i0 = 0; i0 < 5; ++i0) {
    if (f11[i0] != rhs.f11[i0]) {
      return false;
    }
  }
  for (int i0 = 0; i0 < 5; ++i0) {
    if (f12[i0] != rhs.f12[i0]) {
      return false;
    }
  }
  for (int i0 = 0; i0 < 5; ++i0) {
    if (f13[i0] != rhs.f13[i0]) {
      return false;
    }
  }
  for (int i0 = 0; i0 < 5; ++i0) {
    if (f14[i0] != rhs.f14[i0]) {
      return false;
    }
  }
  for (int i0 = 0; i0 < 5; ++i0) {
    if (f15[i0] != rhs.f15[i0]) {
      return false;
    }
  }
  if (f20 != rhs.f20) {
    return false;
  }
  if (f21 != rhs.f21) {
    return false;
  }
  if (f22 != rhs.f22) {
    return false;
  }
  if (f23 != rhs.f23) {
    return false;
  }
  if (f24 != rhs.f24) {
    return false;
  }
  if (f25 != rhs.f25) {
    return false;
  }
  for (int i0 = 0; i0 < 6; ++i0) {
    if (f30[i0] != rhs.f30[i0]) {
      return false;
    }
  }
  for (int i0 = 0; i0 < 6; ++i0) {
    if (f31[i0] != rhs.f31[i0]) {
      return false;
    }
  }
  for (int i0 = 0; i0 < 6; ++i0) {
    if (f32[i0] != rhs.f32[i0]) {
      return false;
    }
  }
  for (int i0 = 0; i0 < 6; ++i0) {
    if (f33[i0] != rhs.f33[i0]) {
      return false;
    }
  }
  for (int i0 = 0; i0 < 6; ++i0) {
    if (f34[i0] != rhs.f34[i0]) {
      return false;
    }
  }
  for (int i0 = 0; i0 < 6; ++i0) {
    if (f35[i0] != rhs.f35[i0]) {
      return false;
    }
  }
  if (f40 != rhs.f40) {
    return false;
  }
  if (f41 != rhs.f41) {
    return false;
  }
  if (f42 != rhs.f42) {
    return false;
  }
  if (f43 != rhs.f43) {
    return false;
  }
  if (f44 != rhs.f44) {
    return false;
  }
  if (f45 != rhs.f45) {
    return false;
  }
  for (int i0 = 0; i0 < 7; ++i0) {
    for (int i1 = 0; i1 < 5; ++i1) {
      if (f50[i0][i1] != rhs.f50[i0][i1]) {
        return false;
      }
    }
  }
  for (int i0 = 0; i0 < 7; ++i0) {
    for (int i1 = 0; i1 < 5; ++i1) {
      if (f51[i0][i1] != rhs.f51[i0][i1]) {
        return false;
      }
    }
  }
  for (int i0 = 0; i0 < 7; ++i0) {
    for (int i1 = 0; i1 < 5; ++i1) {
      if (f52[i0][i1] != rhs.f52[i0][i1]) {
        return false;
      }
    }
  }
  for (int i0 = 0; i0 < 7; ++i0) {
    for (int i1 = 0; i1 < 5; ++i1) {
      if (f53[i0][i1] != rhs.f53[i0][i1]) {
        return false;
      }
    }
  }
  for (int i0 = 0; i0 < 7; ++i0) {
    for (int i1 = 0; i1 < 5; ++i1) {
      if (f54[i0][i1] != rhs.f54[i0][i1]) {
        return false;
      }
    }
  }
  for (int i0 = 0; i0 < 7; ++i0) {
    for (int i1 = 0; i1 < 5; ++i1) {
      if (f55[i0][i1] != rhs.f55[i0][i1]) {
        return false;
      }
    }
  }
  if (f60 != rhs.f60) {
    return false;
  }
  if (f61 != rhs.f61) {
    return false;
  }
  if (f62 != rhs.f62) {
    return false;
  }
  if (f63 != rhs.f63) {
    return false;
  }
  if (f64 != rhs.f64) {
    return false;
  }
  if (f65 != rhs.f65) {
    return false;
  }
  return true;
}

void swap(AStruct& lhs, AStruct& rhs)
{
  using std::swap;
  swap(lhs.f1, rhs.f1);
  swap(lhs.f2, rhs.f2);
  swap(lhs.f3, rhs.f3);
  swap(lhs.f4, rhs.f4);
  swap(lhs.f5, rhs.f5);
  swap(lhs.f6, rhs.f6);
  swap(lhs.f6a, rhs.f6a);
  swap(lhs.f7, rhs.f7);
  swap(lhs.f8, rhs.f8);
  std::swap_ranges(lhs.f10, lhs.f10 + 5, rhs.f10);
  std::swap_ranges(lhs.f11, lhs.f11 + 5, rhs.f11);
  std::swap_ranges(lhs.f12, lhs.f12 + 5, rhs.f12);
  std::swap_ranges(lhs.f13, lhs.f13 + 5, rhs.f13);
  std::swap_ranges(lhs.f14, lhs.f14 + 5, rhs.f14);
  std::swap_ranges(lhs.f15, lhs.f15 + 5, rhs.f15);
  swap(lhs.f20, rhs.f20);
  swap(lhs.f21, rhs.f21);
  swap(lhs.f22, rhs.f22);
  swap(lhs.f23, rhs.f23);
  swap(lhs.f24, rhs.f24);
  swap(lhs.f25, rhs.f25);
  std::swap_ranges(lhs.f30, lhs.f30 + 6, rhs.f30);
  std::swap_ranges(lhs.f31, lhs.f31 + 6, rhs.f31);
  std::swap_ranges(lhs.f32, lhs.f32 + 6, rhs.f32);
  std::swap_ranges(lhs.f33, lhs.f33 + 6, rhs.f33);
  std::swap_ranges(lhs.f34, lhs.f34 + 6, rhs.f34);
  std::swap_ranges(lhs.f35, lhs.f35 + 6, rhs.f35);
  swap(lhs.f40, rhs.f40);
  swap(lhs.f41, rhs.f41);
  swap(lhs.f42, rhs.f42);
  swap(lhs.f43, rhs.f43);
  swap(lhs.f44, rhs.f44);
  swap(lhs.f45, rhs.f45);
  std::swap_ranges(lhs.f50[0], lhs.f50[0] + 35, rhs.f50[0]);
  std::swap_ranges(lhs.f51[0], lhs.f51[0] + 35, rhs.f51[0]);
  std::swap_ranges(lhs.f52[0], lhs.f52[0] + 35, rhs.f52[0]);
  std::swap_ranges(lhs.f53[0], lhs.f53[0] + 35, rhs.f53[0]);
  std::swap_ranges(lhs.f54[0], lhs.f54[0] + 35, rhs.f54[0]);
  std::swap_ranges(lhs.f55[0], lhs.f55[0] + 35, rhs.f55[0]);
  swap(lhs.f60, rhs.f60);
  swap(lhs.f61, rhs.f61);
  swap(lhs.f62, rhs.f62);
  swap(lhs.f63, rhs.f63);
  swap(lhs.f64, rhs.f64);
  swap(lhs.f65, rhs.f65);
}

ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const AStruct&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, AStruct&) { return true; }

}

/* End STRUCT: AStruct */


/* Begin TYPEDEF: SeqOfAStruct */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::SeqOfAStruct& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const Xyz::SeqOfAStruct& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::SeqOfAStruct& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > seq.maximum()) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::SeqOfAStruct*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<Xyz::AStruct*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfAStruct */


/* Begin TYPEDEF: ArrayOfAStruct */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::ArrayOfAStruct_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  for (CORBA::ULong i0 = 0; i0 < 3; ++i0) {
    gen_find_size(arr[i0], size, padding);
  }
}

bool operator<<(Serializer& strm, const Xyz::ArrayOfAStruct_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 3; ++i0) {
    if (!(strm << arr[i0])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::ArrayOfAStruct_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 3; ++i0) {
    if (!(strm >> arr[i0])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::ArrayOfAStruct_forany*)
{
  ACE_UNUSED_ARG(ser);
  for (ACE_CDR::ULong i = 0; i < 3; ++i) {
    gen_skip_over(ser, static_cast<Xyz::AStruct*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
ArrayOfAStruct_slice* ArrayOfAStruct_alloc()
{
  void* const raw = ACE_Allocator::instance()->malloc(sizeof(ArrayOfAStruct));
  ArrayOfAStruct_slice* const slice = static_cast<ArrayOfAStruct_slice*>(raw);
  ArrayOfAStruct_init_i(slice);
  return slice;
}

void ArrayOfAStruct_init_i(Xyz::AStruct* begin)
{
  std::uninitialized_fill_n(begin, 3, Xyz::AStruct());
}

void ArrayOfAStruct_fini_i(Xyz::AStruct* begin)
{
  for (int i = 0; i < 3; ++i) {
    begin[i].~AStruct();
  }
}

void ArrayOfAStruct_free(ArrayOfAStruct_slice* slice)
{
  if (!slice) return;
  ArrayOfAStruct_fini_i(slice);
  ACE_Allocator::instance()->free(slice);
}

ArrayOfAStruct_slice* ArrayOfAStruct_dup(const ArrayOfAStruct_slice* slice)
{
  ArrayOfAStruct_slice* const arr = ArrayOfAStruct_alloc();
  if (arr) ArrayOfAStruct_copy(arr, slice);
  return arr;
}

void ArrayOfAStruct_copy(ArrayOfAStruct_slice* dst, const ArrayOfAStruct_slice* src)
{
  if (!src || !dst) return;
  for (ACE_CDR::ULong i0 = 0; i0 < 3; ++i0) {
    dst[i0] = src[i0];
  }
}

}

/* End TYPEDEF: ArrayOfAStruct */


/* Begin STRUCT: StructContainingArrayOfAStruct */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::StructContainingArrayOfAStruct& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  Xyz::ArrayOfAStruct_forany stru_f1(const_cast<Xyz::ArrayOfAStruct_slice*>(stru.f1));
  gen_find_size(stru_f1, size, padding);
}

bool operator<<(Serializer& strm, const Xyz::StructContainingArrayOfAStruct& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfAStruct_forany stru_f1(const_cast<Xyz::ArrayOfAStruct_slice*>(stru.f1));
  return (strm << stru_f1);
}

bool operator>>(Serializer& strm, Xyz::StructContainingArrayOfAStruct& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfAStruct_forany stru_f1(const_cast<Xyz::ArrayOfAStruct_slice*>(stru.f1));
  return (strm >> stru_f1);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Xyz::StructContainingArrayOfAStruct> : MetaStruct {
  typedef Xyz::StructContainingArrayOfAStruct T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Xyz::StructContainingArrayOfAStruct& typed = *static_cast<const Xyz::StructContainingArrayOfAStruct*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructContainingArrayOfAStruct)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfAStruct_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Xyz::StructContainingArrayOfAStruct");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructContainingArrayOfAStruct)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"f1", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "f1") == 0) {
      return &static_cast<const T*>(stru)->f1;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructContainingArrayOfAStruct)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "f1") == 0) {
      Xyz::ArrayOfAStruct* lhsArr = &static_cast<T*>(lhs)->f1;
      const Xyz::ArrayOfAStruct* rhsArr = static_cast<const Xyz::ArrayOfAStruct*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 3; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructContainingArrayOfAStruct)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructContainingArrayOfAStruct)");
  }
};

template<>
const MetaStruct& getMetaStruct<Xyz::StructContainingArrayOfAStruct>()
{
  static MetaStructImpl<Xyz::StructContainingArrayOfAStruct> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Xyz::StructContainingArrayOfAStruct*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Xyz::StructContainingArrayOfAStruct>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
bool StructContainingArrayOfAStruct::operator==(const StructContainingArrayOfAStruct& rhs) const
{
  for (int i0 = 0; i0 < 3; ++i0) {
    if (f1[i0] != rhs.f1[i0]) {
      return false;
    }
  }
  return true;
}

void swap(StructContainingArrayOfAStruct& lhs, StructContainingArrayOfAStruct& rhs)
{
  using std::swap;
  std::swap_ranges(lhs.f1, lhs.f1 + 3, rhs.f1);
}

ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const StructContainingArrayOfAStruct&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, StructContainingArrayOfAStruct&) { return true; }

}

/* End STRUCT: StructContainingArrayOfAStruct */


/* Begin UNION: AUnion */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::AUnion& uni, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(uni);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(uni._d());
  switch (uni._d()) {
  case Xyz::redx:
    {
      find_size_ulong(size, padding);
      size += ACE_OS::strlen(uni.rv()) + 1;
      break;
    }
  case Xyz::greenx:
    {
      gen_find_size(uni.gv(), size, padding);
      break;
    }
  default:
    {
      gen_find_size(uni.bv(), size, padding);
      break;
    }
  }
}

bool operator<<(Serializer& strm, const Xyz::AUnion& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  if (!(strm << uni._d())) {
    return false;
  }
  switch (uni._d()) {
  case Xyz::redx:
    {
      return (strm << uni.rv());
    }
  case Xyz::greenx:
    {
      return (strm << uni.gv());
    }
  default:
    {
      return (strm << uni.bv());
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::AUnion& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  Xyz::AnEnum disc;
  if (!(strm >> disc)) {
    return false;
  }
  switch (disc) {
  case Xyz::redx:
    {
      FACE::String_var tmp;
      if (strm >> tmp.out()) {
        uni.rv(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case Xyz::greenx:
    {
      Xyz::AStruct tmp;
      if (strm >> tmp) {
        uni.gv(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  default:
    {
      Xyz::SeqOfLong tmp;
      if (strm >> tmp) {
        uni.bv(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::AUnion*)
{
  ACE_UNUSED_ARG(ser);
  Xyz::AnEnum disc;
  if (!(ser >> disc)) {
    return;
  }
  switch (disc) {
  case Xyz::redx:
    {
      ACE_CDR::ULong len;
      ser >> len;
      ser.skip(len);
      break;
    }
  case Xyz::greenx:
    {
    gen_skip_over(ser, static_cast<Xyz::AStruct*>(0));
      break;
    }
  default:
    {
    gen_skip_over(ser, static_cast<Xyz::SeqOfLong*>(0));
      break;
    }
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
AUnion::AUnion() { std::memset (this, 0, sizeof (AUnion)); }

AUnion::AUnion(const AUnion& other) {
  this->_discriminator = other._discriminator;
  switch (this->_discriminator) {
  case Xyz::redx:
    {
    this->_u.rv = (other._u.rv) ? ::CORBA::string_dup(other._u.rv) : 0 ;
      break;
    }
  case Xyz::greenx:
    {
    this->_u.gv = (other._u.gv) ? new Xyz::AStruct(*other._u.gv) : 0;
      break;
    }
  default:
    {
    this->_u.bv = (other._u.bv) ? new Xyz::SeqOfLong(*other._u.bv) : 0;
      break;
    }
  }
}

AUnion& AUnion::operator=(const AUnion& other) {
  if (this != &other) {
    _reset();
    this->_discriminator = other._discriminator;
  switch (this->_discriminator) {
  case Xyz::redx:
    {
      this->_u.rv = (other._u.rv) ? ::CORBA::string_dup(other._u.rv) : 0 ;
      break;
    }
  case Xyz::greenx:
    {
      this->_u.gv = (other._u.gv) ? new Xyz::AStruct(*other._u.gv) : 0;
      break;
    }
  default:
    {
      this->_u.bv = (other._u.bv) ? new Xyz::SeqOfLong(*other._u.bv) : 0;
      break;
    }
  }
  }
  return *this;
}

bool AUnion::operator==(const AUnion& rhs) const
{
  if (this->_discriminator != rhs._discriminator) return false;
  switch (this->_discriminator) {
  case Xyz::redx:
    {
      return std::strcmp (this->_u.rv, rhs._u.rv) == 0 ;
      break;
    }
  case Xyz::greenx:
    {
      return *this->_u.gv == *rhs._u.gv;
      break;
    }
  default:
    {
      return *this->_u.bv == *rhs._u.bv;
      break;
    }
  }
    return false;
  }
void AUnion::_reset()
{
  switch (this->_discriminator) {
  case Xyz::redx:
    {
      ::CORBA::string_free(this->_u.rv);
      this->_u.rv = 0;
      break;
    }
  case Xyz::greenx:
    {
      delete this->_u.gv;
      this->_u.gv = 0;
      break;
    }
  default:
    {
      delete this->_u.bv;
      this->_u.bv = 0;
      break;
    }
  }
  }
ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const AUnion&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, AUnion&) { return true; }

}

/* End UNION: AUnion */


/* Begin UNION: BigUnion */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::BigUnion& uni, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(uni);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(uni._d());
  switch (uni._d()) {
  case 1:
    {
      if ((size + padding) % 8) {
        padding += 8 - ((size + padding) % 8);
      }
      size += gen_max_marshaled_size(uni.f1());
      break;
    }
  case 2:
    {
      if ((size + padding) % 4) {
        padding += 4 - ((size + padding) % 4);
      }
      size += gen_max_marshaled_size(uni.f2());
      break;
    }
  case 3:
    {
      size += gen_max_marshaled_size(ACE_OutputCDR::from_boolean(uni.f3()));
      break;
    }
  case 4:
    {
      find_size_ulong(size, padding);
      size += ACE_OS::strlen(uni.f4()) + 1;
      break;
    }
  case 5:
    {
      size += gen_max_marshaled_size(ACE_OutputCDR::from_char(uni.f5()));
      break;
    }
  case 6:
    {
      size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(uni.f6()));
      break;
    }
  case 7:
    {
      if ((size + padding) % 4) {
        padding += 4 - ((size + padding) % 4);
      }
      size += gen_max_marshaled_size(uni.f7());
      break;
    }
  case 8:
    {
      find_size_ulong(size, padding);
      break;
    }
  case 10:
    {
          Xyz::ArrayOfBoolean_forany uni_f10(const_cast<Xyz::ArrayOfBoolean_slice*>(uni.f10()));
      gen_find_size(uni_f10, size, padding);
      break;
    }
  case 11:
    {
          Xyz::ArrayOfString_forany uni_f11(const_cast<Xyz::ArrayOfString_slice*>(uni.f11()));
      gen_find_size(uni_f11, size, padding);
      break;
    }
  case 12:
    {
          Xyz::ArrayOfChar_forany uni_f12(const_cast<Xyz::ArrayOfChar_slice*>(uni.f12()));
      gen_find_size(uni_f12, size, padding);
      break;
    }
  case 13:
    {
          Xyz::ArrayOfOctet_forany uni_f13(const_cast<Xyz::ArrayOfOctet_slice*>(uni.f13()));
      gen_find_size(uni_f13, size, padding);
      break;
    }
  case 14:
    {
          Xyz::ArrayOfLong_forany uni_f14(const_cast<Xyz::ArrayOfLong_slice*>(uni.f14()));
      gen_find_size(uni_f14, size, padding);
      break;
    }
  case 15:
    {
          Xyz::ArrayOfAnEnum_forany uni_f15(const_cast<Xyz::ArrayOfAnEnum_slice*>(uni.f15()));
      gen_find_size(uni_f15, size, padding);
      break;
    }
  case 20:
    {
      gen_find_size(uni.f20(), size, padding);
      break;
    }
  case 21:
    {
      gen_find_size(uni.f21(), size, padding);
      break;
    }
  case 22:
    {
      gen_find_size(uni.f22(), size, padding);
      break;
    }
  case 23:
    {
      gen_find_size(uni.f23(), size, padding);
      break;
    }
  case 24:
    {
      gen_find_size(uni.f24(), size, padding);
      break;
    }
  case 25:
    {
      gen_find_size(uni.f25(), size, padding);
      break;
    }
  case 30:
    {
          Xyz::ArrayOfSeqOfBoolean_forany uni_f30(const_cast<Xyz::ArrayOfSeqOfBoolean_slice*>(uni.f30()));
      gen_find_size(uni_f30, size, padding);
      break;
    }
  case 31:
    {
          Xyz::ArrayOfSeqOfString_forany uni_f31(const_cast<Xyz::ArrayOfSeqOfString_slice*>(uni.f31()));
      gen_find_size(uni_f31, size, padding);
      break;
    }
  case 32:
    {
          Xyz::ArrayOfSeqOfChar_forany uni_f32(const_cast<Xyz::ArrayOfSeqOfChar_slice*>(uni.f32()));
      gen_find_size(uni_f32, size, padding);
      break;
    }
  case 33:
    {
          Xyz::ArrayOfSeqOfOctet_forany uni_f33(const_cast<Xyz::ArrayOfSeqOfOctet_slice*>(uni.f33()));
      gen_find_size(uni_f33, size, padding);
      break;
    }
  case 34:
    {
          Xyz::ArrayOfSeqOfLong_forany uni_f34(const_cast<Xyz::ArrayOfSeqOfLong_slice*>(uni.f34()));
      gen_find_size(uni_f34, size, padding);
      break;
    }
  case 35:
    {
          Xyz::ArrayOfSeqOfAnEnum_forany uni_f35(const_cast<Xyz::ArrayOfSeqOfAnEnum_slice*>(uni.f35()));
      gen_find_size(uni_f35, size, padding);
      break;
    }
  case 40:
    {
      gen_find_size(uni.f40(), size, padding);
      break;
    }
  case 41:
    {
      gen_find_size(uni.f41(), size, padding);
      break;
    }
  case 42:
    {
      gen_find_size(uni.f42(), size, padding);
      break;
    }
  case 43:
    {
      gen_find_size(uni.f43(), size, padding);
      break;
    }
  case 44:
    {
      gen_find_size(uni.f44(), size, padding);
      break;
    }
  case 45:
    {
      gen_find_size(uni.f45(), size, padding);
      break;
    }
  case 50:
    {
          Xyz::ArrayOfArrayOfBoolean_forany uni_f50(const_cast<Xyz::ArrayOfArrayOfBoolean_slice*>(uni.f50()));
      gen_find_size(uni_f50, size, padding);
      break;
    }
  case 51:
    {
          Xyz::ArrayOfArrayOfString_forany uni_f51(const_cast<Xyz::ArrayOfArrayOfString_slice*>(uni.f51()));
      gen_find_size(uni_f51, size, padding);
      break;
    }
  case 52:
    {
          Xyz::ArrayOfArrayOfChar_forany uni_f52(const_cast<Xyz::ArrayOfArrayOfChar_slice*>(uni.f52()));
      gen_find_size(uni_f52, size, padding);
      break;
    }
  case 53:
    {
          Xyz::ArrayOfArrayOfOctet_forany uni_f53(const_cast<Xyz::ArrayOfArrayOfOctet_slice*>(uni.f53()));
      gen_find_size(uni_f53, size, padding);
      break;
    }
  case 54:
    {
          Xyz::ArrayOfArrayOfLong_forany uni_f54(const_cast<Xyz::ArrayOfArrayOfLong_slice*>(uni.f54()));
      gen_find_size(uni_f54, size, padding);
      break;
    }
  case 55:
    {
          Xyz::ArrayOfArrayOfAnEnum_forany uni_f55(const_cast<Xyz::ArrayOfArrayOfAnEnum_slice*>(uni.f55()));
      gen_find_size(uni_f55, size, padding);
      break;
    }
  case 60:
    {
      gen_find_size(uni.f60(), size, padding);
      break;
    }
  case 61:
    {
      gen_find_size(uni.f61(), size, padding);
      break;
    }
  case 62:
    {
      gen_find_size(uni.f62(), size, padding);
      break;
    }
  case 63:
    {
      gen_find_size(uni.f63(), size, padding);
      break;
    }
  case 64:
    {
      gen_find_size(uni.f64(), size, padding);
      break;
    }
  case 65:
    {
      gen_find_size(uni.f65(), size, padding);
      break;
    }
  case 66:
    {
      size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(uni.f6a()));
      break;
    }
  case 90:
    {
      gen_find_size(uni.f90(), size, padding);
      break;
    }
  case 91:
    {
      gen_find_size(uni.f91(), size, padding);
      break;
    }
  case 92:
    {
          Xyz::ArrayOfAStruct_forany uni_v92(const_cast<Xyz::ArrayOfAStruct_slice*>(uni.v92()));
      gen_find_size(uni_v92, size, padding);
      break;
    }
  case 93:
    {
      if ((size + padding) % 8) {
        padding += 8 - ((size + padding) % 8);
      }
      size += gen_max_marshaled_size(uni.ld());
      break;
    }
  default:
    break;
  }
}

bool operator<<(Serializer& strm, const Xyz::BigUnion& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  if (!(strm << uni._d())) {
    return false;
  }
  switch (uni._d()) {
  case 1:
    {
      return (strm << uni.f1());
    }
  case 2:
    {
      return (strm << uni.f2());
    }
  case 3:
    {
      return (strm << ACE_OutputCDR::from_boolean(uni.f3()));
    }
  case 4:
    {
      return (strm << uni.f4());
    }
  case 5:
    {
      return (strm << ACE_OutputCDR::from_char(uni.f5()));
    }
  case 6:
    {
      return (strm << ACE_OutputCDR::from_octet(uni.f6()));
    }
  case 7:
    {
      return (strm << uni.f7());
    }
  case 8:
    {
      return (strm << uni.f8());
    }
  case 10:
    {
      Xyz::ArrayOfBoolean_forany uni_f10(const_cast<Xyz::ArrayOfBoolean_slice*>(uni.f10()));
      return (strm << uni_f10);
    }
  case 11:
    {
      Xyz::ArrayOfString_forany uni_f11(const_cast<Xyz::ArrayOfString_slice*>(uni.f11()));
      return (strm << uni_f11);
    }
  case 12:
    {
      Xyz::ArrayOfChar_forany uni_f12(const_cast<Xyz::ArrayOfChar_slice*>(uni.f12()));
      return (strm << uni_f12);
    }
  case 13:
    {
      Xyz::ArrayOfOctet_forany uni_f13(const_cast<Xyz::ArrayOfOctet_slice*>(uni.f13()));
      return (strm << uni_f13);
    }
  case 14:
    {
      Xyz::ArrayOfLong_forany uni_f14(const_cast<Xyz::ArrayOfLong_slice*>(uni.f14()));
      return (strm << uni_f14);
    }
  case 15:
    {
      Xyz::ArrayOfAnEnum_forany uni_f15(const_cast<Xyz::ArrayOfAnEnum_slice*>(uni.f15()));
      return (strm << uni_f15);
    }
  case 20:
    {
      return (strm << uni.f20());
    }
  case 21:
    {
      return (strm << uni.f21());
    }
  case 22:
    {
      return (strm << uni.f22());
    }
  case 23:
    {
      return (strm << uni.f23());
    }
  case 24:
    {
      return (strm << uni.f24());
    }
  case 25:
    {
      return (strm << uni.f25());
    }
  case 30:
    {
      Xyz::ArrayOfSeqOfBoolean_forany uni_f30(const_cast<Xyz::ArrayOfSeqOfBoolean_slice*>(uni.f30()));
      return (strm << uni_f30);
    }
  case 31:
    {
      Xyz::ArrayOfSeqOfString_forany uni_f31(const_cast<Xyz::ArrayOfSeqOfString_slice*>(uni.f31()));
      return (strm << uni_f31);
    }
  case 32:
    {
      Xyz::ArrayOfSeqOfChar_forany uni_f32(const_cast<Xyz::ArrayOfSeqOfChar_slice*>(uni.f32()));
      return (strm << uni_f32);
    }
  case 33:
    {
      Xyz::ArrayOfSeqOfOctet_forany uni_f33(const_cast<Xyz::ArrayOfSeqOfOctet_slice*>(uni.f33()));
      return (strm << uni_f33);
    }
  case 34:
    {
      Xyz::ArrayOfSeqOfLong_forany uni_f34(const_cast<Xyz::ArrayOfSeqOfLong_slice*>(uni.f34()));
      return (strm << uni_f34);
    }
  case 35:
    {
      Xyz::ArrayOfSeqOfAnEnum_forany uni_f35(const_cast<Xyz::ArrayOfSeqOfAnEnum_slice*>(uni.f35()));
      return (strm << uni_f35);
    }
  case 40:
    {
      return (strm << uni.f40());
    }
  case 41:
    {
      return (strm << uni.f41());
    }
  case 42:
    {
      return (strm << uni.f42());
    }
  case 43:
    {
      return (strm << uni.f43());
    }
  case 44:
    {
      return (strm << uni.f44());
    }
  case 45:
    {
      return (strm << uni.f45());
    }
  case 50:
    {
      Xyz::ArrayOfArrayOfBoolean_forany uni_f50(const_cast<Xyz::ArrayOfArrayOfBoolean_slice*>(uni.f50()));
      return (strm << uni_f50);
    }
  case 51:
    {
      Xyz::ArrayOfArrayOfString_forany uni_f51(const_cast<Xyz::ArrayOfArrayOfString_slice*>(uni.f51()));
      return (strm << uni_f51);
    }
  case 52:
    {
      Xyz::ArrayOfArrayOfChar_forany uni_f52(const_cast<Xyz::ArrayOfArrayOfChar_slice*>(uni.f52()));
      return (strm << uni_f52);
    }
  case 53:
    {
      Xyz::ArrayOfArrayOfOctet_forany uni_f53(const_cast<Xyz::ArrayOfArrayOfOctet_slice*>(uni.f53()));
      return (strm << uni_f53);
    }
  case 54:
    {
      Xyz::ArrayOfArrayOfLong_forany uni_f54(const_cast<Xyz::ArrayOfArrayOfLong_slice*>(uni.f54()));
      return (strm << uni_f54);
    }
  case 55:
    {
      Xyz::ArrayOfArrayOfAnEnum_forany uni_f55(const_cast<Xyz::ArrayOfArrayOfAnEnum_slice*>(uni.f55()));
      return (strm << uni_f55);
    }
  case 60:
    {
      return (strm << uni.f60());
    }
  case 61:
    {
      return (strm << uni.f61());
    }
  case 62:
    {
      return (strm << uni.f62());
    }
  case 63:
    {
      return (strm << uni.f63());
    }
  case 64:
    {
      return (strm << uni.f64());
    }
  case 65:
    {
      return (strm << uni.f65());
    }
  case 66:
    {
      return (strm << ACE_OutputCDR::from_octet(uni.f6a()));
    }
  case 90:
    {
      return (strm << uni.f90());
    }
  case 91:
    {
      return (strm << uni.f91());
    }
  case 92:
    {
      Xyz::ArrayOfAStruct_forany uni_v92(const_cast<Xyz::ArrayOfAStruct_slice*>(uni.v92()));
      return (strm << uni_v92);
    }
  case 93:
    {
      return (strm << uni.ld());
    }
  default:
    break;
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::BigUnion& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  CORBA::Long disc;
  if (!(strm >> disc)) {
    return false;
  }
  switch (disc) {
  case 1:
    {
      CORBA::Double tmp;
      if (strm >> tmp) {
        uni.f1(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 2:
    {
      CORBA::Float tmp;
      if (strm >> tmp) {
        uni.f2(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 3:
    {
      CORBA::Boolean tmp;
      if (strm >> ACE_InputCDR::to_boolean(tmp)) {
        uni.f3(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 4:
    {
      FACE::String_var tmp;
      if (strm >> tmp.out()) {
        uni.f4(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 5:
    {
      CORBA::Char tmp;
      if (strm >> ACE_InputCDR::to_char(tmp)) {
        uni.f5(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 6:
    {
      CORBA::Octet tmp;
      if (strm >> ACE_InputCDR::to_octet(tmp)) {
        uni.f6(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 7:
    {
      CORBA::Long tmp;
      if (strm >> tmp) {
        uni.f7(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 8:
    {
      Xyz::AnEnum tmp;
      if (strm >> tmp) {
        uni.f8(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 10:
    {
      Xyz::ArrayOfBoolean tmp;
      Xyz::ArrayOfBoolean_forany fa = tmp;
      if (strm >> fa) {
        uni.f10(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 11:
    {
      Xyz::ArrayOfString tmp;
      Xyz::ArrayOfString_forany fa = tmp;
      if (strm >> fa) {
        uni.f11(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 12:
    {
      Xyz::ArrayOfChar tmp;
      Xyz::ArrayOfChar_forany fa = tmp;
      if (strm >> fa) {
        uni.f12(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 13:
    {
      Xyz::ArrayOfOctet tmp;
      Xyz::ArrayOfOctet_forany fa = tmp;
      if (strm >> fa) {
        uni.f13(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 14:
    {
      Xyz::ArrayOfLong tmp;
      Xyz::ArrayOfLong_forany fa = tmp;
      if (strm >> fa) {
        uni.f14(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 15:
    {
      Xyz::ArrayOfAnEnum tmp;
      Xyz::ArrayOfAnEnum_forany fa = tmp;
      if (strm >> fa) {
        uni.f15(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 20:
    {
      Xyz::SeqOfBoolean tmp;
      if (strm >> tmp) {
        uni.f20(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 21:
    {
      Xyz::SeqOfString tmp;
      if (strm >> tmp) {
        uni.f21(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 22:
    {
      Xyz::SeqOfChar tmp;
      if (strm >> tmp) {
        uni.f22(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 23:
    {
      Xyz::SeqOfOctet tmp;
      if (strm >> tmp) {
        uni.f23(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 24:
    {
      Xyz::SeqOfLong tmp;
      if (strm >> tmp) {
        uni.f24(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 25:
    {
      Xyz::SeqOfAnEnum tmp;
      if (strm >> tmp) {
        uni.f25(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 30:
    {
      Xyz::ArrayOfSeqOfBoolean tmp;
      Xyz::ArrayOfSeqOfBoolean_forany fa = tmp;
      if (strm >> fa) {
        uni.f30(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 31:
    {
      Xyz::ArrayOfSeqOfString tmp;
      Xyz::ArrayOfSeqOfString_forany fa = tmp;
      if (strm >> fa) {
        uni.f31(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 32:
    {
      Xyz::ArrayOfSeqOfChar tmp;
      Xyz::ArrayOfSeqOfChar_forany fa = tmp;
      if (strm >> fa) {
        uni.f32(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 33:
    {
      Xyz::ArrayOfSeqOfOctet tmp;
      Xyz::ArrayOfSeqOfOctet_forany fa = tmp;
      if (strm >> fa) {
        uni.f33(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 34:
    {
      Xyz::ArrayOfSeqOfLong tmp;
      Xyz::ArrayOfSeqOfLong_forany fa = tmp;
      if (strm >> fa) {
        uni.f34(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 35:
    {
      Xyz::ArrayOfSeqOfAnEnum tmp;
      Xyz::ArrayOfSeqOfAnEnum_forany fa = tmp;
      if (strm >> fa) {
        uni.f35(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 40:
    {
      Xyz::SeqOfArrayOfBoolean tmp;
      if (strm >> tmp) {
        uni.f40(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 41:
    {
      Xyz::SeqOfArrayOfString tmp;
      if (strm >> tmp) {
        uni.f41(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 42:
    {
      Xyz::SeqOfArrayOfChar tmp;
      if (strm >> tmp) {
        uni.f42(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 43:
    {
      Xyz::SeqOfArrayOfOctet tmp;
      if (strm >> tmp) {
        uni.f43(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 44:
    {
      Xyz::SeqOfArrayOfLong tmp;
      if (strm >> tmp) {
        uni.f44(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 45:
    {
      Xyz::SeqOfArrayOfAnEnum tmp;
      if (strm >> tmp) {
        uni.f45(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 50:
    {
      Xyz::ArrayOfArrayOfBoolean tmp;
      Xyz::ArrayOfArrayOfBoolean_forany fa = tmp;
      if (strm >> fa) {
        uni.f50(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 51:
    {
      Xyz::ArrayOfArrayOfString tmp;
      Xyz::ArrayOfArrayOfString_forany fa = tmp;
      if (strm >> fa) {
        uni.f51(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 52:
    {
      Xyz::ArrayOfArrayOfChar tmp;
      Xyz::ArrayOfArrayOfChar_forany fa = tmp;
      if (strm >> fa) {
        uni.f52(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 53:
    {
      Xyz::ArrayOfArrayOfOctet tmp;
      Xyz::ArrayOfArrayOfOctet_forany fa = tmp;
      if (strm >> fa) {
        uni.f53(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 54:
    {
      Xyz::ArrayOfArrayOfLong tmp;
      Xyz::ArrayOfArrayOfLong_forany fa = tmp;
      if (strm >> fa) {
        uni.f54(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 55:
    {
      Xyz::ArrayOfArrayOfAnEnum tmp;
      Xyz::ArrayOfArrayOfAnEnum_forany fa = tmp;
      if (strm >> fa) {
        uni.f55(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 60:
    {
      Xyz::SeqOfSeqOfBoolean tmp;
      if (strm >> tmp) {
        uni.f60(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 61:
    {
      Xyz::SeqOfSeqOfString tmp;
      if (strm >> tmp) {
        uni.f61(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 62:
    {
      Xyz::SeqOfSeqOfChar tmp;
      if (strm >> tmp) {
        uni.f62(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 63:
    {
      Xyz::SeqOfSeqOfOctet tmp;
      if (strm >> tmp) {
        uni.f63(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 64:
    {
      Xyz::SeqOfSeqOfLong tmp;
      if (strm >> tmp) {
        uni.f64(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 65:
    {
      Xyz::SeqOfSeqOfAnEnum tmp;
      if (strm >> tmp) {
        uni.f65(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 66:
    {
      Xyz::OctetTypedef tmp;
      if (strm >> ACE_InputCDR::to_octet(tmp)) {
        uni.f6a(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 90:
    {
      Xyz::AStruct tmp;
      if (strm >> tmp) {
        uni.f90(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 91:
    {
      Xyz::SeqOfAStruct tmp;
      if (strm >> tmp) {
        uni.f91(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 92:
    {
      Xyz::ArrayOfAStruct tmp;
      Xyz::ArrayOfAStruct_forany fa = tmp;
      if (strm >> fa) {
        uni.v92(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 93:
    {
      CORBA::LongDouble tmp;
      if (strm >> tmp) {
        uni.ld(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  default:
    uni._d(disc);
    break;
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::BigUnion*)
{
  ACE_UNUSED_ARG(ser);
  CORBA::Long disc;
  if (!(ser >> disc)) {
    return;
  }
  switch (disc) {
  case 1:
    {
    ser.skip(1, 8);
      break;
    }
  case 2:
    {
    ser.skip(1, 4);
      break;
    }
  case 3:
    {
    ser.skip(1, 1);
      break;
    }
  case 4:
    {
      ACE_CDR::ULong len;
      ser >> len;
      ser.skip(len);
      break;
    }
  case 5:
    {
    ser.skip(1, 1);
      break;
    }
  case 6:
    {
    ser.skip(1, 1);
      break;
    }
  case 7:
    {
    ser.skip(1, 4);
      break;
    }
  case 8:
    {
    ser.skip(1, 4);
      break;
    }
  case 10:
    {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfBoolean_forany*>(0));
      break;
    }
  case 11:
    {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfString_forany*>(0));
      break;
    }
  case 12:
    {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfChar_forany*>(0));
      break;
    }
  case 13:
    {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfOctet_forany*>(0));
      break;
    }
  case 14:
    {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfLong_forany*>(0));
      break;
    }
  case 15:
    {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfAnEnum_forany*>(0));
      break;
    }
  case 20:
    {
    gen_skip_over(ser, static_cast<Xyz::SeqOfBoolean*>(0));
      break;
    }
  case 21:
    {
    gen_skip_over(ser, static_cast<Xyz::SeqOfString*>(0));
      break;
    }
  case 22:
    {
    gen_skip_over(ser, static_cast<Xyz::SeqOfChar*>(0));
      break;
    }
  case 23:
    {
    gen_skip_over(ser, static_cast<Xyz::SeqOfOctet*>(0));
      break;
    }
  case 24:
    {
    gen_skip_over(ser, static_cast<Xyz::SeqOfLong*>(0));
      break;
    }
  case 25:
    {
    gen_skip_over(ser, static_cast<Xyz::SeqOfAnEnum*>(0));
      break;
    }
  case 30:
    {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfSeqOfBoolean_forany*>(0));
      break;
    }
  case 31:
    {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfSeqOfString_forany*>(0));
      break;
    }
  case 32:
    {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfSeqOfChar_forany*>(0));
      break;
    }
  case 33:
    {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfSeqOfOctet_forany*>(0));
      break;
    }
  case 34:
    {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfSeqOfLong_forany*>(0));
      break;
    }
  case 35:
    {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfSeqOfAnEnum_forany*>(0));
      break;
    }
  case 40:
    {
    gen_skip_over(ser, static_cast<Xyz::SeqOfArrayOfBoolean*>(0));
      break;
    }
  case 41:
    {
    gen_skip_over(ser, static_cast<Xyz::SeqOfArrayOfString*>(0));
      break;
    }
  case 42:
    {
    gen_skip_over(ser, static_cast<Xyz::SeqOfArrayOfChar*>(0));
      break;
    }
  case 43:
    {
    gen_skip_over(ser, static_cast<Xyz::SeqOfArrayOfOctet*>(0));
      break;
    }
  case 44:
    {
    gen_skip_over(ser, static_cast<Xyz::SeqOfArrayOfLong*>(0));
      break;
    }
  case 45:
    {
    gen_skip_over(ser, static_cast<Xyz::SeqOfArrayOfAnEnum*>(0));
      break;
    }
  case 50:
    {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfArrayOfBoolean_forany*>(0));
      break;
    }
  case 51:
    {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfArrayOfString_forany*>(0));
      break;
    }
  case 52:
    {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfArrayOfChar_forany*>(0));
      break;
    }
  case 53:
    {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfArrayOfOctet_forany*>(0));
      break;
    }
  case 54:
    {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfArrayOfLong_forany*>(0));
      break;
    }
  case 55:
    {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfArrayOfAnEnum_forany*>(0));
      break;
    }
  case 60:
    {
    gen_skip_over(ser, static_cast<Xyz::SeqOfSeqOfBoolean*>(0));
      break;
    }
  case 61:
    {
    gen_skip_over(ser, static_cast<Xyz::SeqOfSeqOfString*>(0));
      break;
    }
  case 62:
    {
    gen_skip_over(ser, static_cast<Xyz::SeqOfSeqOfChar*>(0));
      break;
    }
  case 63:
    {
    gen_skip_over(ser, static_cast<Xyz::SeqOfSeqOfOctet*>(0));
      break;
    }
  case 64:
    {
    gen_skip_over(ser, static_cast<Xyz::SeqOfSeqOfLong*>(0));
      break;
    }
  case 65:
    {
    gen_skip_over(ser, static_cast<Xyz::SeqOfSeqOfAnEnum*>(0));
      break;
    }
  case 66:
    {
    ser.skip(1, 1);
      break;
    }
  case 90:
    {
    gen_skip_over(ser, static_cast<Xyz::AStruct*>(0));
      break;
    }
  case 91:
    {
    gen_skip_over(ser, static_cast<Xyz::SeqOfAStruct*>(0));
      break;
    }
  case 92:
    {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfAStruct_forany*>(0));
      break;
    }
  case 93:
    {
    ser.skip(1, 16);
      break;
    }
  default:
    break;
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
BigUnion::BigUnion() { std::memset (this, 0, sizeof (BigUnion)); }

BigUnion::BigUnion(const BigUnion& other) {
  this->_discriminator = other._discriminator;
  switch (this->_discriminator) {
  case 1:
    {
    this->_u.f1 = other._u.f1;
      break;
    }
  case 2:
    {
    this->_u.f2 = other._u.f2;
      break;
    }
  case 3:
    {
    this->_u.f3 = other._u.f3;
      break;
    }
  case 4:
    {
    this->_u.f4 = (other._u.f4) ? ::CORBA::string_dup(other._u.f4) : 0 ;
      break;
    }
  case 5:
    {
    this->_u.f5 = other._u.f5;
      break;
    }
  case 6:
    {
    this->_u.f6 = other._u.f6;
      break;
    }
  case 7:
    {
    this->_u.f7 = other._u.f7;
      break;
    }
  case 8:
    {
    this->_u.f8 = other._u.f8;
      break;
    }
  case 10:
    {
    this->_u.f10 = (other._u.f10) ? Xyz::ArrayOfBoolean_dup(other._u.f10) : 0 ;
      break;
    }
  case 11:
    {
    this->_u.f11 = (other._u.f11) ? Xyz::ArrayOfString_dup(other._u.f11) : 0 ;
      break;
    }
  case 12:
    {
    this->_u.f12 = (other._u.f12) ? Xyz::ArrayOfChar_dup(other._u.f12) : 0 ;
      break;
    }
  case 13:
    {
    this->_u.f13 = (other._u.f13) ? Xyz::ArrayOfOctet_dup(other._u.f13) : 0 ;
      break;
    }
  case 14:
    {
    this->_u.f14 = (other._u.f14) ? Xyz::ArrayOfLong_dup(other._u.f14) : 0 ;
      break;
    }
  case 15:
    {
    this->_u.f15 = (other._u.f15) ? Xyz::ArrayOfAnEnum_dup(other._u.f15) : 0 ;
      break;
    }
  case 20:
    {
    this->_u.f20 = (other._u.f20) ? new Xyz::SeqOfBoolean(*other._u.f20) : 0;
      break;
    }
  case 21:
    {
    this->_u.f21 = (other._u.f21) ? new Xyz::SeqOfString(*other._u.f21) : 0;
      break;
    }
  case 22:
    {
    this->_u.f22 = (other._u.f22) ? new Xyz::SeqOfChar(*other._u.f22) : 0;
      break;
    }
  case 23:
    {
    this->_u.f23 = (other._u.f23) ? new Xyz::SeqOfOctet(*other._u.f23) : 0;
      break;
    }
  case 24:
    {
    this->_u.f24 = (other._u.f24) ? new Xyz::SeqOfLong(*other._u.f24) : 0;
      break;
    }
  case 25:
    {
    this->_u.f25 = (other._u.f25) ? new Xyz::SeqOfAnEnum(*other._u.f25) : 0;
      break;
    }
  case 30:
    {
    this->_u.f30 = (other._u.f30) ? Xyz::ArrayOfSeqOfBoolean_dup(other._u.f30) : 0 ;
      break;
    }
  case 31:
    {
    this->_u.f31 = (other._u.f31) ? Xyz::ArrayOfSeqOfString_dup(other._u.f31) : 0 ;
      break;
    }
  case 32:
    {
    this->_u.f32 = (other._u.f32) ? Xyz::ArrayOfSeqOfChar_dup(other._u.f32) : 0 ;
      break;
    }
  case 33:
    {
    this->_u.f33 = (other._u.f33) ? Xyz::ArrayOfSeqOfOctet_dup(other._u.f33) : 0 ;
      break;
    }
  case 34:
    {
    this->_u.f34 = (other._u.f34) ? Xyz::ArrayOfSeqOfLong_dup(other._u.f34) : 0 ;
      break;
    }
  case 35:
    {
    this->_u.f35 = (other._u.f35) ? Xyz::ArrayOfSeqOfAnEnum_dup(other._u.f35) : 0 ;
      break;
    }
  case 40:
    {
    this->_u.f40 = (other._u.f40) ? new Xyz::SeqOfArrayOfBoolean(*other._u.f40) : 0;
      break;
    }
  case 41:
    {
    this->_u.f41 = (other._u.f41) ? new Xyz::SeqOfArrayOfString(*other._u.f41) : 0;
      break;
    }
  case 42:
    {
    this->_u.f42 = (other._u.f42) ? new Xyz::SeqOfArrayOfChar(*other._u.f42) : 0;
      break;
    }
  case 43:
    {
    this->_u.f43 = (other._u.f43) ? new Xyz::SeqOfArrayOfOctet(*other._u.f43) : 0;
      break;
    }
  case 44:
    {
    this->_u.f44 = (other._u.f44) ? new Xyz::SeqOfArrayOfLong(*other._u.f44) : 0;
      break;
    }
  case 45:
    {
    this->_u.f45 = (other._u.f45) ? new Xyz::SeqOfArrayOfAnEnum(*other._u.f45) : 0;
      break;
    }
  case 50:
    {
    this->_u.f50 = (other._u.f50) ? Xyz::ArrayOfArrayOfBoolean_dup(other._u.f50) : 0 ;
      break;
    }
  case 51:
    {
    this->_u.f51 = (other._u.f51) ? Xyz::ArrayOfArrayOfString_dup(other._u.f51) : 0 ;
      break;
    }
  case 52:
    {
    this->_u.f52 = (other._u.f52) ? Xyz::ArrayOfArrayOfChar_dup(other._u.f52) : 0 ;
      break;
    }
  case 53:
    {
    this->_u.f53 = (other._u.f53) ? Xyz::ArrayOfArrayOfOctet_dup(other._u.f53) : 0 ;
      break;
    }
  case 54:
    {
    this->_u.f54 = (other._u.f54) ? Xyz::ArrayOfArrayOfLong_dup(other._u.f54) : 0 ;
      break;
    }
  case 55:
    {
    this->_u.f55 = (other._u.f55) ? Xyz::ArrayOfArrayOfAnEnum_dup(other._u.f55) : 0 ;
      break;
    }
  case 60:
    {
    this->_u.f60 = (other._u.f60) ? new Xyz::SeqOfSeqOfBoolean(*other._u.f60) : 0;
      break;
    }
  case 61:
    {
    this->_u.f61 = (other._u.f61) ? new Xyz::SeqOfSeqOfString(*other._u.f61) : 0;
      break;
    }
  case 62:
    {
    this->_u.f62 = (other._u.f62) ? new Xyz::SeqOfSeqOfChar(*other._u.f62) : 0;
      break;
    }
  case 63:
    {
    this->_u.f63 = (other._u.f63) ? new Xyz::SeqOfSeqOfOctet(*other._u.f63) : 0;
      break;
    }
  case 64:
    {
    this->_u.f64 = (other._u.f64) ? new Xyz::SeqOfSeqOfLong(*other._u.f64) : 0;
      break;
    }
  case 65:
    {
    this->_u.f65 = (other._u.f65) ? new Xyz::SeqOfSeqOfAnEnum(*other._u.f65) : 0;
      break;
    }
  case 66:
    {
    this->_u.f6a = other._u.f6a;
      break;
    }
  case 90:
    {
    this->_u.f90 = (other._u.f90) ? new Xyz::AStruct(*other._u.f90) : 0;
      break;
    }
  case 91:
    {
    this->_u.f91 = (other._u.f91) ? new Xyz::SeqOfAStruct(*other._u.f91) : 0;
      break;
    }
  case 92:
    {
    this->_u.v92 = (other._u.v92) ? Xyz::ArrayOfAStruct_dup(other._u.v92) : 0 ;
      break;
    }
  case 93:
    {
    this->_u.ld = other._u.ld;
      break;
    }
  default:
    break;
  }
}

BigUnion& BigUnion::operator=(const BigUnion& other) {
  if (this != &other) {
    _reset();
    this->_discriminator = other._discriminator;
  switch (this->_discriminator) {
  case 1:
    {
      this->_u.f1 = other._u.f1;
      break;
    }
  case 2:
    {
      this->_u.f2 = other._u.f2;
      break;
    }
  case 3:
    {
      this->_u.f3 = other._u.f3;
      break;
    }
  case 4:
    {
      this->_u.f4 = (other._u.f4) ? ::CORBA::string_dup(other._u.f4) : 0 ;
      break;
    }
  case 5:
    {
      this->_u.f5 = other._u.f5;
      break;
    }
  case 6:
    {
      this->_u.f6 = other._u.f6;
      break;
    }
  case 7:
    {
      this->_u.f7 = other._u.f7;
      break;
    }
  case 8:
    {
      this->_u.f8 = other._u.f8;
      break;
    }
  case 10:
    {
    this->_u.f10 = (other._u.f10) ? Xyz::ArrayOfBoolean_dup(other._u.f10) : 0 ;
      break;
    }
  case 11:
    {
    this->_u.f11 = (other._u.f11) ? Xyz::ArrayOfString_dup(other._u.f11) : 0 ;
      break;
    }
  case 12:
    {
    this->_u.f12 = (other._u.f12) ? Xyz::ArrayOfChar_dup(other._u.f12) : 0 ;
      break;
    }
  case 13:
    {
    this->_u.f13 = (other._u.f13) ? Xyz::ArrayOfOctet_dup(other._u.f13) : 0 ;
      break;
    }
  case 14:
    {
    this->_u.f14 = (other._u.f14) ? Xyz::ArrayOfLong_dup(other._u.f14) : 0 ;
      break;
    }
  case 15:
    {
    this->_u.f15 = (other._u.f15) ? Xyz::ArrayOfAnEnum_dup(other._u.f15) : 0 ;
      break;
    }
  case 20:
    {
      this->_u.f20 = (other._u.f20) ? new Xyz::SeqOfBoolean(*other._u.f20) : 0;
      break;
    }
  case 21:
    {
      this->_u.f21 = (other._u.f21) ? new Xyz::SeqOfString(*other._u.f21) : 0;
      break;
    }
  case 22:
    {
      this->_u.f22 = (other._u.f22) ? new Xyz::SeqOfChar(*other._u.f22) : 0;
      break;
    }
  case 23:
    {
      this->_u.f23 = (other._u.f23) ? new Xyz::SeqOfOctet(*other._u.f23) : 0;
      break;
    }
  case 24:
    {
      this->_u.f24 = (other._u.f24) ? new Xyz::SeqOfLong(*other._u.f24) : 0;
      break;
    }
  case 25:
    {
      this->_u.f25 = (other._u.f25) ? new Xyz::SeqOfAnEnum(*other._u.f25) : 0;
      break;
    }
  case 30:
    {
    this->_u.f30 = (other._u.f30) ? Xyz::ArrayOfSeqOfBoolean_dup(other._u.f30) : 0 ;
      break;
    }
  case 31:
    {
    this->_u.f31 = (other._u.f31) ? Xyz::ArrayOfSeqOfString_dup(other._u.f31) : 0 ;
      break;
    }
  case 32:
    {
    this->_u.f32 = (other._u.f32) ? Xyz::ArrayOfSeqOfChar_dup(other._u.f32) : 0 ;
      break;
    }
  case 33:
    {
    this->_u.f33 = (other._u.f33) ? Xyz::ArrayOfSeqOfOctet_dup(other._u.f33) : 0 ;
      break;
    }
  case 34:
    {
    this->_u.f34 = (other._u.f34) ? Xyz::ArrayOfSeqOfLong_dup(other._u.f34) : 0 ;
      break;
    }
  case 35:
    {
    this->_u.f35 = (other._u.f35) ? Xyz::ArrayOfSeqOfAnEnum_dup(other._u.f35) : 0 ;
      break;
    }
  case 40:
    {
      this->_u.f40 = (other._u.f40) ? new Xyz::SeqOfArrayOfBoolean(*other._u.f40) : 0;
      break;
    }
  case 41:
    {
      this->_u.f41 = (other._u.f41) ? new Xyz::SeqOfArrayOfString(*other._u.f41) : 0;
      break;
    }
  case 42:
    {
      this->_u.f42 = (other._u.f42) ? new Xyz::SeqOfArrayOfChar(*other._u.f42) : 0;
      break;
    }
  case 43:
    {
      this->_u.f43 = (other._u.f43) ? new Xyz::SeqOfArrayOfOctet(*other._u.f43) : 0;
      break;
    }
  case 44:
    {
      this->_u.f44 = (other._u.f44) ? new Xyz::SeqOfArrayOfLong(*other._u.f44) : 0;
      break;
    }
  case 45:
    {
      this->_u.f45 = (other._u.f45) ? new Xyz::SeqOfArrayOfAnEnum(*other._u.f45) : 0;
      break;
    }
  case 50:
    {
    this->_u.f50 = (other._u.f50) ? Xyz::ArrayOfArrayOfBoolean_dup(other._u.f50) : 0 ;
      break;
    }
  case 51:
    {
    this->_u.f51 = (other._u.f51) ? Xyz::ArrayOfArrayOfString_dup(other._u.f51) : 0 ;
      break;
    }
  case 52:
    {
    this->_u.f52 = (other._u.f52) ? Xyz::ArrayOfArrayOfChar_dup(other._u.f52) : 0 ;
      break;
    }
  case 53:
    {
    this->_u.f53 = (other._u.f53) ? Xyz::ArrayOfArrayOfOctet_dup(other._u.f53) : 0 ;
      break;
    }
  case 54:
    {
    this->_u.f54 = (other._u.f54) ? Xyz::ArrayOfArrayOfLong_dup(other._u.f54) : 0 ;
      break;
    }
  case 55:
    {
    this->_u.f55 = (other._u.f55) ? Xyz::ArrayOfArrayOfAnEnum_dup(other._u.f55) : 0 ;
      break;
    }
  case 60:
    {
      this->_u.f60 = (other._u.f60) ? new Xyz::SeqOfSeqOfBoolean(*other._u.f60) : 0;
      break;
    }
  case 61:
    {
      this->_u.f61 = (other._u.f61) ? new Xyz::SeqOfSeqOfString(*other._u.f61) : 0;
      break;
    }
  case 62:
    {
      this->_u.f62 = (other._u.f62) ? new Xyz::SeqOfSeqOfChar(*other._u.f62) : 0;
      break;
    }
  case 63:
    {
      this->_u.f63 = (other._u.f63) ? new Xyz::SeqOfSeqOfOctet(*other._u.f63) : 0;
      break;
    }
  case 64:
    {
      this->_u.f64 = (other._u.f64) ? new Xyz::SeqOfSeqOfLong(*other._u.f64) : 0;
      break;
    }
  case 65:
    {
      this->_u.f65 = (other._u.f65) ? new Xyz::SeqOfSeqOfAnEnum(*other._u.f65) : 0;
      break;
    }
  case 66:
    {
      this->_u.f6a = other._u.f6a;
      break;
    }
  case 90:
    {
      this->_u.f90 = (other._u.f90) ? new Xyz::AStruct(*other._u.f90) : 0;
      break;
    }
  case 91:
    {
      this->_u.f91 = (other._u.f91) ? new Xyz::SeqOfAStruct(*other._u.f91) : 0;
      break;
    }
  case 92:
    {
    this->_u.v92 = (other._u.v92) ? Xyz::ArrayOfAStruct_dup(other._u.v92) : 0 ;
      break;
    }
  case 93:
    {
      this->_u.ld = other._u.ld;
      break;
    }
  default:
    break;
  }
  }
  return *this;
}

bool BigUnion::operator==(const BigUnion& rhs) const
{
  if (this->_discriminator != rhs._discriminator) return false;
  switch (this->_discriminator) {
  case 1:
    {
      return this->_u.f1 == rhs._u.f1;
      break;
    }
  case 2:
    {
      return this->_u.f2 == rhs._u.f2;
      break;
    }
  case 3:
    {
      return this->_u.f3 == rhs._u.f3;
      break;
    }
  case 4:
    {
      return std::strcmp (this->_u.f4, rhs._u.f4) == 0 ;
      break;
    }
  case 5:
    {
      return this->_u.f5 == rhs._u.f5;
      break;
    }
  case 6:
    {
      return this->_u.f6 == rhs._u.f6;
      break;
    }
  case 7:
    {
      return this->_u.f7 == rhs._u.f7;
      break;
    }
  case 8:
    {
      return this->_u.f8 == rhs._u.f8;
      break;
    }
  case 10:
    {
      return false;
      break;
    }
  case 11:
    {
      return false;
      break;
    }
  case 12:
    {
      return false;
      break;
    }
  case 13:
    {
      return false;
      break;
    }
  case 14:
    {
      return false;
      break;
    }
  case 15:
    {
      return false;
      break;
    }
  case 20:
    {
      return *this->_u.f20 == *rhs._u.f20;
      break;
    }
  case 21:
    {
      return *this->_u.f21 == *rhs._u.f21;
      break;
    }
  case 22:
    {
      return *this->_u.f22 == *rhs._u.f22;
      break;
    }
  case 23:
    {
      return *this->_u.f23 == *rhs._u.f23;
      break;
    }
  case 24:
    {
      return *this->_u.f24 == *rhs._u.f24;
      break;
    }
  case 25:
    {
      return *this->_u.f25 == *rhs._u.f25;
      break;
    }
  case 30:
    {
      return false;
      break;
    }
  case 31:
    {
      return false;
      break;
    }
  case 32:
    {
      return false;
      break;
    }
  case 33:
    {
      return false;
      break;
    }
  case 34:
    {
      return false;
      break;
    }
  case 35:
    {
      return false;
      break;
    }
  case 40:
    {
      return *this->_u.f40 == *rhs._u.f40;
      break;
    }
  case 41:
    {
      return *this->_u.f41 == *rhs._u.f41;
      break;
    }
  case 42:
    {
      return *this->_u.f42 == *rhs._u.f42;
      break;
    }
  case 43:
    {
      return *this->_u.f43 == *rhs._u.f43;
      break;
    }
  case 44:
    {
      return *this->_u.f44 == *rhs._u.f44;
      break;
    }
  case 45:
    {
      return *this->_u.f45 == *rhs._u.f45;
      break;
    }
  case 50:
    {
      return false;
      break;
    }
  case 51:
    {
      return false;
      break;
    }
  case 52:
    {
      return false;
      break;
    }
  case 53:
    {
      return false;
      break;
    }
  case 54:
    {
      return false;
      break;
    }
  case 55:
    {
      return false;
      break;
    }
  case 60:
    {
      return *this->_u.f60 == *rhs._u.f60;
      break;
    }
  case 61:
    {
      return *this->_u.f61 == *rhs._u.f61;
      break;
    }
  case 62:
    {
      return *this->_u.f62 == *rhs._u.f62;
      break;
    }
  case 63:
    {
      return *this->_u.f63 == *rhs._u.f63;
      break;
    }
  case 64:
    {
      return *this->_u.f64 == *rhs._u.f64;
      break;
    }
  case 65:
    {
      return *this->_u.f65 == *rhs._u.f65;
      break;
    }
  case 66:
    {
      return this->_u.f6a == rhs._u.f6a;
      break;
    }
  case 90:
    {
      return *this->_u.f90 == *rhs._u.f90;
      break;
    }
  case 91:
    {
      return *this->_u.f91 == *rhs._u.f91;
      break;
    }
  case 92:
    {
      return false;
      break;
    }
  case 93:
    {
      return this->_u.ld == rhs._u.ld;
      break;
    }
  default:
    break;
  }
    return false;
  }
void BigUnion::_reset()
{
  switch (this->_discriminator) {
  case 1:
    {
      break;
    }
  case 2:
    {
      break;
    }
  case 3:
    {
      break;
    }
  case 4:
    {
      ::CORBA::string_free(this->_u.f4);
      this->_u.f4 = 0;
      break;
    }
  case 5:
    {
      break;
    }
  case 6:
    {
      break;
    }
  case 7:
    {
      break;
    }
  case 8:
    {
      break;
    }
  case 10:
    {
      Xyz::ArrayOfBoolean_free(this->_u.f10);
      this->_u.f10 = 0;
      break;
    }
  case 11:
    {
      Xyz::ArrayOfString_free(this->_u.f11);
      this->_u.f11 = 0;
      break;
    }
  case 12:
    {
      Xyz::ArrayOfChar_free(this->_u.f12);
      this->_u.f12 = 0;
      break;
    }
  case 13:
    {
      Xyz::ArrayOfOctet_free(this->_u.f13);
      this->_u.f13 = 0;
      break;
    }
  case 14:
    {
      Xyz::ArrayOfLong_free(this->_u.f14);
      this->_u.f14 = 0;
      break;
    }
  case 15:
    {
      Xyz::ArrayOfAnEnum_free(this->_u.f15);
      this->_u.f15 = 0;
      break;
    }
  case 20:
    {
      delete this->_u.f20;
      this->_u.f20 = 0;
      break;
    }
  case 21:
    {
      delete this->_u.f21;
      this->_u.f21 = 0;
      break;
    }
  case 22:
    {
      delete this->_u.f22;
      this->_u.f22 = 0;
      break;
    }
  case 23:
    {
      delete this->_u.f23;
      this->_u.f23 = 0;
      break;
    }
  case 24:
    {
      delete this->_u.f24;
      this->_u.f24 = 0;
      break;
    }
  case 25:
    {
      delete this->_u.f25;
      this->_u.f25 = 0;
      break;
    }
  case 30:
    {
      Xyz::ArrayOfSeqOfBoolean_free(this->_u.f30);
      this->_u.f30 = 0;
      break;
    }
  case 31:
    {
      Xyz::ArrayOfSeqOfString_free(this->_u.f31);
      this->_u.f31 = 0;
      break;
    }
  case 32:
    {
      Xyz::ArrayOfSeqOfChar_free(this->_u.f32);
      this->_u.f32 = 0;
      break;
    }
  case 33:
    {
      Xyz::ArrayOfSeqOfOctet_free(this->_u.f33);
      this->_u.f33 = 0;
      break;
    }
  case 34:
    {
      Xyz::ArrayOfSeqOfLong_free(this->_u.f34);
      this->_u.f34 = 0;
      break;
    }
  case 35:
    {
      Xyz::ArrayOfSeqOfAnEnum_free(this->_u.f35);
      this->_u.f35 = 0;
      break;
    }
  case 40:
    {
      delete this->_u.f40;
      this->_u.f40 = 0;
      break;
    }
  case 41:
    {
      delete this->_u.f41;
      this->_u.f41 = 0;
      break;
    }
  case 42:
    {
      delete this->_u.f42;
      this->_u.f42 = 0;
      break;
    }
  case 43:
    {
      delete this->_u.f43;
      this->_u.f43 = 0;
      break;
    }
  case 44:
    {
      delete this->_u.f44;
      this->_u.f44 = 0;
      break;
    }
  case 45:
    {
      delete this->_u.f45;
      this->_u.f45 = 0;
      break;
    }
  case 50:
    {
      Xyz::ArrayOfArrayOfBoolean_free(this->_u.f50);
      this->_u.f50 = 0;
      break;
    }
  case 51:
    {
      Xyz::ArrayOfArrayOfString_free(this->_u.f51);
      this->_u.f51 = 0;
      break;
    }
  case 52:
    {
      Xyz::ArrayOfArrayOfChar_free(this->_u.f52);
      this->_u.f52 = 0;
      break;
    }
  case 53:
    {
      Xyz::ArrayOfArrayOfOctet_free(this->_u.f53);
      this->_u.f53 = 0;
      break;
    }
  case 54:
    {
      Xyz::ArrayOfArrayOfLong_free(this->_u.f54);
      this->_u.f54 = 0;
      break;
    }
  case 55:
    {
      Xyz::ArrayOfArrayOfAnEnum_free(this->_u.f55);
      this->_u.f55 = 0;
      break;
    }
  case 60:
    {
      delete this->_u.f60;
      this->_u.f60 = 0;
      break;
    }
  case 61:
    {
      delete this->_u.f61;
      this->_u.f61 = 0;
      break;
    }
  case 62:
    {
      delete this->_u.f62;
      this->_u.f62 = 0;
      break;
    }
  case 63:
    {
      delete this->_u.f63;
      this->_u.f63 = 0;
      break;
    }
  case 64:
    {
      delete this->_u.f64;
      this->_u.f64 = 0;
      break;
    }
  case 65:
    {
      delete this->_u.f65;
      this->_u.f65 = 0;
      break;
    }
  case 66:
    {
      break;
    }
  case 90:
    {
      delete this->_u.f90;
      this->_u.f90 = 0;
      break;
    }
  case 91:
    {
      delete this->_u.f91;
      this->_u.f91 = 0;
      break;
    }
  case 92:
    {
      Xyz::ArrayOfAStruct_free(this->_u.v92);
      this->_u.v92 = 0;
      break;
    }
  case 93:
    {
      break;
    }
  default:
    break;
  }
  }
ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const BigUnion&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, BigUnion&) { return true; }

}

/* End UNION: BigUnion */


/* Begin STRUCT: StructAUnion */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::StructAUnion& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.sau_f1, size, padding);
}

bool operator<<(Serializer& strm, const Xyz::StructAUnion& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.sau_f1);
}

bool operator>>(Serializer& strm, Xyz::StructAUnion& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.sau_f1);
}

size_t gen_max_marshaled_size(const Xyz::StructAUnion& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructAUnion> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Xyz::StructAUnion> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructAUnion> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Xyz::StructAUnion> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
::DDS::DataWriter_ptr StructAUnionTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<StructAUnion> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr StructAUnionTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructAUnion> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr StructAUnionTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructAUnion> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<StructAUnion, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& StructAUnionTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<StructAUnion>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool StructAUnionTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* StructAUnionTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
StructAUnionTypeSupport::_ptr_type StructAUnionTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Xyz::StructAUnion> : MetaStruct {
  typedef Xyz::StructAUnion T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Xyz::StructAUnion& typed = *static_cast<const Xyz::StructAUnion*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructAUnion)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<Xyz::AUnion*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Xyz::StructAUnion");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructAUnion)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"sau_f1", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "sau_f1") == 0) {
      return &static_cast<const T*>(stru)->sau_f1;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructAUnion)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "sau_f1") == 0) {
      static_cast<T*>(lhs)->sau_f1 = *static_cast<const Xyz::AUnion*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructAUnion)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructAUnion)");
  }
};

template<>
const MetaStruct& getMetaStruct<Xyz::StructAUnion>()
{
  static MetaStructImpl<Xyz::StructAUnion> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Xyz::StructAUnion*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Xyz::StructAUnion>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
bool StructAUnion::operator==(const StructAUnion& rhs) const
{
  if (sau_f1 != rhs.sau_f1) {
    return false;
  }
  return true;
}

void swap(StructAUnion& lhs, StructAUnion& rhs)
{
  using std::swap;
  swap(lhs.sau_f1, rhs.sau_f1);
}

ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const StructAUnion&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, StructAUnion&) { return true; }

}

/* End STRUCT: StructAUnion */


/* Begin TYPEDEF: SeqOfAUnion */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::SeqOfAUnion& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const Xyz::SeqOfAUnion& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::SeqOfAUnion& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > seq.maximum()) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::SeqOfAUnion*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfAUnion */


/* Begin TYPEDEF: AStructSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::AStructSeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const Xyz::AStructSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::AStructSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > seq.maximum()) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::AStructSeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<Xyz::AStruct*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: AStructSeq */


/* Begin TYPEDEF: ArrayOfAStructSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::ArrayOfAStructSeq_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  for (CORBA::ULong i0 = 0; i0 < 3; ++i0) {
    gen_find_size(arr[i0], size, padding);
  }
}

bool operator<<(Serializer& strm, const Xyz::ArrayOfAStructSeq_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 3; ++i0) {
    if (!(strm << arr[i0])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::ArrayOfAStructSeq_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 3; ++i0) {
    if (!(strm >> arr[i0])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::ArrayOfAStructSeq_forany*)
{
  ACE_UNUSED_ARG(ser);
  for (ACE_CDR::ULong i = 0; i < 3; ++i) {
    gen_skip_over(ser, static_cast<Xyz::AStructSeq*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
ArrayOfAStructSeq_slice* ArrayOfAStructSeq_alloc()
{
  void* const raw = ACE_Allocator::instance()->malloc(sizeof(ArrayOfAStructSeq));
  ArrayOfAStructSeq_slice* const slice = static_cast<ArrayOfAStructSeq_slice*>(raw);
  ArrayOfAStructSeq_init_i(slice);
  return slice;
}

void ArrayOfAStructSeq_init_i(Xyz::AStructSeq* begin)
{
  std::uninitialized_fill_n(begin, 3, Xyz::AStructSeq());
}

void ArrayOfAStructSeq_fini_i(Xyz::AStructSeq* begin)
{
  for (int i = 0; i < 3; ++i) {
    begin[i].~AStructSeq();
  }
}

void ArrayOfAStructSeq_free(ArrayOfAStructSeq_slice* slice)
{
  if (!slice) return;
  ArrayOfAStructSeq_fini_i(slice);
  ACE_Allocator::instance()->free(slice);
}

ArrayOfAStructSeq_slice* ArrayOfAStructSeq_dup(const ArrayOfAStructSeq_slice* slice)
{
  ArrayOfAStructSeq_slice* const arr = ArrayOfAStructSeq_alloc();
  if (arr) ArrayOfAStructSeq_copy(arr, slice);
  return arr;
}

void ArrayOfAStructSeq_copy(ArrayOfAStructSeq_slice* dst, const ArrayOfAStructSeq_slice* src)
{
  if (!src || !dst) return;
  for (ACE_CDR::ULong i0 = 0; i0 < 3; ++i0) {
    dst[i0] = src[i0];
  }
}

}

/* End TYPEDEF: ArrayOfAStructSeq */


/* Begin STRUCT: StructContainingArrayOfAStructSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::StructContainingArrayOfAStructSeq& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  Xyz::ArrayOfAStructSeq_forany stru_f1(const_cast<Xyz::ArrayOfAStructSeq_slice*>(stru.f1));
  gen_find_size(stru_f1, size, padding);
}

bool operator<<(Serializer& strm, const Xyz::StructContainingArrayOfAStructSeq& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfAStructSeq_forany stru_f1(const_cast<Xyz::ArrayOfAStructSeq_slice*>(stru.f1));
  return (strm << stru_f1);
}

bool operator>>(Serializer& strm, Xyz::StructContainingArrayOfAStructSeq& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfAStructSeq_forany stru_f1(const_cast<Xyz::ArrayOfAStructSeq_slice*>(stru.f1));
  return (strm >> stru_f1);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Xyz::StructContainingArrayOfAStructSeq> : MetaStruct {
  typedef Xyz::StructContainingArrayOfAStructSeq T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Xyz::StructContainingArrayOfAStructSeq& typed = *static_cast<const Xyz::StructContainingArrayOfAStructSeq*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructContainingArrayOfAStructSeq)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfAStructSeq_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Xyz::StructContainingArrayOfAStructSeq");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructContainingArrayOfAStructSeq)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"f1", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "f1") == 0) {
      return &static_cast<const T*>(stru)->f1;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructContainingArrayOfAStructSeq)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "f1") == 0) {
      Xyz::ArrayOfAStructSeq* lhsArr = &static_cast<T*>(lhs)->f1;
      const Xyz::ArrayOfAStructSeq* rhsArr = static_cast<const Xyz::ArrayOfAStructSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 3; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructContainingArrayOfAStructSeq)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructContainingArrayOfAStructSeq)");
  }
};

template<>
const MetaStruct& getMetaStruct<Xyz::StructContainingArrayOfAStructSeq>()
{
  static MetaStructImpl<Xyz::StructContainingArrayOfAStructSeq> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Xyz::StructContainingArrayOfAStructSeq*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Xyz::StructContainingArrayOfAStructSeq>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
bool StructContainingArrayOfAStructSeq::operator==(const StructContainingArrayOfAStructSeq& rhs) const
{
  for (int i0 = 0; i0 < 3; ++i0) {
    if (f1[i0] != rhs.f1[i0]) {
      return false;
    }
  }
  return true;
}

void swap(StructContainingArrayOfAStructSeq& lhs, StructContainingArrayOfAStructSeq& rhs)
{
  using std::swap;
  std::swap_ranges(lhs.f1, lhs.f1 + 3, rhs.f1);
}

ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const StructContainingArrayOfAStructSeq&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, StructContainingArrayOfAStructSeq&) { return true; }

}

/* End STRUCT: StructContainingArrayOfAStructSeq */


/* Begin TYPEDEF: BigUnionSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::BigUnionSeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const Xyz::BigUnionSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::BigUnionSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::BigUnionSeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: BigUnionSeq */


/* Begin TYPEDEF: OctetArray */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::OctetArray_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += 3 * max_marshaled_size_octet();
}

bool operator<<(Serializer& strm, const Xyz::OctetArray_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.write_octet_array(arr.in(), 3);
}

bool operator>>(Serializer& strm, Xyz::OctetArray_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.read_octet_array(arr.out(), 3);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::OctetArray_forany*)
{
  ACE_UNUSED_ARG(ser);
  ser.skip(3, 1);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
OctetArray_slice* OctetArray_alloc()
{
  void* const raw = ACE_Allocator::instance()->malloc(sizeof(OctetArray));
  OctetArray_slice* const slice = static_cast<OctetArray_slice*>(raw);
  OctetArray_init_i(slice);
  return slice;
}

void OctetArray_init_i(::FACE::Octet* begin)
{
  ACE_UNUSED_ARG(begin);
}

void OctetArray_fini_i(::FACE::Octet* begin)
{
  ACE_UNUSED_ARG(begin);
}

void OctetArray_free(OctetArray_slice* slice)
{
  if (!slice) return;
  OctetArray_fini_i(slice);
  ACE_Allocator::instance()->free(slice);
}

OctetArray_slice* OctetArray_dup(const OctetArray_slice* slice)
{
  OctetArray_slice* const arr = OctetArray_alloc();
  if (arr) OctetArray_copy(arr, slice);
  return arr;
}

void OctetArray_copy(OctetArray_slice* dst, const OctetArray_slice* src)
{
  if (!src || !dst) return;
  for (ACE_CDR::ULong i0 = 0; i0 < 3; ++i0) {
    dst[i0] = src[i0];
  }
}

}

/* End TYPEDEF: OctetArray */


/* Begin STRUCT: Foo */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::Foo& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  Xyz::OctetArray_forany stru_ooo(const_cast<Xyz::OctetArray_slice*>(stru.ooo));
  Xyz::ArrayOfAStruct_forany stru_structArray(const_cast<Xyz::ArrayOfAStruct_slice*>(stru.structArray));
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.key);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.octer));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.theOctetTypedef));
  find_size_ulong(size, padding);
  gen_find_size(stru_ooo, size, padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.theString.in()) + 1;
  gen_find_size(stru.thestruct, size, padding);
  gen_find_size(stru.theStructSeq, size, padding);
  gen_find_size(stru_structArray, size, padding);
  gen_find_size(stru.theUnion, size, padding);
  gen_find_size(stru.theSeqOfUnion, size, padding);
  gen_find_size(stru.theBigUnion, size, padding);
  gen_find_size(stru.theSeqOfBitUnion, size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.x);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.y);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_wchar(stru.theWChar));
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.theWString.in()) * OpenDDS::DCPS::Serializer::WCHAR_SIZE;
  if ((size + padding) % 8) {
    padding += 8 - ((size + padding) % 8);
  }
  size += gen_max_marshaled_size(stru.theLongDouble);
}

bool operator<<(Serializer& strm, const Xyz::Foo& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::OctetArray_forany stru_ooo(const_cast<Xyz::OctetArray_slice*>(stru.ooo));
  Xyz::ArrayOfAStruct_forany stru_structArray(const_cast<Xyz::ArrayOfAStruct_slice*>(stru.structArray));
  return (strm << stru.key)
    && (strm << ACE_OutputCDR::from_octet(stru.octer))
    && (strm << ACE_OutputCDR::from_octet(stru.theOctetTypedef))
    && (strm << stru.xcolor)
    && (strm << stru_ooo)
    && (strm << stru.theString.in())
    && (strm << stru.thestruct)
    && (strm << stru.theStructSeq)
    && (strm << stru_structArray)
    && (strm << stru.theUnion)
    && (strm << stru.theSeqOfUnion)
    && (strm << stru.theBigUnion)
    && (strm << stru.theSeqOfBitUnion)
    && (strm << stru.x)
    && (strm << stru.y)
    && (strm << ACE_OutputCDR::from_wchar(stru.theWChar))
    && (strm << stru.theWString.in())
    && (strm << stru.theLongDouble);
}

bool operator>>(Serializer& strm, Xyz::Foo& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::OctetArray_forany stru_ooo(const_cast<Xyz::OctetArray_slice*>(stru.ooo));
  Xyz::ArrayOfAStruct_forany stru_structArray(const_cast<Xyz::ArrayOfAStruct_slice*>(stru.structArray));
  return (strm >> stru.key)
    && (strm >> ACE_InputCDR::to_octet(stru.octer))
    && (strm >> ACE_InputCDR::to_octet(stru.theOctetTypedef))
    && (strm >> stru.xcolor)
    && (strm >> stru_ooo)
    && (strm >> stru.theString.out())
    && (strm >> stru.thestruct)
    && (strm >> stru.theStructSeq)
    && (strm >> stru_structArray)
    && (strm >> stru.theUnion)
    && (strm >> stru.theSeqOfUnion)
    && (strm >> stru.theBigUnion)
    && (strm >> stru.theSeqOfBitUnion)
    && (strm >> stru.x)
    && (strm >> stru.y)
    && (strm >> ACE_InputCDR::to_wchar(stru.theWChar))
    && (strm >> stru.theWString.out())
    && (strm >> stru.theLongDouble);
}

size_t gen_max_marshaled_size(const Xyz::Foo& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const Xyz::Foo> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 8;
}

void gen_find_size(KeyOnly<const Xyz::Foo> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.key);
  find_size_ulong(size, padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Xyz::Foo> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.t.key)
    && (strm << stru.t.xcolor);
}

bool operator>>(Serializer& strm, KeyOnly<Xyz::Foo> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.t.key)
    && (strm >> stru.t.xcolor);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
::DDS::DataWriter_ptr FooTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<Foo> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr FooTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<Foo> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr FooTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<Foo> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<Foo, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& FooTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<Foo>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool FooTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* FooTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
FooTypeSupport::_ptr_type FooTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Xyz::Foo> : MetaStruct {
  typedef Xyz::Foo T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 2; }

  Value getValue(const void* stru, const char* field) const
  {
    const Xyz::Foo& typed = *static_cast<const Xyz::Foo*>(stru);
    if (std::strcmp(field, "key") == 0) {
      return typed.key;
    }
    if (std::strcmp(field, "octer") == 0) {
      return typed.octer;
    }
    if (std::strcmp(field, "theOctetTypedef") == 0) {
      return typed.theOctetTypedef;
    }
    if (std::strcmp(field, "xcolor") == 0) {
      return gen_Xyz_AnEnum_names[typed.xcolor];
    }
    if (std::strcmp(field, "theString") == 0) {
      return typed.theString.in();
    }
    if (std::strncmp(field, "thestruct.", 10) == 0) {
      return getMetaStruct<Xyz::AStruct>().getValue(&typed.thestruct, field + 10);
    }
    if (std::strcmp(field, "x") == 0) {
      return typed.x;
    }
    if (std::strcmp(field, "y") == 0) {
      return typed.y;
    }
    if (std::strcmp(field, "theWChar") == 0) {
      return typed.theWChar;
    }
    if (std::strcmp(field, "theWString") == 0) {
      return typed.theWString.in();
    }
    if (std::strcmp(field, "theLongDouble") == 0) {
      return typed.theLongDouble;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::Foo)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "key") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'key' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "octer") == 0) {
      ACE_CDR::Octet val;
      if (!(ser >> ACE_InputCDR::to_octet(val))) {
        throw std::runtime_error("Field 'octer' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 1);
    }
    if (std::strcmp(field, "theOctetTypedef") == 0) {
      ACE_CDR::Octet val;
      if (!(ser >> ACE_InputCDR::to_octet(val))) {
        throw std::runtime_error("Field 'theOctetTypedef' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 1);
    }
    if (std::strcmp(field, "xcolor") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'xcolor' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    gen_skip_over(ser, static_cast<Xyz::OctetArray_forany*>(0));
    if (std::strcmp(field, "theString") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'theString' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'theString' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strncmp(field, "thestruct.", 10) == 0) {
      return getMetaStruct<Xyz::AStruct>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<Xyz::AStruct*>(0));
    }
    gen_skip_over(ser, static_cast<Xyz::AStructSeq*>(0));
    gen_skip_over(ser, static_cast<Xyz::ArrayOfAStruct_forany*>(0));
    gen_skip_over(ser, static_cast<Xyz::AUnion*>(0));
    gen_skip_over(ser, static_cast<Xyz::SeqOfAUnion*>(0));
    gen_skip_over(ser, static_cast<Xyz::BigUnion*>(0));
    gen_skip_over(ser, static_cast<Xyz::BigUnionSeq*>(0));
    if (std::strcmp(field, "x") == 0) {
      ACE_CDR::Float val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'x' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "y") == 0) {
      ACE_CDR::Float val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'y' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "theWChar") == 0) {
      ACE_CDR::WChar val;
      if (!(ser >> ACE_InputCDR::to_wchar(val))) {
        throw std::runtime_error("Field 'theWChar' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::Octet len;
      if (!(ser >> ACE_InputCDR::to_octet(len))) {
        throw std::runtime_error("WChar 'theWChar' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strcmp(field, "theWString") == 0) {
      TAO::WString_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'theWString' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'theWString' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strcmp(field, "theLongDouble") == 0) {
      ACE_CDR::LongDouble val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'theLongDouble' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 16);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Xyz::Foo");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "key") == 0) {
      return make_field_cmp(&T::key, next);
    }
    if (std::strcmp(field, "octer") == 0) {
      return make_field_cmp(&T::octer, next);
    }
    if (std::strcmp(field, "theOctetTypedef") == 0) {
      return make_field_cmp(&T::theOctetTypedef, next);
    }
    if (std::strcmp(field, "xcolor") == 0) {
      return make_field_cmp(&T::xcolor, next);
    }
    if (std::strcmp(field, "theString") == 0) {
      return make_field_cmp(&T::theString, next);
    }
    if (std::strncmp(field, "thestruct.", 10) == 0) {
      return make_struct_cmp(&T::thestruct, getMetaStruct<Xyz::AStruct>().create_qc_comparator(field + 10), next);
    }
    if (std::strcmp(field, "x") == 0) {
      return make_field_cmp(&T::x, next);
    }
    if (std::strcmp(field, "y") == 0) {
      return make_field_cmp(&T::y, next);
    }
    if (std::strcmp(field, "theWChar") == 0) {
      return make_field_cmp(&T::theWChar, next);
    }
    if (std::strcmp(field, "theWString") == 0) {
      return make_field_cmp(&T::theWString, next);
    }
    if (std::strcmp(field, "theLongDouble") == 0) {
      return make_field_cmp(&T::theLongDouble, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::Foo)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"key", "octer", "theOctetTypedef", "xcolor", "ooo", "theString", "thestruct", "theStructSeq", "structArray", "theUnion", "theSeqOfUnion", "theBigUnion", "theSeqOfBitUnion", "x", "y", "theWChar", "theWString", "theLongDouble", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "key") == 0) {
      return &static_cast<const T*>(stru)->key;
    }
    if (std::strcmp(field, "octer") == 0) {
      return &static_cast<const T*>(stru)->octer;
    }
    if (std::strcmp(field, "theOctetTypedef") == 0) {
      return &static_cast<const T*>(stru)->theOctetTypedef;
    }
    if (std::strcmp(field, "xcolor") == 0) {
      return &static_cast<const T*>(stru)->xcolor;
    }
    if (std::strcmp(field, "ooo") == 0) {
      return &static_cast<const T*>(stru)->ooo;
    }
    if (std::strcmp(field, "theString") == 0) {
      return &static_cast<const T*>(stru)->theString;
    }
    if (std::strcmp(field, "thestruct") == 0) {
      return &static_cast<const T*>(stru)->thestruct;
    }
    if (std::strcmp(field, "theStructSeq") == 0) {
      return &static_cast<const T*>(stru)->theStructSeq;
    }
    if (std::strcmp(field, "structArray") == 0) {
      return &static_cast<const T*>(stru)->structArray;
    }
    if (std::strcmp(field, "theUnion") == 0) {
      return &static_cast<const T*>(stru)->theUnion;
    }
    if (std::strcmp(field, "theSeqOfUnion") == 0) {
      return &static_cast<const T*>(stru)->theSeqOfUnion;
    }
    if (std::strcmp(field, "theBigUnion") == 0) {
      return &static_cast<const T*>(stru)->theBigUnion;
    }
    if (std::strcmp(field, "theSeqOfBitUnion") == 0) {
      return &static_cast<const T*>(stru)->theSeqOfBitUnion;
    }
    if (std::strcmp(field, "x") == 0) {
      return &static_cast<const T*>(stru)->x;
    }
    if (std::strcmp(field, "y") == 0) {
      return &static_cast<const T*>(stru)->y;
    }
    if (std::strcmp(field, "theWChar") == 0) {
      return &static_cast<const T*>(stru)->theWChar;
    }
    if (std::strcmp(field, "theWString") == 0) {
      return &static_cast<const T*>(stru)->theWString;
    }
    if (std::strcmp(field, "theLongDouble") == 0) {
      return &static_cast<const T*>(stru)->theLongDouble;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::Foo)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "key") == 0) {
      static_cast<T*>(lhs)->key = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "octer") == 0) {
      static_cast<T*>(lhs)->octer = *static_cast<const CORBA::Octet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "theOctetTypedef") == 0) {
      static_cast<T*>(lhs)->theOctetTypedef = *static_cast<const Xyz::OctetTypedef*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "xcolor") == 0) {
      static_cast<T*>(lhs)->xcolor = *static_cast<const Xyz::AnEnum*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ooo") == 0) {
      Xyz::OctetArray* lhsArr = &static_cast<T*>(lhs)->ooo;
      const Xyz::OctetArray* rhsArr = static_cast<const Xyz::OctetArray*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 3; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    if (std::strcmp(field, "theString") == 0) {
      static_cast<T*>(lhs)->theString = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "thestruct") == 0) {
      static_cast<T*>(lhs)->thestruct = *static_cast<const Xyz::AStruct*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "theStructSeq") == 0) {
      static_cast<T*>(lhs)->theStructSeq = *static_cast<const Xyz::AStructSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "structArray") == 0) {
      Xyz::ArrayOfAStruct* lhsArr = &static_cast<T*>(lhs)->structArray;
      const Xyz::ArrayOfAStruct* rhsArr = static_cast<const Xyz::ArrayOfAStruct*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 3; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    if (std::strcmp(field, "theUnion") == 0) {
      static_cast<T*>(lhs)->theUnion = *static_cast<const Xyz::AUnion*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "theSeqOfUnion") == 0) {
      static_cast<T*>(lhs)->theSeqOfUnion = *static_cast<const Xyz::SeqOfAUnion*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "theBigUnion") == 0) {
      static_cast<T*>(lhs)->theBigUnion = *static_cast<const Xyz::BigUnion*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "theSeqOfBitUnion") == 0) {
      static_cast<T*>(lhs)->theSeqOfBitUnion = *static_cast<const Xyz::BigUnionSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "x") == 0) {
      static_cast<T*>(lhs)->x = *static_cast<const CORBA::Float*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "y") == 0) {
      static_cast<T*>(lhs)->y = *static_cast<const CORBA::Float*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "theWChar") == 0) {
      static_cast<T*>(lhs)->theWChar = *static_cast<const CORBA::WChar*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "theWString") == 0) {
      static_cast<T*>(lhs)->theWString = *static_cast<const TAO::WString_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "theLongDouble") == 0) {
      static_cast<T*>(lhs)->theLongDouble = *static_cast<const CORBA::LongDouble*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::Foo)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "key") == 0) {
      return static_cast<const T*>(lhs)->key == static_cast<const T*>(rhs)->key;
    }
    if (std::strcmp(field, "octer") == 0) {
      return static_cast<const T*>(lhs)->octer == static_cast<const T*>(rhs)->octer;
    }
    if (std::strcmp(field, "theOctetTypedef") == 0) {
      return static_cast<const T*>(lhs)->theOctetTypedef == static_cast<const T*>(rhs)->theOctetTypedef;
    }
    if (std::strcmp(field, "xcolor") == 0) {
      return static_cast<const T*>(lhs)->xcolor == static_cast<const T*>(rhs)->xcolor;
    }
    if (std::strcmp(field, "theString") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->theString.in(), static_cast<const T*>(rhs)->theString.in());
    }
    if (std::strcmp(field, "x") == 0) {
      return static_cast<const T*>(lhs)->x == static_cast<const T*>(rhs)->x;
    }
    if (std::strcmp(field, "y") == 0) {
      return static_cast<const T*>(lhs)->y == static_cast<const T*>(rhs)->y;
    }
    if (std::strcmp(field, "theWChar") == 0) {
      return static_cast<const T*>(lhs)->theWChar == static_cast<const T*>(rhs)->theWChar;
    }
    if (std::strcmp(field, "theWString") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->theWString.in(), static_cast<const T*>(rhs)->theWString.in());
    }
    if (std::strcmp(field, "theLongDouble") == 0) {
      return static_cast<const T*>(lhs)->theLongDouble == static_cast<const T*>(rhs)->theLongDouble;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::Foo)");
  }
};

template<>
const MetaStruct& getMetaStruct<Xyz::Foo>()
{
  static MetaStructImpl<Xyz::Foo> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Xyz::Foo*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Xyz::Foo>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
bool Foo::operator==(const Foo& rhs) const
{
  if (key != rhs.key) {
    return false;
  }
  if (octer != rhs.octer) {
    return false;
  }
  if (theOctetTypedef != rhs.theOctetTypedef) {
    return false;
  }
  if (xcolor != rhs.xcolor) {
    return false;
  }
  for (int i0 = 0; i0 < 3; ++i0) {
    if (ooo[i0] != rhs.ooo[i0]) {
      return false;
    }
  }
  if (theString != rhs.theString) {
    return false;
  }
  if (thestruct != rhs.thestruct) {
    return false;
  }
  if (theStructSeq != rhs.theStructSeq) {
    return false;
  }
  for (int i0 = 0; i0 < 3; ++i0) {
    if (structArray[i0] != rhs.structArray[i0]) {
      return false;
    }
  }
  if (theUnion != rhs.theUnion) {
    return false;
  }
  if (theSeqOfUnion != rhs.theSeqOfUnion) {
    return false;
  }
  if (theBigUnion != rhs.theBigUnion) {
    return false;
  }
  if (theSeqOfBitUnion != rhs.theSeqOfBitUnion) {
    return false;
  }
  if (x != rhs.x) {
    return false;
  }
  if (y != rhs.y) {
    return false;
  }
  if (theWChar != rhs.theWChar) {
    return false;
  }
  if (theWString != rhs.theWString) {
    return false;
  }
  if (theLongDouble != rhs.theLongDouble) {
    return false;
  }
  return true;
}

void swap(Foo& lhs, Foo& rhs)
{
  using std::swap;
  swap(lhs.key, rhs.key);
  swap(lhs.octer, rhs.octer);
  swap(lhs.theOctetTypedef, rhs.theOctetTypedef);
  swap(lhs.xcolor, rhs.xcolor);
  std::swap_ranges(lhs.ooo, lhs.ooo + 3, rhs.ooo);
  swap(lhs.theString, rhs.theString);
  swap(lhs.thestruct, rhs.thestruct);
  swap(lhs.theStructSeq, rhs.theStructSeq);
  std::swap_ranges(lhs.structArray, lhs.structArray + 3, rhs.structArray);
  swap(lhs.theUnion, rhs.theUnion);
  swap(lhs.theSeqOfUnion, rhs.theSeqOfUnion);
  swap(lhs.theBigUnion, rhs.theBigUnion);
  swap(lhs.theSeqOfBitUnion, rhs.theSeqOfBitUnion);
  swap(lhs.x, rhs.x);
  swap(lhs.y, rhs.y);
  swap(lhs.theWChar, rhs.theWChar);
  swap(lhs.theWString, rhs.theWString);
  swap(lhs.theLongDouble, rhs.theLongDouble);
}

ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const Foo&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, Foo&) { return true; }

}

/* End STRUCT: Foo */

/* End MODULE: Xyz */
