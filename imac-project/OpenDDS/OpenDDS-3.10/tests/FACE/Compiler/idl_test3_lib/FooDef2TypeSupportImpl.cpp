/* Generated by /Users/yc/MyGithub/imac-project/OpenDDS/OpenDDS-3.10/bin/opendds_idl version 3.10 (ACE version 6.2a_p11) running on input file ../../../DCPS/Compiler/idl_test3_lib/FooDef2.idl */
#include "FooDef2TypeSupportImpl.h"

#include <algorithm>
#include <cstring>
#include <stdexcept>
#include "dds/DCPS/BuiltInTopicUtils.h"
#include "dds/DCPS/ContentFilteredTopicImpl.h"
#include "dds/DCPS/DataReaderImpl_T.h"
#include "dds/DCPS/DataWriterImpl_T.h"
#include "dds/DCPS/FilterEvaluator.h"
#include "dds/DCPS/MultiTopicDataReader_T.h"
#include "dds/DCPS/PoolAllocator.h"
#include "dds/DCPS/PublicationInstance.h"
#include "dds/DCPS/PublisherImpl.h"
#include "dds/DCPS/Qos_Helper.h"
#include "dds/DCPS/RakeData.h"
#include "dds/DCPS/RakeResults_T.h"
#include "dds/DCPS/ReceivedDataElementList.h"
#include "dds/DCPS/Registered_Data_Types.h"
#include "dds/DCPS/Service_Participant.h"
#include "dds/DCPS/SubscriberImpl.h"
#include "dds/DCPS/Util.h"
#include "dds/DCPS/debug.h"
#include "dds/DdsDcpsDomainC.h"
#include "SharedTypesTypeSupportImpl.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: Xyz */



/* Begin ENUM: AnEnum */


/* End ENUM: AnEnum */


/* Begin TYPEDEF: SeqOfBoolean */


/* End TYPEDEF: SeqOfBoolean */


/* Begin TYPEDEF: SeqOfString */


/* End TYPEDEF: SeqOfString */


/* Begin TYPEDEF: SeqOfChar */


/* End TYPEDEF: SeqOfChar */


/* Begin TYPEDEF: SeqOfOctet */


/* End TYPEDEF: SeqOfOctet */


/* Begin TYPEDEF: SeqOfLong */


/* End TYPEDEF: SeqOfLong */


/* Begin TYPEDEF: SeqOfAnEnum */


/* End TYPEDEF: SeqOfAnEnum */


/* Begin TYPEDEF: ArrayOfBoolean */


/* End TYPEDEF: ArrayOfBoolean */


/* Begin TYPEDEF: ArrayOfString */


/* End TYPEDEF: ArrayOfString */


/* Begin TYPEDEF: ArrayOfChar */


/* End TYPEDEF: ArrayOfChar */


/* Begin TYPEDEF: ArrayOfOctet */


/* End TYPEDEF: ArrayOfOctet */


/* Begin TYPEDEF: ArrayOfLong */


/* End TYPEDEF: ArrayOfLong */


/* Begin TYPEDEF: ArrayOfAnEnum */


/* End TYPEDEF: ArrayOfAnEnum */


/* Begin TYPEDEF: ArrayOfSeqOfBoolean */


/* End TYPEDEF: ArrayOfSeqOfBoolean */


/* Begin TYPEDEF: ArrayOfSeqOfString */


/* End TYPEDEF: ArrayOfSeqOfString */


/* Begin TYPEDEF: ArrayOfSeqOfChar */


/* End TYPEDEF: ArrayOfSeqOfChar */


/* Begin TYPEDEF: ArrayOfSeqOfOctet */


/* End TYPEDEF: ArrayOfSeqOfOctet */


/* Begin TYPEDEF: ArrayOfSeqOfLong */


/* End TYPEDEF: ArrayOfSeqOfLong */


/* Begin TYPEDEF: ArrayOfSeqOfAnEnum */


/* End TYPEDEF: ArrayOfSeqOfAnEnum */

/* End MODULE: Xyz */


/* Begin MODULE: Xyz */



/* Begin STRUCT: StructOfArrayOfBoolean */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::StructOfArrayOfBoolean& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  Xyz::ArrayOfBoolean_forany stru_f(const_cast<Xyz::ArrayOfBoolean_slice*>(stru.f));
  gen_find_size(stru_f, size, padding);
}

bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfBoolean& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfBoolean_forany stru_f(const_cast<Xyz::ArrayOfBoolean_slice*>(stru.f));
  return (strm << stru_f);
}

bool operator>>(Serializer& strm, Xyz::StructOfArrayOfBoolean& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfBoolean_forany stru_f(const_cast<Xyz::ArrayOfBoolean_slice*>(stru.f));
  return (strm >> stru_f);
}

size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfBoolean& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 5;
}

size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfBoolean> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfBoolean> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfBoolean> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfBoolean> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
::DDS::DataWriter_ptr StructOfArrayOfBooleanTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<StructOfArrayOfBoolean> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr StructOfArrayOfBooleanTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfBoolean> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr StructOfArrayOfBooleanTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfBoolean> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<StructOfArrayOfBoolean, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& StructOfArrayOfBooleanTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<StructOfArrayOfBoolean>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool StructOfArrayOfBooleanTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* StructOfArrayOfBooleanTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
StructOfArrayOfBooleanTypeSupport::_ptr_type StructOfArrayOfBooleanTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Xyz::StructOfArrayOfBoolean> : MetaStruct {
  typedef Xyz::StructOfArrayOfBoolean T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Xyz::StructOfArrayOfBoolean& typed = *static_cast<const Xyz::StructOfArrayOfBoolean*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfBoolean)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfBoolean_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Xyz::StructOfArrayOfBoolean");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfBoolean)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"f", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "f") == 0) {
      return &static_cast<const T*>(stru)->f;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfBoolean)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "f") == 0) {
      Xyz::ArrayOfBoolean* lhsArr = &static_cast<T*>(lhs)->f;
      const Xyz::ArrayOfBoolean* rhsArr = static_cast<const Xyz::ArrayOfBoolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 5; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfBoolean)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfBoolean)");
  }
};

template<>
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfBoolean>()
{
  static MetaStructImpl<Xyz::StructOfArrayOfBoolean> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfBoolean*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Xyz::StructOfArrayOfBoolean>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
bool StructOfArrayOfBoolean::operator==(const StructOfArrayOfBoolean& rhs) const
{
  for (int i0 = 0; i0 < 5; ++i0) {
    if (f[i0] != rhs.f[i0]) {
      return false;
    }
  }
  return true;
}

ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const StructOfArrayOfBoolean&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, StructOfArrayOfBoolean&) { return true; }

}

/* End STRUCT: StructOfArrayOfBoolean */


/* Begin STRUCT: StructOfArrayOfString */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::StructOfArrayOfString& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  Xyz::ArrayOfString_forany stru_f(const_cast<Xyz::ArrayOfString_slice*>(stru.f));
  gen_find_size(stru_f, size, padding);
}

bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfString& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfString_forany stru_f(const_cast<Xyz::ArrayOfString_slice*>(stru.f));
  return (strm << stru_f);
}

bool operator>>(Serializer& strm, Xyz::StructOfArrayOfString& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfString_forany stru_f(const_cast<Xyz::ArrayOfString_slice*>(stru.f));
  return (strm >> stru_f);
}

size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfString& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 60;
}

size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfString> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfString> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfString> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfString> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
::DDS::DataWriter_ptr StructOfArrayOfStringTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<StructOfArrayOfString> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr StructOfArrayOfStringTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfString> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr StructOfArrayOfStringTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfString> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<StructOfArrayOfString, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& StructOfArrayOfStringTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<StructOfArrayOfString>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool StructOfArrayOfStringTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* StructOfArrayOfStringTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
StructOfArrayOfStringTypeSupport::_ptr_type StructOfArrayOfStringTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Xyz::StructOfArrayOfString> : MetaStruct {
  typedef Xyz::StructOfArrayOfString T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Xyz::StructOfArrayOfString& typed = *static_cast<const Xyz::StructOfArrayOfString*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfString)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfString_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Xyz::StructOfArrayOfString");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfString)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"f", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "f") == 0) {
      return &static_cast<const T*>(stru)->f;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfString)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "f") == 0) {
      Xyz::ArrayOfString* lhsArr = &static_cast<T*>(lhs)->f;
      const Xyz::ArrayOfString* rhsArr = static_cast<const Xyz::ArrayOfString*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 5; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfString)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfString)");
  }
};

template<>
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfString>()
{
  static MetaStructImpl<Xyz::StructOfArrayOfString> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfString*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Xyz::StructOfArrayOfString>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
bool StructOfArrayOfString::operator==(const StructOfArrayOfString& rhs) const
{
  for (int i0 = 0; i0 < 5; ++i0) {
    if (f[i0] != rhs.f[i0]) {
      return false;
    }
  }
  return true;
}

void swap(StructOfArrayOfString& lhs, StructOfArrayOfString& rhs)
{
  using std::swap;
  std::swap_ranges(lhs.f, lhs.f + 5, rhs.f);
}

ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const StructOfArrayOfString&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, StructOfArrayOfString&) { return true; }

}

/* End STRUCT: StructOfArrayOfString */


/* Begin STRUCT: StructOfArrayOfChar */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::StructOfArrayOfChar& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  Xyz::ArrayOfChar_forany stru_f(const_cast<Xyz::ArrayOfChar_slice*>(stru.f));
  gen_find_size(stru_f, size, padding);
}

bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfChar& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfChar_forany stru_f(const_cast<Xyz::ArrayOfChar_slice*>(stru.f));
  return (strm << stru_f);
}

bool operator>>(Serializer& strm, Xyz::StructOfArrayOfChar& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfChar_forany stru_f(const_cast<Xyz::ArrayOfChar_slice*>(stru.f));
  return (strm >> stru_f);
}

size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfChar& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 5;
}

size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfChar> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfChar> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfChar> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfChar> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
::DDS::DataWriter_ptr StructOfArrayOfCharTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<StructOfArrayOfChar> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr StructOfArrayOfCharTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfChar> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr StructOfArrayOfCharTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfChar> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<StructOfArrayOfChar, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& StructOfArrayOfCharTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<StructOfArrayOfChar>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool StructOfArrayOfCharTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* StructOfArrayOfCharTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
StructOfArrayOfCharTypeSupport::_ptr_type StructOfArrayOfCharTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Xyz::StructOfArrayOfChar> : MetaStruct {
  typedef Xyz::StructOfArrayOfChar T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Xyz::StructOfArrayOfChar& typed = *static_cast<const Xyz::StructOfArrayOfChar*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfChar)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfChar_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Xyz::StructOfArrayOfChar");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfChar)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"f", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "f") == 0) {
      return &static_cast<const T*>(stru)->f;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfChar)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "f") == 0) {
      Xyz::ArrayOfChar* lhsArr = &static_cast<T*>(lhs)->f;
      const Xyz::ArrayOfChar* rhsArr = static_cast<const Xyz::ArrayOfChar*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 5; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfChar)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfChar)");
  }
};

template<>
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfChar>()
{
  static MetaStructImpl<Xyz::StructOfArrayOfChar> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfChar*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Xyz::StructOfArrayOfChar>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
bool StructOfArrayOfChar::operator==(const StructOfArrayOfChar& rhs) const
{
  for (int i0 = 0; i0 < 5; ++i0) {
    if (f[i0] != rhs.f[i0]) {
      return false;
    }
  }
  return true;
}

ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const StructOfArrayOfChar&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, StructOfArrayOfChar&) { return true; }

}

/* End STRUCT: StructOfArrayOfChar */


/* Begin STRUCT: StructOfArrayOfOctet */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::StructOfArrayOfOctet& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  Xyz::ArrayOfOctet_forany stru_f(const_cast<Xyz::ArrayOfOctet_slice*>(stru.f));
  gen_find_size(stru_f, size, padding);
}

bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfOctet& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfOctet_forany stru_f(const_cast<Xyz::ArrayOfOctet_slice*>(stru.f));
  return (strm << stru_f);
}

bool operator>>(Serializer& strm, Xyz::StructOfArrayOfOctet& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfOctet_forany stru_f(const_cast<Xyz::ArrayOfOctet_slice*>(stru.f));
  return (strm >> stru_f);
}

size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfOctet& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 5;
}

size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfOctet> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfOctet> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfOctet> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfOctet> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
::DDS::DataWriter_ptr StructOfArrayOfOctetTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<StructOfArrayOfOctet> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr StructOfArrayOfOctetTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfOctet> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr StructOfArrayOfOctetTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfOctet> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<StructOfArrayOfOctet, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& StructOfArrayOfOctetTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<StructOfArrayOfOctet>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool StructOfArrayOfOctetTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* StructOfArrayOfOctetTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
StructOfArrayOfOctetTypeSupport::_ptr_type StructOfArrayOfOctetTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Xyz::StructOfArrayOfOctet> : MetaStruct {
  typedef Xyz::StructOfArrayOfOctet T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Xyz::StructOfArrayOfOctet& typed = *static_cast<const Xyz::StructOfArrayOfOctet*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfOctet)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfOctet_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Xyz::StructOfArrayOfOctet");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfOctet)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"f", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "f") == 0) {
      return &static_cast<const T*>(stru)->f;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfOctet)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "f") == 0) {
      Xyz::ArrayOfOctet* lhsArr = &static_cast<T*>(lhs)->f;
      const Xyz::ArrayOfOctet* rhsArr = static_cast<const Xyz::ArrayOfOctet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 5; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfOctet)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfOctet)");
  }
};

template<>
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfOctet>()
{
  static MetaStructImpl<Xyz::StructOfArrayOfOctet> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfOctet*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Xyz::StructOfArrayOfOctet>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
bool StructOfArrayOfOctet::operator==(const StructOfArrayOfOctet& rhs) const
{
  for (int i0 = 0; i0 < 5; ++i0) {
    if (f[i0] != rhs.f[i0]) {
      return false;
    }
  }
  return true;
}

ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const StructOfArrayOfOctet&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, StructOfArrayOfOctet&) { return true; }

}

/* End STRUCT: StructOfArrayOfOctet */


/* Begin STRUCT: StructOfArrayOfLong */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::StructOfArrayOfLong& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  Xyz::ArrayOfLong_forany stru_f(const_cast<Xyz::ArrayOfLong_slice*>(stru.f));
  gen_find_size(stru_f, size, padding);
}

bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfLong& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfLong_forany stru_f(const_cast<Xyz::ArrayOfLong_slice*>(stru.f));
  return (strm << stru_f);
}

bool operator>>(Serializer& strm, Xyz::StructOfArrayOfLong& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfLong_forany stru_f(const_cast<Xyz::ArrayOfLong_slice*>(stru.f));
  return (strm >> stru_f);
}

size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfLong& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 20;
}

size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfLong> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfLong> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfLong> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfLong> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
::DDS::DataWriter_ptr StructOfArrayOfLongTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<StructOfArrayOfLong> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr StructOfArrayOfLongTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfLong> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr StructOfArrayOfLongTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfLong> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<StructOfArrayOfLong, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& StructOfArrayOfLongTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<StructOfArrayOfLong>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool StructOfArrayOfLongTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* StructOfArrayOfLongTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
StructOfArrayOfLongTypeSupport::_ptr_type StructOfArrayOfLongTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Xyz::StructOfArrayOfLong> : MetaStruct {
  typedef Xyz::StructOfArrayOfLong T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Xyz::StructOfArrayOfLong& typed = *static_cast<const Xyz::StructOfArrayOfLong*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfLong)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfLong_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Xyz::StructOfArrayOfLong");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfLong)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"f", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "f") == 0) {
      return &static_cast<const T*>(stru)->f;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfLong)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "f") == 0) {
      Xyz::ArrayOfLong* lhsArr = &static_cast<T*>(lhs)->f;
      const Xyz::ArrayOfLong* rhsArr = static_cast<const Xyz::ArrayOfLong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 5; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfLong)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfLong)");
  }
};

template<>
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfLong>()
{
  static MetaStructImpl<Xyz::StructOfArrayOfLong> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfLong*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Xyz::StructOfArrayOfLong>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
bool StructOfArrayOfLong::operator==(const StructOfArrayOfLong& rhs) const
{
  for (int i0 = 0; i0 < 5; ++i0) {
    if (f[i0] != rhs.f[i0]) {
      return false;
    }
  }
  return true;
}

ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const StructOfArrayOfLong&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, StructOfArrayOfLong&) { return true; }

}

/* End STRUCT: StructOfArrayOfLong */


/* Begin STRUCT: StructOfArrayOfAnEnum */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::StructOfArrayOfAnEnum& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  Xyz::ArrayOfAnEnum_forany stru_f(const_cast<Xyz::ArrayOfAnEnum_slice*>(stru.f));
  gen_find_size(stru_f, size, padding);
}

bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfAnEnum& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfAnEnum_forany stru_f(const_cast<Xyz::ArrayOfAnEnum_slice*>(stru.f));
  return (strm << stru_f);
}

bool operator>>(Serializer& strm, Xyz::StructOfArrayOfAnEnum& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Xyz::ArrayOfAnEnum_forany stru_f(const_cast<Xyz::ArrayOfAnEnum_slice*>(stru.f));
  return (strm >> stru_f);
}

size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfAnEnum& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 20;
}

size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfAnEnum> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfAnEnum> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfAnEnum> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfAnEnum> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
::DDS::DataWriter_ptr StructOfArrayOfAnEnumTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<StructOfArrayOfAnEnum> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr StructOfArrayOfAnEnumTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfAnEnum> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr StructOfArrayOfAnEnumTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfArrayOfAnEnum> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<StructOfArrayOfAnEnum, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& StructOfArrayOfAnEnumTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<StructOfArrayOfAnEnum>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool StructOfArrayOfAnEnumTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* StructOfArrayOfAnEnumTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
StructOfArrayOfAnEnumTypeSupport::_ptr_type StructOfArrayOfAnEnumTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Xyz::StructOfArrayOfAnEnum> : MetaStruct {
  typedef Xyz::StructOfArrayOfAnEnum T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Xyz::StructOfArrayOfAnEnum& typed = *static_cast<const Xyz::StructOfArrayOfAnEnum*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfAnEnum)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<Xyz::ArrayOfAnEnum_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Xyz::StructOfArrayOfAnEnum");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfAnEnum)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"f", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "f") == 0) {
      return &static_cast<const T*>(stru)->f;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfAnEnum)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "f") == 0) {
      Xyz::ArrayOfAnEnum* lhsArr = &static_cast<T*>(lhs)->f;
      const Xyz::ArrayOfAnEnum* rhsArr = static_cast<const Xyz::ArrayOfAnEnum*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 5; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfAnEnum)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfArrayOfAnEnum)");
  }
};

template<>
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfAnEnum>()
{
  static MetaStructImpl<Xyz::StructOfArrayOfAnEnum> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfAnEnum*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Xyz::StructOfArrayOfAnEnum>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
bool StructOfArrayOfAnEnum::operator==(const StructOfArrayOfAnEnum& rhs) const
{
  for (int i0 = 0; i0 < 5; ++i0) {
    if (f[i0] != rhs.f[i0]) {
      return false;
    }
  }
  return true;
}

ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const StructOfArrayOfAnEnum&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, StructOfArrayOfAnEnum&) { return true; }

}

/* End STRUCT: StructOfArrayOfAnEnum */


/* Begin TYPEDEF: ArrayOfBoolean2 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::ArrayOfBoolean2_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += 5 * max_marshaled_size_boolean();
}

bool operator<<(Serializer& strm, const Xyz::ArrayOfBoolean2_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.write_boolean_array(arr.in(), 5);
}

bool operator>>(Serializer& strm, Xyz::ArrayOfBoolean2_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.read_boolean_array(arr.out(), 5);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::ArrayOfBoolean2_forany*)
{
  ACE_UNUSED_ARG(ser);
  ser.skip(5, 1);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
ArrayOfBoolean2_slice* ArrayOfBoolean2_alloc()
{
  void* const raw = ACE_Allocator::instance()->malloc(sizeof(ArrayOfBoolean2));
  ArrayOfBoolean2_slice* const slice = static_cast<ArrayOfBoolean2_slice*>(raw);
  ArrayOfBoolean2_init_i(slice);
  return slice;
}

void ArrayOfBoolean2_init_i(::FACE::Boolean* begin)
{
  ACE_UNUSED_ARG(begin);
}

void ArrayOfBoolean2_fini_i(::FACE::Boolean* begin)
{
  ACE_UNUSED_ARG(begin);
}

void ArrayOfBoolean2_free(ArrayOfBoolean2_slice* slice)
{
  if (!slice) return;
  ArrayOfBoolean2_fini_i(slice);
  ACE_Allocator::instance()->free(slice);
}

ArrayOfBoolean2_slice* ArrayOfBoolean2_dup(const ArrayOfBoolean2_slice* slice)
{
  ArrayOfBoolean2_slice* const arr = ArrayOfBoolean2_alloc();
  if (arr) ArrayOfBoolean2_copy(arr, slice);
  return arr;
}

void ArrayOfBoolean2_copy(ArrayOfBoolean2_slice* dst, const ArrayOfBoolean2_slice* src)
{
  if (!src || !dst) return;
  for (ACE_CDR::ULong i0 = 0; i0 < 5; ++i0) {
    dst[i0] = src[i0];
  }
}

}

/* End TYPEDEF: ArrayOfBoolean2 */


/* Begin TYPEDEF: ArrayOfString2 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::ArrayOfString2_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  for (CORBA::ULong i0 = 0; i0 < 5; ++i0) {
    find_size_ulong(size, padding);
    size += ACE_OS::strlen(arr[i0].in()) + 1;
  }
}

bool operator<<(Serializer& strm, const Xyz::ArrayOfString2_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 5; ++i0) {
    if (!(strm << arr[i0].in())) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::ArrayOfString2_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 5; ++i0) {
    if (!(strm >> arr[i0].out())) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::ArrayOfString2_forany*)
{
  ACE_UNUSED_ARG(ser);
  for (ACE_CDR::ULong i = 0; i < 5; ++i) {
    ACE_CDR::ULong strlength;
    ser >> strlength;
    ser.skip(strlength);
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
ArrayOfString2_slice* ArrayOfString2_alloc()
{
  void* const raw = ACE_Allocator::instance()->malloc(sizeof(ArrayOfString2));
  ArrayOfString2_slice* const slice = static_cast<ArrayOfString2_slice*>(raw);
  ArrayOfString2_init_i(slice);
  return slice;
}

void ArrayOfString2_init_i(::OpenDDS::FaceTypes::String_mgr* begin)
{
  std::uninitialized_fill_n(begin, 5, ::OpenDDS::FaceTypes::String_mgr());
}

void ArrayOfString2_fini_i(::OpenDDS::FaceTypes::String_mgr* begin)
{
  for (int i = 0; i < 5; ++i) {
    begin[i].~StringManager();
  }
}

void ArrayOfString2_free(ArrayOfString2_slice* slice)
{
  if (!slice) return;
  ArrayOfString2_fini_i(slice);
  ACE_Allocator::instance()->free(slice);
}

ArrayOfString2_slice* ArrayOfString2_dup(const ArrayOfString2_slice* slice)
{
  ArrayOfString2_slice* const arr = ArrayOfString2_alloc();
  if (arr) ArrayOfString2_copy(arr, slice);
  return arr;
}

void ArrayOfString2_copy(ArrayOfString2_slice* dst, const ArrayOfString2_slice* src)
{
  if (!src || !dst) return;
  for (ACE_CDR::ULong i0 = 0; i0 < 5; ++i0) {
    dst[i0] = src[i0];
  }
}

}

/* End TYPEDEF: ArrayOfString2 */


/* Begin TYPEDEF: ArrayOfChar2 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::ArrayOfChar2_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += 5 * max_marshaled_size_char();
}

bool operator<<(Serializer& strm, const Xyz::ArrayOfChar2_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.write_char_array(arr.in(), 5);
}

bool operator>>(Serializer& strm, Xyz::ArrayOfChar2_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.read_char_array(arr.out(), 5);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::ArrayOfChar2_forany*)
{
  ACE_UNUSED_ARG(ser);
  ser.skip(5, 1);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
ArrayOfChar2_slice* ArrayOfChar2_alloc()
{
  void* const raw = ACE_Allocator::instance()->malloc(sizeof(ArrayOfChar2));
  ArrayOfChar2_slice* const slice = static_cast<ArrayOfChar2_slice*>(raw);
  ArrayOfChar2_init_i(slice);
  return slice;
}

void ArrayOfChar2_init_i(::FACE::Char* begin)
{
  ACE_UNUSED_ARG(begin);
}

void ArrayOfChar2_fini_i(::FACE::Char* begin)
{
  ACE_UNUSED_ARG(begin);
}

void ArrayOfChar2_free(ArrayOfChar2_slice* slice)
{
  if (!slice) return;
  ArrayOfChar2_fini_i(slice);
  ACE_Allocator::instance()->free(slice);
}

ArrayOfChar2_slice* ArrayOfChar2_dup(const ArrayOfChar2_slice* slice)
{
  ArrayOfChar2_slice* const arr = ArrayOfChar2_alloc();
  if (arr) ArrayOfChar2_copy(arr, slice);
  return arr;
}

void ArrayOfChar2_copy(ArrayOfChar2_slice* dst, const ArrayOfChar2_slice* src)
{
  if (!src || !dst) return;
  for (ACE_CDR::ULong i0 = 0; i0 < 5; ++i0) {
    dst[i0] = src[i0];
  }
}

}

/* End TYPEDEF: ArrayOfChar2 */


/* Begin TYPEDEF: ArrayOfOctet2 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::ArrayOfOctet2_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += 5 * max_marshaled_size_octet();
}

bool operator<<(Serializer& strm, const Xyz::ArrayOfOctet2_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.write_octet_array(arr.in(), 5);
}

bool operator>>(Serializer& strm, Xyz::ArrayOfOctet2_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.read_octet_array(arr.out(), 5);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::ArrayOfOctet2_forany*)
{
  ACE_UNUSED_ARG(ser);
  ser.skip(5, 1);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
ArrayOfOctet2_slice* ArrayOfOctet2_alloc()
{
  void* const raw = ACE_Allocator::instance()->malloc(sizeof(ArrayOfOctet2));
  ArrayOfOctet2_slice* const slice = static_cast<ArrayOfOctet2_slice*>(raw);
  ArrayOfOctet2_init_i(slice);
  return slice;
}

void ArrayOfOctet2_init_i(::FACE::Octet* begin)
{
  ACE_UNUSED_ARG(begin);
}

void ArrayOfOctet2_fini_i(::FACE::Octet* begin)
{
  ACE_UNUSED_ARG(begin);
}

void ArrayOfOctet2_free(ArrayOfOctet2_slice* slice)
{
  if (!slice) return;
  ArrayOfOctet2_fini_i(slice);
  ACE_Allocator::instance()->free(slice);
}

ArrayOfOctet2_slice* ArrayOfOctet2_dup(const ArrayOfOctet2_slice* slice)
{
  ArrayOfOctet2_slice* const arr = ArrayOfOctet2_alloc();
  if (arr) ArrayOfOctet2_copy(arr, slice);
  return arr;
}

void ArrayOfOctet2_copy(ArrayOfOctet2_slice* dst, const ArrayOfOctet2_slice* src)
{
  if (!src || !dst) return;
  for (ACE_CDR::ULong i0 = 0; i0 < 5; ++i0) {
    dst[i0] = src[i0];
  }
}

}

/* End TYPEDEF: ArrayOfOctet2 */


/* Begin TYPEDEF: ArrayOfLong2 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::ArrayOfLong2_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += 5 * gen_max_marshaled_size(CORBA::Long());
}

bool operator<<(Serializer& strm, const Xyz::ArrayOfLong2_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.write_long_array(arr.in(), 5);
}

bool operator>>(Serializer& strm, Xyz::ArrayOfLong2_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.read_long_array(arr.out(), 5);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::ArrayOfLong2_forany*)
{
  ACE_UNUSED_ARG(ser);
  ser.skip(5, 4);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
ArrayOfLong2_slice* ArrayOfLong2_alloc()
{
  void* const raw = ACE_Allocator::instance()->malloc(sizeof(ArrayOfLong2));
  ArrayOfLong2_slice* const slice = static_cast<ArrayOfLong2_slice*>(raw);
  ArrayOfLong2_init_i(slice);
  return slice;
}

void ArrayOfLong2_init_i(::FACE::Long* begin)
{
  ACE_UNUSED_ARG(begin);
}

void ArrayOfLong2_fini_i(::FACE::Long* begin)
{
  ACE_UNUSED_ARG(begin);
}

void ArrayOfLong2_free(ArrayOfLong2_slice* slice)
{
  if (!slice) return;
  ArrayOfLong2_fini_i(slice);
  ACE_Allocator::instance()->free(slice);
}

ArrayOfLong2_slice* ArrayOfLong2_dup(const ArrayOfLong2_slice* slice)
{
  ArrayOfLong2_slice* const arr = ArrayOfLong2_alloc();
  if (arr) ArrayOfLong2_copy(arr, slice);
  return arr;
}

void ArrayOfLong2_copy(ArrayOfLong2_slice* dst, const ArrayOfLong2_slice* src)
{
  if (!src || !dst) return;
  for (ACE_CDR::ULong i0 = 0; i0 < 5; ++i0) {
    dst[i0] = src[i0];
  }
}

}

/* End TYPEDEF: ArrayOfLong2 */


/* Begin TYPEDEF: ArrayOfAnEnum2 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::ArrayOfAnEnum2_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += 4 * max_marshaled_size_ulong();
}

bool operator<<(Serializer& strm, const Xyz::ArrayOfAnEnum2_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 5; ++i0) {
    if (!(strm << arr[i0])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::ArrayOfAnEnum2_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 5; ++i0) {
    if (!(strm >> arr[i0])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::ArrayOfAnEnum2_forany*)
{
  ACE_UNUSED_ARG(ser);
  ser.skip(5, 4);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
ArrayOfAnEnum2_slice* ArrayOfAnEnum2_alloc()
{
  void* const raw = ACE_Allocator::instance()->malloc(sizeof(ArrayOfAnEnum2));
  ArrayOfAnEnum2_slice* const slice = static_cast<ArrayOfAnEnum2_slice*>(raw);
  ArrayOfAnEnum2_init_i(slice);
  return slice;
}

void ArrayOfAnEnum2_init_i(Xyz::AnEnum* begin)
{
  ACE_UNUSED_ARG(begin);
}

void ArrayOfAnEnum2_fini_i(Xyz::AnEnum* begin)
{
  ACE_UNUSED_ARG(begin);
}

void ArrayOfAnEnum2_free(ArrayOfAnEnum2_slice* slice)
{
  if (!slice) return;
  ArrayOfAnEnum2_fini_i(slice);
  ACE_Allocator::instance()->free(slice);
}

ArrayOfAnEnum2_slice* ArrayOfAnEnum2_dup(const ArrayOfAnEnum2_slice* slice)
{
  ArrayOfAnEnum2_slice* const arr = ArrayOfAnEnum2_alloc();
  if (arr) ArrayOfAnEnum2_copy(arr, slice);
  return arr;
}

void ArrayOfAnEnum2_copy(ArrayOfAnEnum2_slice* dst, const ArrayOfAnEnum2_slice* src)
{
  if (!src || !dst) return;
  for (ACE_CDR::ULong i0 = 0; i0 < 5; ++i0) {
    dst[i0] = src[i0];
  }
}

}

/* End TYPEDEF: ArrayOfAnEnum2 */


/* Begin STRUCT: StructOfSeqOfBoolean */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::StructOfSeqOfBoolean& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.field, size, padding);
}

bool operator<<(Serializer& strm, const Xyz::StructOfSeqOfBoolean& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.field);
}

bool operator>>(Serializer& strm, Xyz::StructOfSeqOfBoolean& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.field);
}

size_t gen_max_marshaled_size(const Xyz::StructOfSeqOfBoolean& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 10;
}

size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfSeqOfBoolean> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Xyz::StructOfSeqOfBoolean> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfSeqOfBoolean> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfSeqOfBoolean> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
::DDS::DataWriter_ptr StructOfSeqOfBooleanTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<StructOfSeqOfBoolean> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr StructOfSeqOfBooleanTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfSeqOfBoolean> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr StructOfSeqOfBooleanTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfSeqOfBoolean> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<StructOfSeqOfBoolean, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& StructOfSeqOfBooleanTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<StructOfSeqOfBoolean>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool StructOfSeqOfBooleanTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* StructOfSeqOfBooleanTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
StructOfSeqOfBooleanTypeSupport::_ptr_type StructOfSeqOfBooleanTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Xyz::StructOfSeqOfBoolean> : MetaStruct {
  typedef Xyz::StructOfSeqOfBoolean T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Xyz::StructOfSeqOfBoolean& typed = *static_cast<const Xyz::StructOfSeqOfBoolean*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfBoolean)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<Xyz::SeqOfBoolean*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Xyz::StructOfSeqOfBoolean");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfBoolean)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"field", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "field") == 0) {
      return &static_cast<const T*>(stru)->field;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfBoolean)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "field") == 0) {
      static_cast<T*>(lhs)->field = *static_cast<const Xyz::SeqOfBoolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfBoolean)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfBoolean)");
  }
};

template<>
const MetaStruct& getMetaStruct<Xyz::StructOfSeqOfBoolean>()
{
  static MetaStructImpl<Xyz::StructOfSeqOfBoolean> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Xyz::StructOfSeqOfBoolean*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Xyz::StructOfSeqOfBoolean>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
bool StructOfSeqOfBoolean::operator==(const StructOfSeqOfBoolean& rhs) const
{
  if (field != rhs.field) {
    return false;
  }
  return true;
}

void swap(StructOfSeqOfBoolean& lhs, StructOfSeqOfBoolean& rhs)
{
  using std::swap;
  swap(lhs.field, rhs.field);
}

ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const StructOfSeqOfBoolean&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, StructOfSeqOfBoolean&) { return true; }

}

/* End STRUCT: StructOfSeqOfBoolean */


/* Begin STRUCT: StructOfSeqOfString */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::StructOfSeqOfString& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.field, size, padding);
}

bool operator<<(Serializer& strm, const Xyz::StructOfSeqOfString& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.field);
}

bool operator>>(Serializer& strm, Xyz::StructOfSeqOfString& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.field);
}

size_t gen_max_marshaled_size(const Xyz::StructOfSeqOfString& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfSeqOfString> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Xyz::StructOfSeqOfString> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfSeqOfString> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfSeqOfString> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
::DDS::DataWriter_ptr StructOfSeqOfStringTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<StructOfSeqOfString> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr StructOfSeqOfStringTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfSeqOfString> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr StructOfSeqOfStringTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfSeqOfString> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<StructOfSeqOfString, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& StructOfSeqOfStringTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<StructOfSeqOfString>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool StructOfSeqOfStringTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* StructOfSeqOfStringTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
StructOfSeqOfStringTypeSupport::_ptr_type StructOfSeqOfStringTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Xyz::StructOfSeqOfString> : MetaStruct {
  typedef Xyz::StructOfSeqOfString T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Xyz::StructOfSeqOfString& typed = *static_cast<const Xyz::StructOfSeqOfString*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfString)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<Xyz::SeqOfString*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Xyz::StructOfSeqOfString");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfString)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"field", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "field") == 0) {
      return &static_cast<const T*>(stru)->field;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfString)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "field") == 0) {
      static_cast<T*>(lhs)->field = *static_cast<const Xyz::SeqOfString*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfString)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfString)");
  }
};

template<>
const MetaStruct& getMetaStruct<Xyz::StructOfSeqOfString>()
{
  static MetaStructImpl<Xyz::StructOfSeqOfString> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Xyz::StructOfSeqOfString*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Xyz::StructOfSeqOfString>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
bool StructOfSeqOfString::operator==(const StructOfSeqOfString& rhs) const
{
  if (field != rhs.field) {
    return false;
  }
  return true;
}

void swap(StructOfSeqOfString& lhs, StructOfSeqOfString& rhs)
{
  using std::swap;
  swap(lhs.field, rhs.field);
}

ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const StructOfSeqOfString&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, StructOfSeqOfString&) { return true; }

}

/* End STRUCT: StructOfSeqOfString */


/* Begin STRUCT: StructOfSeqOfChar */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::StructOfSeqOfChar& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.field, size, padding);
}

bool operator<<(Serializer& strm, const Xyz::StructOfSeqOfChar& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.field);
}

bool operator>>(Serializer& strm, Xyz::StructOfSeqOfChar& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.field);
}

size_t gen_max_marshaled_size(const Xyz::StructOfSeqOfChar& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 10;
}

size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfSeqOfChar> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Xyz::StructOfSeqOfChar> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfSeqOfChar> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfSeqOfChar> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
::DDS::DataWriter_ptr StructOfSeqOfCharTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<StructOfSeqOfChar> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr StructOfSeqOfCharTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfSeqOfChar> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr StructOfSeqOfCharTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfSeqOfChar> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<StructOfSeqOfChar, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& StructOfSeqOfCharTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<StructOfSeqOfChar>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool StructOfSeqOfCharTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* StructOfSeqOfCharTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
StructOfSeqOfCharTypeSupport::_ptr_type StructOfSeqOfCharTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Xyz::StructOfSeqOfChar> : MetaStruct {
  typedef Xyz::StructOfSeqOfChar T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Xyz::StructOfSeqOfChar& typed = *static_cast<const Xyz::StructOfSeqOfChar*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfChar)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<Xyz::SeqOfChar*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Xyz::StructOfSeqOfChar");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfChar)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"field", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "field") == 0) {
      return &static_cast<const T*>(stru)->field;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfChar)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "field") == 0) {
      static_cast<T*>(lhs)->field = *static_cast<const Xyz::SeqOfChar*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfChar)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfChar)");
  }
};

template<>
const MetaStruct& getMetaStruct<Xyz::StructOfSeqOfChar>()
{
  static MetaStructImpl<Xyz::StructOfSeqOfChar> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Xyz::StructOfSeqOfChar*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Xyz::StructOfSeqOfChar>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
bool StructOfSeqOfChar::operator==(const StructOfSeqOfChar& rhs) const
{
  if (field != rhs.field) {
    return false;
  }
  return true;
}

void swap(StructOfSeqOfChar& lhs, StructOfSeqOfChar& rhs)
{
  using std::swap;
  swap(lhs.field, rhs.field);
}

ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const StructOfSeqOfChar&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, StructOfSeqOfChar&) { return true; }

}

/* End STRUCT: StructOfSeqOfChar */


/* Begin STRUCT: StructOfSeqOfOctet */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::StructOfSeqOfOctet& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.field, size, padding);
}

bool operator<<(Serializer& strm, const Xyz::StructOfSeqOfOctet& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.field);
}

bool operator>>(Serializer& strm, Xyz::StructOfSeqOfOctet& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.field);
}

size_t gen_max_marshaled_size(const Xyz::StructOfSeqOfOctet& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 10;
}

size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfSeqOfOctet> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Xyz::StructOfSeqOfOctet> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfSeqOfOctet> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfSeqOfOctet> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
::DDS::DataWriter_ptr StructOfSeqOfOctetTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<StructOfSeqOfOctet> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr StructOfSeqOfOctetTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfSeqOfOctet> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr StructOfSeqOfOctetTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfSeqOfOctet> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<StructOfSeqOfOctet, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& StructOfSeqOfOctetTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<StructOfSeqOfOctet>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool StructOfSeqOfOctetTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* StructOfSeqOfOctetTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
StructOfSeqOfOctetTypeSupport::_ptr_type StructOfSeqOfOctetTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Xyz::StructOfSeqOfOctet> : MetaStruct {
  typedef Xyz::StructOfSeqOfOctet T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Xyz::StructOfSeqOfOctet& typed = *static_cast<const Xyz::StructOfSeqOfOctet*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfOctet)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<Xyz::SeqOfOctet*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Xyz::StructOfSeqOfOctet");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfOctet)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"field", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "field") == 0) {
      return &static_cast<const T*>(stru)->field;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfOctet)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "field") == 0) {
      static_cast<T*>(lhs)->field = *static_cast<const Xyz::SeqOfOctet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfOctet)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfOctet)");
  }
};

template<>
const MetaStruct& getMetaStruct<Xyz::StructOfSeqOfOctet>()
{
  static MetaStructImpl<Xyz::StructOfSeqOfOctet> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Xyz::StructOfSeqOfOctet*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Xyz::StructOfSeqOfOctet>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
bool StructOfSeqOfOctet::operator==(const StructOfSeqOfOctet& rhs) const
{
  if (field != rhs.field) {
    return false;
  }
  return true;
}

void swap(StructOfSeqOfOctet& lhs, StructOfSeqOfOctet& rhs)
{
  using std::swap;
  swap(lhs.field, rhs.field);
}

ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const StructOfSeqOfOctet&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, StructOfSeqOfOctet&) { return true; }

}

/* End STRUCT: StructOfSeqOfOctet */


/* Begin STRUCT: StructOfSeqOfLong */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::StructOfSeqOfLong& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.field, size, padding);
}

bool operator<<(Serializer& strm, const Xyz::StructOfSeqOfLong& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.field);
}

bool operator>>(Serializer& strm, Xyz::StructOfSeqOfLong& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.field);
}

size_t gen_max_marshaled_size(const Xyz::StructOfSeqOfLong& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 28;
}

size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfSeqOfLong> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Xyz::StructOfSeqOfLong> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfSeqOfLong> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfSeqOfLong> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
::DDS::DataWriter_ptr StructOfSeqOfLongTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<StructOfSeqOfLong> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr StructOfSeqOfLongTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfSeqOfLong> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr StructOfSeqOfLongTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfSeqOfLong> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<StructOfSeqOfLong, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& StructOfSeqOfLongTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<StructOfSeqOfLong>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool StructOfSeqOfLongTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* StructOfSeqOfLongTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
StructOfSeqOfLongTypeSupport::_ptr_type StructOfSeqOfLongTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Xyz::StructOfSeqOfLong> : MetaStruct {
  typedef Xyz::StructOfSeqOfLong T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Xyz::StructOfSeqOfLong& typed = *static_cast<const Xyz::StructOfSeqOfLong*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfLong)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<Xyz::SeqOfLong*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Xyz::StructOfSeqOfLong");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfLong)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"field", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "field") == 0) {
      return &static_cast<const T*>(stru)->field;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfLong)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "field") == 0) {
      static_cast<T*>(lhs)->field = *static_cast<const Xyz::SeqOfLong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfLong)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfLong)");
  }
};

template<>
const MetaStruct& getMetaStruct<Xyz::StructOfSeqOfLong>()
{
  static MetaStructImpl<Xyz::StructOfSeqOfLong> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Xyz::StructOfSeqOfLong*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Xyz::StructOfSeqOfLong>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
bool StructOfSeqOfLong::operator==(const StructOfSeqOfLong& rhs) const
{
  if (field != rhs.field) {
    return false;
  }
  return true;
}

void swap(StructOfSeqOfLong& lhs, StructOfSeqOfLong& rhs)
{
  using std::swap;
  swap(lhs.field, rhs.field);
}

ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const StructOfSeqOfLong&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, StructOfSeqOfLong&) { return true; }

}

/* End STRUCT: StructOfSeqOfLong */


/* Begin STRUCT: StructOfSeqOfAnEnum */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::StructOfSeqOfAnEnum& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.field, size, padding);
}

bool operator<<(Serializer& strm, const Xyz::StructOfSeqOfAnEnum& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.field);
}

bool operator>>(Serializer& strm, Xyz::StructOfSeqOfAnEnum& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.field);
}

size_t gen_max_marshaled_size(const Xyz::StructOfSeqOfAnEnum& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfSeqOfAnEnum> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Xyz::StructOfSeqOfAnEnum> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfSeqOfAnEnum> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfSeqOfAnEnum> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
::DDS::DataWriter_ptr StructOfSeqOfAnEnumTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<StructOfSeqOfAnEnum> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr StructOfSeqOfAnEnumTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfSeqOfAnEnum> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr StructOfSeqOfAnEnumTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<StructOfSeqOfAnEnum> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<StructOfSeqOfAnEnum, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& StructOfSeqOfAnEnumTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<StructOfSeqOfAnEnum>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool StructOfSeqOfAnEnumTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* StructOfSeqOfAnEnumTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
StructOfSeqOfAnEnumTypeSupport::_ptr_type StructOfSeqOfAnEnumTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Xyz::StructOfSeqOfAnEnum> : MetaStruct {
  typedef Xyz::StructOfSeqOfAnEnum T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Xyz::StructOfSeqOfAnEnum& typed = *static_cast<const Xyz::StructOfSeqOfAnEnum*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfAnEnum)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<Xyz::SeqOfAnEnum*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Xyz::StructOfSeqOfAnEnum");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfAnEnum)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"field", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "field") == 0) {
      return &static_cast<const T*>(stru)->field;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfAnEnum)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "field") == 0) {
      static_cast<T*>(lhs)->field = *static_cast<const Xyz::SeqOfAnEnum*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfAnEnum)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Xyz::StructOfSeqOfAnEnum)");
  }
};

template<>
const MetaStruct& getMetaStruct<Xyz::StructOfSeqOfAnEnum>()
{
  static MetaStructImpl<Xyz::StructOfSeqOfAnEnum> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, Xyz::StructOfSeqOfAnEnum*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Xyz::StructOfSeqOfAnEnum>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
bool StructOfSeqOfAnEnum::operator==(const StructOfSeqOfAnEnum& rhs) const
{
  if (field != rhs.field) {
    return false;
  }
  return true;
}

void swap(StructOfSeqOfAnEnum& lhs, StructOfSeqOfAnEnum& rhs)
{
  using std::swap;
  swap(lhs.field, rhs.field);
}

ACE_CDR::Boolean operator<< (ACE_OutputCDR &, const StructOfSeqOfAnEnum&) { return true; }

ACE_CDR::Boolean operator>> (ACE_InputCDR &, StructOfSeqOfAnEnum&) { return true; }

}

/* End STRUCT: StructOfSeqOfAnEnum */

/* End MODULE: Xyz */
