/* -*- C++ -*- */
/* Generated by /Users/yc/MyGithub/imac-project/OpenDDS/OpenDDS-3.10/bin/opendds_idl version 3.10 (ACE version 6.2a_p11) running on input file ../../../DCPS/Compiler/idl_test3_lib/SharedTypes.idl */
#ifndef OPENDDS_IDL_GENERATED_SHAREDTYPESC_H_H9A6GO
#define OPENDDS_IDL_GENERATED_SHAREDTYPESC_H_H9A6GO
#include <tao/orbconf.h>
#include <tao/Basic_Types.h>
#include <ace/CDR_Stream.h>
#include <tao/Array_VarOut_T.h>
#include <tao/Seq_Out_T.h>
#include "FACE/Sequence.h"
#include "FACE/SequenceVar.h"
#include "FACE/StringManager.h"
#include "FACE/types.hpp"
#include "dds/DCPS/SafetyProfilePool.h"
#include "foolib_export.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: Xyz */



/* Begin ENUM: AnEnum */

namespace Xyz {
enum AnEnum {
  redx,
  greenx,
  bluex
};

typedef AnEnum& AnEnum_out;
}

/* End ENUM: AnEnum */


/* Begin TYPEDEF: SeqOfBoolean */

namespace Xyz {
class SeqOfBoolean;
typedef ::OpenDDS::FaceTypes::SequenceVar<SeqOfBoolean> SeqOfBoolean_var;
typedef ::TAO_Seq_Out_T<SeqOfBoolean> SeqOfBoolean_out;

class FooLib_Export SeqOfBoolean : public ::OpenDDS::FaceTypes::Sequence< ::FACE::Boolean, ::OpenDDS::FaceTypes::Bounded<6> > {
public:
  typedef SeqOfBoolean_var _var_type;
  typedef SeqOfBoolean_out _out_type;

  SeqOfBoolean() {}
  SeqOfBoolean(const SeqOfBoolean& seq) : ::OpenDDS::FaceTypes::Sequence< ::FACE::Boolean, ::OpenDDS::FaceTypes::Bounded<6> >(seq) {}
  friend void swap(SeqOfBoolean& a, SeqOfBoolean& b) { a.swap(b); }
  SeqOfBoolean& operator=(const SeqOfBoolean& rhs)
  {
    SeqOfBoolean tmp(rhs);
    swap(tmp);
    return *this;
  }
  SeqOfBoolean(::FACE::UnsignedLong length, ::FACE::Boolean* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< ::FACE::Boolean, ::OpenDDS::FaceTypes::Bounded<6> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const SeqOfBoolean&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, SeqOfBoolean&) { return true; }

}

/* End TYPEDEF: SeqOfBoolean */


/* Begin TYPEDEF: SeqOfString */

namespace Xyz {
class SeqOfString;
typedef ::OpenDDS::FaceTypes::SequenceVar<SeqOfString> SeqOfString_var;
typedef ::TAO_Seq_Out_T<SeqOfString> SeqOfString_out;

class FooLib_Export SeqOfString : public ::OpenDDS::FaceTypes::Sequence< ::FACE::Char*, ::OpenDDS::FaceTypes::Bounded<6>, ::OpenDDS::FaceTypes::StringEltPolicy< ::FACE::Char> > {
public:
  typedef SeqOfString_var _var_type;
  typedef SeqOfString_out _out_type;

  SeqOfString() {}
  SeqOfString(const SeqOfString& seq) : ::OpenDDS::FaceTypes::Sequence< ::FACE::Char*, ::OpenDDS::FaceTypes::Bounded<6>, ::OpenDDS::FaceTypes::StringEltPolicy< ::FACE::Char> >(seq) {}
  friend void swap(SeqOfString& a, SeqOfString& b) { a.swap(b); }
  SeqOfString& operator=(const SeqOfString& rhs)
  {
    SeqOfString tmp(rhs);
    swap(tmp);
    return *this;
  }
  SeqOfString(::FACE::UnsignedLong length, ::FACE::Char** data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< ::FACE::Char*, ::OpenDDS::FaceTypes::Bounded<6>, ::OpenDDS::FaceTypes::StringEltPolicy< ::FACE::Char> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const SeqOfString&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, SeqOfString&) { return true; }

}

/* End TYPEDEF: SeqOfString */


/* Begin TYPEDEF: SeqOfChar */

namespace Xyz {
class SeqOfChar;
typedef ::OpenDDS::FaceTypes::SequenceVar<SeqOfChar> SeqOfChar_var;
typedef ::TAO_Seq_Out_T<SeqOfChar> SeqOfChar_out;

class FooLib_Export SeqOfChar : public ::OpenDDS::FaceTypes::Sequence< ::FACE::Char, ::OpenDDS::FaceTypes::Bounded<6> > {
public:
  typedef SeqOfChar_var _var_type;
  typedef SeqOfChar_out _out_type;

  SeqOfChar() {}
  SeqOfChar(const SeqOfChar& seq) : ::OpenDDS::FaceTypes::Sequence< ::FACE::Char, ::OpenDDS::FaceTypes::Bounded<6> >(seq) {}
  friend void swap(SeqOfChar& a, SeqOfChar& b) { a.swap(b); }
  SeqOfChar& operator=(const SeqOfChar& rhs)
  {
    SeqOfChar tmp(rhs);
    swap(tmp);
    return *this;
  }
  SeqOfChar(::FACE::UnsignedLong length, ::FACE::Char* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< ::FACE::Char, ::OpenDDS::FaceTypes::Bounded<6> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const SeqOfChar&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, SeqOfChar&) { return true; }

}

/* End TYPEDEF: SeqOfChar */


/* Begin TYPEDEF: SeqOfOctet */

namespace Xyz {
class SeqOfOctet;
typedef ::OpenDDS::FaceTypes::SequenceVar<SeqOfOctet> SeqOfOctet_var;
typedef ::TAO_Seq_Out_T<SeqOfOctet> SeqOfOctet_out;

class FooLib_Export SeqOfOctet : public ::OpenDDS::FaceTypes::Sequence< ::FACE::Octet, ::OpenDDS::FaceTypes::Bounded<6> > {
public:
  typedef SeqOfOctet_var _var_type;
  typedef SeqOfOctet_out _out_type;

  SeqOfOctet() {}
  SeqOfOctet(const SeqOfOctet& seq) : ::OpenDDS::FaceTypes::Sequence< ::FACE::Octet, ::OpenDDS::FaceTypes::Bounded<6> >(seq) {}
  friend void swap(SeqOfOctet& a, SeqOfOctet& b) { a.swap(b); }
  SeqOfOctet& operator=(const SeqOfOctet& rhs)
  {
    SeqOfOctet tmp(rhs);
    swap(tmp);
    return *this;
  }
  SeqOfOctet(::FACE::UnsignedLong length, ::FACE::Octet* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< ::FACE::Octet, ::OpenDDS::FaceTypes::Bounded<6> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const SeqOfOctet&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, SeqOfOctet&) { return true; }

}

/* End TYPEDEF: SeqOfOctet */


/* Begin TYPEDEF: SeqOfLong */

namespace Xyz {
class SeqOfLong;
typedef ::OpenDDS::FaceTypes::SequenceVar<SeqOfLong> SeqOfLong_var;
typedef ::TAO_Seq_Out_T<SeqOfLong> SeqOfLong_out;

class FooLib_Export SeqOfLong : public ::OpenDDS::FaceTypes::Sequence< ::FACE::Long, ::OpenDDS::FaceTypes::Bounded<6> > {
public:
  typedef SeqOfLong_var _var_type;
  typedef SeqOfLong_out _out_type;

  SeqOfLong() {}
  SeqOfLong(const SeqOfLong& seq) : ::OpenDDS::FaceTypes::Sequence< ::FACE::Long, ::OpenDDS::FaceTypes::Bounded<6> >(seq) {}
  friend void swap(SeqOfLong& a, SeqOfLong& b) { a.swap(b); }
  SeqOfLong& operator=(const SeqOfLong& rhs)
  {
    SeqOfLong tmp(rhs);
    swap(tmp);
    return *this;
  }
  SeqOfLong(::FACE::UnsignedLong length, ::FACE::Long* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< ::FACE::Long, ::OpenDDS::FaceTypes::Bounded<6> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const SeqOfLong&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, SeqOfLong&) { return true; }

}

/* End TYPEDEF: SeqOfLong */


/* Begin TYPEDEF: SeqOfAnEnum */

namespace Xyz {
class SeqOfAnEnum;
typedef ::OpenDDS::FaceTypes::SequenceVar<SeqOfAnEnum> SeqOfAnEnum_var;
typedef ::TAO_Seq_Out_T<SeqOfAnEnum> SeqOfAnEnum_out;

class FooLib_Export SeqOfAnEnum : public ::OpenDDS::FaceTypes::Sequence< Xyz::AnEnum, ::OpenDDS::FaceTypes::Unbounded > {
public:
  typedef SeqOfAnEnum_var _var_type;
  typedef SeqOfAnEnum_out _out_type;

  SeqOfAnEnum() {}
  SeqOfAnEnum(const SeqOfAnEnum& seq) : ::OpenDDS::FaceTypes::Sequence< Xyz::AnEnum, ::OpenDDS::FaceTypes::Unbounded >(seq) {}
  friend void swap(SeqOfAnEnum& a, SeqOfAnEnum& b) { a.swap(b); }
  SeqOfAnEnum& operator=(const SeqOfAnEnum& rhs)
  {
    SeqOfAnEnum tmp(rhs);
    swap(tmp);
    return *this;
  }
  SeqOfAnEnum(::FACE::UnsignedLong maximum)
    : ::OpenDDS::FaceTypes::Sequence< Xyz::AnEnum, ::OpenDDS::FaceTypes::Unbounded >(maximum, 0u, 0, true) {}
  SeqOfAnEnum(::FACE::UnsignedLong maximum, ::FACE::UnsignedLong length, Xyz::AnEnum* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< Xyz::AnEnum, ::OpenDDS::FaceTypes::Unbounded >(maximum, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const SeqOfAnEnum&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, SeqOfAnEnum&) { return true; }

}

/* End TYPEDEF: SeqOfAnEnum */


/* Begin TYPEDEF: ArrayOfBoolean */

namespace Xyz {
typedef ::FACE::Boolean ArrayOfBoolean[5];
typedef ::FACE::Boolean ArrayOfBoolean_slice;
struct ArrayOfBoolean_tag {};
typedef ::TAO_FixedArray_Var_T<ArrayOfBoolean, ArrayOfBoolean_slice, ArrayOfBoolean_tag> ArrayOfBoolean_var;
typedef ArrayOfBoolean ArrayOfBoolean_out;
typedef ::TAO_Array_Forany_T<ArrayOfBoolean, ArrayOfBoolean_slice, ArrayOfBoolean_tag> ArrayOfBoolean_forany;

FooLib_Export ArrayOfBoolean_slice* ArrayOfBoolean_alloc();
FooLib_Export void ArrayOfBoolean_init_i(::FACE::Boolean* begin);
FooLib_Export void ArrayOfBoolean_fini_i(::FACE::Boolean* begin);
FooLib_Export void ArrayOfBoolean_free(ArrayOfBoolean_slice* slice);
FooLib_Export ArrayOfBoolean_slice* ArrayOfBoolean_dup(const ArrayOfBoolean_slice* slice);
FooLib_Export void ArrayOfBoolean_copy(ArrayOfBoolean_slice* dst, const ArrayOfBoolean_slice* src);

inline ACE_CDR::Boolean operator<<(ACE_OutputCDR &, const ArrayOfBoolean_forany&) { return true; }

inline ACE_CDR::Boolean operator>>(ACE_InputCDR &, ArrayOfBoolean_forany&) { return true; }

}
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace TAO {
template <>
struct FooLib_Export Array_Traits<Xyz::ArrayOfBoolean_forany>
{
  static void free(Xyz::ArrayOfBoolean_slice* slice)
  {
    Xyz::ArrayOfBoolean_free(slice);
  }

  static Xyz::ArrayOfBoolean_slice* dup(const Xyz::ArrayOfBoolean_slice* slice)
  {
    return Xyz::ArrayOfBoolean_dup(slice);
  }

  static void copy(Xyz::ArrayOfBoolean_slice* dst, const Xyz::ArrayOfBoolean_slice* src)
  {
    Xyz::ArrayOfBoolean_copy(dst, src);
  }

  static Xyz::ArrayOfBoolean_slice* alloc()
  {
    return Xyz::ArrayOfBoolean_alloc();
  }

  static void zero(Xyz::ArrayOfBoolean_slice* slice)
  {
    Xyz::ArrayOfBoolean_fini_i(slice);
    Xyz::ArrayOfBoolean_init_i(slice);
  }
  static void construct(Xyz::ArrayOfBoolean_slice* slice)
  {
    Xyz::ArrayOfBoolean_init_i(slice);
  }
  static void destroy(Xyz::ArrayOfBoolean_slice* slice)
  {
    Xyz::ArrayOfBoolean_fini_i(slice);
  }
};
}
TAO_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ArrayOfBoolean */


/* Begin TYPEDEF: ArrayOfString */

namespace Xyz {
typedef ::OpenDDS::FaceTypes::String_mgr ArrayOfString[5];
typedef ::OpenDDS::FaceTypes::String_mgr ArrayOfString_slice;
struct ArrayOfString_tag {};
typedef ::TAO_VarArray_Var_T<ArrayOfString, ArrayOfString_slice, ArrayOfString_tag> ArrayOfString_var;
typedef ::TAO_Array_Out_T<ArrayOfString, ArrayOfString_var, ArrayOfString_slice, ArrayOfString_tag> ArrayOfString_out;
typedef ::TAO_Array_Forany_T<ArrayOfString, ArrayOfString_slice, ArrayOfString_tag> ArrayOfString_forany;

FooLib_Export ArrayOfString_slice* ArrayOfString_alloc();
FooLib_Export void ArrayOfString_init_i(::OpenDDS::FaceTypes::String_mgr* begin);
FooLib_Export void ArrayOfString_fini_i(::OpenDDS::FaceTypes::String_mgr* begin);
FooLib_Export void ArrayOfString_free(ArrayOfString_slice* slice);
FooLib_Export ArrayOfString_slice* ArrayOfString_dup(const ArrayOfString_slice* slice);
FooLib_Export void ArrayOfString_copy(ArrayOfString_slice* dst, const ArrayOfString_slice* src);

inline ACE_CDR::Boolean operator<<(ACE_OutputCDR &, const ArrayOfString_forany&) { return true; }

inline ACE_CDR::Boolean operator>>(ACE_InputCDR &, ArrayOfString_forany&) { return true; }

}
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace TAO {
template <>
struct FooLib_Export Array_Traits<Xyz::ArrayOfString_forany>
{
  static void free(Xyz::ArrayOfString_slice* slice)
  {
    Xyz::ArrayOfString_free(slice);
  }

  static Xyz::ArrayOfString_slice* dup(const Xyz::ArrayOfString_slice* slice)
  {
    return Xyz::ArrayOfString_dup(slice);
  }

  static void copy(Xyz::ArrayOfString_slice* dst, const Xyz::ArrayOfString_slice* src)
  {
    Xyz::ArrayOfString_copy(dst, src);
  }

  static Xyz::ArrayOfString_slice* alloc()
  {
    return Xyz::ArrayOfString_alloc();
  }

  static void zero(Xyz::ArrayOfString_slice* slice)
  {
    Xyz::ArrayOfString_fini_i(slice);
    Xyz::ArrayOfString_init_i(slice);
  }
  static void construct(Xyz::ArrayOfString_slice* slice)
  {
    Xyz::ArrayOfString_init_i(slice);
  }
  static void destroy(Xyz::ArrayOfString_slice* slice)
  {
    Xyz::ArrayOfString_fini_i(slice);
  }
};
}
TAO_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ArrayOfString */


/* Begin TYPEDEF: ArrayOfChar */

namespace Xyz {
typedef ::FACE::Char ArrayOfChar[5];
typedef ::FACE::Char ArrayOfChar_slice;
struct ArrayOfChar_tag {};
typedef ::TAO_FixedArray_Var_T<ArrayOfChar, ArrayOfChar_slice, ArrayOfChar_tag> ArrayOfChar_var;
typedef ArrayOfChar ArrayOfChar_out;
typedef ::TAO_Array_Forany_T<ArrayOfChar, ArrayOfChar_slice, ArrayOfChar_tag> ArrayOfChar_forany;

FooLib_Export ArrayOfChar_slice* ArrayOfChar_alloc();
FooLib_Export void ArrayOfChar_init_i(::FACE::Char* begin);
FooLib_Export void ArrayOfChar_fini_i(::FACE::Char* begin);
FooLib_Export void ArrayOfChar_free(ArrayOfChar_slice* slice);
FooLib_Export ArrayOfChar_slice* ArrayOfChar_dup(const ArrayOfChar_slice* slice);
FooLib_Export void ArrayOfChar_copy(ArrayOfChar_slice* dst, const ArrayOfChar_slice* src);

inline ACE_CDR::Boolean operator<<(ACE_OutputCDR &, const ArrayOfChar_forany&) { return true; }

inline ACE_CDR::Boolean operator>>(ACE_InputCDR &, ArrayOfChar_forany&) { return true; }

}
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace TAO {
template <>
struct FooLib_Export Array_Traits<Xyz::ArrayOfChar_forany>
{
  static void free(Xyz::ArrayOfChar_slice* slice)
  {
    Xyz::ArrayOfChar_free(slice);
  }

  static Xyz::ArrayOfChar_slice* dup(const Xyz::ArrayOfChar_slice* slice)
  {
    return Xyz::ArrayOfChar_dup(slice);
  }

  static void copy(Xyz::ArrayOfChar_slice* dst, const Xyz::ArrayOfChar_slice* src)
  {
    Xyz::ArrayOfChar_copy(dst, src);
  }

  static Xyz::ArrayOfChar_slice* alloc()
  {
    return Xyz::ArrayOfChar_alloc();
  }

  static void zero(Xyz::ArrayOfChar_slice* slice)
  {
    Xyz::ArrayOfChar_fini_i(slice);
    Xyz::ArrayOfChar_init_i(slice);
  }
  static void construct(Xyz::ArrayOfChar_slice* slice)
  {
    Xyz::ArrayOfChar_init_i(slice);
  }
  static void destroy(Xyz::ArrayOfChar_slice* slice)
  {
    Xyz::ArrayOfChar_fini_i(slice);
  }
};
}
TAO_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ArrayOfChar */


/* Begin TYPEDEF: ArrayOfOctet */

namespace Xyz {
typedef ::FACE::Octet ArrayOfOctet[5];
typedef ::FACE::Octet ArrayOfOctet_slice;
struct ArrayOfOctet_tag {};
typedef ::TAO_FixedArray_Var_T<ArrayOfOctet, ArrayOfOctet_slice, ArrayOfOctet_tag> ArrayOfOctet_var;
typedef ArrayOfOctet ArrayOfOctet_out;
typedef ::TAO_Array_Forany_T<ArrayOfOctet, ArrayOfOctet_slice, ArrayOfOctet_tag> ArrayOfOctet_forany;

FooLib_Export ArrayOfOctet_slice* ArrayOfOctet_alloc();
FooLib_Export void ArrayOfOctet_init_i(::FACE::Octet* begin);
FooLib_Export void ArrayOfOctet_fini_i(::FACE::Octet* begin);
FooLib_Export void ArrayOfOctet_free(ArrayOfOctet_slice* slice);
FooLib_Export ArrayOfOctet_slice* ArrayOfOctet_dup(const ArrayOfOctet_slice* slice);
FooLib_Export void ArrayOfOctet_copy(ArrayOfOctet_slice* dst, const ArrayOfOctet_slice* src);

inline ACE_CDR::Boolean operator<<(ACE_OutputCDR &, const ArrayOfOctet_forany&) { return true; }

inline ACE_CDR::Boolean operator>>(ACE_InputCDR &, ArrayOfOctet_forany&) { return true; }

}
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace TAO {
template <>
struct FooLib_Export Array_Traits<Xyz::ArrayOfOctet_forany>
{
  static void free(Xyz::ArrayOfOctet_slice* slice)
  {
    Xyz::ArrayOfOctet_free(slice);
  }

  static Xyz::ArrayOfOctet_slice* dup(const Xyz::ArrayOfOctet_slice* slice)
  {
    return Xyz::ArrayOfOctet_dup(slice);
  }

  static void copy(Xyz::ArrayOfOctet_slice* dst, const Xyz::ArrayOfOctet_slice* src)
  {
    Xyz::ArrayOfOctet_copy(dst, src);
  }

  static Xyz::ArrayOfOctet_slice* alloc()
  {
    return Xyz::ArrayOfOctet_alloc();
  }

  static void zero(Xyz::ArrayOfOctet_slice* slice)
  {
    Xyz::ArrayOfOctet_fini_i(slice);
    Xyz::ArrayOfOctet_init_i(slice);
  }
  static void construct(Xyz::ArrayOfOctet_slice* slice)
  {
    Xyz::ArrayOfOctet_init_i(slice);
  }
  static void destroy(Xyz::ArrayOfOctet_slice* slice)
  {
    Xyz::ArrayOfOctet_fini_i(slice);
  }
};
}
TAO_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ArrayOfOctet */


/* Begin TYPEDEF: ArrayOfLong */

namespace Xyz {
typedef ::FACE::Long ArrayOfLong[5];
typedef ::FACE::Long ArrayOfLong_slice;
struct ArrayOfLong_tag {};
typedef ::TAO_FixedArray_Var_T<ArrayOfLong, ArrayOfLong_slice, ArrayOfLong_tag> ArrayOfLong_var;
typedef ArrayOfLong ArrayOfLong_out;
typedef ::TAO_Array_Forany_T<ArrayOfLong, ArrayOfLong_slice, ArrayOfLong_tag> ArrayOfLong_forany;

FooLib_Export ArrayOfLong_slice* ArrayOfLong_alloc();
FooLib_Export void ArrayOfLong_init_i(::FACE::Long* begin);
FooLib_Export void ArrayOfLong_fini_i(::FACE::Long* begin);
FooLib_Export void ArrayOfLong_free(ArrayOfLong_slice* slice);
FooLib_Export ArrayOfLong_slice* ArrayOfLong_dup(const ArrayOfLong_slice* slice);
FooLib_Export void ArrayOfLong_copy(ArrayOfLong_slice* dst, const ArrayOfLong_slice* src);

inline ACE_CDR::Boolean operator<<(ACE_OutputCDR &, const ArrayOfLong_forany&) { return true; }

inline ACE_CDR::Boolean operator>>(ACE_InputCDR &, ArrayOfLong_forany&) { return true; }

}
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace TAO {
template <>
struct FooLib_Export Array_Traits<Xyz::ArrayOfLong_forany>
{
  static void free(Xyz::ArrayOfLong_slice* slice)
  {
    Xyz::ArrayOfLong_free(slice);
  }

  static Xyz::ArrayOfLong_slice* dup(const Xyz::ArrayOfLong_slice* slice)
  {
    return Xyz::ArrayOfLong_dup(slice);
  }

  static void copy(Xyz::ArrayOfLong_slice* dst, const Xyz::ArrayOfLong_slice* src)
  {
    Xyz::ArrayOfLong_copy(dst, src);
  }

  static Xyz::ArrayOfLong_slice* alloc()
  {
    return Xyz::ArrayOfLong_alloc();
  }

  static void zero(Xyz::ArrayOfLong_slice* slice)
  {
    Xyz::ArrayOfLong_fini_i(slice);
    Xyz::ArrayOfLong_init_i(slice);
  }
  static void construct(Xyz::ArrayOfLong_slice* slice)
  {
    Xyz::ArrayOfLong_init_i(slice);
  }
  static void destroy(Xyz::ArrayOfLong_slice* slice)
  {
    Xyz::ArrayOfLong_fini_i(slice);
  }
};
}
TAO_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ArrayOfLong */


/* Begin TYPEDEF: ArrayOfAnEnum */

namespace Xyz {
typedef Xyz::AnEnum ArrayOfAnEnum[5];
typedef Xyz::AnEnum ArrayOfAnEnum_slice;
struct ArrayOfAnEnum_tag {};
typedef ::TAO_FixedArray_Var_T<ArrayOfAnEnum, ArrayOfAnEnum_slice, ArrayOfAnEnum_tag> ArrayOfAnEnum_var;
typedef ArrayOfAnEnum ArrayOfAnEnum_out;
typedef ::TAO_Array_Forany_T<ArrayOfAnEnum, ArrayOfAnEnum_slice, ArrayOfAnEnum_tag> ArrayOfAnEnum_forany;

FooLib_Export ArrayOfAnEnum_slice* ArrayOfAnEnum_alloc();
FooLib_Export void ArrayOfAnEnum_init_i(Xyz::AnEnum* begin);
FooLib_Export void ArrayOfAnEnum_fini_i(Xyz::AnEnum* begin);
FooLib_Export void ArrayOfAnEnum_free(ArrayOfAnEnum_slice* slice);
FooLib_Export ArrayOfAnEnum_slice* ArrayOfAnEnum_dup(const ArrayOfAnEnum_slice* slice);
FooLib_Export void ArrayOfAnEnum_copy(ArrayOfAnEnum_slice* dst, const ArrayOfAnEnum_slice* src);

inline ACE_CDR::Boolean operator<<(ACE_OutputCDR &, const ArrayOfAnEnum_forany&) { return true; }

inline ACE_CDR::Boolean operator>>(ACE_InputCDR &, ArrayOfAnEnum_forany&) { return true; }

}
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace TAO {
template <>
struct FooLib_Export Array_Traits<Xyz::ArrayOfAnEnum_forany>
{
  static void free(Xyz::ArrayOfAnEnum_slice* slice)
  {
    Xyz::ArrayOfAnEnum_free(slice);
  }

  static Xyz::ArrayOfAnEnum_slice* dup(const Xyz::ArrayOfAnEnum_slice* slice)
  {
    return Xyz::ArrayOfAnEnum_dup(slice);
  }

  static void copy(Xyz::ArrayOfAnEnum_slice* dst, const Xyz::ArrayOfAnEnum_slice* src)
  {
    Xyz::ArrayOfAnEnum_copy(dst, src);
  }

  static Xyz::ArrayOfAnEnum_slice* alloc()
  {
    return Xyz::ArrayOfAnEnum_alloc();
  }

  static void zero(Xyz::ArrayOfAnEnum_slice* slice)
  {
    Xyz::ArrayOfAnEnum_fini_i(slice);
    Xyz::ArrayOfAnEnum_init_i(slice);
  }
  static void construct(Xyz::ArrayOfAnEnum_slice* slice)
  {
    Xyz::ArrayOfAnEnum_init_i(slice);
  }
  static void destroy(Xyz::ArrayOfAnEnum_slice* slice)
  {
    Xyz::ArrayOfAnEnum_fini_i(slice);
  }
};
}
TAO_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ArrayOfAnEnum */


/* Begin TYPEDEF: ArrayOfSeqOfBoolean */

namespace Xyz {
typedef Xyz::SeqOfBoolean ArrayOfSeqOfBoolean[6];
typedef Xyz::SeqOfBoolean ArrayOfSeqOfBoolean_slice;
struct ArrayOfSeqOfBoolean_tag {};
typedef ::TAO_VarArray_Var_T<ArrayOfSeqOfBoolean, ArrayOfSeqOfBoolean_slice, ArrayOfSeqOfBoolean_tag> ArrayOfSeqOfBoolean_var;
typedef ::TAO_Array_Out_T<ArrayOfSeqOfBoolean, ArrayOfSeqOfBoolean_var, ArrayOfSeqOfBoolean_slice, ArrayOfSeqOfBoolean_tag> ArrayOfSeqOfBoolean_out;
typedef ::TAO_Array_Forany_T<ArrayOfSeqOfBoolean, ArrayOfSeqOfBoolean_slice, ArrayOfSeqOfBoolean_tag> ArrayOfSeqOfBoolean_forany;

FooLib_Export ArrayOfSeqOfBoolean_slice* ArrayOfSeqOfBoolean_alloc();
FooLib_Export void ArrayOfSeqOfBoolean_init_i(Xyz::SeqOfBoolean* begin);
FooLib_Export void ArrayOfSeqOfBoolean_fini_i(Xyz::SeqOfBoolean* begin);
FooLib_Export void ArrayOfSeqOfBoolean_free(ArrayOfSeqOfBoolean_slice* slice);
FooLib_Export ArrayOfSeqOfBoolean_slice* ArrayOfSeqOfBoolean_dup(const ArrayOfSeqOfBoolean_slice* slice);
FooLib_Export void ArrayOfSeqOfBoolean_copy(ArrayOfSeqOfBoolean_slice* dst, const ArrayOfSeqOfBoolean_slice* src);

inline ACE_CDR::Boolean operator<<(ACE_OutputCDR &, const ArrayOfSeqOfBoolean_forany&) { return true; }

inline ACE_CDR::Boolean operator>>(ACE_InputCDR &, ArrayOfSeqOfBoolean_forany&) { return true; }

}
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace TAO {
template <>
struct FooLib_Export Array_Traits<Xyz::ArrayOfSeqOfBoolean_forany>
{
  static void free(Xyz::ArrayOfSeqOfBoolean_slice* slice)
  {
    Xyz::ArrayOfSeqOfBoolean_free(slice);
  }

  static Xyz::ArrayOfSeqOfBoolean_slice* dup(const Xyz::ArrayOfSeqOfBoolean_slice* slice)
  {
    return Xyz::ArrayOfSeqOfBoolean_dup(slice);
  }

  static void copy(Xyz::ArrayOfSeqOfBoolean_slice* dst, const Xyz::ArrayOfSeqOfBoolean_slice* src)
  {
    Xyz::ArrayOfSeqOfBoolean_copy(dst, src);
  }

  static Xyz::ArrayOfSeqOfBoolean_slice* alloc()
  {
    return Xyz::ArrayOfSeqOfBoolean_alloc();
  }

  static void zero(Xyz::ArrayOfSeqOfBoolean_slice* slice)
  {
    Xyz::ArrayOfSeqOfBoolean_fini_i(slice);
    Xyz::ArrayOfSeqOfBoolean_init_i(slice);
  }
  static void construct(Xyz::ArrayOfSeqOfBoolean_slice* slice)
  {
    Xyz::ArrayOfSeqOfBoolean_init_i(slice);
  }
  static void destroy(Xyz::ArrayOfSeqOfBoolean_slice* slice)
  {
    Xyz::ArrayOfSeqOfBoolean_fini_i(slice);
  }
};
}
TAO_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ArrayOfSeqOfBoolean */


/* Begin TYPEDEF: ArrayOfSeqOfString */

namespace Xyz {
typedef Xyz::SeqOfString ArrayOfSeqOfString[6];
typedef Xyz::SeqOfString ArrayOfSeqOfString_slice;
struct ArrayOfSeqOfString_tag {};
typedef ::TAO_VarArray_Var_T<ArrayOfSeqOfString, ArrayOfSeqOfString_slice, ArrayOfSeqOfString_tag> ArrayOfSeqOfString_var;
typedef ::TAO_Array_Out_T<ArrayOfSeqOfString, ArrayOfSeqOfString_var, ArrayOfSeqOfString_slice, ArrayOfSeqOfString_tag> ArrayOfSeqOfString_out;
typedef ::TAO_Array_Forany_T<ArrayOfSeqOfString, ArrayOfSeqOfString_slice, ArrayOfSeqOfString_tag> ArrayOfSeqOfString_forany;

FooLib_Export ArrayOfSeqOfString_slice* ArrayOfSeqOfString_alloc();
FooLib_Export void ArrayOfSeqOfString_init_i(Xyz::SeqOfString* begin);
FooLib_Export void ArrayOfSeqOfString_fini_i(Xyz::SeqOfString* begin);
FooLib_Export void ArrayOfSeqOfString_free(ArrayOfSeqOfString_slice* slice);
FooLib_Export ArrayOfSeqOfString_slice* ArrayOfSeqOfString_dup(const ArrayOfSeqOfString_slice* slice);
FooLib_Export void ArrayOfSeqOfString_copy(ArrayOfSeqOfString_slice* dst, const ArrayOfSeqOfString_slice* src);

inline ACE_CDR::Boolean operator<<(ACE_OutputCDR &, const ArrayOfSeqOfString_forany&) { return true; }

inline ACE_CDR::Boolean operator>>(ACE_InputCDR &, ArrayOfSeqOfString_forany&) { return true; }

}
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace TAO {
template <>
struct FooLib_Export Array_Traits<Xyz::ArrayOfSeqOfString_forany>
{
  static void free(Xyz::ArrayOfSeqOfString_slice* slice)
  {
    Xyz::ArrayOfSeqOfString_free(slice);
  }

  static Xyz::ArrayOfSeqOfString_slice* dup(const Xyz::ArrayOfSeqOfString_slice* slice)
  {
    return Xyz::ArrayOfSeqOfString_dup(slice);
  }

  static void copy(Xyz::ArrayOfSeqOfString_slice* dst, const Xyz::ArrayOfSeqOfString_slice* src)
  {
    Xyz::ArrayOfSeqOfString_copy(dst, src);
  }

  static Xyz::ArrayOfSeqOfString_slice* alloc()
  {
    return Xyz::ArrayOfSeqOfString_alloc();
  }

  static void zero(Xyz::ArrayOfSeqOfString_slice* slice)
  {
    Xyz::ArrayOfSeqOfString_fini_i(slice);
    Xyz::ArrayOfSeqOfString_init_i(slice);
  }
  static void construct(Xyz::ArrayOfSeqOfString_slice* slice)
  {
    Xyz::ArrayOfSeqOfString_init_i(slice);
  }
  static void destroy(Xyz::ArrayOfSeqOfString_slice* slice)
  {
    Xyz::ArrayOfSeqOfString_fini_i(slice);
  }
};
}
TAO_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ArrayOfSeqOfString */


/* Begin TYPEDEF: ArrayOfSeqOfChar */

namespace Xyz {
typedef Xyz::SeqOfChar ArrayOfSeqOfChar[6];
typedef Xyz::SeqOfChar ArrayOfSeqOfChar_slice;
struct ArrayOfSeqOfChar_tag {};
typedef ::TAO_VarArray_Var_T<ArrayOfSeqOfChar, ArrayOfSeqOfChar_slice, ArrayOfSeqOfChar_tag> ArrayOfSeqOfChar_var;
typedef ::TAO_Array_Out_T<ArrayOfSeqOfChar, ArrayOfSeqOfChar_var, ArrayOfSeqOfChar_slice, ArrayOfSeqOfChar_tag> ArrayOfSeqOfChar_out;
typedef ::TAO_Array_Forany_T<ArrayOfSeqOfChar, ArrayOfSeqOfChar_slice, ArrayOfSeqOfChar_tag> ArrayOfSeqOfChar_forany;

FooLib_Export ArrayOfSeqOfChar_slice* ArrayOfSeqOfChar_alloc();
FooLib_Export void ArrayOfSeqOfChar_init_i(Xyz::SeqOfChar* begin);
FooLib_Export void ArrayOfSeqOfChar_fini_i(Xyz::SeqOfChar* begin);
FooLib_Export void ArrayOfSeqOfChar_free(ArrayOfSeqOfChar_slice* slice);
FooLib_Export ArrayOfSeqOfChar_slice* ArrayOfSeqOfChar_dup(const ArrayOfSeqOfChar_slice* slice);
FooLib_Export void ArrayOfSeqOfChar_copy(ArrayOfSeqOfChar_slice* dst, const ArrayOfSeqOfChar_slice* src);

inline ACE_CDR::Boolean operator<<(ACE_OutputCDR &, const ArrayOfSeqOfChar_forany&) { return true; }

inline ACE_CDR::Boolean operator>>(ACE_InputCDR &, ArrayOfSeqOfChar_forany&) { return true; }

}
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace TAO {
template <>
struct FooLib_Export Array_Traits<Xyz::ArrayOfSeqOfChar_forany>
{
  static void free(Xyz::ArrayOfSeqOfChar_slice* slice)
  {
    Xyz::ArrayOfSeqOfChar_free(slice);
  }

  static Xyz::ArrayOfSeqOfChar_slice* dup(const Xyz::ArrayOfSeqOfChar_slice* slice)
  {
    return Xyz::ArrayOfSeqOfChar_dup(slice);
  }

  static void copy(Xyz::ArrayOfSeqOfChar_slice* dst, const Xyz::ArrayOfSeqOfChar_slice* src)
  {
    Xyz::ArrayOfSeqOfChar_copy(dst, src);
  }

  static Xyz::ArrayOfSeqOfChar_slice* alloc()
  {
    return Xyz::ArrayOfSeqOfChar_alloc();
  }

  static void zero(Xyz::ArrayOfSeqOfChar_slice* slice)
  {
    Xyz::ArrayOfSeqOfChar_fini_i(slice);
    Xyz::ArrayOfSeqOfChar_init_i(slice);
  }
  static void construct(Xyz::ArrayOfSeqOfChar_slice* slice)
  {
    Xyz::ArrayOfSeqOfChar_init_i(slice);
  }
  static void destroy(Xyz::ArrayOfSeqOfChar_slice* slice)
  {
    Xyz::ArrayOfSeqOfChar_fini_i(slice);
  }
};
}
TAO_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ArrayOfSeqOfChar */


/* Begin TYPEDEF: ArrayOfSeqOfOctet */

namespace Xyz {
typedef Xyz::SeqOfOctet ArrayOfSeqOfOctet[6];
typedef Xyz::SeqOfOctet ArrayOfSeqOfOctet_slice;
struct ArrayOfSeqOfOctet_tag {};
typedef ::TAO_VarArray_Var_T<ArrayOfSeqOfOctet, ArrayOfSeqOfOctet_slice, ArrayOfSeqOfOctet_tag> ArrayOfSeqOfOctet_var;
typedef ::TAO_Array_Out_T<ArrayOfSeqOfOctet, ArrayOfSeqOfOctet_var, ArrayOfSeqOfOctet_slice, ArrayOfSeqOfOctet_tag> ArrayOfSeqOfOctet_out;
typedef ::TAO_Array_Forany_T<ArrayOfSeqOfOctet, ArrayOfSeqOfOctet_slice, ArrayOfSeqOfOctet_tag> ArrayOfSeqOfOctet_forany;

FooLib_Export ArrayOfSeqOfOctet_slice* ArrayOfSeqOfOctet_alloc();
FooLib_Export void ArrayOfSeqOfOctet_init_i(Xyz::SeqOfOctet* begin);
FooLib_Export void ArrayOfSeqOfOctet_fini_i(Xyz::SeqOfOctet* begin);
FooLib_Export void ArrayOfSeqOfOctet_free(ArrayOfSeqOfOctet_slice* slice);
FooLib_Export ArrayOfSeqOfOctet_slice* ArrayOfSeqOfOctet_dup(const ArrayOfSeqOfOctet_slice* slice);
FooLib_Export void ArrayOfSeqOfOctet_copy(ArrayOfSeqOfOctet_slice* dst, const ArrayOfSeqOfOctet_slice* src);

inline ACE_CDR::Boolean operator<<(ACE_OutputCDR &, const ArrayOfSeqOfOctet_forany&) { return true; }

inline ACE_CDR::Boolean operator>>(ACE_InputCDR &, ArrayOfSeqOfOctet_forany&) { return true; }

}
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace TAO {
template <>
struct FooLib_Export Array_Traits<Xyz::ArrayOfSeqOfOctet_forany>
{
  static void free(Xyz::ArrayOfSeqOfOctet_slice* slice)
  {
    Xyz::ArrayOfSeqOfOctet_free(slice);
  }

  static Xyz::ArrayOfSeqOfOctet_slice* dup(const Xyz::ArrayOfSeqOfOctet_slice* slice)
  {
    return Xyz::ArrayOfSeqOfOctet_dup(slice);
  }

  static void copy(Xyz::ArrayOfSeqOfOctet_slice* dst, const Xyz::ArrayOfSeqOfOctet_slice* src)
  {
    Xyz::ArrayOfSeqOfOctet_copy(dst, src);
  }

  static Xyz::ArrayOfSeqOfOctet_slice* alloc()
  {
    return Xyz::ArrayOfSeqOfOctet_alloc();
  }

  static void zero(Xyz::ArrayOfSeqOfOctet_slice* slice)
  {
    Xyz::ArrayOfSeqOfOctet_fini_i(slice);
    Xyz::ArrayOfSeqOfOctet_init_i(slice);
  }
  static void construct(Xyz::ArrayOfSeqOfOctet_slice* slice)
  {
    Xyz::ArrayOfSeqOfOctet_init_i(slice);
  }
  static void destroy(Xyz::ArrayOfSeqOfOctet_slice* slice)
  {
    Xyz::ArrayOfSeqOfOctet_fini_i(slice);
  }
};
}
TAO_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ArrayOfSeqOfOctet */


/* Begin TYPEDEF: ArrayOfSeqOfLong */

namespace Xyz {
typedef Xyz::SeqOfLong ArrayOfSeqOfLong[6];
typedef Xyz::SeqOfLong ArrayOfSeqOfLong_slice;
struct ArrayOfSeqOfLong_tag {};
typedef ::TAO_VarArray_Var_T<ArrayOfSeqOfLong, ArrayOfSeqOfLong_slice, ArrayOfSeqOfLong_tag> ArrayOfSeqOfLong_var;
typedef ::TAO_Array_Out_T<ArrayOfSeqOfLong, ArrayOfSeqOfLong_var, ArrayOfSeqOfLong_slice, ArrayOfSeqOfLong_tag> ArrayOfSeqOfLong_out;
typedef ::TAO_Array_Forany_T<ArrayOfSeqOfLong, ArrayOfSeqOfLong_slice, ArrayOfSeqOfLong_tag> ArrayOfSeqOfLong_forany;

FooLib_Export ArrayOfSeqOfLong_slice* ArrayOfSeqOfLong_alloc();
FooLib_Export void ArrayOfSeqOfLong_init_i(Xyz::SeqOfLong* begin);
FooLib_Export void ArrayOfSeqOfLong_fini_i(Xyz::SeqOfLong* begin);
FooLib_Export void ArrayOfSeqOfLong_free(ArrayOfSeqOfLong_slice* slice);
FooLib_Export ArrayOfSeqOfLong_slice* ArrayOfSeqOfLong_dup(const ArrayOfSeqOfLong_slice* slice);
FooLib_Export void ArrayOfSeqOfLong_copy(ArrayOfSeqOfLong_slice* dst, const ArrayOfSeqOfLong_slice* src);

inline ACE_CDR::Boolean operator<<(ACE_OutputCDR &, const ArrayOfSeqOfLong_forany&) { return true; }

inline ACE_CDR::Boolean operator>>(ACE_InputCDR &, ArrayOfSeqOfLong_forany&) { return true; }

}
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace TAO {
template <>
struct FooLib_Export Array_Traits<Xyz::ArrayOfSeqOfLong_forany>
{
  static void free(Xyz::ArrayOfSeqOfLong_slice* slice)
  {
    Xyz::ArrayOfSeqOfLong_free(slice);
  }

  static Xyz::ArrayOfSeqOfLong_slice* dup(const Xyz::ArrayOfSeqOfLong_slice* slice)
  {
    return Xyz::ArrayOfSeqOfLong_dup(slice);
  }

  static void copy(Xyz::ArrayOfSeqOfLong_slice* dst, const Xyz::ArrayOfSeqOfLong_slice* src)
  {
    Xyz::ArrayOfSeqOfLong_copy(dst, src);
  }

  static Xyz::ArrayOfSeqOfLong_slice* alloc()
  {
    return Xyz::ArrayOfSeqOfLong_alloc();
  }

  static void zero(Xyz::ArrayOfSeqOfLong_slice* slice)
  {
    Xyz::ArrayOfSeqOfLong_fini_i(slice);
    Xyz::ArrayOfSeqOfLong_init_i(slice);
  }
  static void construct(Xyz::ArrayOfSeqOfLong_slice* slice)
  {
    Xyz::ArrayOfSeqOfLong_init_i(slice);
  }
  static void destroy(Xyz::ArrayOfSeqOfLong_slice* slice)
  {
    Xyz::ArrayOfSeqOfLong_fini_i(slice);
  }
};
}
TAO_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ArrayOfSeqOfLong */


/* Begin TYPEDEF: ArrayOfSeqOfAnEnum */

namespace Xyz {
typedef Xyz::SeqOfAnEnum ArrayOfSeqOfAnEnum[6];
typedef Xyz::SeqOfAnEnum ArrayOfSeqOfAnEnum_slice;
struct ArrayOfSeqOfAnEnum_tag {};
typedef ::TAO_VarArray_Var_T<ArrayOfSeqOfAnEnum, ArrayOfSeqOfAnEnum_slice, ArrayOfSeqOfAnEnum_tag> ArrayOfSeqOfAnEnum_var;
typedef ::TAO_Array_Out_T<ArrayOfSeqOfAnEnum, ArrayOfSeqOfAnEnum_var, ArrayOfSeqOfAnEnum_slice, ArrayOfSeqOfAnEnum_tag> ArrayOfSeqOfAnEnum_out;
typedef ::TAO_Array_Forany_T<ArrayOfSeqOfAnEnum, ArrayOfSeqOfAnEnum_slice, ArrayOfSeqOfAnEnum_tag> ArrayOfSeqOfAnEnum_forany;

FooLib_Export ArrayOfSeqOfAnEnum_slice* ArrayOfSeqOfAnEnum_alloc();
FooLib_Export void ArrayOfSeqOfAnEnum_init_i(Xyz::SeqOfAnEnum* begin);
FooLib_Export void ArrayOfSeqOfAnEnum_fini_i(Xyz::SeqOfAnEnum* begin);
FooLib_Export void ArrayOfSeqOfAnEnum_free(ArrayOfSeqOfAnEnum_slice* slice);
FooLib_Export ArrayOfSeqOfAnEnum_slice* ArrayOfSeqOfAnEnum_dup(const ArrayOfSeqOfAnEnum_slice* slice);
FooLib_Export void ArrayOfSeqOfAnEnum_copy(ArrayOfSeqOfAnEnum_slice* dst, const ArrayOfSeqOfAnEnum_slice* src);

inline ACE_CDR::Boolean operator<<(ACE_OutputCDR &, const ArrayOfSeqOfAnEnum_forany&) { return true; }

inline ACE_CDR::Boolean operator>>(ACE_InputCDR &, ArrayOfSeqOfAnEnum_forany&) { return true; }

}
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace TAO {
template <>
struct FooLib_Export Array_Traits<Xyz::ArrayOfSeqOfAnEnum_forany>
{
  static void free(Xyz::ArrayOfSeqOfAnEnum_slice* slice)
  {
    Xyz::ArrayOfSeqOfAnEnum_free(slice);
  }

  static Xyz::ArrayOfSeqOfAnEnum_slice* dup(const Xyz::ArrayOfSeqOfAnEnum_slice* slice)
  {
    return Xyz::ArrayOfSeqOfAnEnum_dup(slice);
  }

  static void copy(Xyz::ArrayOfSeqOfAnEnum_slice* dst, const Xyz::ArrayOfSeqOfAnEnum_slice* src)
  {
    Xyz::ArrayOfSeqOfAnEnum_copy(dst, src);
  }

  static Xyz::ArrayOfSeqOfAnEnum_slice* alloc()
  {
    return Xyz::ArrayOfSeqOfAnEnum_alloc();
  }

  static void zero(Xyz::ArrayOfSeqOfAnEnum_slice* slice)
  {
    Xyz::ArrayOfSeqOfAnEnum_fini_i(slice);
    Xyz::ArrayOfSeqOfAnEnum_init_i(slice);
  }
  static void construct(Xyz::ArrayOfSeqOfAnEnum_slice* slice)
  {
    Xyz::ArrayOfSeqOfAnEnum_init_i(slice);
  }
  static void destroy(Xyz::ArrayOfSeqOfAnEnum_slice* slice)
  {
    Xyz::ArrayOfSeqOfAnEnum_fini_i(slice);
  }
};
}
TAO_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ArrayOfSeqOfAnEnum */

/* End MODULE: Xyz */
#endif /* OPENDDS_IDL_GENERATED_SHAREDTYPESC_H_H9A6GO */
