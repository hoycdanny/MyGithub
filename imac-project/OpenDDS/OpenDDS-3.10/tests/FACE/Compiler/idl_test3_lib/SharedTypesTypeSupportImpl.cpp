/* Generated by /Users/yc/MyGithub/imac-project/OpenDDS/OpenDDS-3.10/bin/opendds_idl version 3.10 (ACE version 6.2a_p11) running on input file ../../../DCPS/Compiler/idl_test3_lib/SharedTypes.idl */
#include "SharedTypesTypeSupportImpl.h"



/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: Xyz */



/* Begin ENUM: AnEnum */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const Xyz::AnEnum& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm, Xyz::AnEnum& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    enumval = static_cast<Xyz::AnEnum>(temp);
    return true;
  }
  return false;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

const char* gen_Xyz_AnEnum_names[] = {
  "redx",
  "greenx",
  "bluex"
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End ENUM: AnEnum */


/* Begin TYPEDEF: SeqOfBoolean */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::SeqOfBoolean& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  size += seq.length() * max_marshaled_size_boolean();
}

bool operator<<(Serializer& strm, const Xyz::SeqOfBoolean& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  return strm.write_boolean_array(seq.get_buffer(), length);
}

bool operator>>(Serializer& strm, Xyz::SeqOfBoolean& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > seq.maximum()) {
    return false;
  }
  seq.length(length);
  if (length == 0) {
    return true;
  }
  return strm.read_boolean_array(seq.get_buffer(), length);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::SeqOfBoolean*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  ser.skip(length, 1);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfBoolean */


/* Begin TYPEDEF: SeqOfString */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::SeqOfString& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    find_size_ulong(size, padding);
    if (seq[i]) {
      size += ACE_OS::strlen(seq[i]) + 1;
    }
  }
}

bool operator<<(Serializer& strm, const Xyz::SeqOfString& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::SeqOfString& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > seq.maximum()) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::SeqOfString*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    ACE_CDR::ULong strlength;
    ser >> strlength;
    ser.skip(strlength);
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfString */


/* Begin TYPEDEF: SeqOfChar */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::SeqOfChar& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  size += seq.length() * max_marshaled_size_char();
}

bool operator<<(Serializer& strm, const Xyz::SeqOfChar& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  return strm.write_char_array(seq.get_buffer(), length);
}

bool operator>>(Serializer& strm, Xyz::SeqOfChar& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > seq.maximum()) {
    return false;
  }
  seq.length(length);
  if (length == 0) {
    return true;
  }
  return strm.read_char_array(seq.get_buffer(), length);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::SeqOfChar*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  ser.skip(length, 1);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfChar */


/* Begin TYPEDEF: SeqOfOctet */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::SeqOfOctet& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  size += seq.length() * max_marshaled_size_octet();
}

bool operator<<(Serializer& strm, const Xyz::SeqOfOctet& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  return strm.write_octet_array(seq.get_buffer(), length);
}

bool operator>>(Serializer& strm, Xyz::SeqOfOctet& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > seq.maximum()) {
    return false;
  }
  seq.length(length);
  if (length == 0) {
    return true;
  }
  return strm.read_octet_array(seq.get_buffer(), length);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::SeqOfOctet*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  ser.skip(length, 1);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfOctet */


/* Begin TYPEDEF: SeqOfLong */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::SeqOfLong& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  size += seq.length() * gen_max_marshaled_size(CORBA::Long());
}

bool operator<<(Serializer& strm, const Xyz::SeqOfLong& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  return strm.write_long_array(seq.get_buffer(), length);
}

bool operator>>(Serializer& strm, Xyz::SeqOfLong& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > seq.maximum()) {
    return false;
  }
  seq.length(length);
  if (length == 0) {
    return true;
  }
  return strm.read_long_array(seq.get_buffer(), length);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::SeqOfLong*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  ser.skip(length, 4);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfLong */


/* Begin TYPEDEF: SeqOfAnEnum */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::SeqOfAnEnum& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  size += seq.length() * max_marshaled_size_ulong();
}

bool operator<<(Serializer& strm, const Xyz::SeqOfAnEnum& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::SeqOfAnEnum& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::SeqOfAnEnum*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  ser.skip(length, 4);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfAnEnum */


/* Begin TYPEDEF: ArrayOfBoolean */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::ArrayOfBoolean_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += 5 * max_marshaled_size_boolean();
}

bool operator<<(Serializer& strm, const Xyz::ArrayOfBoolean_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.write_boolean_array(arr.in(), 5);
}

bool operator>>(Serializer& strm, Xyz::ArrayOfBoolean_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.read_boolean_array(arr.out(), 5);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::ArrayOfBoolean_forany*)
{
  ACE_UNUSED_ARG(ser);
  ser.skip(5, 1);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
ArrayOfBoolean_slice* ArrayOfBoolean_alloc()
{
  void* const raw = ACE_Allocator::instance()->malloc(sizeof(ArrayOfBoolean));
  ArrayOfBoolean_slice* const slice = static_cast<ArrayOfBoolean_slice*>(raw);
  ArrayOfBoolean_init_i(slice);
  return slice;
}

void ArrayOfBoolean_init_i(::FACE::Boolean* begin)
{
  ACE_UNUSED_ARG(begin);
}

void ArrayOfBoolean_fini_i(::FACE::Boolean* begin)
{
  ACE_UNUSED_ARG(begin);
}

void ArrayOfBoolean_free(ArrayOfBoolean_slice* slice)
{
  if (!slice) return;
  ArrayOfBoolean_fini_i(slice);
  ACE_Allocator::instance()->free(slice);
}

ArrayOfBoolean_slice* ArrayOfBoolean_dup(const ArrayOfBoolean_slice* slice)
{
  ArrayOfBoolean_slice* const arr = ArrayOfBoolean_alloc();
  if (arr) ArrayOfBoolean_copy(arr, slice);
  return arr;
}

void ArrayOfBoolean_copy(ArrayOfBoolean_slice* dst, const ArrayOfBoolean_slice* src)
{
  if (!src || !dst) return;
  for (ACE_CDR::ULong i0 = 0; i0 < 5; ++i0) {
    dst[i0] = src[i0];
  }
}

}

/* End TYPEDEF: ArrayOfBoolean */


/* Begin TYPEDEF: ArrayOfString */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::ArrayOfString_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  for (CORBA::ULong i0 = 0; i0 < 5; ++i0) {
    find_size_ulong(size, padding);
    size += ACE_OS::strlen(arr[i0].in()) + 1;
  }
}

bool operator<<(Serializer& strm, const Xyz::ArrayOfString_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 5; ++i0) {
    if (!(strm << arr[i0].in())) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::ArrayOfString_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 5; ++i0) {
    if (!(strm >> arr[i0].out())) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::ArrayOfString_forany*)
{
  ACE_UNUSED_ARG(ser);
  for (ACE_CDR::ULong i = 0; i < 5; ++i) {
    ACE_CDR::ULong strlength;
    ser >> strlength;
    ser.skip(strlength);
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
ArrayOfString_slice* ArrayOfString_alloc()
{
  void* const raw = ACE_Allocator::instance()->malloc(sizeof(ArrayOfString));
  ArrayOfString_slice* const slice = static_cast<ArrayOfString_slice*>(raw);
  ArrayOfString_init_i(slice);
  return slice;
}

void ArrayOfString_init_i(::OpenDDS::FaceTypes::String_mgr* begin)
{
  std::uninitialized_fill_n(begin, 5, ::OpenDDS::FaceTypes::String_mgr());
}

void ArrayOfString_fini_i(::OpenDDS::FaceTypes::String_mgr* begin)
{
  for (int i = 0; i < 5; ++i) {
    begin[i].~StringManager();
  }
}

void ArrayOfString_free(ArrayOfString_slice* slice)
{
  if (!slice) return;
  ArrayOfString_fini_i(slice);
  ACE_Allocator::instance()->free(slice);
}

ArrayOfString_slice* ArrayOfString_dup(const ArrayOfString_slice* slice)
{
  ArrayOfString_slice* const arr = ArrayOfString_alloc();
  if (arr) ArrayOfString_copy(arr, slice);
  return arr;
}

void ArrayOfString_copy(ArrayOfString_slice* dst, const ArrayOfString_slice* src)
{
  if (!src || !dst) return;
  for (ACE_CDR::ULong i0 = 0; i0 < 5; ++i0) {
    dst[i0] = src[i0];
  }
}

}

/* End TYPEDEF: ArrayOfString */


/* Begin TYPEDEF: ArrayOfChar */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::ArrayOfChar_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += 5 * max_marshaled_size_char();
}

bool operator<<(Serializer& strm, const Xyz::ArrayOfChar_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.write_char_array(arr.in(), 5);
}

bool operator>>(Serializer& strm, Xyz::ArrayOfChar_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.read_char_array(arr.out(), 5);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::ArrayOfChar_forany*)
{
  ACE_UNUSED_ARG(ser);
  ser.skip(5, 1);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
ArrayOfChar_slice* ArrayOfChar_alloc()
{
  void* const raw = ACE_Allocator::instance()->malloc(sizeof(ArrayOfChar));
  ArrayOfChar_slice* const slice = static_cast<ArrayOfChar_slice*>(raw);
  ArrayOfChar_init_i(slice);
  return slice;
}

void ArrayOfChar_init_i(::FACE::Char* begin)
{
  ACE_UNUSED_ARG(begin);
}

void ArrayOfChar_fini_i(::FACE::Char* begin)
{
  ACE_UNUSED_ARG(begin);
}

void ArrayOfChar_free(ArrayOfChar_slice* slice)
{
  if (!slice) return;
  ArrayOfChar_fini_i(slice);
  ACE_Allocator::instance()->free(slice);
}

ArrayOfChar_slice* ArrayOfChar_dup(const ArrayOfChar_slice* slice)
{
  ArrayOfChar_slice* const arr = ArrayOfChar_alloc();
  if (arr) ArrayOfChar_copy(arr, slice);
  return arr;
}

void ArrayOfChar_copy(ArrayOfChar_slice* dst, const ArrayOfChar_slice* src)
{
  if (!src || !dst) return;
  for (ACE_CDR::ULong i0 = 0; i0 < 5; ++i0) {
    dst[i0] = src[i0];
  }
}

}

/* End TYPEDEF: ArrayOfChar */


/* Begin TYPEDEF: ArrayOfOctet */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::ArrayOfOctet_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += 5 * max_marshaled_size_octet();
}

bool operator<<(Serializer& strm, const Xyz::ArrayOfOctet_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.write_octet_array(arr.in(), 5);
}

bool operator>>(Serializer& strm, Xyz::ArrayOfOctet_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.read_octet_array(arr.out(), 5);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::ArrayOfOctet_forany*)
{
  ACE_UNUSED_ARG(ser);
  ser.skip(5, 1);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
ArrayOfOctet_slice* ArrayOfOctet_alloc()
{
  void* const raw = ACE_Allocator::instance()->malloc(sizeof(ArrayOfOctet));
  ArrayOfOctet_slice* const slice = static_cast<ArrayOfOctet_slice*>(raw);
  ArrayOfOctet_init_i(slice);
  return slice;
}

void ArrayOfOctet_init_i(::FACE::Octet* begin)
{
  ACE_UNUSED_ARG(begin);
}

void ArrayOfOctet_fini_i(::FACE::Octet* begin)
{
  ACE_UNUSED_ARG(begin);
}

void ArrayOfOctet_free(ArrayOfOctet_slice* slice)
{
  if (!slice) return;
  ArrayOfOctet_fini_i(slice);
  ACE_Allocator::instance()->free(slice);
}

ArrayOfOctet_slice* ArrayOfOctet_dup(const ArrayOfOctet_slice* slice)
{
  ArrayOfOctet_slice* const arr = ArrayOfOctet_alloc();
  if (arr) ArrayOfOctet_copy(arr, slice);
  return arr;
}

void ArrayOfOctet_copy(ArrayOfOctet_slice* dst, const ArrayOfOctet_slice* src)
{
  if (!src || !dst) return;
  for (ACE_CDR::ULong i0 = 0; i0 < 5; ++i0) {
    dst[i0] = src[i0];
  }
}

}

/* End TYPEDEF: ArrayOfOctet */


/* Begin TYPEDEF: ArrayOfLong */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::ArrayOfLong_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += 5 * gen_max_marshaled_size(CORBA::Long());
}

bool operator<<(Serializer& strm, const Xyz::ArrayOfLong_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.write_long_array(arr.in(), 5);
}

bool operator>>(Serializer& strm, Xyz::ArrayOfLong_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.read_long_array(arr.out(), 5);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::ArrayOfLong_forany*)
{
  ACE_UNUSED_ARG(ser);
  ser.skip(5, 4);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
ArrayOfLong_slice* ArrayOfLong_alloc()
{
  void* const raw = ACE_Allocator::instance()->malloc(sizeof(ArrayOfLong));
  ArrayOfLong_slice* const slice = static_cast<ArrayOfLong_slice*>(raw);
  ArrayOfLong_init_i(slice);
  return slice;
}

void ArrayOfLong_init_i(::FACE::Long* begin)
{
  ACE_UNUSED_ARG(begin);
}

void ArrayOfLong_fini_i(::FACE::Long* begin)
{
  ACE_UNUSED_ARG(begin);
}

void ArrayOfLong_free(ArrayOfLong_slice* slice)
{
  if (!slice) return;
  ArrayOfLong_fini_i(slice);
  ACE_Allocator::instance()->free(slice);
}

ArrayOfLong_slice* ArrayOfLong_dup(const ArrayOfLong_slice* slice)
{
  ArrayOfLong_slice* const arr = ArrayOfLong_alloc();
  if (arr) ArrayOfLong_copy(arr, slice);
  return arr;
}

void ArrayOfLong_copy(ArrayOfLong_slice* dst, const ArrayOfLong_slice* src)
{
  if (!src || !dst) return;
  for (ACE_CDR::ULong i0 = 0; i0 < 5; ++i0) {
    dst[i0] = src[i0];
  }
}

}

/* End TYPEDEF: ArrayOfLong */


/* Begin TYPEDEF: ArrayOfAnEnum */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::ArrayOfAnEnum_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += 4 * max_marshaled_size_ulong();
}

bool operator<<(Serializer& strm, const Xyz::ArrayOfAnEnum_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 5; ++i0) {
    if (!(strm << arr[i0])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::ArrayOfAnEnum_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 5; ++i0) {
    if (!(strm >> arr[i0])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::ArrayOfAnEnum_forany*)
{
  ACE_UNUSED_ARG(ser);
  ser.skip(5, 4);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
ArrayOfAnEnum_slice* ArrayOfAnEnum_alloc()
{
  void* const raw = ACE_Allocator::instance()->malloc(sizeof(ArrayOfAnEnum));
  ArrayOfAnEnum_slice* const slice = static_cast<ArrayOfAnEnum_slice*>(raw);
  ArrayOfAnEnum_init_i(slice);
  return slice;
}

void ArrayOfAnEnum_init_i(Xyz::AnEnum* begin)
{
  ACE_UNUSED_ARG(begin);
}

void ArrayOfAnEnum_fini_i(Xyz::AnEnum* begin)
{
  ACE_UNUSED_ARG(begin);
}

void ArrayOfAnEnum_free(ArrayOfAnEnum_slice* slice)
{
  if (!slice) return;
  ArrayOfAnEnum_fini_i(slice);
  ACE_Allocator::instance()->free(slice);
}

ArrayOfAnEnum_slice* ArrayOfAnEnum_dup(const ArrayOfAnEnum_slice* slice)
{
  ArrayOfAnEnum_slice* const arr = ArrayOfAnEnum_alloc();
  if (arr) ArrayOfAnEnum_copy(arr, slice);
  return arr;
}

void ArrayOfAnEnum_copy(ArrayOfAnEnum_slice* dst, const ArrayOfAnEnum_slice* src)
{
  if (!src || !dst) return;
  for (ACE_CDR::ULong i0 = 0; i0 < 5; ++i0) {
    dst[i0] = src[i0];
  }
}

}

/* End TYPEDEF: ArrayOfAnEnum */


/* Begin TYPEDEF: ArrayOfSeqOfBoolean */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::ArrayOfSeqOfBoolean_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  for (CORBA::ULong i0 = 0; i0 < 6; ++i0) {
    gen_find_size(arr[i0], size, padding);
  }
}

bool operator<<(Serializer& strm, const Xyz::ArrayOfSeqOfBoolean_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 6; ++i0) {
    if (!(strm << arr[i0])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::ArrayOfSeqOfBoolean_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 6; ++i0) {
    if (!(strm >> arr[i0])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::ArrayOfSeqOfBoolean_forany*)
{
  ACE_UNUSED_ARG(ser);
  for (ACE_CDR::ULong i = 0; i < 6; ++i) {
    gen_skip_over(ser, static_cast<Xyz::SeqOfBoolean*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
ArrayOfSeqOfBoolean_slice* ArrayOfSeqOfBoolean_alloc()
{
  void* const raw = ACE_Allocator::instance()->malloc(sizeof(ArrayOfSeqOfBoolean));
  ArrayOfSeqOfBoolean_slice* const slice = static_cast<ArrayOfSeqOfBoolean_slice*>(raw);
  ArrayOfSeqOfBoolean_init_i(slice);
  return slice;
}

void ArrayOfSeqOfBoolean_init_i(Xyz::SeqOfBoolean* begin)
{
  std::uninitialized_fill_n(begin, 6, Xyz::SeqOfBoolean());
}

void ArrayOfSeqOfBoolean_fini_i(Xyz::SeqOfBoolean* begin)
{
  for (int i = 0; i < 6; ++i) {
    begin[i].~SeqOfBoolean();
  }
}

void ArrayOfSeqOfBoolean_free(ArrayOfSeqOfBoolean_slice* slice)
{
  if (!slice) return;
  ArrayOfSeqOfBoolean_fini_i(slice);
  ACE_Allocator::instance()->free(slice);
}

ArrayOfSeqOfBoolean_slice* ArrayOfSeqOfBoolean_dup(const ArrayOfSeqOfBoolean_slice* slice)
{
  ArrayOfSeqOfBoolean_slice* const arr = ArrayOfSeqOfBoolean_alloc();
  if (arr) ArrayOfSeqOfBoolean_copy(arr, slice);
  return arr;
}

void ArrayOfSeqOfBoolean_copy(ArrayOfSeqOfBoolean_slice* dst, const ArrayOfSeqOfBoolean_slice* src)
{
  if (!src || !dst) return;
  for (ACE_CDR::ULong i0 = 0; i0 < 6; ++i0) {
    dst[i0] = src[i0];
  }
}

}

/* End TYPEDEF: ArrayOfSeqOfBoolean */


/* Begin TYPEDEF: ArrayOfSeqOfString */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::ArrayOfSeqOfString_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  for (CORBA::ULong i0 = 0; i0 < 6; ++i0) {
    gen_find_size(arr[i0], size, padding);
  }
}

bool operator<<(Serializer& strm, const Xyz::ArrayOfSeqOfString_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 6; ++i0) {
    if (!(strm << arr[i0])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::ArrayOfSeqOfString_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 6; ++i0) {
    if (!(strm >> arr[i0])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::ArrayOfSeqOfString_forany*)
{
  ACE_UNUSED_ARG(ser);
  for (ACE_CDR::ULong i = 0; i < 6; ++i) {
    gen_skip_over(ser, static_cast<Xyz::SeqOfString*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
ArrayOfSeqOfString_slice* ArrayOfSeqOfString_alloc()
{
  void* const raw = ACE_Allocator::instance()->malloc(sizeof(ArrayOfSeqOfString));
  ArrayOfSeqOfString_slice* const slice = static_cast<ArrayOfSeqOfString_slice*>(raw);
  ArrayOfSeqOfString_init_i(slice);
  return slice;
}

void ArrayOfSeqOfString_init_i(Xyz::SeqOfString* begin)
{
  std::uninitialized_fill_n(begin, 6, Xyz::SeqOfString());
}

void ArrayOfSeqOfString_fini_i(Xyz::SeqOfString* begin)
{
  for (int i = 0; i < 6; ++i) {
    begin[i].~SeqOfString();
  }
}

void ArrayOfSeqOfString_free(ArrayOfSeqOfString_slice* slice)
{
  if (!slice) return;
  ArrayOfSeqOfString_fini_i(slice);
  ACE_Allocator::instance()->free(slice);
}

ArrayOfSeqOfString_slice* ArrayOfSeqOfString_dup(const ArrayOfSeqOfString_slice* slice)
{
  ArrayOfSeqOfString_slice* const arr = ArrayOfSeqOfString_alloc();
  if (arr) ArrayOfSeqOfString_copy(arr, slice);
  return arr;
}

void ArrayOfSeqOfString_copy(ArrayOfSeqOfString_slice* dst, const ArrayOfSeqOfString_slice* src)
{
  if (!src || !dst) return;
  for (ACE_CDR::ULong i0 = 0; i0 < 6; ++i0) {
    dst[i0] = src[i0];
  }
}

}

/* End TYPEDEF: ArrayOfSeqOfString */


/* Begin TYPEDEF: ArrayOfSeqOfChar */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::ArrayOfSeqOfChar_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  for (CORBA::ULong i0 = 0; i0 < 6; ++i0) {
    gen_find_size(arr[i0], size, padding);
  }
}

bool operator<<(Serializer& strm, const Xyz::ArrayOfSeqOfChar_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 6; ++i0) {
    if (!(strm << arr[i0])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::ArrayOfSeqOfChar_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 6; ++i0) {
    if (!(strm >> arr[i0])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::ArrayOfSeqOfChar_forany*)
{
  ACE_UNUSED_ARG(ser);
  for (ACE_CDR::ULong i = 0; i < 6; ++i) {
    gen_skip_over(ser, static_cast<Xyz::SeqOfChar*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
ArrayOfSeqOfChar_slice* ArrayOfSeqOfChar_alloc()
{
  void* const raw = ACE_Allocator::instance()->malloc(sizeof(ArrayOfSeqOfChar));
  ArrayOfSeqOfChar_slice* const slice = static_cast<ArrayOfSeqOfChar_slice*>(raw);
  ArrayOfSeqOfChar_init_i(slice);
  return slice;
}

void ArrayOfSeqOfChar_init_i(Xyz::SeqOfChar* begin)
{
  std::uninitialized_fill_n(begin, 6, Xyz::SeqOfChar());
}

void ArrayOfSeqOfChar_fini_i(Xyz::SeqOfChar* begin)
{
  for (int i = 0; i < 6; ++i) {
    begin[i].~SeqOfChar();
  }
}

void ArrayOfSeqOfChar_free(ArrayOfSeqOfChar_slice* slice)
{
  if (!slice) return;
  ArrayOfSeqOfChar_fini_i(slice);
  ACE_Allocator::instance()->free(slice);
}

ArrayOfSeqOfChar_slice* ArrayOfSeqOfChar_dup(const ArrayOfSeqOfChar_slice* slice)
{
  ArrayOfSeqOfChar_slice* const arr = ArrayOfSeqOfChar_alloc();
  if (arr) ArrayOfSeqOfChar_copy(arr, slice);
  return arr;
}

void ArrayOfSeqOfChar_copy(ArrayOfSeqOfChar_slice* dst, const ArrayOfSeqOfChar_slice* src)
{
  if (!src || !dst) return;
  for (ACE_CDR::ULong i0 = 0; i0 < 6; ++i0) {
    dst[i0] = src[i0];
  }
}

}

/* End TYPEDEF: ArrayOfSeqOfChar */


/* Begin TYPEDEF: ArrayOfSeqOfOctet */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::ArrayOfSeqOfOctet_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  for (CORBA::ULong i0 = 0; i0 < 6; ++i0) {
    gen_find_size(arr[i0], size, padding);
  }
}

bool operator<<(Serializer& strm, const Xyz::ArrayOfSeqOfOctet_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 6; ++i0) {
    if (!(strm << arr[i0])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::ArrayOfSeqOfOctet_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 6; ++i0) {
    if (!(strm >> arr[i0])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::ArrayOfSeqOfOctet_forany*)
{
  ACE_UNUSED_ARG(ser);
  for (ACE_CDR::ULong i = 0; i < 6; ++i) {
    gen_skip_over(ser, static_cast<Xyz::SeqOfOctet*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
ArrayOfSeqOfOctet_slice* ArrayOfSeqOfOctet_alloc()
{
  void* const raw = ACE_Allocator::instance()->malloc(sizeof(ArrayOfSeqOfOctet));
  ArrayOfSeqOfOctet_slice* const slice = static_cast<ArrayOfSeqOfOctet_slice*>(raw);
  ArrayOfSeqOfOctet_init_i(slice);
  return slice;
}

void ArrayOfSeqOfOctet_init_i(Xyz::SeqOfOctet* begin)
{
  std::uninitialized_fill_n(begin, 6, Xyz::SeqOfOctet());
}

void ArrayOfSeqOfOctet_fini_i(Xyz::SeqOfOctet* begin)
{
  for (int i = 0; i < 6; ++i) {
    begin[i].~SeqOfOctet();
  }
}

void ArrayOfSeqOfOctet_free(ArrayOfSeqOfOctet_slice* slice)
{
  if (!slice) return;
  ArrayOfSeqOfOctet_fini_i(slice);
  ACE_Allocator::instance()->free(slice);
}

ArrayOfSeqOfOctet_slice* ArrayOfSeqOfOctet_dup(const ArrayOfSeqOfOctet_slice* slice)
{
  ArrayOfSeqOfOctet_slice* const arr = ArrayOfSeqOfOctet_alloc();
  if (arr) ArrayOfSeqOfOctet_copy(arr, slice);
  return arr;
}

void ArrayOfSeqOfOctet_copy(ArrayOfSeqOfOctet_slice* dst, const ArrayOfSeqOfOctet_slice* src)
{
  if (!src || !dst) return;
  for (ACE_CDR::ULong i0 = 0; i0 < 6; ++i0) {
    dst[i0] = src[i0];
  }
}

}

/* End TYPEDEF: ArrayOfSeqOfOctet */


/* Begin TYPEDEF: ArrayOfSeqOfLong */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::ArrayOfSeqOfLong_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  for (CORBA::ULong i0 = 0; i0 < 6; ++i0) {
    gen_find_size(arr[i0], size, padding);
  }
}

bool operator<<(Serializer& strm, const Xyz::ArrayOfSeqOfLong_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 6; ++i0) {
    if (!(strm << arr[i0])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::ArrayOfSeqOfLong_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 6; ++i0) {
    if (!(strm >> arr[i0])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::ArrayOfSeqOfLong_forany*)
{
  ACE_UNUSED_ARG(ser);
  for (ACE_CDR::ULong i = 0; i < 6; ++i) {
    gen_skip_over(ser, static_cast<Xyz::SeqOfLong*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
ArrayOfSeqOfLong_slice* ArrayOfSeqOfLong_alloc()
{
  void* const raw = ACE_Allocator::instance()->malloc(sizeof(ArrayOfSeqOfLong));
  ArrayOfSeqOfLong_slice* const slice = static_cast<ArrayOfSeqOfLong_slice*>(raw);
  ArrayOfSeqOfLong_init_i(slice);
  return slice;
}

void ArrayOfSeqOfLong_init_i(Xyz::SeqOfLong* begin)
{
  std::uninitialized_fill_n(begin, 6, Xyz::SeqOfLong());
}

void ArrayOfSeqOfLong_fini_i(Xyz::SeqOfLong* begin)
{
  for (int i = 0; i < 6; ++i) {
    begin[i].~SeqOfLong();
  }
}

void ArrayOfSeqOfLong_free(ArrayOfSeqOfLong_slice* slice)
{
  if (!slice) return;
  ArrayOfSeqOfLong_fini_i(slice);
  ACE_Allocator::instance()->free(slice);
}

ArrayOfSeqOfLong_slice* ArrayOfSeqOfLong_dup(const ArrayOfSeqOfLong_slice* slice)
{
  ArrayOfSeqOfLong_slice* const arr = ArrayOfSeqOfLong_alloc();
  if (arr) ArrayOfSeqOfLong_copy(arr, slice);
  return arr;
}

void ArrayOfSeqOfLong_copy(ArrayOfSeqOfLong_slice* dst, const ArrayOfSeqOfLong_slice* src)
{
  if (!src || !dst) return;
  for (ACE_CDR::ULong i0 = 0; i0 < 6; ++i0) {
    dst[i0] = src[i0];
  }
}

}

/* End TYPEDEF: ArrayOfSeqOfLong */


/* Begin TYPEDEF: ArrayOfSeqOfAnEnum */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Xyz::ArrayOfSeqOfAnEnum_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  for (CORBA::ULong i0 = 0; i0 < 6; ++i0) {
    gen_find_size(arr[i0], size, padding);
  }
}

bool operator<<(Serializer& strm, const Xyz::ArrayOfSeqOfAnEnum_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 6; ++i0) {
    if (!(strm << arr[i0])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Xyz::ArrayOfSeqOfAnEnum_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 6; ++i0) {
    if (!(strm >> arr[i0])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, Xyz::ArrayOfSeqOfAnEnum_forany*)
{
  ACE_UNUSED_ARG(ser);
  for (ACE_CDR::ULong i = 0; i < 6; ++i) {
    gen_skip_over(ser, static_cast<Xyz::SeqOfAnEnum*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
namespace Xyz {
ArrayOfSeqOfAnEnum_slice* ArrayOfSeqOfAnEnum_alloc()
{
  void* const raw = ACE_Allocator::instance()->malloc(sizeof(ArrayOfSeqOfAnEnum));
  ArrayOfSeqOfAnEnum_slice* const slice = static_cast<ArrayOfSeqOfAnEnum_slice*>(raw);
  ArrayOfSeqOfAnEnum_init_i(slice);
  return slice;
}

void ArrayOfSeqOfAnEnum_init_i(Xyz::SeqOfAnEnum* begin)
{
  std::uninitialized_fill_n(begin, 6, Xyz::SeqOfAnEnum());
}

void ArrayOfSeqOfAnEnum_fini_i(Xyz::SeqOfAnEnum* begin)
{
  for (int i = 0; i < 6; ++i) {
    begin[i].~SeqOfAnEnum();
  }
}

void ArrayOfSeqOfAnEnum_free(ArrayOfSeqOfAnEnum_slice* slice)
{
  if (!slice) return;
  ArrayOfSeqOfAnEnum_fini_i(slice);
  ACE_Allocator::instance()->free(slice);
}

ArrayOfSeqOfAnEnum_slice* ArrayOfSeqOfAnEnum_dup(const ArrayOfSeqOfAnEnum_slice* slice)
{
  ArrayOfSeqOfAnEnum_slice* const arr = ArrayOfSeqOfAnEnum_alloc();
  if (arr) ArrayOfSeqOfAnEnum_copy(arr, slice);
  return arr;
}

void ArrayOfSeqOfAnEnum_copy(ArrayOfSeqOfAnEnum_slice* dst, const ArrayOfSeqOfAnEnum_slice* src)
{
  if (!src || !dst) return;
  for (ACE_CDR::ULong i0 = 0; i0 < 6; ++i0) {
    dst[i0] = src[i0];
  }
}

}

/* End TYPEDEF: ArrayOfSeqOfAnEnum */

/* End MODULE: Xyz */
