/* -*- C++ -*- */
/* Generated by /Users/yc/MyGithub/imac-project/OpenDDS/OpenDDS-3.10/bin/opendds_idl version 3.10 (ACE version 6.2a_p11) running on input file ../../../DCPS/Compiler/idl_test3_lib/FooDef.idl */
#ifndef OPENDDS_IDL_GENERATED_FOODEFC_H_GEY2XC
#define OPENDDS_IDL_GENERATED_FOODEFC_H_GEY2XC
#include <tao/orbconf.h>
#include <tao/Basic_Types.h>
#include <ace/CDR_Stream.h>
#include <tao/Array_VarOut_T.h>
#include <tao/Seq_Out_T.h>
#include <tao/VarOut_T.h>
#include "FACE/Sequence.h"
#include "FACE/SequenceVar.h"
#include "FACE/StringManager.h"
#include "FACE/types.hpp"
#include "dds/DCPS/SafetyProfilePool.h"
#include "SharedTypesC.h"
#include "foolib_export.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: Xyz */



/* Begin ENUM: AnEnum */


/* End ENUM: AnEnum */


/* Begin TYPEDEF: SeqOfBoolean */


/* End TYPEDEF: SeqOfBoolean */


/* Begin TYPEDEF: SeqOfString */


/* End TYPEDEF: SeqOfString */


/* Begin TYPEDEF: SeqOfChar */


/* End TYPEDEF: SeqOfChar */


/* Begin TYPEDEF: SeqOfOctet */


/* End TYPEDEF: SeqOfOctet */


/* Begin TYPEDEF: SeqOfLong */


/* End TYPEDEF: SeqOfLong */


/* Begin TYPEDEF: SeqOfAnEnum */


/* End TYPEDEF: SeqOfAnEnum */


/* Begin TYPEDEF: ArrayOfBoolean */


/* End TYPEDEF: ArrayOfBoolean */


/* Begin TYPEDEF: ArrayOfString */


/* End TYPEDEF: ArrayOfString */


/* Begin TYPEDEF: ArrayOfChar */


/* End TYPEDEF: ArrayOfChar */


/* Begin TYPEDEF: ArrayOfOctet */


/* End TYPEDEF: ArrayOfOctet */


/* Begin TYPEDEF: ArrayOfLong */


/* End TYPEDEF: ArrayOfLong */


/* Begin TYPEDEF: ArrayOfAnEnum */


/* End TYPEDEF: ArrayOfAnEnum */


/* Begin TYPEDEF: ArrayOfSeqOfBoolean */


/* End TYPEDEF: ArrayOfSeqOfBoolean */


/* Begin TYPEDEF: ArrayOfSeqOfString */


/* End TYPEDEF: ArrayOfSeqOfString */


/* Begin TYPEDEF: ArrayOfSeqOfChar */


/* End TYPEDEF: ArrayOfSeqOfChar */


/* Begin TYPEDEF: ArrayOfSeqOfOctet */


/* End TYPEDEF: ArrayOfSeqOfOctet */


/* Begin TYPEDEF: ArrayOfSeqOfLong */


/* End TYPEDEF: ArrayOfSeqOfLong */


/* Begin TYPEDEF: ArrayOfSeqOfAnEnum */


/* End TYPEDEF: ArrayOfSeqOfAnEnum */

/* End MODULE: Xyz */


/* Begin MODULE: Xyz */



/* Begin TYPEDEF: SeqOfArrayOfBoolean */

namespace Xyz {
class SeqOfArrayOfBoolean;
typedef ::OpenDDS::FaceTypes::SequenceVar<SeqOfArrayOfBoolean> SeqOfArrayOfBoolean_var;
typedef ::TAO_Seq_Out_T<SeqOfArrayOfBoolean> SeqOfArrayOfBoolean_out;

class FooLib_Export SeqOfArrayOfBoolean : public ::OpenDDS::FaceTypes::Sequence< Xyz::ArrayOfBoolean, ::OpenDDS::FaceTypes::Bounded<8>, ::OpenDDS::FaceTypes::ArrayEltPolicy<Xyz::ArrayOfBoolean_forany> > {
public:
  typedef SeqOfArrayOfBoolean_var _var_type;
  typedef SeqOfArrayOfBoolean_out _out_type;

  SeqOfArrayOfBoolean() {}
  SeqOfArrayOfBoolean(const SeqOfArrayOfBoolean& seq) : ::OpenDDS::FaceTypes::Sequence< Xyz::ArrayOfBoolean, ::OpenDDS::FaceTypes::Bounded<8>, ::OpenDDS::FaceTypes::ArrayEltPolicy<Xyz::ArrayOfBoolean_forany> >(seq) {}
  friend void swap(SeqOfArrayOfBoolean& a, SeqOfArrayOfBoolean& b) { a.swap(b); }
  SeqOfArrayOfBoolean& operator=(const SeqOfArrayOfBoolean& rhs)
  {
    SeqOfArrayOfBoolean tmp(rhs);
    swap(tmp);
    return *this;
  }
  SeqOfArrayOfBoolean(::FACE::UnsignedLong length, Xyz::ArrayOfBoolean* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< Xyz::ArrayOfBoolean, ::OpenDDS::FaceTypes::Bounded<8>, ::OpenDDS::FaceTypes::ArrayEltPolicy<Xyz::ArrayOfBoolean_forany> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const SeqOfArrayOfBoolean&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, SeqOfArrayOfBoolean&) { return true; }

}

/* End TYPEDEF: SeqOfArrayOfBoolean */


/* Begin TYPEDEF: SeqOfArrayOfString */

namespace Xyz {
class SeqOfArrayOfString;
typedef ::OpenDDS::FaceTypes::SequenceVar<SeqOfArrayOfString> SeqOfArrayOfString_var;
typedef ::TAO_Seq_Out_T<SeqOfArrayOfString> SeqOfArrayOfString_out;

class FooLib_Export SeqOfArrayOfString : public ::OpenDDS::FaceTypes::Sequence< Xyz::ArrayOfString, ::OpenDDS::FaceTypes::Bounded<8>, ::OpenDDS::FaceTypes::ArrayEltPolicy<Xyz::ArrayOfString_forany> > {
public:
  typedef SeqOfArrayOfString_var _var_type;
  typedef SeqOfArrayOfString_out _out_type;

  SeqOfArrayOfString() {}
  SeqOfArrayOfString(const SeqOfArrayOfString& seq) : ::OpenDDS::FaceTypes::Sequence< Xyz::ArrayOfString, ::OpenDDS::FaceTypes::Bounded<8>, ::OpenDDS::FaceTypes::ArrayEltPolicy<Xyz::ArrayOfString_forany> >(seq) {}
  friend void swap(SeqOfArrayOfString& a, SeqOfArrayOfString& b) { a.swap(b); }
  SeqOfArrayOfString& operator=(const SeqOfArrayOfString& rhs)
  {
    SeqOfArrayOfString tmp(rhs);
    swap(tmp);
    return *this;
  }
  SeqOfArrayOfString(::FACE::UnsignedLong length, Xyz::ArrayOfString* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< Xyz::ArrayOfString, ::OpenDDS::FaceTypes::Bounded<8>, ::OpenDDS::FaceTypes::ArrayEltPolicy<Xyz::ArrayOfString_forany> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const SeqOfArrayOfString&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, SeqOfArrayOfString&) { return true; }

}

/* End TYPEDEF: SeqOfArrayOfString */


/* Begin TYPEDEF: SeqOfArrayOfChar */

namespace Xyz {
class SeqOfArrayOfChar;
typedef ::OpenDDS::FaceTypes::SequenceVar<SeqOfArrayOfChar> SeqOfArrayOfChar_var;
typedef ::TAO_Seq_Out_T<SeqOfArrayOfChar> SeqOfArrayOfChar_out;

class FooLib_Export SeqOfArrayOfChar : public ::OpenDDS::FaceTypes::Sequence< Xyz::ArrayOfChar, ::OpenDDS::FaceTypes::Bounded<8>, ::OpenDDS::FaceTypes::ArrayEltPolicy<Xyz::ArrayOfChar_forany> > {
public:
  typedef SeqOfArrayOfChar_var _var_type;
  typedef SeqOfArrayOfChar_out _out_type;

  SeqOfArrayOfChar() {}
  SeqOfArrayOfChar(const SeqOfArrayOfChar& seq) : ::OpenDDS::FaceTypes::Sequence< Xyz::ArrayOfChar, ::OpenDDS::FaceTypes::Bounded<8>, ::OpenDDS::FaceTypes::ArrayEltPolicy<Xyz::ArrayOfChar_forany> >(seq) {}
  friend void swap(SeqOfArrayOfChar& a, SeqOfArrayOfChar& b) { a.swap(b); }
  SeqOfArrayOfChar& operator=(const SeqOfArrayOfChar& rhs)
  {
    SeqOfArrayOfChar tmp(rhs);
    swap(tmp);
    return *this;
  }
  SeqOfArrayOfChar(::FACE::UnsignedLong length, Xyz::ArrayOfChar* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< Xyz::ArrayOfChar, ::OpenDDS::FaceTypes::Bounded<8>, ::OpenDDS::FaceTypes::ArrayEltPolicy<Xyz::ArrayOfChar_forany> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const SeqOfArrayOfChar&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, SeqOfArrayOfChar&) { return true; }

}

/* End TYPEDEF: SeqOfArrayOfChar */


/* Begin TYPEDEF: SeqOfArrayOfOctet */

namespace Xyz {
class SeqOfArrayOfOctet;
typedef ::OpenDDS::FaceTypes::SequenceVar<SeqOfArrayOfOctet> SeqOfArrayOfOctet_var;
typedef ::TAO_Seq_Out_T<SeqOfArrayOfOctet> SeqOfArrayOfOctet_out;

class FooLib_Export SeqOfArrayOfOctet : public ::OpenDDS::FaceTypes::Sequence< Xyz::ArrayOfOctet, ::OpenDDS::FaceTypes::Bounded<8>, ::OpenDDS::FaceTypes::ArrayEltPolicy<Xyz::ArrayOfOctet_forany> > {
public:
  typedef SeqOfArrayOfOctet_var _var_type;
  typedef SeqOfArrayOfOctet_out _out_type;

  SeqOfArrayOfOctet() {}
  SeqOfArrayOfOctet(const SeqOfArrayOfOctet& seq) : ::OpenDDS::FaceTypes::Sequence< Xyz::ArrayOfOctet, ::OpenDDS::FaceTypes::Bounded<8>, ::OpenDDS::FaceTypes::ArrayEltPolicy<Xyz::ArrayOfOctet_forany> >(seq) {}
  friend void swap(SeqOfArrayOfOctet& a, SeqOfArrayOfOctet& b) { a.swap(b); }
  SeqOfArrayOfOctet& operator=(const SeqOfArrayOfOctet& rhs)
  {
    SeqOfArrayOfOctet tmp(rhs);
    swap(tmp);
    return *this;
  }
  SeqOfArrayOfOctet(::FACE::UnsignedLong length, Xyz::ArrayOfOctet* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< Xyz::ArrayOfOctet, ::OpenDDS::FaceTypes::Bounded<8>, ::OpenDDS::FaceTypes::ArrayEltPolicy<Xyz::ArrayOfOctet_forany> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const SeqOfArrayOfOctet&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, SeqOfArrayOfOctet&) { return true; }

}

/* End TYPEDEF: SeqOfArrayOfOctet */


/* Begin TYPEDEF: SeqOfArrayOfLong */

namespace Xyz {
class SeqOfArrayOfLong;
typedef ::OpenDDS::FaceTypes::SequenceVar<SeqOfArrayOfLong> SeqOfArrayOfLong_var;
typedef ::TAO_Seq_Out_T<SeqOfArrayOfLong> SeqOfArrayOfLong_out;

class FooLib_Export SeqOfArrayOfLong : public ::OpenDDS::FaceTypes::Sequence< Xyz::ArrayOfLong, ::OpenDDS::FaceTypes::Bounded<8>, ::OpenDDS::FaceTypes::ArrayEltPolicy<Xyz::ArrayOfLong_forany> > {
public:
  typedef SeqOfArrayOfLong_var _var_type;
  typedef SeqOfArrayOfLong_out _out_type;

  SeqOfArrayOfLong() {}
  SeqOfArrayOfLong(const SeqOfArrayOfLong& seq) : ::OpenDDS::FaceTypes::Sequence< Xyz::ArrayOfLong, ::OpenDDS::FaceTypes::Bounded<8>, ::OpenDDS::FaceTypes::ArrayEltPolicy<Xyz::ArrayOfLong_forany> >(seq) {}
  friend void swap(SeqOfArrayOfLong& a, SeqOfArrayOfLong& b) { a.swap(b); }
  SeqOfArrayOfLong& operator=(const SeqOfArrayOfLong& rhs)
  {
    SeqOfArrayOfLong tmp(rhs);
    swap(tmp);
    return *this;
  }
  SeqOfArrayOfLong(::FACE::UnsignedLong length, Xyz::ArrayOfLong* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< Xyz::ArrayOfLong, ::OpenDDS::FaceTypes::Bounded<8>, ::OpenDDS::FaceTypes::ArrayEltPolicy<Xyz::ArrayOfLong_forany> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const SeqOfArrayOfLong&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, SeqOfArrayOfLong&) { return true; }

}

/* End TYPEDEF: SeqOfArrayOfLong */


/* Begin TYPEDEF: SeqOfArrayOfAnEnum */

namespace Xyz {
class SeqOfArrayOfAnEnum;
typedef ::OpenDDS::FaceTypes::SequenceVar<SeqOfArrayOfAnEnum> SeqOfArrayOfAnEnum_var;
typedef ::TAO_Seq_Out_T<SeqOfArrayOfAnEnum> SeqOfArrayOfAnEnum_out;

class FooLib_Export SeqOfArrayOfAnEnum : public ::OpenDDS::FaceTypes::Sequence< Xyz::ArrayOfAnEnum, ::OpenDDS::FaceTypes::Bounded<8>, ::OpenDDS::FaceTypes::ArrayEltPolicy<Xyz::ArrayOfAnEnum_forany> > {
public:
  typedef SeqOfArrayOfAnEnum_var _var_type;
  typedef SeqOfArrayOfAnEnum_out _out_type;

  SeqOfArrayOfAnEnum() {}
  SeqOfArrayOfAnEnum(const SeqOfArrayOfAnEnum& seq) : ::OpenDDS::FaceTypes::Sequence< Xyz::ArrayOfAnEnum, ::OpenDDS::FaceTypes::Bounded<8>, ::OpenDDS::FaceTypes::ArrayEltPolicy<Xyz::ArrayOfAnEnum_forany> >(seq) {}
  friend void swap(SeqOfArrayOfAnEnum& a, SeqOfArrayOfAnEnum& b) { a.swap(b); }
  SeqOfArrayOfAnEnum& operator=(const SeqOfArrayOfAnEnum& rhs)
  {
    SeqOfArrayOfAnEnum tmp(rhs);
    swap(tmp);
    return *this;
  }
  SeqOfArrayOfAnEnum(::FACE::UnsignedLong length, Xyz::ArrayOfAnEnum* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< Xyz::ArrayOfAnEnum, ::OpenDDS::FaceTypes::Bounded<8>, ::OpenDDS::FaceTypes::ArrayEltPolicy<Xyz::ArrayOfAnEnum_forany> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const SeqOfArrayOfAnEnum&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, SeqOfArrayOfAnEnum&) { return true; }

}

/* End TYPEDEF: SeqOfArrayOfAnEnum */


/* Begin TYPEDEF: ArrayOfArrayOfBoolean */

namespace Xyz {
typedef Xyz::ArrayOfBoolean ArrayOfArrayOfBoolean[7];
typedef Xyz::ArrayOfBoolean ArrayOfArrayOfBoolean_slice;
struct ArrayOfArrayOfBoolean_tag {};
typedef ::TAO_FixedArray_Var_T<ArrayOfArrayOfBoolean, ArrayOfArrayOfBoolean_slice, ArrayOfArrayOfBoolean_tag> ArrayOfArrayOfBoolean_var;
typedef ArrayOfArrayOfBoolean ArrayOfArrayOfBoolean_out;
typedef ::TAO_Array_Forany_T<ArrayOfArrayOfBoolean, ArrayOfArrayOfBoolean_slice, ArrayOfArrayOfBoolean_tag> ArrayOfArrayOfBoolean_forany;

FooLib_Export ArrayOfArrayOfBoolean_slice* ArrayOfArrayOfBoolean_alloc();
FooLib_Export void ArrayOfArrayOfBoolean_init_i(Xyz::ArrayOfBoolean* begin);
FooLib_Export void ArrayOfArrayOfBoolean_fini_i(Xyz::ArrayOfBoolean* begin);
FooLib_Export void ArrayOfArrayOfBoolean_free(ArrayOfArrayOfBoolean_slice* slice);
FooLib_Export ArrayOfArrayOfBoolean_slice* ArrayOfArrayOfBoolean_dup(const ArrayOfArrayOfBoolean_slice* slice);
FooLib_Export void ArrayOfArrayOfBoolean_copy(ArrayOfArrayOfBoolean_slice* dst, const ArrayOfArrayOfBoolean_slice* src);

inline ACE_CDR::Boolean operator<<(ACE_OutputCDR &, const ArrayOfArrayOfBoolean_forany&) { return true; }

inline ACE_CDR::Boolean operator>>(ACE_InputCDR &, ArrayOfArrayOfBoolean_forany&) { return true; }

}
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace TAO {
template <>
struct FooLib_Export Array_Traits<Xyz::ArrayOfArrayOfBoolean_forany>
{
  static void free(Xyz::ArrayOfArrayOfBoolean_slice* slice)
  {
    Xyz::ArrayOfArrayOfBoolean_free(slice);
  }

  static Xyz::ArrayOfArrayOfBoolean_slice* dup(const Xyz::ArrayOfArrayOfBoolean_slice* slice)
  {
    return Xyz::ArrayOfArrayOfBoolean_dup(slice);
  }

  static void copy(Xyz::ArrayOfArrayOfBoolean_slice* dst, const Xyz::ArrayOfArrayOfBoolean_slice* src)
  {
    Xyz::ArrayOfArrayOfBoolean_copy(dst, src);
  }

  static Xyz::ArrayOfArrayOfBoolean_slice* alloc()
  {
    return Xyz::ArrayOfArrayOfBoolean_alloc();
  }

  static void zero(Xyz::ArrayOfArrayOfBoolean_slice* slice)
  {
    Xyz::ArrayOfArrayOfBoolean_fini_i(slice);
    Xyz::ArrayOfArrayOfBoolean_init_i(slice);
  }
  static void construct(Xyz::ArrayOfArrayOfBoolean_slice* slice)
  {
    Xyz::ArrayOfArrayOfBoolean_init_i(slice);
  }
  static void destroy(Xyz::ArrayOfArrayOfBoolean_slice* slice)
  {
    Xyz::ArrayOfArrayOfBoolean_fini_i(slice);
  }
};
}
TAO_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ArrayOfArrayOfBoolean */


/* Begin TYPEDEF: ArrayOfArrayOfString */

namespace Xyz {
typedef Xyz::ArrayOfString ArrayOfArrayOfString[7];
typedef Xyz::ArrayOfString ArrayOfArrayOfString_slice;
struct ArrayOfArrayOfString_tag {};
typedef ::TAO_VarArray_Var_T<ArrayOfArrayOfString, ArrayOfArrayOfString_slice, ArrayOfArrayOfString_tag> ArrayOfArrayOfString_var;
typedef ::TAO_Array_Out_T<ArrayOfArrayOfString, ArrayOfArrayOfString_var, ArrayOfArrayOfString_slice, ArrayOfArrayOfString_tag> ArrayOfArrayOfString_out;
typedef ::TAO_Array_Forany_T<ArrayOfArrayOfString, ArrayOfArrayOfString_slice, ArrayOfArrayOfString_tag> ArrayOfArrayOfString_forany;

FooLib_Export ArrayOfArrayOfString_slice* ArrayOfArrayOfString_alloc();
FooLib_Export void ArrayOfArrayOfString_init_i(Xyz::ArrayOfString* begin);
FooLib_Export void ArrayOfArrayOfString_fini_i(Xyz::ArrayOfString* begin);
FooLib_Export void ArrayOfArrayOfString_free(ArrayOfArrayOfString_slice* slice);
FooLib_Export ArrayOfArrayOfString_slice* ArrayOfArrayOfString_dup(const ArrayOfArrayOfString_slice* slice);
FooLib_Export void ArrayOfArrayOfString_copy(ArrayOfArrayOfString_slice* dst, const ArrayOfArrayOfString_slice* src);

inline ACE_CDR::Boolean operator<<(ACE_OutputCDR &, const ArrayOfArrayOfString_forany&) { return true; }

inline ACE_CDR::Boolean operator>>(ACE_InputCDR &, ArrayOfArrayOfString_forany&) { return true; }

}
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace TAO {
template <>
struct FooLib_Export Array_Traits<Xyz::ArrayOfArrayOfString_forany>
{
  static void free(Xyz::ArrayOfArrayOfString_slice* slice)
  {
    Xyz::ArrayOfArrayOfString_free(slice);
  }

  static Xyz::ArrayOfArrayOfString_slice* dup(const Xyz::ArrayOfArrayOfString_slice* slice)
  {
    return Xyz::ArrayOfArrayOfString_dup(slice);
  }

  static void copy(Xyz::ArrayOfArrayOfString_slice* dst, const Xyz::ArrayOfArrayOfString_slice* src)
  {
    Xyz::ArrayOfArrayOfString_copy(dst, src);
  }

  static Xyz::ArrayOfArrayOfString_slice* alloc()
  {
    return Xyz::ArrayOfArrayOfString_alloc();
  }

  static void zero(Xyz::ArrayOfArrayOfString_slice* slice)
  {
    Xyz::ArrayOfArrayOfString_fini_i(slice);
    Xyz::ArrayOfArrayOfString_init_i(slice);
  }
  static void construct(Xyz::ArrayOfArrayOfString_slice* slice)
  {
    Xyz::ArrayOfArrayOfString_init_i(slice);
  }
  static void destroy(Xyz::ArrayOfArrayOfString_slice* slice)
  {
    Xyz::ArrayOfArrayOfString_fini_i(slice);
  }
};
}
TAO_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ArrayOfArrayOfString */


/* Begin TYPEDEF: ArrayOfArrayOfChar */

namespace Xyz {
typedef Xyz::ArrayOfChar ArrayOfArrayOfChar[7];
typedef Xyz::ArrayOfChar ArrayOfArrayOfChar_slice;
struct ArrayOfArrayOfChar_tag {};
typedef ::TAO_FixedArray_Var_T<ArrayOfArrayOfChar, ArrayOfArrayOfChar_slice, ArrayOfArrayOfChar_tag> ArrayOfArrayOfChar_var;
typedef ArrayOfArrayOfChar ArrayOfArrayOfChar_out;
typedef ::TAO_Array_Forany_T<ArrayOfArrayOfChar, ArrayOfArrayOfChar_slice, ArrayOfArrayOfChar_tag> ArrayOfArrayOfChar_forany;

FooLib_Export ArrayOfArrayOfChar_slice* ArrayOfArrayOfChar_alloc();
FooLib_Export void ArrayOfArrayOfChar_init_i(Xyz::ArrayOfChar* begin);
FooLib_Export void ArrayOfArrayOfChar_fini_i(Xyz::ArrayOfChar* begin);
FooLib_Export void ArrayOfArrayOfChar_free(ArrayOfArrayOfChar_slice* slice);
FooLib_Export ArrayOfArrayOfChar_slice* ArrayOfArrayOfChar_dup(const ArrayOfArrayOfChar_slice* slice);
FooLib_Export void ArrayOfArrayOfChar_copy(ArrayOfArrayOfChar_slice* dst, const ArrayOfArrayOfChar_slice* src);

inline ACE_CDR::Boolean operator<<(ACE_OutputCDR &, const ArrayOfArrayOfChar_forany&) { return true; }

inline ACE_CDR::Boolean operator>>(ACE_InputCDR &, ArrayOfArrayOfChar_forany&) { return true; }

}
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace TAO {
template <>
struct FooLib_Export Array_Traits<Xyz::ArrayOfArrayOfChar_forany>
{
  static void free(Xyz::ArrayOfArrayOfChar_slice* slice)
  {
    Xyz::ArrayOfArrayOfChar_free(slice);
  }

  static Xyz::ArrayOfArrayOfChar_slice* dup(const Xyz::ArrayOfArrayOfChar_slice* slice)
  {
    return Xyz::ArrayOfArrayOfChar_dup(slice);
  }

  static void copy(Xyz::ArrayOfArrayOfChar_slice* dst, const Xyz::ArrayOfArrayOfChar_slice* src)
  {
    Xyz::ArrayOfArrayOfChar_copy(dst, src);
  }

  static Xyz::ArrayOfArrayOfChar_slice* alloc()
  {
    return Xyz::ArrayOfArrayOfChar_alloc();
  }

  static void zero(Xyz::ArrayOfArrayOfChar_slice* slice)
  {
    Xyz::ArrayOfArrayOfChar_fini_i(slice);
    Xyz::ArrayOfArrayOfChar_init_i(slice);
  }
  static void construct(Xyz::ArrayOfArrayOfChar_slice* slice)
  {
    Xyz::ArrayOfArrayOfChar_init_i(slice);
  }
  static void destroy(Xyz::ArrayOfArrayOfChar_slice* slice)
  {
    Xyz::ArrayOfArrayOfChar_fini_i(slice);
  }
};
}
TAO_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ArrayOfArrayOfChar */


/* Begin TYPEDEF: ArrayOfArrayOfOctet */

namespace Xyz {
typedef Xyz::ArrayOfOctet ArrayOfArrayOfOctet[7];
typedef Xyz::ArrayOfOctet ArrayOfArrayOfOctet_slice;
struct ArrayOfArrayOfOctet_tag {};
typedef ::TAO_FixedArray_Var_T<ArrayOfArrayOfOctet, ArrayOfArrayOfOctet_slice, ArrayOfArrayOfOctet_tag> ArrayOfArrayOfOctet_var;
typedef ArrayOfArrayOfOctet ArrayOfArrayOfOctet_out;
typedef ::TAO_Array_Forany_T<ArrayOfArrayOfOctet, ArrayOfArrayOfOctet_slice, ArrayOfArrayOfOctet_tag> ArrayOfArrayOfOctet_forany;

FooLib_Export ArrayOfArrayOfOctet_slice* ArrayOfArrayOfOctet_alloc();
FooLib_Export void ArrayOfArrayOfOctet_init_i(Xyz::ArrayOfOctet* begin);
FooLib_Export void ArrayOfArrayOfOctet_fini_i(Xyz::ArrayOfOctet* begin);
FooLib_Export void ArrayOfArrayOfOctet_free(ArrayOfArrayOfOctet_slice* slice);
FooLib_Export ArrayOfArrayOfOctet_slice* ArrayOfArrayOfOctet_dup(const ArrayOfArrayOfOctet_slice* slice);
FooLib_Export void ArrayOfArrayOfOctet_copy(ArrayOfArrayOfOctet_slice* dst, const ArrayOfArrayOfOctet_slice* src);

inline ACE_CDR::Boolean operator<<(ACE_OutputCDR &, const ArrayOfArrayOfOctet_forany&) { return true; }

inline ACE_CDR::Boolean operator>>(ACE_InputCDR &, ArrayOfArrayOfOctet_forany&) { return true; }

}
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace TAO {
template <>
struct FooLib_Export Array_Traits<Xyz::ArrayOfArrayOfOctet_forany>
{
  static void free(Xyz::ArrayOfArrayOfOctet_slice* slice)
  {
    Xyz::ArrayOfArrayOfOctet_free(slice);
  }

  static Xyz::ArrayOfArrayOfOctet_slice* dup(const Xyz::ArrayOfArrayOfOctet_slice* slice)
  {
    return Xyz::ArrayOfArrayOfOctet_dup(slice);
  }

  static void copy(Xyz::ArrayOfArrayOfOctet_slice* dst, const Xyz::ArrayOfArrayOfOctet_slice* src)
  {
    Xyz::ArrayOfArrayOfOctet_copy(dst, src);
  }

  static Xyz::ArrayOfArrayOfOctet_slice* alloc()
  {
    return Xyz::ArrayOfArrayOfOctet_alloc();
  }

  static void zero(Xyz::ArrayOfArrayOfOctet_slice* slice)
  {
    Xyz::ArrayOfArrayOfOctet_fini_i(slice);
    Xyz::ArrayOfArrayOfOctet_init_i(slice);
  }
  static void construct(Xyz::ArrayOfArrayOfOctet_slice* slice)
  {
    Xyz::ArrayOfArrayOfOctet_init_i(slice);
  }
  static void destroy(Xyz::ArrayOfArrayOfOctet_slice* slice)
  {
    Xyz::ArrayOfArrayOfOctet_fini_i(slice);
  }
};
}
TAO_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ArrayOfArrayOfOctet */


/* Begin TYPEDEF: ArrayOfArrayOfLong */

namespace Xyz {
typedef Xyz::ArrayOfLong ArrayOfArrayOfLong[7];
typedef Xyz::ArrayOfLong ArrayOfArrayOfLong_slice;
struct ArrayOfArrayOfLong_tag {};
typedef ::TAO_FixedArray_Var_T<ArrayOfArrayOfLong, ArrayOfArrayOfLong_slice, ArrayOfArrayOfLong_tag> ArrayOfArrayOfLong_var;
typedef ArrayOfArrayOfLong ArrayOfArrayOfLong_out;
typedef ::TAO_Array_Forany_T<ArrayOfArrayOfLong, ArrayOfArrayOfLong_slice, ArrayOfArrayOfLong_tag> ArrayOfArrayOfLong_forany;

FooLib_Export ArrayOfArrayOfLong_slice* ArrayOfArrayOfLong_alloc();
FooLib_Export void ArrayOfArrayOfLong_init_i(Xyz::ArrayOfLong* begin);
FooLib_Export void ArrayOfArrayOfLong_fini_i(Xyz::ArrayOfLong* begin);
FooLib_Export void ArrayOfArrayOfLong_free(ArrayOfArrayOfLong_slice* slice);
FooLib_Export ArrayOfArrayOfLong_slice* ArrayOfArrayOfLong_dup(const ArrayOfArrayOfLong_slice* slice);
FooLib_Export void ArrayOfArrayOfLong_copy(ArrayOfArrayOfLong_slice* dst, const ArrayOfArrayOfLong_slice* src);

inline ACE_CDR::Boolean operator<<(ACE_OutputCDR &, const ArrayOfArrayOfLong_forany&) { return true; }

inline ACE_CDR::Boolean operator>>(ACE_InputCDR &, ArrayOfArrayOfLong_forany&) { return true; }

}
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace TAO {
template <>
struct FooLib_Export Array_Traits<Xyz::ArrayOfArrayOfLong_forany>
{
  static void free(Xyz::ArrayOfArrayOfLong_slice* slice)
  {
    Xyz::ArrayOfArrayOfLong_free(slice);
  }

  static Xyz::ArrayOfArrayOfLong_slice* dup(const Xyz::ArrayOfArrayOfLong_slice* slice)
  {
    return Xyz::ArrayOfArrayOfLong_dup(slice);
  }

  static void copy(Xyz::ArrayOfArrayOfLong_slice* dst, const Xyz::ArrayOfArrayOfLong_slice* src)
  {
    Xyz::ArrayOfArrayOfLong_copy(dst, src);
  }

  static Xyz::ArrayOfArrayOfLong_slice* alloc()
  {
    return Xyz::ArrayOfArrayOfLong_alloc();
  }

  static void zero(Xyz::ArrayOfArrayOfLong_slice* slice)
  {
    Xyz::ArrayOfArrayOfLong_fini_i(slice);
    Xyz::ArrayOfArrayOfLong_init_i(slice);
  }
  static void construct(Xyz::ArrayOfArrayOfLong_slice* slice)
  {
    Xyz::ArrayOfArrayOfLong_init_i(slice);
  }
  static void destroy(Xyz::ArrayOfArrayOfLong_slice* slice)
  {
    Xyz::ArrayOfArrayOfLong_fini_i(slice);
  }
};
}
TAO_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ArrayOfArrayOfLong */


/* Begin TYPEDEF: ArrayOfArrayOfAnEnum */

namespace Xyz {
typedef Xyz::ArrayOfAnEnum ArrayOfArrayOfAnEnum[7];
typedef Xyz::ArrayOfAnEnum ArrayOfArrayOfAnEnum_slice;
struct ArrayOfArrayOfAnEnum_tag {};
typedef ::TAO_FixedArray_Var_T<ArrayOfArrayOfAnEnum, ArrayOfArrayOfAnEnum_slice, ArrayOfArrayOfAnEnum_tag> ArrayOfArrayOfAnEnum_var;
typedef ArrayOfArrayOfAnEnum ArrayOfArrayOfAnEnum_out;
typedef ::TAO_Array_Forany_T<ArrayOfArrayOfAnEnum, ArrayOfArrayOfAnEnum_slice, ArrayOfArrayOfAnEnum_tag> ArrayOfArrayOfAnEnum_forany;

FooLib_Export ArrayOfArrayOfAnEnum_slice* ArrayOfArrayOfAnEnum_alloc();
FooLib_Export void ArrayOfArrayOfAnEnum_init_i(Xyz::ArrayOfAnEnum* begin);
FooLib_Export void ArrayOfArrayOfAnEnum_fini_i(Xyz::ArrayOfAnEnum* begin);
FooLib_Export void ArrayOfArrayOfAnEnum_free(ArrayOfArrayOfAnEnum_slice* slice);
FooLib_Export ArrayOfArrayOfAnEnum_slice* ArrayOfArrayOfAnEnum_dup(const ArrayOfArrayOfAnEnum_slice* slice);
FooLib_Export void ArrayOfArrayOfAnEnum_copy(ArrayOfArrayOfAnEnum_slice* dst, const ArrayOfArrayOfAnEnum_slice* src);

inline ACE_CDR::Boolean operator<<(ACE_OutputCDR &, const ArrayOfArrayOfAnEnum_forany&) { return true; }

inline ACE_CDR::Boolean operator>>(ACE_InputCDR &, ArrayOfArrayOfAnEnum_forany&) { return true; }

}
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace TAO {
template <>
struct FooLib_Export Array_Traits<Xyz::ArrayOfArrayOfAnEnum_forany>
{
  static void free(Xyz::ArrayOfArrayOfAnEnum_slice* slice)
  {
    Xyz::ArrayOfArrayOfAnEnum_free(slice);
  }

  static Xyz::ArrayOfArrayOfAnEnum_slice* dup(const Xyz::ArrayOfArrayOfAnEnum_slice* slice)
  {
    return Xyz::ArrayOfArrayOfAnEnum_dup(slice);
  }

  static void copy(Xyz::ArrayOfArrayOfAnEnum_slice* dst, const Xyz::ArrayOfArrayOfAnEnum_slice* src)
  {
    Xyz::ArrayOfArrayOfAnEnum_copy(dst, src);
  }

  static Xyz::ArrayOfArrayOfAnEnum_slice* alloc()
  {
    return Xyz::ArrayOfArrayOfAnEnum_alloc();
  }

  static void zero(Xyz::ArrayOfArrayOfAnEnum_slice* slice)
  {
    Xyz::ArrayOfArrayOfAnEnum_fini_i(slice);
    Xyz::ArrayOfArrayOfAnEnum_init_i(slice);
  }
  static void construct(Xyz::ArrayOfArrayOfAnEnum_slice* slice)
  {
    Xyz::ArrayOfArrayOfAnEnum_init_i(slice);
  }
  static void destroy(Xyz::ArrayOfArrayOfAnEnum_slice* slice)
  {
    Xyz::ArrayOfArrayOfAnEnum_fini_i(slice);
  }
};
}
TAO_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ArrayOfArrayOfAnEnum */


/* Begin STRUCT: StructOfArrayOfArrayOfBoolean */

namespace Xyz {
struct StructOfArrayOfArrayOfBoolean;
typedef ::TAO_Fixed_Var_T<StructOfArrayOfArrayOfBoolean> StructOfArrayOfArrayOfBoolean_var;
typedef StructOfArrayOfArrayOfBoolean& StructOfArrayOfArrayOfBoolean_out;

struct FooLib_Export StructOfArrayOfArrayOfBoolean
{
  typedef StructOfArrayOfArrayOfBoolean_var _var_type;
  typedef StructOfArrayOfArrayOfBoolean_out _out_type;

  Xyz::ArrayOfArrayOfBoolean f;

  bool operator==(const StructOfArrayOfArrayOfBoolean& rhs) const;
  bool operator!=(const StructOfArrayOfArrayOfBoolean& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
};

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const StructOfArrayOfArrayOfBoolean& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, StructOfArrayOfArrayOfBoolean& x);

}

/* End STRUCT: StructOfArrayOfArrayOfBoolean */


/* Begin STRUCT: StructOfArrayOfArrayOfString */

namespace Xyz {
struct StructOfArrayOfArrayOfString;
typedef ::TAO_Var_Var_T<StructOfArrayOfArrayOfString> StructOfArrayOfArrayOfString_var;
typedef ::TAO_Out_T<StructOfArrayOfArrayOfString> StructOfArrayOfArrayOfString_out;

struct FooLib_Export StructOfArrayOfArrayOfString
{
  typedef StructOfArrayOfArrayOfString_var _var_type;
  typedef StructOfArrayOfArrayOfString_out _out_type;

  Xyz::ArrayOfArrayOfString f;

  bool operator==(const StructOfArrayOfArrayOfString& rhs) const;
  bool operator!=(const StructOfArrayOfArrayOfString& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
};

FooLib_Export void swap(StructOfArrayOfArrayOfString& lhs, StructOfArrayOfArrayOfString& rhs);

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const StructOfArrayOfArrayOfString& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, StructOfArrayOfArrayOfString& x);

}

/* End STRUCT: StructOfArrayOfArrayOfString */


/* Begin STRUCT: StructOfArrayOfArrayOfChar */

namespace Xyz {
struct StructOfArrayOfArrayOfChar;
typedef ::TAO_Fixed_Var_T<StructOfArrayOfArrayOfChar> StructOfArrayOfArrayOfChar_var;
typedef StructOfArrayOfArrayOfChar& StructOfArrayOfArrayOfChar_out;

struct FooLib_Export StructOfArrayOfArrayOfChar
{
  typedef StructOfArrayOfArrayOfChar_var _var_type;
  typedef StructOfArrayOfArrayOfChar_out _out_type;

  Xyz::ArrayOfArrayOfChar f;

  bool operator==(const StructOfArrayOfArrayOfChar& rhs) const;
  bool operator!=(const StructOfArrayOfArrayOfChar& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
};

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const StructOfArrayOfArrayOfChar& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, StructOfArrayOfArrayOfChar& x);

}

/* End STRUCT: StructOfArrayOfArrayOfChar */


/* Begin STRUCT: StructOfArrayOfArrayOfOctet */

namespace Xyz {
struct StructOfArrayOfArrayOfOctet;
typedef ::TAO_Fixed_Var_T<StructOfArrayOfArrayOfOctet> StructOfArrayOfArrayOfOctet_var;
typedef StructOfArrayOfArrayOfOctet& StructOfArrayOfArrayOfOctet_out;

struct FooLib_Export StructOfArrayOfArrayOfOctet
{
  typedef StructOfArrayOfArrayOfOctet_var _var_type;
  typedef StructOfArrayOfArrayOfOctet_out _out_type;

  Xyz::ArrayOfArrayOfOctet f;

  bool operator==(const StructOfArrayOfArrayOfOctet& rhs) const;
  bool operator!=(const StructOfArrayOfArrayOfOctet& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
};

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const StructOfArrayOfArrayOfOctet& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, StructOfArrayOfArrayOfOctet& x);

}

/* End STRUCT: StructOfArrayOfArrayOfOctet */


/* Begin STRUCT: StructOfArrayOfArrayOfLong */

namespace Xyz {
struct StructOfArrayOfArrayOfLong;
typedef ::TAO_Fixed_Var_T<StructOfArrayOfArrayOfLong> StructOfArrayOfArrayOfLong_var;
typedef StructOfArrayOfArrayOfLong& StructOfArrayOfArrayOfLong_out;

struct FooLib_Export StructOfArrayOfArrayOfLong
{
  typedef StructOfArrayOfArrayOfLong_var _var_type;
  typedef StructOfArrayOfArrayOfLong_out _out_type;

  Xyz::ArrayOfArrayOfLong f;

  bool operator==(const StructOfArrayOfArrayOfLong& rhs) const;
  bool operator!=(const StructOfArrayOfArrayOfLong& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
};

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const StructOfArrayOfArrayOfLong& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, StructOfArrayOfArrayOfLong& x);

}

/* End STRUCT: StructOfArrayOfArrayOfLong */


/* Begin STRUCT: StructOfArrayOfArrayOfAnEnum */

namespace Xyz {
struct StructOfArrayOfArrayOfAnEnum;
typedef ::TAO_Fixed_Var_T<StructOfArrayOfArrayOfAnEnum> StructOfArrayOfArrayOfAnEnum_var;
typedef StructOfArrayOfArrayOfAnEnum& StructOfArrayOfArrayOfAnEnum_out;

struct FooLib_Export StructOfArrayOfArrayOfAnEnum
{
  typedef StructOfArrayOfArrayOfAnEnum_var _var_type;
  typedef StructOfArrayOfArrayOfAnEnum_out _out_type;

  Xyz::ArrayOfArrayOfAnEnum f;

  bool operator==(const StructOfArrayOfArrayOfAnEnum& rhs) const;
  bool operator!=(const StructOfArrayOfArrayOfAnEnum& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
};

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const StructOfArrayOfArrayOfAnEnum& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, StructOfArrayOfArrayOfAnEnum& x);

}

/* End STRUCT: StructOfArrayOfArrayOfAnEnum */


/* Begin TYPEDEF: SeqOfSeqOfBoolean */

namespace Xyz {
class SeqOfSeqOfBoolean;
typedef ::OpenDDS::FaceTypes::SequenceVar<SeqOfSeqOfBoolean> SeqOfSeqOfBoolean_var;
typedef ::TAO_Seq_Out_T<SeqOfSeqOfBoolean> SeqOfSeqOfBoolean_out;

class FooLib_Export SeqOfSeqOfBoolean : public ::OpenDDS::FaceTypes::Sequence< Xyz::SeqOfBoolean, ::OpenDDS::FaceTypes::Bounded<4>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::SeqOfBoolean> > {
public:
  typedef SeqOfSeqOfBoolean_var _var_type;
  typedef SeqOfSeqOfBoolean_out _out_type;

  SeqOfSeqOfBoolean() {}
  SeqOfSeqOfBoolean(const SeqOfSeqOfBoolean& seq) : ::OpenDDS::FaceTypes::Sequence< Xyz::SeqOfBoolean, ::OpenDDS::FaceTypes::Bounded<4>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::SeqOfBoolean> >(seq) {}
  friend void swap(SeqOfSeqOfBoolean& a, SeqOfSeqOfBoolean& b) { a.swap(b); }
  SeqOfSeqOfBoolean& operator=(const SeqOfSeqOfBoolean& rhs)
  {
    SeqOfSeqOfBoolean tmp(rhs);
    swap(tmp);
    return *this;
  }
  SeqOfSeqOfBoolean(::FACE::UnsignedLong length, Xyz::SeqOfBoolean* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< Xyz::SeqOfBoolean, ::OpenDDS::FaceTypes::Bounded<4>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::SeqOfBoolean> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const SeqOfSeqOfBoolean&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, SeqOfSeqOfBoolean&) { return true; }

}

/* End TYPEDEF: SeqOfSeqOfBoolean */


/* Begin TYPEDEF: SeqOfSeqOfString */

namespace Xyz {
class SeqOfSeqOfString;
typedef ::OpenDDS::FaceTypes::SequenceVar<SeqOfSeqOfString> SeqOfSeqOfString_var;
typedef ::TAO_Seq_Out_T<SeqOfSeqOfString> SeqOfSeqOfString_out;

class FooLib_Export SeqOfSeqOfString : public ::OpenDDS::FaceTypes::Sequence< Xyz::SeqOfString, ::OpenDDS::FaceTypes::Bounded<4>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::SeqOfString> > {
public:
  typedef SeqOfSeqOfString_var _var_type;
  typedef SeqOfSeqOfString_out _out_type;

  SeqOfSeqOfString() {}
  SeqOfSeqOfString(const SeqOfSeqOfString& seq) : ::OpenDDS::FaceTypes::Sequence< Xyz::SeqOfString, ::OpenDDS::FaceTypes::Bounded<4>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::SeqOfString> >(seq) {}
  friend void swap(SeqOfSeqOfString& a, SeqOfSeqOfString& b) { a.swap(b); }
  SeqOfSeqOfString& operator=(const SeqOfSeqOfString& rhs)
  {
    SeqOfSeqOfString tmp(rhs);
    swap(tmp);
    return *this;
  }
  SeqOfSeqOfString(::FACE::UnsignedLong length, Xyz::SeqOfString* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< Xyz::SeqOfString, ::OpenDDS::FaceTypes::Bounded<4>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::SeqOfString> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const SeqOfSeqOfString&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, SeqOfSeqOfString&) { return true; }

}

/* End TYPEDEF: SeqOfSeqOfString */


/* Begin TYPEDEF: SeqOfSeqOfChar */

namespace Xyz {
class SeqOfSeqOfChar;
typedef ::OpenDDS::FaceTypes::SequenceVar<SeqOfSeqOfChar> SeqOfSeqOfChar_var;
typedef ::TAO_Seq_Out_T<SeqOfSeqOfChar> SeqOfSeqOfChar_out;

class FooLib_Export SeqOfSeqOfChar : public ::OpenDDS::FaceTypes::Sequence< Xyz::SeqOfChar, ::OpenDDS::FaceTypes::Bounded<4>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::SeqOfChar> > {
public:
  typedef SeqOfSeqOfChar_var _var_type;
  typedef SeqOfSeqOfChar_out _out_type;

  SeqOfSeqOfChar() {}
  SeqOfSeqOfChar(const SeqOfSeqOfChar& seq) : ::OpenDDS::FaceTypes::Sequence< Xyz::SeqOfChar, ::OpenDDS::FaceTypes::Bounded<4>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::SeqOfChar> >(seq) {}
  friend void swap(SeqOfSeqOfChar& a, SeqOfSeqOfChar& b) { a.swap(b); }
  SeqOfSeqOfChar& operator=(const SeqOfSeqOfChar& rhs)
  {
    SeqOfSeqOfChar tmp(rhs);
    swap(tmp);
    return *this;
  }
  SeqOfSeqOfChar(::FACE::UnsignedLong length, Xyz::SeqOfChar* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< Xyz::SeqOfChar, ::OpenDDS::FaceTypes::Bounded<4>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::SeqOfChar> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const SeqOfSeqOfChar&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, SeqOfSeqOfChar&) { return true; }

}

/* End TYPEDEF: SeqOfSeqOfChar */


/* Begin TYPEDEF: SeqOfSeqOfOctet */

namespace Xyz {
class SeqOfSeqOfOctet;
typedef ::OpenDDS::FaceTypes::SequenceVar<SeqOfSeqOfOctet> SeqOfSeqOfOctet_var;
typedef ::TAO_Seq_Out_T<SeqOfSeqOfOctet> SeqOfSeqOfOctet_out;

class FooLib_Export SeqOfSeqOfOctet : public ::OpenDDS::FaceTypes::Sequence< Xyz::SeqOfOctet, ::OpenDDS::FaceTypes::Bounded<4>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::SeqOfOctet> > {
public:
  typedef SeqOfSeqOfOctet_var _var_type;
  typedef SeqOfSeqOfOctet_out _out_type;

  SeqOfSeqOfOctet() {}
  SeqOfSeqOfOctet(const SeqOfSeqOfOctet& seq) : ::OpenDDS::FaceTypes::Sequence< Xyz::SeqOfOctet, ::OpenDDS::FaceTypes::Bounded<4>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::SeqOfOctet> >(seq) {}
  friend void swap(SeqOfSeqOfOctet& a, SeqOfSeqOfOctet& b) { a.swap(b); }
  SeqOfSeqOfOctet& operator=(const SeqOfSeqOfOctet& rhs)
  {
    SeqOfSeqOfOctet tmp(rhs);
    swap(tmp);
    return *this;
  }
  SeqOfSeqOfOctet(::FACE::UnsignedLong length, Xyz::SeqOfOctet* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< Xyz::SeqOfOctet, ::OpenDDS::FaceTypes::Bounded<4>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::SeqOfOctet> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const SeqOfSeqOfOctet&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, SeqOfSeqOfOctet&) { return true; }

}

/* End TYPEDEF: SeqOfSeqOfOctet */


/* Begin TYPEDEF: SeqOfSeqOfLong */

namespace Xyz {
class SeqOfSeqOfLong;
typedef ::OpenDDS::FaceTypes::SequenceVar<SeqOfSeqOfLong> SeqOfSeqOfLong_var;
typedef ::TAO_Seq_Out_T<SeqOfSeqOfLong> SeqOfSeqOfLong_out;

class FooLib_Export SeqOfSeqOfLong : public ::OpenDDS::FaceTypes::Sequence< Xyz::SeqOfLong, ::OpenDDS::FaceTypes::Bounded<4>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::SeqOfLong> > {
public:
  typedef SeqOfSeqOfLong_var _var_type;
  typedef SeqOfSeqOfLong_out _out_type;

  SeqOfSeqOfLong() {}
  SeqOfSeqOfLong(const SeqOfSeqOfLong& seq) : ::OpenDDS::FaceTypes::Sequence< Xyz::SeqOfLong, ::OpenDDS::FaceTypes::Bounded<4>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::SeqOfLong> >(seq) {}
  friend void swap(SeqOfSeqOfLong& a, SeqOfSeqOfLong& b) { a.swap(b); }
  SeqOfSeqOfLong& operator=(const SeqOfSeqOfLong& rhs)
  {
    SeqOfSeqOfLong tmp(rhs);
    swap(tmp);
    return *this;
  }
  SeqOfSeqOfLong(::FACE::UnsignedLong length, Xyz::SeqOfLong* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< Xyz::SeqOfLong, ::OpenDDS::FaceTypes::Bounded<4>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::SeqOfLong> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const SeqOfSeqOfLong&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, SeqOfSeqOfLong&) { return true; }

}

/* End TYPEDEF: SeqOfSeqOfLong */


/* Begin TYPEDEF: SeqOfSeqOfAnEnum */

namespace Xyz {
class SeqOfSeqOfAnEnum;
typedef ::OpenDDS::FaceTypes::SequenceVar<SeqOfSeqOfAnEnum> SeqOfSeqOfAnEnum_var;
typedef ::TAO_Seq_Out_T<SeqOfSeqOfAnEnum> SeqOfSeqOfAnEnum_out;

class FooLib_Export SeqOfSeqOfAnEnum : public ::OpenDDS::FaceTypes::Sequence< Xyz::SeqOfAnEnum, ::OpenDDS::FaceTypes::Bounded<4>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::SeqOfAnEnum> > {
public:
  typedef SeqOfSeqOfAnEnum_var _var_type;
  typedef SeqOfSeqOfAnEnum_out _out_type;

  SeqOfSeqOfAnEnum() {}
  SeqOfSeqOfAnEnum(const SeqOfSeqOfAnEnum& seq) : ::OpenDDS::FaceTypes::Sequence< Xyz::SeqOfAnEnum, ::OpenDDS::FaceTypes::Bounded<4>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::SeqOfAnEnum> >(seq) {}
  friend void swap(SeqOfSeqOfAnEnum& a, SeqOfSeqOfAnEnum& b) { a.swap(b); }
  SeqOfSeqOfAnEnum& operator=(const SeqOfSeqOfAnEnum& rhs)
  {
    SeqOfSeqOfAnEnum tmp(rhs);
    swap(tmp);
    return *this;
  }
  SeqOfSeqOfAnEnum(::FACE::UnsignedLong length, Xyz::SeqOfAnEnum* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< Xyz::SeqOfAnEnum, ::OpenDDS::FaceTypes::Bounded<4>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::SeqOfAnEnum> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const SeqOfSeqOfAnEnum&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, SeqOfSeqOfAnEnum&) { return true; }

}

/* End TYPEDEF: SeqOfSeqOfAnEnum */


/* Begin TYPEDEF: OctetTypedef */

namespace Xyz {
typedef ::FACE::Octet OctetTypedef;
typedef ::FACE::Octet_out OctetTypedef_out;
}

/* End TYPEDEF: OctetTypedef */


/* Begin STRUCT: StructOfSeqOfSeqOfLong */

namespace Xyz {
struct StructOfSeqOfSeqOfLong;
typedef ::TAO_Var_Var_T<StructOfSeqOfSeqOfLong> StructOfSeqOfSeqOfLong_var;
typedef ::TAO_Out_T<StructOfSeqOfSeqOfLong> StructOfSeqOfSeqOfLong_out;

struct FooLib_Export StructOfSeqOfSeqOfLong
{
  typedef StructOfSeqOfSeqOfLong_var _var_type;
  typedef StructOfSeqOfSeqOfLong_out _out_type;

  Xyz::SeqOfSeqOfLong field;

  bool operator==(const StructOfSeqOfSeqOfLong& rhs) const;
  bool operator!=(const StructOfSeqOfSeqOfLong& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
};

FooLib_Export void swap(StructOfSeqOfSeqOfLong& lhs, StructOfSeqOfSeqOfLong& rhs);

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const StructOfSeqOfSeqOfLong& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, StructOfSeqOfSeqOfLong& x);

}

/* End STRUCT: StructOfSeqOfSeqOfLong */


/* Begin TYPEDEF: SevenStr */

namespace Xyz {
typedef ::FACE::Char* SevenStr;
typedef ::FACE::String_var SevenStr_var;
typedef ::FACE::String_out SevenStr_out;
}

/* End TYPEDEF: SevenStr */


/* Begin STRUCT: AStruct */

namespace Xyz {
struct AStruct;
typedef ::TAO_Var_Var_T<AStruct> AStruct_var;
typedef ::TAO_Out_T<AStruct> AStruct_out;

struct FooLib_Export AStruct
{
  typedef AStruct_var _var_type;
  typedef AStruct_out _out_type;

  ::FACE::Double f1;
  ::FACE::Float f2;
  ::FACE::Boolean f3;
  ::OpenDDS::FaceTypes::String_mgr f4;
  ::FACE::Char f5;
  ::FACE::Octet f6;
  Xyz::OctetTypedef f6a;
  ::FACE::Long f7;
  Xyz::AnEnum f8;
  Xyz::ArrayOfBoolean f10;
  Xyz::ArrayOfString f11;
  Xyz::ArrayOfChar f12;
  Xyz::ArrayOfOctet f13;
  Xyz::ArrayOfLong f14;
  Xyz::ArrayOfAnEnum f15;
  Xyz::SeqOfBoolean f20;
  Xyz::SeqOfString f21;
  Xyz::SeqOfChar f22;
  Xyz::SeqOfOctet f23;
  Xyz::SeqOfLong f24;
  Xyz::SeqOfAnEnum f25;
  Xyz::ArrayOfSeqOfBoolean f30;
  Xyz::ArrayOfSeqOfString f31;
  Xyz::ArrayOfSeqOfChar f32;
  Xyz::ArrayOfSeqOfOctet f33;
  Xyz::ArrayOfSeqOfLong f34;
  Xyz::ArrayOfSeqOfAnEnum f35;
  Xyz::SeqOfArrayOfBoolean f40;
  Xyz::SeqOfArrayOfString f41;
  Xyz::SeqOfArrayOfChar f42;
  Xyz::SeqOfArrayOfOctet f43;
  Xyz::SeqOfArrayOfLong f44;
  Xyz::SeqOfArrayOfAnEnum f45;
  Xyz::ArrayOfArrayOfBoolean f50;
  Xyz::ArrayOfArrayOfString f51;
  Xyz::ArrayOfArrayOfChar f52;
  Xyz::ArrayOfArrayOfOctet f53;
  Xyz::ArrayOfArrayOfLong f54;
  Xyz::ArrayOfArrayOfAnEnum f55;
  Xyz::SeqOfSeqOfBoolean f60;
  Xyz::SeqOfSeqOfString f61;
  Xyz::SeqOfSeqOfChar f62;
  Xyz::SeqOfSeqOfOctet f63;
  Xyz::SeqOfSeqOfLong f64;
  Xyz::SeqOfSeqOfAnEnum f65;

  bool operator==(const AStruct& rhs) const;
  bool operator!=(const AStruct& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
};

FooLib_Export void swap(AStruct& lhs, AStruct& rhs);

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const AStruct& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, AStruct& x);

}

/* End STRUCT: AStruct */


/* Begin TYPEDEF: SeqOfAStruct */

namespace Xyz {
class SeqOfAStruct;
typedef ::OpenDDS::FaceTypes::SequenceVar<SeqOfAStruct> SeqOfAStruct_var;
typedef ::TAO_Seq_Out_T<SeqOfAStruct> SeqOfAStruct_out;

class FooLib_Export SeqOfAStruct : public ::OpenDDS::FaceTypes::Sequence< Xyz::AStruct, ::OpenDDS::FaceTypes::Bounded<2>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::AStruct> > {
public:
  typedef SeqOfAStruct_var _var_type;
  typedef SeqOfAStruct_out _out_type;

  SeqOfAStruct() {}
  SeqOfAStruct(const SeqOfAStruct& seq) : ::OpenDDS::FaceTypes::Sequence< Xyz::AStruct, ::OpenDDS::FaceTypes::Bounded<2>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::AStruct> >(seq) {}
  friend void swap(SeqOfAStruct& a, SeqOfAStruct& b) { a.swap(b); }
  SeqOfAStruct& operator=(const SeqOfAStruct& rhs)
  {
    SeqOfAStruct tmp(rhs);
    swap(tmp);
    return *this;
  }
  SeqOfAStruct(::FACE::UnsignedLong length, Xyz::AStruct* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< Xyz::AStruct, ::OpenDDS::FaceTypes::Bounded<2>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::AStruct> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const SeqOfAStruct&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, SeqOfAStruct&) { return true; }

}

/* End TYPEDEF: SeqOfAStruct */


/* Begin TYPEDEF: ArrayOfAStruct */

namespace Xyz {
typedef Xyz::AStruct ArrayOfAStruct[3];
typedef Xyz::AStruct ArrayOfAStruct_slice;
struct ArrayOfAStruct_tag {};
typedef ::TAO_VarArray_Var_T<ArrayOfAStruct, ArrayOfAStruct_slice, ArrayOfAStruct_tag> ArrayOfAStruct_var;
typedef ::TAO_Array_Out_T<ArrayOfAStruct, ArrayOfAStruct_var, ArrayOfAStruct_slice, ArrayOfAStruct_tag> ArrayOfAStruct_out;
typedef ::TAO_Array_Forany_T<ArrayOfAStruct, ArrayOfAStruct_slice, ArrayOfAStruct_tag> ArrayOfAStruct_forany;

FooLib_Export ArrayOfAStruct_slice* ArrayOfAStruct_alloc();
FooLib_Export void ArrayOfAStruct_init_i(Xyz::AStruct* begin);
FooLib_Export void ArrayOfAStruct_fini_i(Xyz::AStruct* begin);
FooLib_Export void ArrayOfAStruct_free(ArrayOfAStruct_slice* slice);
FooLib_Export ArrayOfAStruct_slice* ArrayOfAStruct_dup(const ArrayOfAStruct_slice* slice);
FooLib_Export void ArrayOfAStruct_copy(ArrayOfAStruct_slice* dst, const ArrayOfAStruct_slice* src);

inline ACE_CDR::Boolean operator<<(ACE_OutputCDR &, const ArrayOfAStruct_forany&) { return true; }

inline ACE_CDR::Boolean operator>>(ACE_InputCDR &, ArrayOfAStruct_forany&) { return true; }

}
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace TAO {
template <>
struct FooLib_Export Array_Traits<Xyz::ArrayOfAStruct_forany>
{
  static void free(Xyz::ArrayOfAStruct_slice* slice)
  {
    Xyz::ArrayOfAStruct_free(slice);
  }

  static Xyz::ArrayOfAStruct_slice* dup(const Xyz::ArrayOfAStruct_slice* slice)
  {
    return Xyz::ArrayOfAStruct_dup(slice);
  }

  static void copy(Xyz::ArrayOfAStruct_slice* dst, const Xyz::ArrayOfAStruct_slice* src)
  {
    Xyz::ArrayOfAStruct_copy(dst, src);
  }

  static Xyz::ArrayOfAStruct_slice* alloc()
  {
    return Xyz::ArrayOfAStruct_alloc();
  }

  static void zero(Xyz::ArrayOfAStruct_slice* slice)
  {
    Xyz::ArrayOfAStruct_fini_i(slice);
    Xyz::ArrayOfAStruct_init_i(slice);
  }
  static void construct(Xyz::ArrayOfAStruct_slice* slice)
  {
    Xyz::ArrayOfAStruct_init_i(slice);
  }
  static void destroy(Xyz::ArrayOfAStruct_slice* slice)
  {
    Xyz::ArrayOfAStruct_fini_i(slice);
  }
};
}
TAO_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ArrayOfAStruct */


/* Begin STRUCT: StructContainingArrayOfAStruct */

namespace Xyz {
struct StructContainingArrayOfAStruct;
typedef ::TAO_Var_Var_T<StructContainingArrayOfAStruct> StructContainingArrayOfAStruct_var;
typedef ::TAO_Out_T<StructContainingArrayOfAStruct> StructContainingArrayOfAStruct_out;

struct FooLib_Export StructContainingArrayOfAStruct
{
  typedef StructContainingArrayOfAStruct_var _var_type;
  typedef StructContainingArrayOfAStruct_out _out_type;

  Xyz::ArrayOfAStruct f1;

  bool operator==(const StructContainingArrayOfAStruct& rhs) const;
  bool operator!=(const StructContainingArrayOfAStruct& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
};

FooLib_Export void swap(StructContainingArrayOfAStruct& lhs, StructContainingArrayOfAStruct& rhs);

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const StructContainingArrayOfAStruct& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, StructContainingArrayOfAStruct& x);

}

/* End STRUCT: StructContainingArrayOfAStruct */


/* Begin UNION: AUnion */

namespace Xyz {
class AUnion;
typedef ::TAO_Var_Var_T<AUnion> AUnion_var;
typedef ::TAO_Out_T<AUnion> AUnion_out;

class FooLib_Export AUnion 
{
 public:
  typedef AUnion_var _var_type;
  typedef AUnion_out _out_type;
  AUnion();
  AUnion(const AUnion&);
  ~AUnion() { _reset(); };
  AUnion& operator=(const AUnion&);
  void _d(Xyz::AnEnum d) { _discriminator = d; }
  Xyz::AnEnum _d() const { return _discriminator; }
  void rv (::FACE::Char* x) {
    _reset();
    this->_u.rv = x;
    _discriminator = Xyz::redx;
  }
  void rv (const ::FACE::Char* x) {
    _reset();
    this->_u.rv = ::CORBA::string_dup(x);
    _discriminator = Xyz::redx;
  }
  void rv (const ::FACE::String_var& x) {
    _reset();
    this->_u.rv = ::CORBA::string_dup(x.in());
    _discriminator = Xyz::redx;
  }
  const ::FACE::Char* rv () const {
    return this->_u.rv;
  }
  void gv (const Xyz::AStruct& x) {
    _reset();
    this->_u.gv = new Xyz::AStruct(x);
    _discriminator = Xyz::greenx;
  }
  const Xyz::AStruct& gv () const {
    return *this->_u.gv;
  }
  Xyz::AStruct& gv () {
    return *this->_u.gv;
  }
  void bv (const Xyz::SeqOfLong& x) {
    _reset();
    this->_u.bv = new Xyz::SeqOfLong(x);
    _discriminator = Xyz::bluex;
  }
  const Xyz::SeqOfLong& bv () const {
    return *this->_u.bv;
  }
  Xyz::SeqOfLong& bv () {
    return *this->_u.bv;
  }
  bool operator==(const AUnion& rhs) const;
  bool operator!=(const AUnion& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
 private:
  Xyz::AnEnum _discriminator;
  union {
    ::FACE::Char* rv;
    Xyz::AStruct* gv;
    Xyz::SeqOfLong* bv;
  } _u;
  void _reset();
};

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const AUnion& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, AUnion& x);

}

/* End UNION: AUnion */


/* Begin UNION: BigUnion */

namespace Xyz {
class BigUnion;
typedef ::TAO_Var_Var_T<BigUnion> BigUnion_var;
typedef ::TAO_Out_T<BigUnion> BigUnion_out;

class FooLib_Export BigUnion 
{
 public:
  typedef BigUnion_var _var_type;
  typedef BigUnion_out _out_type;
  BigUnion();
  BigUnion(const BigUnion&);
  ~BigUnion() { _reset(); };
  BigUnion& operator=(const BigUnion&);
  void _d(CORBA::Long d) { _discriminator = d; }
  CORBA::Long _d() const { return _discriminator; }
  void f1 (::FACE::Double x) {
    _reset();
    this->_u.f1 = x;
    _discriminator = 1;
  }
  ::FACE::Double f1 () const {
    return this->_u.f1;
  }
  void f2 (::FACE::Float x) {
    _reset();
    this->_u.f2 = x;
    _discriminator = 2;
  }
  ::FACE::Float f2 () const {
    return this->_u.f2;
  }
  void f3 (::FACE::Boolean x) {
    _reset();
    this->_u.f3 = x;
    _discriminator = 3;
  }
  ::FACE::Boolean f3 () const {
    return this->_u.f3;
  }
  void f4 (::FACE::Char* x) {
    _reset();
    this->_u.f4 = x;
    _discriminator = 4;
  }
  void f4 (const ::FACE::Char* x) {
    _reset();
    this->_u.f4 = ::CORBA::string_dup(x);
    _discriminator = 4;
  }
  void f4 (const ::FACE::String_var& x) {
    _reset();
    this->_u.f4 = ::CORBA::string_dup(x.in());
    _discriminator = 4;
  }
  const ::FACE::Char* f4 () const {
    return this->_u.f4;
  }
  void f5 (::FACE::Char x) {
    _reset();
    this->_u.f5 = x;
    _discriminator = 5;
  }
  ::FACE::Char f5 () const {
    return this->_u.f5;
  }
  void f6 (::FACE::Octet x) {
    _reset();
    this->_u.f6 = x;
    _discriminator = 6;
  }
  ::FACE::Octet f6 () const {
    return this->_u.f6;
  }
  void f7 (::FACE::Long x) {
    _reset();
    this->_u.f7 = x;
    _discriminator = 7;
  }
  ::FACE::Long f7 () const {
    return this->_u.f7;
  }
  void f8 (Xyz::AnEnum x) {
    _reset();
    this->_u.f8 = x;
    _discriminator = 8;
  }
  Xyz::AnEnum f8 () const {
    return this->_u.f8;
  }
  void f10 (Xyz::ArrayOfBoolean x) {
    _reset();
    this->_u.f10 = Xyz::ArrayOfBoolean_dup(x);
    _discriminator = 10;
  }
  Xyz::ArrayOfBoolean_slice* f10 () const {
    return this->_u.f10;
  }
  void f11 (Xyz::ArrayOfString x) {
    _reset();
    this->_u.f11 = Xyz::ArrayOfString_dup(x);
    _discriminator = 11;
  }
  Xyz::ArrayOfString_slice* f11 () const {
    return this->_u.f11;
  }
  void f12 (Xyz::ArrayOfChar x) {
    _reset();
    this->_u.f12 = Xyz::ArrayOfChar_dup(x);
    _discriminator = 12;
  }
  Xyz::ArrayOfChar_slice* f12 () const {
    return this->_u.f12;
  }
  void f13 (Xyz::ArrayOfOctet x) {
    _reset();
    this->_u.f13 = Xyz::ArrayOfOctet_dup(x);
    _discriminator = 13;
  }
  Xyz::ArrayOfOctet_slice* f13 () const {
    return this->_u.f13;
  }
  void f14 (Xyz::ArrayOfLong x) {
    _reset();
    this->_u.f14 = Xyz::ArrayOfLong_dup(x);
    _discriminator = 14;
  }
  Xyz::ArrayOfLong_slice* f14 () const {
    return this->_u.f14;
  }
  void f15 (Xyz::ArrayOfAnEnum x) {
    _reset();
    this->_u.f15 = Xyz::ArrayOfAnEnum_dup(x);
    _discriminator = 15;
  }
  Xyz::ArrayOfAnEnum_slice* f15 () const {
    return this->_u.f15;
  }
  void f20 (const Xyz::SeqOfBoolean& x) {
    _reset();
    this->_u.f20 = new Xyz::SeqOfBoolean(x);
    _discriminator = 20;
  }
  const Xyz::SeqOfBoolean& f20 () const {
    return *this->_u.f20;
  }
  Xyz::SeqOfBoolean& f20 () {
    return *this->_u.f20;
  }
  void f21 (const Xyz::SeqOfString& x) {
    _reset();
    this->_u.f21 = new Xyz::SeqOfString(x);
    _discriminator = 21;
  }
  const Xyz::SeqOfString& f21 () const {
    return *this->_u.f21;
  }
  Xyz::SeqOfString& f21 () {
    return *this->_u.f21;
  }
  void f22 (const Xyz::SeqOfChar& x) {
    _reset();
    this->_u.f22 = new Xyz::SeqOfChar(x);
    _discriminator = 22;
  }
  const Xyz::SeqOfChar& f22 () const {
    return *this->_u.f22;
  }
  Xyz::SeqOfChar& f22 () {
    return *this->_u.f22;
  }
  void f23 (const Xyz::SeqOfOctet& x) {
    _reset();
    this->_u.f23 = new Xyz::SeqOfOctet(x);
    _discriminator = 23;
  }
  const Xyz::SeqOfOctet& f23 () const {
    return *this->_u.f23;
  }
  Xyz::SeqOfOctet& f23 () {
    return *this->_u.f23;
  }
  void f24 (const Xyz::SeqOfLong& x) {
    _reset();
    this->_u.f24 = new Xyz::SeqOfLong(x);
    _discriminator = 24;
  }
  const Xyz::SeqOfLong& f24 () const {
    return *this->_u.f24;
  }
  Xyz::SeqOfLong& f24 () {
    return *this->_u.f24;
  }
  void f25 (const Xyz::SeqOfAnEnum& x) {
    _reset();
    this->_u.f25 = new Xyz::SeqOfAnEnum(x);
    _discriminator = 25;
  }
  const Xyz::SeqOfAnEnum& f25 () const {
    return *this->_u.f25;
  }
  Xyz::SeqOfAnEnum& f25 () {
    return *this->_u.f25;
  }
  void f30 (Xyz::ArrayOfSeqOfBoolean x) {
    _reset();
    this->_u.f30 = Xyz::ArrayOfSeqOfBoolean_dup(x);
    _discriminator = 30;
  }
  Xyz::ArrayOfSeqOfBoolean_slice* f30 () const {
    return this->_u.f30;
  }
  void f31 (Xyz::ArrayOfSeqOfString x) {
    _reset();
    this->_u.f31 = Xyz::ArrayOfSeqOfString_dup(x);
    _discriminator = 31;
  }
  Xyz::ArrayOfSeqOfString_slice* f31 () const {
    return this->_u.f31;
  }
  void f32 (Xyz::ArrayOfSeqOfChar x) {
    _reset();
    this->_u.f32 = Xyz::ArrayOfSeqOfChar_dup(x);
    _discriminator = 32;
  }
  Xyz::ArrayOfSeqOfChar_slice* f32 () const {
    return this->_u.f32;
  }
  void f33 (Xyz::ArrayOfSeqOfOctet x) {
    _reset();
    this->_u.f33 = Xyz::ArrayOfSeqOfOctet_dup(x);
    _discriminator = 33;
  }
  Xyz::ArrayOfSeqOfOctet_slice* f33 () const {
    return this->_u.f33;
  }
  void f34 (Xyz::ArrayOfSeqOfLong x) {
    _reset();
    this->_u.f34 = Xyz::ArrayOfSeqOfLong_dup(x);
    _discriminator = 34;
  }
  Xyz::ArrayOfSeqOfLong_slice* f34 () const {
    return this->_u.f34;
  }
  void f35 (Xyz::ArrayOfSeqOfAnEnum x) {
    _reset();
    this->_u.f35 = Xyz::ArrayOfSeqOfAnEnum_dup(x);
    _discriminator = 35;
  }
  Xyz::ArrayOfSeqOfAnEnum_slice* f35 () const {
    return this->_u.f35;
  }
  void f40 (const Xyz::SeqOfArrayOfBoolean& x) {
    _reset();
    this->_u.f40 = new Xyz::SeqOfArrayOfBoolean(x);
    _discriminator = 40;
  }
  const Xyz::SeqOfArrayOfBoolean& f40 () const {
    return *this->_u.f40;
  }
  Xyz::SeqOfArrayOfBoolean& f40 () {
    return *this->_u.f40;
  }
  void f41 (const Xyz::SeqOfArrayOfString& x) {
    _reset();
    this->_u.f41 = new Xyz::SeqOfArrayOfString(x);
    _discriminator = 41;
  }
  const Xyz::SeqOfArrayOfString& f41 () const {
    return *this->_u.f41;
  }
  Xyz::SeqOfArrayOfString& f41 () {
    return *this->_u.f41;
  }
  void f42 (const Xyz::SeqOfArrayOfChar& x) {
    _reset();
    this->_u.f42 = new Xyz::SeqOfArrayOfChar(x);
    _discriminator = 42;
  }
  const Xyz::SeqOfArrayOfChar& f42 () const {
    return *this->_u.f42;
  }
  Xyz::SeqOfArrayOfChar& f42 () {
    return *this->_u.f42;
  }
  void f43 (const Xyz::SeqOfArrayOfOctet& x) {
    _reset();
    this->_u.f43 = new Xyz::SeqOfArrayOfOctet(x);
    _discriminator = 43;
  }
  const Xyz::SeqOfArrayOfOctet& f43 () const {
    return *this->_u.f43;
  }
  Xyz::SeqOfArrayOfOctet& f43 () {
    return *this->_u.f43;
  }
  void f44 (const Xyz::SeqOfArrayOfLong& x) {
    _reset();
    this->_u.f44 = new Xyz::SeqOfArrayOfLong(x);
    _discriminator = 44;
  }
  const Xyz::SeqOfArrayOfLong& f44 () const {
    return *this->_u.f44;
  }
  Xyz::SeqOfArrayOfLong& f44 () {
    return *this->_u.f44;
  }
  void f45 (const Xyz::SeqOfArrayOfAnEnum& x) {
    _reset();
    this->_u.f45 = new Xyz::SeqOfArrayOfAnEnum(x);
    _discriminator = 45;
  }
  const Xyz::SeqOfArrayOfAnEnum& f45 () const {
    return *this->_u.f45;
  }
  Xyz::SeqOfArrayOfAnEnum& f45 () {
    return *this->_u.f45;
  }
  void f50 (Xyz::ArrayOfArrayOfBoolean x) {
    _reset();
    this->_u.f50 = Xyz::ArrayOfArrayOfBoolean_dup(x);
    _discriminator = 50;
  }
  Xyz::ArrayOfArrayOfBoolean_slice* f50 () const {
    return this->_u.f50;
  }
  void f51 (Xyz::ArrayOfArrayOfString x) {
    _reset();
    this->_u.f51 = Xyz::ArrayOfArrayOfString_dup(x);
    _discriminator = 51;
  }
  Xyz::ArrayOfArrayOfString_slice* f51 () const {
    return this->_u.f51;
  }
  void f52 (Xyz::ArrayOfArrayOfChar x) {
    _reset();
    this->_u.f52 = Xyz::ArrayOfArrayOfChar_dup(x);
    _discriminator = 52;
  }
  Xyz::ArrayOfArrayOfChar_slice* f52 () const {
    return this->_u.f52;
  }
  void f53 (Xyz::ArrayOfArrayOfOctet x) {
    _reset();
    this->_u.f53 = Xyz::ArrayOfArrayOfOctet_dup(x);
    _discriminator = 53;
  }
  Xyz::ArrayOfArrayOfOctet_slice* f53 () const {
    return this->_u.f53;
  }
  void f54 (Xyz::ArrayOfArrayOfLong x) {
    _reset();
    this->_u.f54 = Xyz::ArrayOfArrayOfLong_dup(x);
    _discriminator = 54;
  }
  Xyz::ArrayOfArrayOfLong_slice* f54 () const {
    return this->_u.f54;
  }
  void f55 (Xyz::ArrayOfArrayOfAnEnum x) {
    _reset();
    this->_u.f55 = Xyz::ArrayOfArrayOfAnEnum_dup(x);
    _discriminator = 55;
  }
  Xyz::ArrayOfArrayOfAnEnum_slice* f55 () const {
    return this->_u.f55;
  }
  void f60 (const Xyz::SeqOfSeqOfBoolean& x) {
    _reset();
    this->_u.f60 = new Xyz::SeqOfSeqOfBoolean(x);
    _discriminator = 60;
  }
  const Xyz::SeqOfSeqOfBoolean& f60 () const {
    return *this->_u.f60;
  }
  Xyz::SeqOfSeqOfBoolean& f60 () {
    return *this->_u.f60;
  }
  void f61 (const Xyz::SeqOfSeqOfString& x) {
    _reset();
    this->_u.f61 = new Xyz::SeqOfSeqOfString(x);
    _discriminator = 61;
  }
  const Xyz::SeqOfSeqOfString& f61 () const {
    return *this->_u.f61;
  }
  Xyz::SeqOfSeqOfString& f61 () {
    return *this->_u.f61;
  }
  void f62 (const Xyz::SeqOfSeqOfChar& x) {
    _reset();
    this->_u.f62 = new Xyz::SeqOfSeqOfChar(x);
    _discriminator = 62;
  }
  const Xyz::SeqOfSeqOfChar& f62 () const {
    return *this->_u.f62;
  }
  Xyz::SeqOfSeqOfChar& f62 () {
    return *this->_u.f62;
  }
  void f63 (const Xyz::SeqOfSeqOfOctet& x) {
    _reset();
    this->_u.f63 = new Xyz::SeqOfSeqOfOctet(x);
    _discriminator = 63;
  }
  const Xyz::SeqOfSeqOfOctet& f63 () const {
    return *this->_u.f63;
  }
  Xyz::SeqOfSeqOfOctet& f63 () {
    return *this->_u.f63;
  }
  void f64 (const Xyz::SeqOfSeqOfLong& x) {
    _reset();
    this->_u.f64 = new Xyz::SeqOfSeqOfLong(x);
    _discriminator = 64;
  }
  const Xyz::SeqOfSeqOfLong& f64 () const {
    return *this->_u.f64;
  }
  Xyz::SeqOfSeqOfLong& f64 () {
    return *this->_u.f64;
  }
  void f65 (const Xyz::SeqOfSeqOfAnEnum& x) {
    _reset();
    this->_u.f65 = new Xyz::SeqOfSeqOfAnEnum(x);
    _discriminator = 65;
  }
  const Xyz::SeqOfSeqOfAnEnum& f65 () const {
    return *this->_u.f65;
  }
  Xyz::SeqOfSeqOfAnEnum& f65 () {
    return *this->_u.f65;
  }
  void f6a (Xyz::OctetTypedef x) {
    _reset();
    this->_u.f6a = x;
    _discriminator = 66;
  }
  Xyz::OctetTypedef f6a () const {
    return this->_u.f6a;
  }
  void f90 (const Xyz::AStruct& x) {
    _reset();
    this->_u.f90 = new Xyz::AStruct(x);
    _discriminator = 90;
  }
  const Xyz::AStruct& f90 () const {
    return *this->_u.f90;
  }
  Xyz::AStruct& f90 () {
    return *this->_u.f90;
  }
  void f91 (const Xyz::SeqOfAStruct& x) {
    _reset();
    this->_u.f91 = new Xyz::SeqOfAStruct(x);
    _discriminator = 91;
  }
  const Xyz::SeqOfAStruct& f91 () const {
    return *this->_u.f91;
  }
  Xyz::SeqOfAStruct& f91 () {
    return *this->_u.f91;
  }
  void v92 (Xyz::ArrayOfAStruct x) {
    _reset();
    this->_u.v92 = Xyz::ArrayOfAStruct_dup(x);
    _discriminator = 92;
  }
  Xyz::ArrayOfAStruct_slice* v92 () const {
    return this->_u.v92;
  }
  void ld (::FACE::LongDouble x) {
    _reset();
    this->_u.ld = x;
    _discriminator = 93;
  }
  ::FACE::LongDouble ld () const {
    return this->_u.ld;
  }
  void _default() {
    _reset();
    _discriminator = -2147483647;
  }
  bool operator==(const BigUnion& rhs) const;
  bool operator!=(const BigUnion& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
 private:
  CORBA::Long _discriminator;
  union {
    ::FACE::Double f1;
    ::FACE::Float f2;
    ::FACE::Boolean f3;
    ::FACE::Char* f4;
    ::FACE::Char f5;
    ::FACE::Octet f6;
    ::FACE::Long f7;
    Xyz::AnEnum f8;
    Xyz::ArrayOfBoolean_slice* f10;
    Xyz::ArrayOfString_slice* f11;
    Xyz::ArrayOfChar_slice* f12;
    Xyz::ArrayOfOctet_slice* f13;
    Xyz::ArrayOfLong_slice* f14;
    Xyz::ArrayOfAnEnum_slice* f15;
    Xyz::SeqOfBoolean* f20;
    Xyz::SeqOfString* f21;
    Xyz::SeqOfChar* f22;
    Xyz::SeqOfOctet* f23;
    Xyz::SeqOfLong* f24;
    Xyz::SeqOfAnEnum* f25;
    Xyz::ArrayOfSeqOfBoolean_slice* f30;
    Xyz::ArrayOfSeqOfString_slice* f31;
    Xyz::ArrayOfSeqOfChar_slice* f32;
    Xyz::ArrayOfSeqOfOctet_slice* f33;
    Xyz::ArrayOfSeqOfLong_slice* f34;
    Xyz::ArrayOfSeqOfAnEnum_slice* f35;
    Xyz::SeqOfArrayOfBoolean* f40;
    Xyz::SeqOfArrayOfString* f41;
    Xyz::SeqOfArrayOfChar* f42;
    Xyz::SeqOfArrayOfOctet* f43;
    Xyz::SeqOfArrayOfLong* f44;
    Xyz::SeqOfArrayOfAnEnum* f45;
    Xyz::ArrayOfArrayOfBoolean_slice* f50;
    Xyz::ArrayOfArrayOfString_slice* f51;
    Xyz::ArrayOfArrayOfChar_slice* f52;
    Xyz::ArrayOfArrayOfOctet_slice* f53;
    Xyz::ArrayOfArrayOfLong_slice* f54;
    Xyz::ArrayOfArrayOfAnEnum_slice* f55;
    Xyz::SeqOfSeqOfBoolean* f60;
    Xyz::SeqOfSeqOfString* f61;
    Xyz::SeqOfSeqOfChar* f62;
    Xyz::SeqOfSeqOfOctet* f63;
    Xyz::SeqOfSeqOfLong* f64;
    Xyz::SeqOfSeqOfAnEnum* f65;
    Xyz::OctetTypedef f6a;
    Xyz::AStruct* f90;
    Xyz::SeqOfAStruct* f91;
    Xyz::ArrayOfAStruct_slice* v92;
    ::FACE::LongDouble ld;
  } _u;
  void _reset();
};

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const BigUnion& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, BigUnion& x);

}

/* End UNION: BigUnion */


/* Begin STRUCT: StructAUnion */

namespace Xyz {
struct StructAUnion;
typedef ::TAO_Var_Var_T<StructAUnion> StructAUnion_var;
typedef ::TAO_Out_T<StructAUnion> StructAUnion_out;

struct FooLib_Export StructAUnion
{
  typedef StructAUnion_var _var_type;
  typedef StructAUnion_out _out_type;

  Xyz::AUnion sau_f1;

  bool operator==(const StructAUnion& rhs) const;
  bool operator!=(const StructAUnion& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
};

FooLib_Export void swap(StructAUnion& lhs, StructAUnion& rhs);

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const StructAUnion& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, StructAUnion& x);

}

/* End STRUCT: StructAUnion */


/* Begin TYPEDEF: SeqOfAUnion */

namespace Xyz {
class SeqOfAUnion;
typedef ::OpenDDS::FaceTypes::SequenceVar<SeqOfAUnion> SeqOfAUnion_var;
typedef ::TAO_Seq_Out_T<SeqOfAUnion> SeqOfAUnion_out;

class FooLib_Export SeqOfAUnion : public ::OpenDDS::FaceTypes::Sequence< Xyz::AUnion, ::OpenDDS::FaceTypes::Bounded<3>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::AUnion> > {
public:
  typedef SeqOfAUnion_var _var_type;
  typedef SeqOfAUnion_out _out_type;

  SeqOfAUnion() {}
  SeqOfAUnion(const SeqOfAUnion& seq) : ::OpenDDS::FaceTypes::Sequence< Xyz::AUnion, ::OpenDDS::FaceTypes::Bounded<3>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::AUnion> >(seq) {}
  friend void swap(SeqOfAUnion& a, SeqOfAUnion& b) { a.swap(b); }
  SeqOfAUnion& operator=(const SeqOfAUnion& rhs)
  {
    SeqOfAUnion tmp(rhs);
    swap(tmp);
    return *this;
  }
  SeqOfAUnion(::FACE::UnsignedLong length, Xyz::AUnion* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< Xyz::AUnion, ::OpenDDS::FaceTypes::Bounded<3>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::AUnion> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const SeqOfAUnion&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, SeqOfAUnion&) { return true; }

}

/* End TYPEDEF: SeqOfAUnion */


/* Begin TYPEDEF: AStructSeq */

namespace Xyz {
class AStructSeq;
typedef ::OpenDDS::FaceTypes::SequenceVar<AStructSeq> AStructSeq_var;
typedef ::TAO_Seq_Out_T<AStructSeq> AStructSeq_out;

class FooLib_Export AStructSeq : public ::OpenDDS::FaceTypes::Sequence< Xyz::AStruct, ::OpenDDS::FaceTypes::Bounded<3>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::AStruct> > {
public:
  typedef AStructSeq_var _var_type;
  typedef AStructSeq_out _out_type;

  AStructSeq() {}
  AStructSeq(const AStructSeq& seq) : ::OpenDDS::FaceTypes::Sequence< Xyz::AStruct, ::OpenDDS::FaceTypes::Bounded<3>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::AStruct> >(seq) {}
  friend void swap(AStructSeq& a, AStructSeq& b) { a.swap(b); }
  AStructSeq& operator=(const AStructSeq& rhs)
  {
    AStructSeq tmp(rhs);
    swap(tmp);
    return *this;
  }
  AStructSeq(::FACE::UnsignedLong length, Xyz::AStruct* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< Xyz::AStruct, ::OpenDDS::FaceTypes::Bounded<3>, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::AStruct> >(0u, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const AStructSeq&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, AStructSeq&) { return true; }

}

/* End TYPEDEF: AStructSeq */


/* Begin TYPEDEF: ArrayOfAStructSeq */

namespace Xyz {
typedef Xyz::AStructSeq ArrayOfAStructSeq[3];
typedef Xyz::AStructSeq ArrayOfAStructSeq_slice;
struct ArrayOfAStructSeq_tag {};
typedef ::TAO_VarArray_Var_T<ArrayOfAStructSeq, ArrayOfAStructSeq_slice, ArrayOfAStructSeq_tag> ArrayOfAStructSeq_var;
typedef ::TAO_Array_Out_T<ArrayOfAStructSeq, ArrayOfAStructSeq_var, ArrayOfAStructSeq_slice, ArrayOfAStructSeq_tag> ArrayOfAStructSeq_out;
typedef ::TAO_Array_Forany_T<ArrayOfAStructSeq, ArrayOfAStructSeq_slice, ArrayOfAStructSeq_tag> ArrayOfAStructSeq_forany;

FooLib_Export ArrayOfAStructSeq_slice* ArrayOfAStructSeq_alloc();
FooLib_Export void ArrayOfAStructSeq_init_i(Xyz::AStructSeq* begin);
FooLib_Export void ArrayOfAStructSeq_fini_i(Xyz::AStructSeq* begin);
FooLib_Export void ArrayOfAStructSeq_free(ArrayOfAStructSeq_slice* slice);
FooLib_Export ArrayOfAStructSeq_slice* ArrayOfAStructSeq_dup(const ArrayOfAStructSeq_slice* slice);
FooLib_Export void ArrayOfAStructSeq_copy(ArrayOfAStructSeq_slice* dst, const ArrayOfAStructSeq_slice* src);

inline ACE_CDR::Boolean operator<<(ACE_OutputCDR &, const ArrayOfAStructSeq_forany&) { return true; }

inline ACE_CDR::Boolean operator>>(ACE_InputCDR &, ArrayOfAStructSeq_forany&) { return true; }

}
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace TAO {
template <>
struct FooLib_Export Array_Traits<Xyz::ArrayOfAStructSeq_forany>
{
  static void free(Xyz::ArrayOfAStructSeq_slice* slice)
  {
    Xyz::ArrayOfAStructSeq_free(slice);
  }

  static Xyz::ArrayOfAStructSeq_slice* dup(const Xyz::ArrayOfAStructSeq_slice* slice)
  {
    return Xyz::ArrayOfAStructSeq_dup(slice);
  }

  static void copy(Xyz::ArrayOfAStructSeq_slice* dst, const Xyz::ArrayOfAStructSeq_slice* src)
  {
    Xyz::ArrayOfAStructSeq_copy(dst, src);
  }

  static Xyz::ArrayOfAStructSeq_slice* alloc()
  {
    return Xyz::ArrayOfAStructSeq_alloc();
  }

  static void zero(Xyz::ArrayOfAStructSeq_slice* slice)
  {
    Xyz::ArrayOfAStructSeq_fini_i(slice);
    Xyz::ArrayOfAStructSeq_init_i(slice);
  }
  static void construct(Xyz::ArrayOfAStructSeq_slice* slice)
  {
    Xyz::ArrayOfAStructSeq_init_i(slice);
  }
  static void destroy(Xyz::ArrayOfAStructSeq_slice* slice)
  {
    Xyz::ArrayOfAStructSeq_fini_i(slice);
  }
};
}
TAO_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ArrayOfAStructSeq */


/* Begin STRUCT: StructContainingArrayOfAStructSeq */

namespace Xyz {
struct StructContainingArrayOfAStructSeq;
typedef ::TAO_Var_Var_T<StructContainingArrayOfAStructSeq> StructContainingArrayOfAStructSeq_var;
typedef ::TAO_Out_T<StructContainingArrayOfAStructSeq> StructContainingArrayOfAStructSeq_out;

struct FooLib_Export StructContainingArrayOfAStructSeq
{
  typedef StructContainingArrayOfAStructSeq_var _var_type;
  typedef StructContainingArrayOfAStructSeq_out _out_type;

  Xyz::ArrayOfAStructSeq f1;

  bool operator==(const StructContainingArrayOfAStructSeq& rhs) const;
  bool operator!=(const StructContainingArrayOfAStructSeq& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
};

FooLib_Export void swap(StructContainingArrayOfAStructSeq& lhs, StructContainingArrayOfAStructSeq& rhs);

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const StructContainingArrayOfAStructSeq& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, StructContainingArrayOfAStructSeq& x);

}

/* End STRUCT: StructContainingArrayOfAStructSeq */


/* Begin TYPEDEF: BigUnionSeq */

namespace Xyz {
class BigUnionSeq;
typedef ::OpenDDS::FaceTypes::SequenceVar<BigUnionSeq> BigUnionSeq_var;
typedef ::TAO_Seq_Out_T<BigUnionSeq> BigUnionSeq_out;

class FooLib_Export BigUnionSeq : public ::OpenDDS::FaceTypes::Sequence< Xyz::BigUnion, ::OpenDDS::FaceTypes::Unbounded, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::BigUnion> > {
public:
  typedef BigUnionSeq_var _var_type;
  typedef BigUnionSeq_out _out_type;

  BigUnionSeq() {}
  BigUnionSeq(const BigUnionSeq& seq) : ::OpenDDS::FaceTypes::Sequence< Xyz::BigUnion, ::OpenDDS::FaceTypes::Unbounded, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::BigUnion> >(seq) {}
  friend void swap(BigUnionSeq& a, BigUnionSeq& b) { a.swap(b); }
  BigUnionSeq& operator=(const BigUnionSeq& rhs)
  {
    BigUnionSeq tmp(rhs);
    swap(tmp);
    return *this;
  }
  BigUnionSeq(::FACE::UnsignedLong maximum)
    : ::OpenDDS::FaceTypes::Sequence< Xyz::BigUnion, ::OpenDDS::FaceTypes::Unbounded, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::BigUnion> >(maximum, 0u, 0, true) {}
  BigUnionSeq(::FACE::UnsignedLong maximum, ::FACE::UnsignedLong length, Xyz::BigUnion* data, ::FACE::Boolean release = false)
    : ::OpenDDS::FaceTypes::Sequence< Xyz::BigUnion, ::OpenDDS::FaceTypes::Unbounded, ::OpenDDS::FaceTypes::VariEltPolicy<Xyz::BigUnion> >(maximum, length, data, release) {}
};

inline ACE_CDR::Boolean operator<< (ACE_OutputCDR&, const BigUnionSeq&) { return true; }

inline ACE_CDR::Boolean operator>> (ACE_InputCDR&, BigUnionSeq&) { return true; }

}

/* End TYPEDEF: BigUnionSeq */


/* Begin TYPEDEF: OctetArray */

namespace Xyz {
typedef ::FACE::Octet OctetArray[3];
typedef ::FACE::Octet OctetArray_slice;
struct OctetArray_tag {};
typedef ::TAO_FixedArray_Var_T<OctetArray, OctetArray_slice, OctetArray_tag> OctetArray_var;
typedef OctetArray OctetArray_out;
typedef ::TAO_Array_Forany_T<OctetArray, OctetArray_slice, OctetArray_tag> OctetArray_forany;

FooLib_Export OctetArray_slice* OctetArray_alloc();
FooLib_Export void OctetArray_init_i(::FACE::Octet* begin);
FooLib_Export void OctetArray_fini_i(::FACE::Octet* begin);
FooLib_Export void OctetArray_free(OctetArray_slice* slice);
FooLib_Export OctetArray_slice* OctetArray_dup(const OctetArray_slice* slice);
FooLib_Export void OctetArray_copy(OctetArray_slice* dst, const OctetArray_slice* src);

inline ACE_CDR::Boolean operator<<(ACE_OutputCDR &, const OctetArray_forany&) { return true; }

inline ACE_CDR::Boolean operator>>(ACE_InputCDR &, OctetArray_forany&) { return true; }

}
TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace TAO {
template <>
struct FooLib_Export Array_Traits<Xyz::OctetArray_forany>
{
  static void free(Xyz::OctetArray_slice* slice)
  {
    Xyz::OctetArray_free(slice);
  }

  static Xyz::OctetArray_slice* dup(const Xyz::OctetArray_slice* slice)
  {
    return Xyz::OctetArray_dup(slice);
  }

  static void copy(Xyz::OctetArray_slice* dst, const Xyz::OctetArray_slice* src)
  {
    Xyz::OctetArray_copy(dst, src);
  }

  static Xyz::OctetArray_slice* alloc()
  {
    return Xyz::OctetArray_alloc();
  }

  static void zero(Xyz::OctetArray_slice* slice)
  {
    Xyz::OctetArray_fini_i(slice);
    Xyz::OctetArray_init_i(slice);
  }
  static void construct(Xyz::OctetArray_slice* slice)
  {
    Xyz::OctetArray_init_i(slice);
  }
  static void destroy(Xyz::OctetArray_slice* slice)
  {
    Xyz::OctetArray_fini_i(slice);
  }
};
}
TAO_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: OctetArray */


/* Begin STRUCT: Foo */

namespace Xyz {
struct Foo;
typedef ::TAO_Var_Var_T<Foo> Foo_var;
typedef ::TAO_Out_T<Foo> Foo_out;

struct FooLib_Export Foo
{
  typedef Foo_var _var_type;
  typedef Foo_out _out_type;

  ::FACE::Long key;
  ::FACE::Octet octer;
  Xyz::OctetTypedef theOctetTypedef;
  Xyz::AnEnum xcolor;
  Xyz::OctetArray ooo;
  ::OpenDDS::FaceTypes::String_mgr theString;
  Xyz::AStruct thestruct;
  Xyz::AStructSeq theStructSeq;
  Xyz::ArrayOfAStruct structArray;
  Xyz::AUnion theUnion;
  Xyz::SeqOfAUnion theSeqOfUnion;
  Xyz::BigUnion theBigUnion;
  Xyz::BigUnionSeq theSeqOfBitUnion;
  ::FACE::Float x;
  ::FACE::Float y;
  ::FACE::WChar theWChar;
  ::OpenDDS::FaceTypes::WString_mgr theWString;
  ::FACE::LongDouble theLongDouble;

  bool operator==(const Foo& rhs) const;
  bool operator!=(const Foo& rhs) const { return !(*this == rhs); }
  OPENDDS_POOL_ALLOCATION_HOOKS
};

FooLib_Export void swap(Foo& lhs, Foo& rhs);

FooLib_Export ACE_CDR::Boolean operator<< (ACE_OutputCDR& os, const Foo& x);

FooLib_Export ACE_CDR::Boolean operator>> (ACE_InputCDR& os, Foo& x);

}

/* End STRUCT: Foo */

/* End MODULE: Xyz */
#endif /* OPENDDS_IDL_GENERATED_FOODEFC_H_GEY2XC */
