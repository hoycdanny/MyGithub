/* -*- C++ -*- */
/* Generated by /Users/yc/MyGithub/imac-project/OpenDDS/OpenDDS-3.10/bin/opendds_idl version 3.10 (ACE version 6.2a_p11) running on input file ../../../DCPS/Compiler/idl_test3_lib/FooDef.idl */
#ifndef OPENDDS_IDL_GENERATED_FOODEFTYPESUPPORTIMPL_H_GQYGAU
#define OPENDDS_IDL_GENERATED_FOODEFTYPESUPPORTIMPL_H_GQYGAU
#include "FooDefC.h"
#include "dds/DCPS/Definitions.h"
#include "FooDefTypeSupportC.h"
#include "SharedTypesC.h"
#include "dds/DCPS/PoolAllocationBase.h"
#include "dds/DCPS/Serializer.h"
#include "dds/DCPS/TypeSupportImpl.h"
#include "foolib_export.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: Xyz */



/* Begin ENUM: AnEnum */


/* End ENUM: AnEnum */


/* Begin TYPEDEF: SeqOfBoolean */


/* End TYPEDEF: SeqOfBoolean */


/* Begin TYPEDEF: SeqOfString */


/* End TYPEDEF: SeqOfString */


/* Begin TYPEDEF: SeqOfChar */


/* End TYPEDEF: SeqOfChar */


/* Begin TYPEDEF: SeqOfOctet */


/* End TYPEDEF: SeqOfOctet */


/* Begin TYPEDEF: SeqOfLong */


/* End TYPEDEF: SeqOfLong */


/* Begin TYPEDEF: SeqOfAnEnum */


/* End TYPEDEF: SeqOfAnEnum */


/* Begin TYPEDEF: ArrayOfBoolean */


/* End TYPEDEF: ArrayOfBoolean */


/* Begin TYPEDEF: ArrayOfString */


/* End TYPEDEF: ArrayOfString */


/* Begin TYPEDEF: ArrayOfChar */


/* End TYPEDEF: ArrayOfChar */


/* Begin TYPEDEF: ArrayOfOctet */


/* End TYPEDEF: ArrayOfOctet */


/* Begin TYPEDEF: ArrayOfLong */


/* End TYPEDEF: ArrayOfLong */


/* Begin TYPEDEF: ArrayOfAnEnum */


/* End TYPEDEF: ArrayOfAnEnum */


/* Begin TYPEDEF: ArrayOfSeqOfBoolean */


/* End TYPEDEF: ArrayOfSeqOfBoolean */


/* Begin TYPEDEF: ArrayOfSeqOfString */


/* End TYPEDEF: ArrayOfSeqOfString */


/* Begin TYPEDEF: ArrayOfSeqOfChar */


/* End TYPEDEF: ArrayOfSeqOfChar */


/* Begin TYPEDEF: ArrayOfSeqOfOctet */


/* End TYPEDEF: ArrayOfSeqOfOctet */


/* Begin TYPEDEF: ArrayOfSeqOfLong */


/* End TYPEDEF: ArrayOfSeqOfLong */


/* Begin TYPEDEF: ArrayOfSeqOfAnEnum */


/* End TYPEDEF: ArrayOfSeqOfAnEnum */

/* End MODULE: Xyz */


/* Begin MODULE: Xyz */



/* Begin TYPEDEF: SeqOfArrayOfBoolean */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::SeqOfArrayOfBoolean& seq, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::SeqOfArrayOfBoolean& seq);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::SeqOfArrayOfBoolean& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::SeqOfArrayOfBoolean*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfArrayOfBoolean */


/* Begin TYPEDEF: SeqOfArrayOfString */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::SeqOfArrayOfString& seq, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::SeqOfArrayOfString& seq);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::SeqOfArrayOfString& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::SeqOfArrayOfString*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfArrayOfString */


/* Begin TYPEDEF: SeqOfArrayOfChar */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::SeqOfArrayOfChar& seq, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::SeqOfArrayOfChar& seq);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::SeqOfArrayOfChar& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::SeqOfArrayOfChar*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfArrayOfChar */


/* Begin TYPEDEF: SeqOfArrayOfOctet */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::SeqOfArrayOfOctet& seq, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::SeqOfArrayOfOctet& seq);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::SeqOfArrayOfOctet& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::SeqOfArrayOfOctet*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfArrayOfOctet */


/* Begin TYPEDEF: SeqOfArrayOfLong */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::SeqOfArrayOfLong& seq, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::SeqOfArrayOfLong& seq);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::SeqOfArrayOfLong& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::SeqOfArrayOfLong*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfArrayOfLong */


/* Begin TYPEDEF: SeqOfArrayOfAnEnum */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::SeqOfArrayOfAnEnum& seq, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::SeqOfArrayOfAnEnum& seq);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::SeqOfArrayOfAnEnum& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::SeqOfArrayOfAnEnum*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfArrayOfAnEnum */


/* Begin TYPEDEF: ArrayOfArrayOfBoolean */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::ArrayOfArrayOfBoolean_forany& arr, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::ArrayOfArrayOfBoolean_forany& arr);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::ArrayOfArrayOfBoolean_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::ArrayOfArrayOfBoolean_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: ArrayOfArrayOfBoolean */


/* Begin TYPEDEF: ArrayOfArrayOfString */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::ArrayOfArrayOfString_forany& arr, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::ArrayOfArrayOfString_forany& arr);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::ArrayOfArrayOfString_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::ArrayOfArrayOfString_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: ArrayOfArrayOfString */


/* Begin TYPEDEF: ArrayOfArrayOfChar */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::ArrayOfArrayOfChar_forany& arr, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::ArrayOfArrayOfChar_forany& arr);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::ArrayOfArrayOfChar_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::ArrayOfArrayOfChar_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: ArrayOfArrayOfChar */


/* Begin TYPEDEF: ArrayOfArrayOfOctet */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::ArrayOfArrayOfOctet_forany& arr, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::ArrayOfArrayOfOctet_forany& arr);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::ArrayOfArrayOfOctet_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::ArrayOfArrayOfOctet_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: ArrayOfArrayOfOctet */


/* Begin TYPEDEF: ArrayOfArrayOfLong */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::ArrayOfArrayOfLong_forany& arr, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::ArrayOfArrayOfLong_forany& arr);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::ArrayOfArrayOfLong_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::ArrayOfArrayOfLong_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: ArrayOfArrayOfLong */


/* Begin TYPEDEF: ArrayOfArrayOfAnEnum */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::ArrayOfArrayOfAnEnum_forany& arr, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::ArrayOfArrayOfAnEnum_forany& arr);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::ArrayOfArrayOfAnEnum_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::ArrayOfArrayOfAnEnum_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: ArrayOfArrayOfAnEnum */


/* Begin STRUCT: StructOfArrayOfArrayOfBoolean */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::StructOfArrayOfArrayOfBoolean& stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfArrayOfBoolean& stru);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::StructOfArrayOfArrayOfBoolean& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

class MetaStruct;

template<typename T>
const MetaStruct& getMetaStruct();

template<>
FooLib_Export
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfArrayOfBoolean>();
FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfArrayOfBoolean*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StructOfArrayOfArrayOfBoolean */


/* Begin STRUCT: StructOfArrayOfArrayOfString */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::StructOfArrayOfArrayOfString& stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfArrayOfString& stru);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::StructOfArrayOfArrayOfString& stru);

FooLib_Export
size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfArrayOfString& stru, bool align);

FooLib_Export
size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfArrayOfString> stru, bool align);

FooLib_Export
void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfArrayOfString> stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfArrayOfString> stru);

FooLib_Export
bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfArrayOfString> stru);

template <>
struct MarshalTraits<Xyz::StructOfArrayOfArrayOfString> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct FooLib_Export StructOfArrayOfArrayOfString_OpenDDS_KeyLessThan {
  bool operator()(const Xyz::StructOfArrayOfArrayOfString&, const Xyz::StructOfArrayOfArrayOfString&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Xyz {
class StructOfArrayOfArrayOfStringTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Xyz::StructOfArrayOfArrayOfString> {
  typedef Xyz::StructOfArrayOfArrayOfString MessageType;
  typedef Xyz::StructOfArrayOfArrayOfStringSeq MessageSequenceType;
  typedef Xyz::StructOfArrayOfArrayOfStringTypeSupport TypeSupportType;
  typedef Xyz::StructOfArrayOfArrayOfStringTypeSupportImpl TypeSupportTypeImpl;
  typedef Xyz::StructOfArrayOfArrayOfStringDataWriter DataWriterType;
  typedef Xyz::StructOfArrayOfArrayOfStringDataReader DataReaderType;
  typedef Xyz::StructOfArrayOfArrayOfString_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Xyz::StructOfArrayOfArrayOfString"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
class FooLib_Export StructOfArrayOfArrayOfStringTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<StructOfArrayOfArrayOfStringTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<StructOfArrayOfArrayOfString> TraitsType;
  typedef StructOfArrayOfArrayOfStringTypeSupport TypeSupportType;
  typedef StructOfArrayOfArrayOfStringTypeSupport::_var_type _var_type;
  typedef StructOfArrayOfArrayOfStringTypeSupport::_ptr_type _ptr_type;

  StructOfArrayOfArrayOfStringTypeSupportImpl() {}
  virtual ~StructOfArrayOfArrayOfStringTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static StructOfArrayOfArrayOfStringTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
FooLib_Export
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfArrayOfString>();
FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfArrayOfString*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StructOfArrayOfArrayOfString */


/* Begin STRUCT: StructOfArrayOfArrayOfChar */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::StructOfArrayOfArrayOfChar& stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfArrayOfChar& stru);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::StructOfArrayOfArrayOfChar& stru);

FooLib_Export
size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfArrayOfChar& stru, bool align);

FooLib_Export
size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfArrayOfChar> stru, bool align);

FooLib_Export
void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfArrayOfChar> stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfArrayOfChar> stru);

FooLib_Export
bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfArrayOfChar> stru);

template <>
struct MarshalTraits<Xyz::StructOfArrayOfArrayOfChar> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct FooLib_Export StructOfArrayOfArrayOfChar_OpenDDS_KeyLessThan {
  bool operator()(const Xyz::StructOfArrayOfArrayOfChar&, const Xyz::StructOfArrayOfArrayOfChar&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Xyz {
class StructOfArrayOfArrayOfCharTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Xyz::StructOfArrayOfArrayOfChar> {
  typedef Xyz::StructOfArrayOfArrayOfChar MessageType;
  typedef Xyz::StructOfArrayOfArrayOfCharSeq MessageSequenceType;
  typedef Xyz::StructOfArrayOfArrayOfCharTypeSupport TypeSupportType;
  typedef Xyz::StructOfArrayOfArrayOfCharTypeSupportImpl TypeSupportTypeImpl;
  typedef Xyz::StructOfArrayOfArrayOfCharDataWriter DataWriterType;
  typedef Xyz::StructOfArrayOfArrayOfCharDataReader DataReaderType;
  typedef Xyz::StructOfArrayOfArrayOfChar_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Xyz::StructOfArrayOfArrayOfChar"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
class FooLib_Export StructOfArrayOfArrayOfCharTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<StructOfArrayOfArrayOfCharTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<StructOfArrayOfArrayOfChar> TraitsType;
  typedef StructOfArrayOfArrayOfCharTypeSupport TypeSupportType;
  typedef StructOfArrayOfArrayOfCharTypeSupport::_var_type _var_type;
  typedef StructOfArrayOfArrayOfCharTypeSupport::_ptr_type _ptr_type;

  StructOfArrayOfArrayOfCharTypeSupportImpl() {}
  virtual ~StructOfArrayOfArrayOfCharTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static StructOfArrayOfArrayOfCharTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
FooLib_Export
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfArrayOfChar>();
FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfArrayOfChar*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StructOfArrayOfArrayOfChar */


/* Begin STRUCT: StructOfArrayOfArrayOfOctet */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::StructOfArrayOfArrayOfOctet& stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfArrayOfOctet& stru);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::StructOfArrayOfArrayOfOctet& stru);

FooLib_Export
size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfArrayOfOctet& stru, bool align);

FooLib_Export
size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfArrayOfOctet> stru, bool align);

FooLib_Export
void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfArrayOfOctet> stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfArrayOfOctet> stru);

FooLib_Export
bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfArrayOfOctet> stru);

template <>
struct MarshalTraits<Xyz::StructOfArrayOfArrayOfOctet> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct FooLib_Export StructOfArrayOfArrayOfOctet_OpenDDS_KeyLessThan {
  bool operator()(const Xyz::StructOfArrayOfArrayOfOctet&, const Xyz::StructOfArrayOfArrayOfOctet&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Xyz {
class StructOfArrayOfArrayOfOctetTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Xyz::StructOfArrayOfArrayOfOctet> {
  typedef Xyz::StructOfArrayOfArrayOfOctet MessageType;
  typedef Xyz::StructOfArrayOfArrayOfOctetSeq MessageSequenceType;
  typedef Xyz::StructOfArrayOfArrayOfOctetTypeSupport TypeSupportType;
  typedef Xyz::StructOfArrayOfArrayOfOctetTypeSupportImpl TypeSupportTypeImpl;
  typedef Xyz::StructOfArrayOfArrayOfOctetDataWriter DataWriterType;
  typedef Xyz::StructOfArrayOfArrayOfOctetDataReader DataReaderType;
  typedef Xyz::StructOfArrayOfArrayOfOctet_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Xyz::StructOfArrayOfArrayOfOctet"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
class FooLib_Export StructOfArrayOfArrayOfOctetTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<StructOfArrayOfArrayOfOctetTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<StructOfArrayOfArrayOfOctet> TraitsType;
  typedef StructOfArrayOfArrayOfOctetTypeSupport TypeSupportType;
  typedef StructOfArrayOfArrayOfOctetTypeSupport::_var_type _var_type;
  typedef StructOfArrayOfArrayOfOctetTypeSupport::_ptr_type _ptr_type;

  StructOfArrayOfArrayOfOctetTypeSupportImpl() {}
  virtual ~StructOfArrayOfArrayOfOctetTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static StructOfArrayOfArrayOfOctetTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
FooLib_Export
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfArrayOfOctet>();
FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfArrayOfOctet*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StructOfArrayOfArrayOfOctet */


/* Begin STRUCT: StructOfArrayOfArrayOfLong */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::StructOfArrayOfArrayOfLong& stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfArrayOfLong& stru);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::StructOfArrayOfArrayOfLong& stru);

FooLib_Export
size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfArrayOfLong& stru, bool align);

FooLib_Export
size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfArrayOfLong> stru, bool align);

FooLib_Export
void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfArrayOfLong> stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfArrayOfLong> stru);

FooLib_Export
bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfArrayOfLong> stru);

template <>
struct MarshalTraits<Xyz::StructOfArrayOfArrayOfLong> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct FooLib_Export StructOfArrayOfArrayOfLong_OpenDDS_KeyLessThan {
  bool operator()(const Xyz::StructOfArrayOfArrayOfLong&, const Xyz::StructOfArrayOfArrayOfLong&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Xyz {
class StructOfArrayOfArrayOfLongTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Xyz::StructOfArrayOfArrayOfLong> {
  typedef Xyz::StructOfArrayOfArrayOfLong MessageType;
  typedef Xyz::StructOfArrayOfArrayOfLongSeq MessageSequenceType;
  typedef Xyz::StructOfArrayOfArrayOfLongTypeSupport TypeSupportType;
  typedef Xyz::StructOfArrayOfArrayOfLongTypeSupportImpl TypeSupportTypeImpl;
  typedef Xyz::StructOfArrayOfArrayOfLongDataWriter DataWriterType;
  typedef Xyz::StructOfArrayOfArrayOfLongDataReader DataReaderType;
  typedef Xyz::StructOfArrayOfArrayOfLong_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Xyz::StructOfArrayOfArrayOfLong"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
class FooLib_Export StructOfArrayOfArrayOfLongTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<StructOfArrayOfArrayOfLongTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<StructOfArrayOfArrayOfLong> TraitsType;
  typedef StructOfArrayOfArrayOfLongTypeSupport TypeSupportType;
  typedef StructOfArrayOfArrayOfLongTypeSupport::_var_type _var_type;
  typedef StructOfArrayOfArrayOfLongTypeSupport::_ptr_type _ptr_type;

  StructOfArrayOfArrayOfLongTypeSupportImpl() {}
  virtual ~StructOfArrayOfArrayOfLongTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static StructOfArrayOfArrayOfLongTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
FooLib_Export
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfArrayOfLong>();
FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfArrayOfLong*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StructOfArrayOfArrayOfLong */


/* Begin STRUCT: StructOfArrayOfArrayOfAnEnum */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::StructOfArrayOfArrayOfAnEnum& stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::StructOfArrayOfArrayOfAnEnum& stru);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::StructOfArrayOfArrayOfAnEnum& stru);

FooLib_Export
size_t gen_max_marshaled_size(const Xyz::StructOfArrayOfArrayOfAnEnum& stru, bool align);

FooLib_Export
size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfArrayOfArrayOfAnEnum> stru, bool align);

FooLib_Export
void gen_find_size(KeyOnly<const Xyz::StructOfArrayOfArrayOfAnEnum> stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfArrayOfArrayOfAnEnum> stru);

FooLib_Export
bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfArrayOfArrayOfAnEnum> stru);

template <>
struct MarshalTraits<Xyz::StructOfArrayOfArrayOfAnEnum> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct FooLib_Export StructOfArrayOfArrayOfAnEnum_OpenDDS_KeyLessThan {
  bool operator()(const Xyz::StructOfArrayOfArrayOfAnEnum&, const Xyz::StructOfArrayOfArrayOfAnEnum&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Xyz {
class StructOfArrayOfArrayOfAnEnumTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Xyz::StructOfArrayOfArrayOfAnEnum> {
  typedef Xyz::StructOfArrayOfArrayOfAnEnum MessageType;
  typedef Xyz::StructOfArrayOfArrayOfAnEnumSeq MessageSequenceType;
  typedef Xyz::StructOfArrayOfArrayOfAnEnumTypeSupport TypeSupportType;
  typedef Xyz::StructOfArrayOfArrayOfAnEnumTypeSupportImpl TypeSupportTypeImpl;
  typedef Xyz::StructOfArrayOfArrayOfAnEnumDataWriter DataWriterType;
  typedef Xyz::StructOfArrayOfArrayOfAnEnumDataReader DataReaderType;
  typedef Xyz::StructOfArrayOfArrayOfAnEnum_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Xyz::StructOfArrayOfArrayOfAnEnum"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
class FooLib_Export StructOfArrayOfArrayOfAnEnumTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<StructOfArrayOfArrayOfAnEnumTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<StructOfArrayOfArrayOfAnEnum> TraitsType;
  typedef StructOfArrayOfArrayOfAnEnumTypeSupport TypeSupportType;
  typedef StructOfArrayOfArrayOfAnEnumTypeSupport::_var_type _var_type;
  typedef StructOfArrayOfArrayOfAnEnumTypeSupport::_ptr_type _ptr_type;

  StructOfArrayOfArrayOfAnEnumTypeSupportImpl() {}
  virtual ~StructOfArrayOfArrayOfAnEnumTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static StructOfArrayOfArrayOfAnEnumTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
FooLib_Export
const MetaStruct& getMetaStruct<Xyz::StructOfArrayOfArrayOfAnEnum>();
FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::StructOfArrayOfArrayOfAnEnum*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StructOfArrayOfArrayOfAnEnum */


/* Begin TYPEDEF: SeqOfSeqOfBoolean */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::SeqOfSeqOfBoolean& seq, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::SeqOfSeqOfBoolean& seq);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::SeqOfSeqOfBoolean& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::SeqOfSeqOfBoolean*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfSeqOfBoolean */


/* Begin TYPEDEF: SeqOfSeqOfString */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::SeqOfSeqOfString& seq, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::SeqOfSeqOfString& seq);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::SeqOfSeqOfString& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::SeqOfSeqOfString*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfSeqOfString */


/* Begin TYPEDEF: SeqOfSeqOfChar */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::SeqOfSeqOfChar& seq, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::SeqOfSeqOfChar& seq);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::SeqOfSeqOfChar& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::SeqOfSeqOfChar*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfSeqOfChar */


/* Begin TYPEDEF: SeqOfSeqOfOctet */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::SeqOfSeqOfOctet& seq, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::SeqOfSeqOfOctet& seq);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::SeqOfSeqOfOctet& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::SeqOfSeqOfOctet*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfSeqOfOctet */


/* Begin TYPEDEF: SeqOfSeqOfLong */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::SeqOfSeqOfLong& seq, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::SeqOfSeqOfLong& seq);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::SeqOfSeqOfLong& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::SeqOfSeqOfLong*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfSeqOfLong */


/* Begin TYPEDEF: SeqOfSeqOfAnEnum */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::SeqOfSeqOfAnEnum& seq, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::SeqOfSeqOfAnEnum& seq);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::SeqOfSeqOfAnEnum& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::SeqOfSeqOfAnEnum*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfSeqOfAnEnum */


/* Begin TYPEDEF: OctetTypedef */


/* End TYPEDEF: OctetTypedef */


/* Begin STRUCT: StructOfSeqOfSeqOfLong */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::StructOfSeqOfSeqOfLong& stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::StructOfSeqOfSeqOfLong& stru);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::StructOfSeqOfSeqOfLong& stru);

FooLib_Export
size_t gen_max_marshaled_size(const Xyz::StructOfSeqOfSeqOfLong& stru, bool align);

FooLib_Export
size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructOfSeqOfSeqOfLong> stru, bool align);

FooLib_Export
void gen_find_size(KeyOnly<const Xyz::StructOfSeqOfSeqOfLong> stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructOfSeqOfSeqOfLong> stru);

FooLib_Export
bool operator>>(Serializer& strm, KeyOnly<Xyz::StructOfSeqOfSeqOfLong> stru);

template <>
struct MarshalTraits<Xyz::StructOfSeqOfSeqOfLong> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct FooLib_Export StructOfSeqOfSeqOfLong_OpenDDS_KeyLessThan {
  bool operator()(const Xyz::StructOfSeqOfSeqOfLong&, const Xyz::StructOfSeqOfSeqOfLong&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Xyz {
class StructOfSeqOfSeqOfLongTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Xyz::StructOfSeqOfSeqOfLong> {
  typedef Xyz::StructOfSeqOfSeqOfLong MessageType;
  typedef Xyz::StructOfSeqOfSeqOfLongSeq MessageSequenceType;
  typedef Xyz::StructOfSeqOfSeqOfLongTypeSupport TypeSupportType;
  typedef Xyz::StructOfSeqOfSeqOfLongTypeSupportImpl TypeSupportTypeImpl;
  typedef Xyz::StructOfSeqOfSeqOfLongDataWriter DataWriterType;
  typedef Xyz::StructOfSeqOfSeqOfLongDataReader DataReaderType;
  typedef Xyz::StructOfSeqOfSeqOfLong_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Xyz::StructOfSeqOfSeqOfLong"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
class FooLib_Export StructOfSeqOfSeqOfLongTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<StructOfSeqOfSeqOfLongTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<StructOfSeqOfSeqOfLong> TraitsType;
  typedef StructOfSeqOfSeqOfLongTypeSupport TypeSupportType;
  typedef StructOfSeqOfSeqOfLongTypeSupport::_var_type _var_type;
  typedef StructOfSeqOfSeqOfLongTypeSupport::_ptr_type _ptr_type;

  StructOfSeqOfSeqOfLongTypeSupportImpl() {}
  virtual ~StructOfSeqOfSeqOfLongTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static StructOfSeqOfSeqOfLongTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
FooLib_Export
const MetaStruct& getMetaStruct<Xyz::StructOfSeqOfSeqOfLong>();
FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::StructOfSeqOfSeqOfLong*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StructOfSeqOfSeqOfLong */


/* Begin TYPEDEF: SevenStr */


/* End TYPEDEF: SevenStr */


/* Begin STRUCT: AStruct */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::AStruct& stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::AStruct& stru);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::AStruct& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
FooLib_Export
const MetaStruct& getMetaStruct<Xyz::AStruct>();
FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::AStruct*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: AStruct */


/* Begin TYPEDEF: SeqOfAStruct */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::SeqOfAStruct& seq, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::SeqOfAStruct& seq);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::SeqOfAStruct& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::SeqOfAStruct*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfAStruct */


/* Begin TYPEDEF: ArrayOfAStruct */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::ArrayOfAStruct_forany& arr, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::ArrayOfAStruct_forany& arr);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::ArrayOfAStruct_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::ArrayOfAStruct_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: ArrayOfAStruct */


/* Begin STRUCT: StructContainingArrayOfAStruct */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::StructContainingArrayOfAStruct& stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::StructContainingArrayOfAStruct& stru);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::StructContainingArrayOfAStruct& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
FooLib_Export
const MetaStruct& getMetaStruct<Xyz::StructContainingArrayOfAStruct>();
FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::StructContainingArrayOfAStruct*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StructContainingArrayOfAStruct */


/* Begin UNION: AUnion */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::AUnion& uni, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::AUnion& uni);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::AUnion& uni);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::AUnion*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End UNION: AUnion */


/* Begin UNION: BigUnion */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::BigUnion& uni, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::BigUnion& uni);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::BigUnion& uni);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::BigUnion*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End UNION: BigUnion */


/* Begin STRUCT: StructAUnion */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::StructAUnion& stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::StructAUnion& stru);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::StructAUnion& stru);

FooLib_Export
size_t gen_max_marshaled_size(const Xyz::StructAUnion& stru, bool align);

FooLib_Export
size_t gen_max_marshaled_size(KeyOnly<const Xyz::StructAUnion> stru, bool align);

FooLib_Export
void gen_find_size(KeyOnly<const Xyz::StructAUnion> stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, KeyOnly<const Xyz::StructAUnion> stru);

FooLib_Export
bool operator>>(Serializer& strm, KeyOnly<Xyz::StructAUnion> stru);

template <>
struct MarshalTraits<Xyz::StructAUnion> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct FooLib_Export StructAUnion_OpenDDS_KeyLessThan {
  bool operator()(const Xyz::StructAUnion&, const Xyz::StructAUnion&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace Xyz {
class StructAUnionTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Xyz::StructAUnion> {
  typedef Xyz::StructAUnion MessageType;
  typedef Xyz::StructAUnionSeq MessageSequenceType;
  typedef Xyz::StructAUnionTypeSupport TypeSupportType;
  typedef Xyz::StructAUnionTypeSupportImpl TypeSupportTypeImpl;
  typedef Xyz::StructAUnionDataWriter DataWriterType;
  typedef Xyz::StructAUnionDataReader DataReaderType;
  typedef Xyz::StructAUnion_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Xyz::StructAUnion"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
class FooLib_Export StructAUnionTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<StructAUnionTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<StructAUnion> TraitsType;
  typedef StructAUnionTypeSupport TypeSupportType;
  typedef StructAUnionTypeSupport::_var_type _var_type;
  typedef StructAUnionTypeSupport::_ptr_type _ptr_type;

  StructAUnionTypeSupportImpl() {}
  virtual ~StructAUnionTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static StructAUnionTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
FooLib_Export
const MetaStruct& getMetaStruct<Xyz::StructAUnion>();
FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::StructAUnion*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StructAUnion */


/* Begin TYPEDEF: SeqOfAUnion */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::SeqOfAUnion& seq, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::SeqOfAUnion& seq);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::SeqOfAUnion& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::SeqOfAUnion*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SeqOfAUnion */


/* Begin TYPEDEF: AStructSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::AStructSeq& seq, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::AStructSeq& seq);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::AStructSeq& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::AStructSeq*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: AStructSeq */


/* Begin TYPEDEF: ArrayOfAStructSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::ArrayOfAStructSeq_forany& arr, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::ArrayOfAStructSeq_forany& arr);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::ArrayOfAStructSeq_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::ArrayOfAStructSeq_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: ArrayOfAStructSeq */


/* Begin STRUCT: StructContainingArrayOfAStructSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::StructContainingArrayOfAStructSeq& stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::StructContainingArrayOfAStructSeq& stru);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::StructContainingArrayOfAStructSeq& stru);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
FooLib_Export
const MetaStruct& getMetaStruct<Xyz::StructContainingArrayOfAStructSeq>();
FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::StructContainingArrayOfAStructSeq*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StructContainingArrayOfAStructSeq */


/* Begin TYPEDEF: BigUnionSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::BigUnionSeq& seq, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::BigUnionSeq& seq);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::BigUnionSeq& seq);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::BigUnionSeq*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: BigUnionSeq */


/* Begin TYPEDEF: OctetArray */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::OctetArray_forany& arr, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::OctetArray_forany& arr);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::OctetArray_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::OctetArray_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: OctetArray */


/* Begin STRUCT: Foo */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

FooLib_Export
void gen_find_size(const Xyz::Foo& stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, const Xyz::Foo& stru);

FooLib_Export
bool operator>>(Serializer& strm, Xyz::Foo& stru);

FooLib_Export
size_t gen_max_marshaled_size(const Xyz::Foo& stru, bool align);

FooLib_Export
size_t gen_max_marshaled_size(KeyOnly<const Xyz::Foo> stru, bool align);

FooLib_Export
void gen_find_size(KeyOnly<const Xyz::Foo> stru, size_t& size, size_t& padding);

FooLib_Export
bool operator<<(Serializer& strm, KeyOnly<const Xyz::Foo> stru);

FooLib_Export
bool operator>>(Serializer& strm, KeyOnly<Xyz::Foo> stru);

template <>
struct MarshalTraits<Xyz::Foo> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct FooLib_Export Foo_OpenDDS_KeyLessThan {
  bool operator()(const Xyz::Foo& v1, const Xyz::Foo& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.key < v2.key) return true;
    if (v2.key < v1.key) return false;
    if (v1.xcolor < v2.xcolor) return true;
    if (v2.xcolor < v1.xcolor) return false;
    return false;
  }
};
}


namespace Xyz {
class FooTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<Xyz::Foo> {
  typedef Xyz::Foo MessageType;
  typedef Xyz::FooSeq MessageSequenceType;
  typedef Xyz::FooTypeSupport TypeSupportType;
  typedef Xyz::FooTypeSupportImpl TypeSupportTypeImpl;
  typedef Xyz::FooDataWriter DataWriterType;
  typedef Xyz::FooDataReader DataReaderType;
  typedef Xyz::Foo_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "Xyz::Foo"; }
  static bool gen_has_key () { return true; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Xyz {
class FooLib_Export FooTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<FooTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<Foo> TraitsType;
  typedef FooTypeSupport TypeSupportType;
  typedef FooTypeSupport::_var_type _var_type;
  typedef FooTypeSupport::_ptr_type _ptr_type;

  FooTypeSupportImpl() {}
  virtual ~FooTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static FooTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
FooLib_Export
const MetaStruct& getMetaStruct<Xyz::Foo>();
FooLib_Export
void gen_skip_over(Serializer& ser, Xyz::Foo*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Foo */

/* End MODULE: Xyz */
#endif /* OPENDDS_IDL_GENERATED_FOODEFTYPESUPPORTIMPL_H_GQYGAU */
