/* Generated by /Users/yc/MyGithub/imac-project/OpenDDS/OpenDDS-3.10/bin/opendds_idl version 3.10 (ACE version 6.2a_p11) running on input file DdsDcpsCore.idl */
#include "DCPS/DdsDcps_pch.h"
#include "DdsDcpsCoreTypeSupportImpl.h"

#include <cstring>
#include <stdexcept>
#include "dds/CorbaSeq/LongSeqTypeSupportImpl.h"
#include "dds/CorbaSeq/OctetSeqTypeSupportImpl.h"
#include "dds/DCPS/BuiltInTopicUtils.h"
#include "dds/DCPS/ContentFilteredTopicImpl.h"
#include "dds/DCPS/DataReaderImpl_T.h"
#include "dds/DCPS/DataWriterImpl_T.h"
#include "dds/DCPS/FilterEvaluator.h"
#include "dds/DCPS/MultiTopicDataReader_T.h"
#include "dds/DCPS/PoolAllocator.h"
#include "dds/DCPS/PublicationInstance.h"
#include "dds/DCPS/PublisherImpl.h"
#include "dds/DCPS/Qos_Helper.h"
#include "dds/DCPS/RakeData.h"
#include "dds/DCPS/RakeResults_T.h"
#include "dds/DCPS/ReceivedDataElementList.h"
#include "dds/DCPS/Registered_Data_Types.h"
#include "dds/DCPS/Service_Participant.h"
#include "dds/DCPS/SubscriberImpl.h"
#include "dds/DCPS/Util.h"
#include "dds/DCPS/debug.h"
#include "dds/DdsDcpsDomainC.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: LongSeq */


/* End TYPEDEF: LongSeq */

/* End MODULE: CORBA */


/* Begin MODULE: DDS */



/* Begin TYPEDEF: StringSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::StringSeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    find_size_ulong(size, padding);
    if (seq[i]) {
      size += ACE_OS::strlen(seq[i]) + 1;
    }
  }
}

bool operator<<(Serializer& strm, const DDS::StringSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, DDS::StringSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq.get_buffer()[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, DDS::StringSeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    ACE_CDR::ULong strlength;
    ser >> strlength;
    ser.skip(strlength);
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: StringSeq */


/* Begin TYPEDEF: InstanceHandle_t */


/* End TYPEDEF: InstanceHandle_t */


/* Begin TYPEDEF: BuiltinTopicKeyValue */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::BuiltinTopicKeyValue_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += 3 * gen_max_marshaled_size(CORBA::Long());
}

bool operator<<(Serializer& strm, const DDS::BuiltinTopicKeyValue_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.write_long_array(arr.in(), 3);
}

bool operator>>(Serializer& strm, DDS::BuiltinTopicKeyValue_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.read_long_array(arr.out(), 3);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, DDS::BuiltinTopicKeyValue_forany*)
{
  ACE_UNUSED_ARG(ser);
  ser.skip(3, 4);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: BuiltinTopicKeyValue */


/* Begin TYPEDEF: InstanceHandleSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::InstanceHandleSeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  size += seq.length() * gen_max_marshaled_size(CORBA::Long());
}

bool operator<<(Serializer& strm, const DDS::InstanceHandleSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  return strm.write_long_array(seq.get_buffer(), length);
}

bool operator>>(Serializer& strm, DDS::InstanceHandleSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  if (length == 0) {
    return true;
  }
  return strm.read_long_array(seq.get_buffer(), length);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, DDS::InstanceHandleSeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  ser.skip(length, 4);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: InstanceHandleSeq */


/* Begin TYPEDEF: QosPolicyId_t */


/* End TYPEDEF: QosPolicyId_t */


/* Begin STRUCT: QosPolicyCount */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::QosPolicyCount& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.policy_id);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.count);
}

bool operator<<(Serializer& strm, const DDS::QosPolicyCount& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.policy_id)
    && (strm << stru.count);
}

bool operator>>(Serializer& strm, DDS::QosPolicyCount& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.policy_id)
    && (strm >> stru.count);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::QosPolicyCount> : MetaStruct {
  typedef DDS::QosPolicyCount T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::QosPolicyCount& typed = *static_cast<const DDS::QosPolicyCount*>(stru);
    if (std::strcmp(field, "policy_id") == 0) {
      return typed.policy_id;
    }
    if (std::strcmp(field, "count") == 0) {
      return typed.count;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::QosPolicyCount)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "policy_id") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'policy_id' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "count") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'count' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::QosPolicyCount");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "policy_id") == 0) {
      return make_field_cmp(&T::policy_id, next);
    }
    if (std::strcmp(field, "count") == 0) {
      return make_field_cmp(&T::count, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::QosPolicyCount)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"policy_id", "count", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "policy_id") == 0) {
      return &static_cast<const T*>(stru)->policy_id;
    }
    if (std::strcmp(field, "count") == 0) {
      return &static_cast<const T*>(stru)->count;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::QosPolicyCount)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "policy_id") == 0) {
      static_cast<T*>(lhs)->policy_id = *static_cast<const DDS::QosPolicyId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "count") == 0) {
      static_cast<T*>(lhs)->count = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::QosPolicyCount)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "policy_id") == 0) {
      return static_cast<const T*>(lhs)->policy_id == static_cast<const T*>(rhs)->policy_id;
    }
    if (std::strcmp(field, "count") == 0) {
      return static_cast<const T*>(lhs)->count == static_cast<const T*>(rhs)->count;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::QosPolicyCount)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::QosPolicyCount>()
{
  static MetaStructImpl<DDS::QosPolicyCount> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::QosPolicyCount*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::QosPolicyCount>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: QosPolicyCount */


/* Begin TYPEDEF: QosPolicyCountSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::QosPolicyCountSeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const DDS::QosPolicyCountSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, DDS::QosPolicyCountSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, DDS::QosPolicyCountSeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<DDS::QosPolicyCount*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: QosPolicyCountSeq */


/* Begin TYPEDEF: OctetSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::OctetSeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  size += seq.length() * max_marshaled_size_octet();
}

bool operator<<(Serializer& strm, const DDS::OctetSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  return strm.write_octet_array(seq.get_buffer(), length);
}

bool operator>>(Serializer& strm, DDS::OctetSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  if (length == 0) {
    return true;
  }
  return strm.read_octet_array(seq.get_buffer(), length);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, DDS::OctetSeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  ser.skip(length, 1);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: OctetSeq */


/* Begin STRUCT: Duration_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::Duration_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.sec);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.nanosec);
}

bool operator<<(Serializer& strm, const DDS::Duration_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.sec)
    && (strm << stru.nanosec);
}

bool operator>>(Serializer& strm, DDS::Duration_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.sec)
    && (strm >> stru.nanosec);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::Duration_t> : MetaStruct {
  typedef DDS::Duration_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::Duration_t& typed = *static_cast<const DDS::Duration_t*>(stru);
    if (std::strcmp(field, "sec") == 0) {
      return typed.sec;
    }
    if (std::strcmp(field, "nanosec") == 0) {
      return typed.nanosec;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::Duration_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "sec") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'sec' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "nanosec") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'nanosec' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::Duration_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "sec") == 0) {
      return make_field_cmp(&T::sec, next);
    }
    if (std::strcmp(field, "nanosec") == 0) {
      return make_field_cmp(&T::nanosec, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::Duration_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"sec", "nanosec", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "sec") == 0) {
      return &static_cast<const T*>(stru)->sec;
    }
    if (std::strcmp(field, "nanosec") == 0) {
      return &static_cast<const T*>(stru)->nanosec;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::Duration_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "sec") == 0) {
      static_cast<T*>(lhs)->sec = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "nanosec") == 0) {
      static_cast<T*>(lhs)->nanosec = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::Duration_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "sec") == 0) {
      return static_cast<const T*>(lhs)->sec == static_cast<const T*>(rhs)->sec;
    }
    if (std::strcmp(field, "nanosec") == 0) {
      return static_cast<const T*>(lhs)->nanosec == static_cast<const T*>(rhs)->nanosec;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::Duration_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::Duration_t>()
{
  static MetaStructImpl<DDS::Duration_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::Duration_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::Duration_t>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Duration_t */


/* Begin STRUCT: UserDataQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::UserDataQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.value, size, padding);
}

bool operator<<(Serializer& strm, const DDS::UserDataQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.value);
}

bool operator>>(Serializer& strm, DDS::UserDataQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.value);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::UserDataQosPolicy> : MetaStruct {
  typedef DDS::UserDataQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::UserDataQosPolicy& typed = *static_cast<const DDS::UserDataQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::UserDataQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<DDS::OctetSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::UserDataQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::UserDataQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::UserDataQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const DDS::OctetSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::UserDataQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::UserDataQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::UserDataQosPolicy>()
{
  static MetaStructImpl<DDS::UserDataQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::UserDataQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::UserDataQosPolicy>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: UserDataQosPolicy */


/* Begin STRUCT: GroupDataQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::GroupDataQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.value, size, padding);
}

bool operator<<(Serializer& strm, const DDS::GroupDataQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.value);
}

bool operator>>(Serializer& strm, DDS::GroupDataQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.value);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::GroupDataQosPolicy> : MetaStruct {
  typedef DDS::GroupDataQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::GroupDataQosPolicy& typed = *static_cast<const DDS::GroupDataQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::GroupDataQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<DDS::OctetSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::GroupDataQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::GroupDataQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::GroupDataQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const DDS::OctetSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::GroupDataQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::GroupDataQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::GroupDataQosPolicy>()
{
  static MetaStructImpl<DDS::GroupDataQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::GroupDataQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::GroupDataQosPolicy>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: GroupDataQosPolicy */


/* Begin STRUCT: TopicDataQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::TopicDataQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.value, size, padding);
}

bool operator<<(Serializer& strm, const DDS::TopicDataQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.value);
}

bool operator>>(Serializer& strm, DDS::TopicDataQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.value);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::TopicDataQosPolicy> : MetaStruct {
  typedef DDS::TopicDataQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::TopicDataQosPolicy& typed = *static_cast<const DDS::TopicDataQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TopicDataQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<DDS::OctetSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::TopicDataQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TopicDataQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TopicDataQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const DDS::OctetSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TopicDataQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TopicDataQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::TopicDataQosPolicy>()
{
  static MetaStructImpl<DDS::TopicDataQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::TopicDataQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::TopicDataQosPolicy>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TopicDataQosPolicy */


/* Begin STRUCT: PartitionQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::PartitionQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.name, size, padding);
}

bool operator<<(Serializer& strm, const DDS::PartitionQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.name);
}

bool operator>>(Serializer& strm, DDS::PartitionQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.name);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::PartitionQosPolicy> : MetaStruct {
  typedef DDS::PartitionQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::PartitionQosPolicy& typed = *static_cast<const DDS::PartitionQosPolicy*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PartitionQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<DDS::StringSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::PartitionQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PartitionQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"name", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "name") == 0) {
      return &static_cast<const T*>(stru)->name;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PartitionQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "name") == 0) {
      static_cast<T*>(lhs)->name = *static_cast<const DDS::StringSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PartitionQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PartitionQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::PartitionQosPolicy>()
{
  static MetaStructImpl<DDS::PartitionQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::PartitionQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::PartitionQosPolicy>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PartitionQosPolicy */


/* Begin ENUM: HistoryQosPolicyKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const DDS::HistoryQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm, DDS::HistoryQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    enumval = static_cast<DDS::HistoryQosPolicyKind>(temp);
    return true;
  }
  return false;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

const char* gen_DDS_HistoryQosPolicyKind_names[] = {
  "KEEP_LAST_HISTORY_QOS",
  "KEEP_ALL_HISTORY_QOS"
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End ENUM: HistoryQosPolicyKind */


/* Begin ENUM: DurabilityQosPolicyKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const DDS::DurabilityQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm, DDS::DurabilityQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    enumval = static_cast<DDS::DurabilityQosPolicyKind>(temp);
    return true;
  }
  return false;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

const char* gen_DDS_DurabilityQosPolicyKind_names[] = {
  "VOLATILE_DURABILITY_QOS",
  "TRANSIENT_LOCAL_DURABILITY_QOS",
  "TRANSIENT_DURABILITY_QOS",
  "PERSISTENT_DURABILITY_QOS"
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End ENUM: DurabilityQosPolicyKind */


/* Begin STRUCT: DurabilityQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::DurabilityQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
}

bool operator<<(Serializer& strm, const DDS::DurabilityQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.kind);
}

bool operator>>(Serializer& strm, DDS::DurabilityQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.kind);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::DurabilityQosPolicy> : MetaStruct {
  typedef DDS::DurabilityQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::DurabilityQosPolicy& typed = *static_cast<const DDS::DurabilityQosPolicy*>(stru);
    if (std::strcmp(field, "kind") == 0) {
      return gen_DDS_DurabilityQosPolicyKind_names[typed.kind];
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DurabilityQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'kind' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::DurabilityQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "kind") == 0) {
      return make_field_cmp(&T::kind, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DurabilityQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"kind", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      return &static_cast<const T*>(stru)->kind;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DurabilityQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "kind") == 0) {
      static_cast<T*>(lhs)->kind = *static_cast<const DDS::DurabilityQosPolicyKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DurabilityQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "kind") == 0) {
      return static_cast<const T*>(lhs)->kind == static_cast<const T*>(rhs)->kind;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DurabilityQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::DurabilityQosPolicy>()
{
  static MetaStructImpl<DDS::DurabilityQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::DurabilityQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::DurabilityQosPolicy>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DurabilityQosPolicy */


/* Begin STRUCT: DurabilityServiceQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::DurabilityServiceQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.service_cleanup_delay, size, padding);
  find_size_ulong(size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.history_depth);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.max_samples);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.max_instances);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.max_samples_per_instance);
}

bool operator<<(Serializer& strm, const DDS::DurabilityServiceQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.service_cleanup_delay)
    && (strm << stru.history_kind)
    && (strm << stru.history_depth)
    && (strm << stru.max_samples)
    && (strm << stru.max_instances)
    && (strm << stru.max_samples_per_instance);
}

bool operator>>(Serializer& strm, DDS::DurabilityServiceQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.service_cleanup_delay)
    && (strm >> stru.history_kind)
    && (strm >> stru.history_depth)
    && (strm >> stru.max_samples)
    && (strm >> stru.max_instances)
    && (strm >> stru.max_samples_per_instance);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::DurabilityServiceQosPolicy> : MetaStruct {
  typedef DDS::DurabilityServiceQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::DurabilityServiceQosPolicy& typed = *static_cast<const DDS::DurabilityServiceQosPolicy*>(stru);
    if (std::strncmp(field, "service_cleanup_delay.", 22) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(&typed.service_cleanup_delay, field + 22);
    }
    if (std::strcmp(field, "history_kind") == 0) {
      return gen_DDS_HistoryQosPolicyKind_names[typed.history_kind];
    }
    if (std::strcmp(field, "history_depth") == 0) {
      return typed.history_depth;
    }
    if (std::strcmp(field, "max_samples") == 0) {
      return typed.max_samples;
    }
    if (std::strcmp(field, "max_instances") == 0) {
      return typed.max_instances;
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      return typed.max_samples_per_instance;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DurabilityServiceQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "service_cleanup_delay.", 22) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(ser, field + 22);
    } else {
      gen_skip_over(ser, static_cast<DDS::Duration_t*>(0));
    }
    if (std::strcmp(field, "history_kind") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'history_kind' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "history_depth") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'history_depth' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "max_samples") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'max_samples' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "max_instances") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'max_instances' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'max_samples_per_instance' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::DurabilityServiceQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "service_cleanup_delay.", 22) == 0) {
      return make_struct_cmp(&T::service_cleanup_delay, getMetaStruct<DDS::Duration_t>().create_qc_comparator(field + 22), next);
    }
    if (std::strcmp(field, "history_kind") == 0) {
      return make_field_cmp(&T::history_kind, next);
    }
    if (std::strcmp(field, "history_depth") == 0) {
      return make_field_cmp(&T::history_depth, next);
    }
    if (std::strcmp(field, "max_samples") == 0) {
      return make_field_cmp(&T::max_samples, next);
    }
    if (std::strcmp(field, "max_instances") == 0) {
      return make_field_cmp(&T::max_instances, next);
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      return make_field_cmp(&T::max_samples_per_instance, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DurabilityServiceQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"service_cleanup_delay", "history_kind", "history_depth", "max_samples", "max_instances", "max_samples_per_instance", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "service_cleanup_delay") == 0) {
      return &static_cast<const T*>(stru)->service_cleanup_delay;
    }
    if (std::strcmp(field, "history_kind") == 0) {
      return &static_cast<const T*>(stru)->history_kind;
    }
    if (std::strcmp(field, "history_depth") == 0) {
      return &static_cast<const T*>(stru)->history_depth;
    }
    if (std::strcmp(field, "max_samples") == 0) {
      return &static_cast<const T*>(stru)->max_samples;
    }
    if (std::strcmp(field, "max_instances") == 0) {
      return &static_cast<const T*>(stru)->max_instances;
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      return &static_cast<const T*>(stru)->max_samples_per_instance;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DurabilityServiceQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "service_cleanup_delay") == 0) {
      static_cast<T*>(lhs)->service_cleanup_delay = *static_cast<const DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "history_kind") == 0) {
      static_cast<T*>(lhs)->history_kind = *static_cast<const DDS::HistoryQosPolicyKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "history_depth") == 0) {
      static_cast<T*>(lhs)->history_depth = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "max_samples") == 0) {
      static_cast<T*>(lhs)->max_samples = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "max_instances") == 0) {
      static_cast<T*>(lhs)->max_instances = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      static_cast<T*>(lhs)->max_samples_per_instance = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DurabilityServiceQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "history_kind") == 0) {
      return static_cast<const T*>(lhs)->history_kind == static_cast<const T*>(rhs)->history_kind;
    }
    if (std::strcmp(field, "history_depth") == 0) {
      return static_cast<const T*>(lhs)->history_depth == static_cast<const T*>(rhs)->history_depth;
    }
    if (std::strcmp(field, "max_samples") == 0) {
      return static_cast<const T*>(lhs)->max_samples == static_cast<const T*>(rhs)->max_samples;
    }
    if (std::strcmp(field, "max_instances") == 0) {
      return static_cast<const T*>(lhs)->max_instances == static_cast<const T*>(rhs)->max_instances;
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      return static_cast<const T*>(lhs)->max_samples_per_instance == static_cast<const T*>(rhs)->max_samples_per_instance;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DurabilityServiceQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::DurabilityServiceQosPolicy>()
{
  static MetaStructImpl<DDS::DurabilityServiceQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::DurabilityServiceQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::DurabilityServiceQosPolicy>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DurabilityServiceQosPolicy */


/* Begin STRUCT: DeadlineQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::DeadlineQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.period, size, padding);
}

bool operator<<(Serializer& strm, const DDS::DeadlineQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.period);
}

bool operator>>(Serializer& strm, DDS::DeadlineQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.period);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::DeadlineQosPolicy> : MetaStruct {
  typedef DDS::DeadlineQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::DeadlineQosPolicy& typed = *static_cast<const DDS::DeadlineQosPolicy*>(stru);
    if (std::strncmp(field, "period.", 7) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(&typed.period, field + 7);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DeadlineQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "period.", 7) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(ser, field + 7);
    } else {
      gen_skip_over(ser, static_cast<DDS::Duration_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::DeadlineQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "period.", 7) == 0) {
      return make_struct_cmp(&T::period, getMetaStruct<DDS::Duration_t>().create_qc_comparator(field + 7), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DeadlineQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"period", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "period") == 0) {
      return &static_cast<const T*>(stru)->period;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DeadlineQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "period") == 0) {
      static_cast<T*>(lhs)->period = *static_cast<const DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DeadlineQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DeadlineQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::DeadlineQosPolicy>()
{
  static MetaStructImpl<DDS::DeadlineQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::DeadlineQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::DeadlineQosPolicy>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DeadlineQosPolicy */


/* Begin STRUCT: LatencyBudgetQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::LatencyBudgetQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.duration, size, padding);
}

bool operator<<(Serializer& strm, const DDS::LatencyBudgetQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.duration);
}

bool operator>>(Serializer& strm, DDS::LatencyBudgetQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.duration);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::LatencyBudgetQosPolicy> : MetaStruct {
  typedef DDS::LatencyBudgetQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::LatencyBudgetQosPolicy& typed = *static_cast<const DDS::LatencyBudgetQosPolicy*>(stru);
    if (std::strncmp(field, "duration.", 9) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(&typed.duration, field + 9);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::LatencyBudgetQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "duration.", 9) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<DDS::Duration_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::LatencyBudgetQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "duration.", 9) == 0) {
      return make_struct_cmp(&T::duration, getMetaStruct<DDS::Duration_t>().create_qc_comparator(field + 9), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::LatencyBudgetQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"duration", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "duration") == 0) {
      return &static_cast<const T*>(stru)->duration;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::LatencyBudgetQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "duration") == 0) {
      static_cast<T*>(lhs)->duration = *static_cast<const DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::LatencyBudgetQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::LatencyBudgetQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::LatencyBudgetQosPolicy>()
{
  static MetaStructImpl<DDS::LatencyBudgetQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::LatencyBudgetQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::LatencyBudgetQosPolicy>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: LatencyBudgetQosPolicy */


/* Begin ENUM: LivelinessQosPolicyKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const DDS::LivelinessQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm, DDS::LivelinessQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    enumval = static_cast<DDS::LivelinessQosPolicyKind>(temp);
    return true;
  }
  return false;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

const char* gen_DDS_LivelinessQosPolicyKind_names[] = {
  "AUTOMATIC_LIVELINESS_QOS",
  "MANUAL_BY_PARTICIPANT_LIVELINESS_QOS",
  "MANUAL_BY_TOPIC_LIVELINESS_QOS"
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End ENUM: LivelinessQosPolicyKind */


/* Begin STRUCT: LivelinessQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::LivelinessQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  gen_find_size(stru.lease_duration, size, padding);
}

bool operator<<(Serializer& strm, const DDS::LivelinessQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.kind)
    && (strm << stru.lease_duration);
}

bool operator>>(Serializer& strm, DDS::LivelinessQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.kind)
    && (strm >> stru.lease_duration);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::LivelinessQosPolicy> : MetaStruct {
  typedef DDS::LivelinessQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::LivelinessQosPolicy& typed = *static_cast<const DDS::LivelinessQosPolicy*>(stru);
    if (std::strcmp(field, "kind") == 0) {
      return gen_DDS_LivelinessQosPolicyKind_names[typed.kind];
    }
    if (std::strncmp(field, "lease_duration.", 15) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(&typed.lease_duration, field + 15);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::LivelinessQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'kind' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strncmp(field, "lease_duration.", 15) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(ser, field + 15);
    } else {
      gen_skip_over(ser, static_cast<DDS::Duration_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::LivelinessQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "kind") == 0) {
      return make_field_cmp(&T::kind, next);
    }
    if (std::strncmp(field, "lease_duration.", 15) == 0) {
      return make_struct_cmp(&T::lease_duration, getMetaStruct<DDS::Duration_t>().create_qc_comparator(field + 15), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::LivelinessQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"kind", "lease_duration", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      return &static_cast<const T*>(stru)->kind;
    }
    if (std::strcmp(field, "lease_duration") == 0) {
      return &static_cast<const T*>(stru)->lease_duration;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::LivelinessQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "kind") == 0) {
      static_cast<T*>(lhs)->kind = *static_cast<const DDS::LivelinessQosPolicyKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "lease_duration") == 0) {
      static_cast<T*>(lhs)->lease_duration = *static_cast<const DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::LivelinessQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "kind") == 0) {
      return static_cast<const T*>(lhs)->kind == static_cast<const T*>(rhs)->kind;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::LivelinessQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::LivelinessQosPolicy>()
{
  static MetaStructImpl<DDS::LivelinessQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::LivelinessQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::LivelinessQosPolicy>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: LivelinessQosPolicy */


/* Begin ENUM: ReliabilityQosPolicyKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const DDS::ReliabilityQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm, DDS::ReliabilityQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    enumval = static_cast<DDS::ReliabilityQosPolicyKind>(temp);
    return true;
  }
  return false;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

const char* gen_DDS_ReliabilityQosPolicyKind_names[] = {
  "BEST_EFFORT_RELIABILITY_QOS",
  "RELIABLE_RELIABILITY_QOS"
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End ENUM: ReliabilityQosPolicyKind */


/* Begin STRUCT: ReliabilityQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::ReliabilityQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  gen_find_size(stru.max_blocking_time, size, padding);
}

bool operator<<(Serializer& strm, const DDS::ReliabilityQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.kind)
    && (strm << stru.max_blocking_time);
}

bool operator>>(Serializer& strm, DDS::ReliabilityQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.kind)
    && (strm >> stru.max_blocking_time);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::ReliabilityQosPolicy> : MetaStruct {
  typedef DDS::ReliabilityQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::ReliabilityQosPolicy& typed = *static_cast<const DDS::ReliabilityQosPolicy*>(stru);
    if (std::strcmp(field, "kind") == 0) {
      return gen_DDS_ReliabilityQosPolicyKind_names[typed.kind];
    }
    if (std::strncmp(field, "max_blocking_time.", 18) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(&typed.max_blocking_time, field + 18);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ReliabilityQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'kind' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strncmp(field, "max_blocking_time.", 18) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(ser, field + 18);
    } else {
      gen_skip_over(ser, static_cast<DDS::Duration_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::ReliabilityQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "kind") == 0) {
      return make_field_cmp(&T::kind, next);
    }
    if (std::strncmp(field, "max_blocking_time.", 18) == 0) {
      return make_struct_cmp(&T::max_blocking_time, getMetaStruct<DDS::Duration_t>().create_qc_comparator(field + 18), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ReliabilityQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"kind", "max_blocking_time", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      return &static_cast<const T*>(stru)->kind;
    }
    if (std::strcmp(field, "max_blocking_time") == 0) {
      return &static_cast<const T*>(stru)->max_blocking_time;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ReliabilityQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "kind") == 0) {
      static_cast<T*>(lhs)->kind = *static_cast<const DDS::ReliabilityQosPolicyKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "max_blocking_time") == 0) {
      static_cast<T*>(lhs)->max_blocking_time = *static_cast<const DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ReliabilityQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "kind") == 0) {
      return static_cast<const T*>(lhs)->kind == static_cast<const T*>(rhs)->kind;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ReliabilityQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::ReliabilityQosPolicy>()
{
  static MetaStructImpl<DDS::ReliabilityQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::ReliabilityQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::ReliabilityQosPolicy>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ReliabilityQosPolicy */


/* Begin ENUM: DestinationOrderQosPolicyKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const DDS::DestinationOrderQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm, DDS::DestinationOrderQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    enumval = static_cast<DDS::DestinationOrderQosPolicyKind>(temp);
    return true;
  }
  return false;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

const char* gen_DDS_DestinationOrderQosPolicyKind_names[] = {
  "BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS",
  "BY_SOURCE_TIMESTAMP_DESTINATIONORDER_QOS"
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End ENUM: DestinationOrderQosPolicyKind */


/* Begin STRUCT: DestinationOrderQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::DestinationOrderQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
}

bool operator<<(Serializer& strm, const DDS::DestinationOrderQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.kind);
}

bool operator>>(Serializer& strm, DDS::DestinationOrderQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.kind);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::DestinationOrderQosPolicy> : MetaStruct {
  typedef DDS::DestinationOrderQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::DestinationOrderQosPolicy& typed = *static_cast<const DDS::DestinationOrderQosPolicy*>(stru);
    if (std::strcmp(field, "kind") == 0) {
      return gen_DDS_DestinationOrderQosPolicyKind_names[typed.kind];
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DestinationOrderQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'kind' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::DestinationOrderQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "kind") == 0) {
      return make_field_cmp(&T::kind, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DestinationOrderQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"kind", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      return &static_cast<const T*>(stru)->kind;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DestinationOrderQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "kind") == 0) {
      static_cast<T*>(lhs)->kind = *static_cast<const DDS::DestinationOrderQosPolicyKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DestinationOrderQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "kind") == 0) {
      return static_cast<const T*>(lhs)->kind == static_cast<const T*>(rhs)->kind;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DestinationOrderQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::DestinationOrderQosPolicy>()
{
  static MetaStructImpl<DDS::DestinationOrderQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::DestinationOrderQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::DestinationOrderQosPolicy>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DestinationOrderQosPolicy */


/* Begin STRUCT: HistoryQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::HistoryQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.depth);
}

bool operator<<(Serializer& strm, const DDS::HistoryQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.kind)
    && (strm << stru.depth);
}

bool operator>>(Serializer& strm, DDS::HistoryQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.kind)
    && (strm >> stru.depth);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::HistoryQosPolicy> : MetaStruct {
  typedef DDS::HistoryQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::HistoryQosPolicy& typed = *static_cast<const DDS::HistoryQosPolicy*>(stru);
    if (std::strcmp(field, "kind") == 0) {
      return gen_DDS_HistoryQosPolicyKind_names[typed.kind];
    }
    if (std::strcmp(field, "depth") == 0) {
      return typed.depth;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::HistoryQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'kind' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "depth") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'depth' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::HistoryQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "kind") == 0) {
      return make_field_cmp(&T::kind, next);
    }
    if (std::strcmp(field, "depth") == 0) {
      return make_field_cmp(&T::depth, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::HistoryQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"kind", "depth", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      return &static_cast<const T*>(stru)->kind;
    }
    if (std::strcmp(field, "depth") == 0) {
      return &static_cast<const T*>(stru)->depth;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::HistoryQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "kind") == 0) {
      static_cast<T*>(lhs)->kind = *static_cast<const DDS::HistoryQosPolicyKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "depth") == 0) {
      static_cast<T*>(lhs)->depth = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::HistoryQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "kind") == 0) {
      return static_cast<const T*>(lhs)->kind == static_cast<const T*>(rhs)->kind;
    }
    if (std::strcmp(field, "depth") == 0) {
      return static_cast<const T*>(lhs)->depth == static_cast<const T*>(rhs)->depth;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::HistoryQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::HistoryQosPolicy>()
{
  static MetaStructImpl<DDS::HistoryQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::HistoryQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::HistoryQosPolicy>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: HistoryQosPolicy */


/* Begin STRUCT: ResourceLimitsQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::ResourceLimitsQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.max_samples);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.max_instances);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.max_samples_per_instance);
}

bool operator<<(Serializer& strm, const DDS::ResourceLimitsQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.max_samples)
    && (strm << stru.max_instances)
    && (strm << stru.max_samples_per_instance);
}

bool operator>>(Serializer& strm, DDS::ResourceLimitsQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.max_samples)
    && (strm >> stru.max_instances)
    && (strm >> stru.max_samples_per_instance);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::ResourceLimitsQosPolicy> : MetaStruct {
  typedef DDS::ResourceLimitsQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::ResourceLimitsQosPolicy& typed = *static_cast<const DDS::ResourceLimitsQosPolicy*>(stru);
    if (std::strcmp(field, "max_samples") == 0) {
      return typed.max_samples;
    }
    if (std::strcmp(field, "max_instances") == 0) {
      return typed.max_instances;
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      return typed.max_samples_per_instance;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ResourceLimitsQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "max_samples") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'max_samples' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "max_instances") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'max_instances' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'max_samples_per_instance' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::ResourceLimitsQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "max_samples") == 0) {
      return make_field_cmp(&T::max_samples, next);
    }
    if (std::strcmp(field, "max_instances") == 0) {
      return make_field_cmp(&T::max_instances, next);
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      return make_field_cmp(&T::max_samples_per_instance, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ResourceLimitsQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"max_samples", "max_instances", "max_samples_per_instance", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "max_samples") == 0) {
      return &static_cast<const T*>(stru)->max_samples;
    }
    if (std::strcmp(field, "max_instances") == 0) {
      return &static_cast<const T*>(stru)->max_instances;
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      return &static_cast<const T*>(stru)->max_samples_per_instance;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ResourceLimitsQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "max_samples") == 0) {
      static_cast<T*>(lhs)->max_samples = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "max_instances") == 0) {
      static_cast<T*>(lhs)->max_instances = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      static_cast<T*>(lhs)->max_samples_per_instance = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ResourceLimitsQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "max_samples") == 0) {
      return static_cast<const T*>(lhs)->max_samples == static_cast<const T*>(rhs)->max_samples;
    }
    if (std::strcmp(field, "max_instances") == 0) {
      return static_cast<const T*>(lhs)->max_instances == static_cast<const T*>(rhs)->max_instances;
    }
    if (std::strcmp(field, "max_samples_per_instance") == 0) {
      return static_cast<const T*>(lhs)->max_samples_per_instance == static_cast<const T*>(rhs)->max_samples_per_instance;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ResourceLimitsQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::ResourceLimitsQosPolicy>()
{
  static MetaStructImpl<DDS::ResourceLimitsQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::ResourceLimitsQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::ResourceLimitsQosPolicy>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ResourceLimitsQosPolicy */


/* Begin STRUCT: TransportPriorityQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::TransportPriorityQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.value);
}

bool operator<<(Serializer& strm, const DDS::TransportPriorityQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.value);
}

bool operator>>(Serializer& strm, DDS::TransportPriorityQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.value);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::TransportPriorityQosPolicy> : MetaStruct {
  typedef DDS::TransportPriorityQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::TransportPriorityQosPolicy& typed = *static_cast<const DDS::TransportPriorityQosPolicy*>(stru);
    if (std::strcmp(field, "value") == 0) {
      return typed.value;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TransportPriorityQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'value' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::TransportPriorityQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "value") == 0) {
      return make_field_cmp(&T::value, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TransportPriorityQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TransportPriorityQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TransportPriorityQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "value") == 0) {
      return static_cast<const T*>(lhs)->value == static_cast<const T*>(rhs)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TransportPriorityQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::TransportPriorityQosPolicy>()
{
  static MetaStructImpl<DDS::TransportPriorityQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::TransportPriorityQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::TransportPriorityQosPolicy>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TransportPriorityQosPolicy */


/* Begin STRUCT: LifespanQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::LifespanQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.duration, size, padding);
}

bool operator<<(Serializer& strm, const DDS::LifespanQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.duration);
}

bool operator>>(Serializer& strm, DDS::LifespanQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.duration);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::LifespanQosPolicy> : MetaStruct {
  typedef DDS::LifespanQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::LifespanQosPolicy& typed = *static_cast<const DDS::LifespanQosPolicy*>(stru);
    if (std::strncmp(field, "duration.", 9) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(&typed.duration, field + 9);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::LifespanQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "duration.", 9) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<DDS::Duration_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::LifespanQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "duration.", 9) == 0) {
      return make_struct_cmp(&T::duration, getMetaStruct<DDS::Duration_t>().create_qc_comparator(field + 9), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::LifespanQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"duration", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "duration") == 0) {
      return &static_cast<const T*>(stru)->duration;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::LifespanQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "duration") == 0) {
      static_cast<T*>(lhs)->duration = *static_cast<const DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::LifespanQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::LifespanQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::LifespanQosPolicy>()
{
  static MetaStructImpl<DDS::LifespanQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::LifespanQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::LifespanQosPolicy>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: LifespanQosPolicy */


/* Begin ENUM: OwnershipQosPolicyKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const DDS::OwnershipQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm, DDS::OwnershipQosPolicyKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    enumval = static_cast<DDS::OwnershipQosPolicyKind>(temp);
    return true;
  }
  return false;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

const char* gen_DDS_OwnershipQosPolicyKind_names[] = {
  "SHARED_OWNERSHIP_QOS",
  "EXCLUSIVE_OWNERSHIP_QOS"
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End ENUM: OwnershipQosPolicyKind */


/* Begin STRUCT: OwnershipQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::OwnershipQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
}

bool operator<<(Serializer& strm, const DDS::OwnershipQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.kind);
}

bool operator>>(Serializer& strm, DDS::OwnershipQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.kind);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::OwnershipQosPolicy> : MetaStruct {
  typedef DDS::OwnershipQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::OwnershipQosPolicy& typed = *static_cast<const DDS::OwnershipQosPolicy*>(stru);
    if (std::strcmp(field, "kind") == 0) {
      return gen_DDS_OwnershipQosPolicyKind_names[typed.kind];
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::OwnershipQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'kind' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::OwnershipQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "kind") == 0) {
      return make_field_cmp(&T::kind, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::OwnershipQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"kind", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      return &static_cast<const T*>(stru)->kind;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::OwnershipQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "kind") == 0) {
      static_cast<T*>(lhs)->kind = *static_cast<const DDS::OwnershipQosPolicyKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::OwnershipQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "kind") == 0) {
      return static_cast<const T*>(lhs)->kind == static_cast<const T*>(rhs)->kind;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::OwnershipQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::OwnershipQosPolicy>()
{
  static MetaStructImpl<DDS::OwnershipQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::OwnershipQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::OwnershipQosPolicy>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: OwnershipQosPolicy */


/* Begin STRUCT: OwnershipStrengthQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::OwnershipStrengthQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.value);
}

bool operator<<(Serializer& strm, const DDS::OwnershipStrengthQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.value);
}

bool operator>>(Serializer& strm, DDS::OwnershipStrengthQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.value);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::OwnershipStrengthQosPolicy> : MetaStruct {
  typedef DDS::OwnershipStrengthQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::OwnershipStrengthQosPolicy& typed = *static_cast<const DDS::OwnershipStrengthQosPolicy*>(stru);
    if (std::strcmp(field, "value") == 0) {
      return typed.value;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::OwnershipStrengthQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'value' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::OwnershipStrengthQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "value") == 0) {
      return make_field_cmp(&T::value, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::OwnershipStrengthQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::OwnershipStrengthQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::OwnershipStrengthQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "value") == 0) {
      return static_cast<const T*>(lhs)->value == static_cast<const T*>(rhs)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::OwnershipStrengthQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::OwnershipStrengthQosPolicy>()
{
  static MetaStructImpl<DDS::OwnershipStrengthQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::OwnershipStrengthQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::OwnershipStrengthQosPolicy>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: OwnershipStrengthQosPolicy */


/* Begin ENUM: PresentationQosPolicyAccessScopeKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const DDS::PresentationQosPolicyAccessScopeKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm, DDS::PresentationQosPolicyAccessScopeKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    enumval = static_cast<DDS::PresentationQosPolicyAccessScopeKind>(temp);
    return true;
  }
  return false;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

const char* gen_DDS_PresentationQosPolicyAccessScopeKind_names[] = {
  "INSTANCE_PRESENTATION_QOS",
  "TOPIC_PRESENTATION_QOS",
  "GROUP_PRESENTATION_QOS"
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End ENUM: PresentationQosPolicyAccessScopeKind */


/* Begin STRUCT: PresentationQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::PresentationQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_boolean(stru.coherent_access));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_boolean(stru.ordered_access));
}

bool operator<<(Serializer& strm, const DDS::PresentationQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.access_scope)
    && (strm << ACE_OutputCDR::from_boolean(stru.coherent_access))
    && (strm << ACE_OutputCDR::from_boolean(stru.ordered_access));
}

bool operator>>(Serializer& strm, DDS::PresentationQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.access_scope)
    && (strm >> ACE_InputCDR::to_boolean(stru.coherent_access))
    && (strm >> ACE_InputCDR::to_boolean(stru.ordered_access));
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::PresentationQosPolicy> : MetaStruct {
  typedef DDS::PresentationQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::PresentationQosPolicy& typed = *static_cast<const DDS::PresentationQosPolicy*>(stru);
    if (std::strcmp(field, "access_scope") == 0) {
      return gen_DDS_PresentationQosPolicyAccessScopeKind_names[typed.access_scope];
    }
    if (std::strcmp(field, "coherent_access") == 0) {
      return typed.coherent_access;
    }
    if (std::strcmp(field, "ordered_access") == 0) {
      return typed.ordered_access;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PresentationQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "access_scope") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'access_scope' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "coherent_access") == 0) {
      ACE_CDR::Boolean val;
      if (!(ser >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'coherent_access' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 1);
    }
    if (std::strcmp(field, "ordered_access") == 0) {
      ACE_CDR::Boolean val;
      if (!(ser >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'ordered_access' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 1);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::PresentationQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "access_scope") == 0) {
      return make_field_cmp(&T::access_scope, next);
    }
    if (std::strcmp(field, "coherent_access") == 0) {
      return make_field_cmp(&T::coherent_access, next);
    }
    if (std::strcmp(field, "ordered_access") == 0) {
      return make_field_cmp(&T::ordered_access, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PresentationQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"access_scope", "coherent_access", "ordered_access", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "access_scope") == 0) {
      return &static_cast<const T*>(stru)->access_scope;
    }
    if (std::strcmp(field, "coherent_access") == 0) {
      return &static_cast<const T*>(stru)->coherent_access;
    }
    if (std::strcmp(field, "ordered_access") == 0) {
      return &static_cast<const T*>(stru)->ordered_access;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PresentationQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "access_scope") == 0) {
      static_cast<T*>(lhs)->access_scope = *static_cast<const DDS::PresentationQosPolicyAccessScopeKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "coherent_access") == 0) {
      static_cast<T*>(lhs)->coherent_access = *static_cast<const CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ordered_access") == 0) {
      static_cast<T*>(lhs)->ordered_access = *static_cast<const CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PresentationQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "access_scope") == 0) {
      return static_cast<const T*>(lhs)->access_scope == static_cast<const T*>(rhs)->access_scope;
    }
    if (std::strcmp(field, "coherent_access") == 0) {
      return static_cast<const T*>(lhs)->coherent_access == static_cast<const T*>(rhs)->coherent_access;
    }
    if (std::strcmp(field, "ordered_access") == 0) {
      return static_cast<const T*>(lhs)->ordered_access == static_cast<const T*>(rhs)->ordered_access;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PresentationQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::PresentationQosPolicy>()
{
  static MetaStructImpl<DDS::PresentationQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::PresentationQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::PresentationQosPolicy>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PresentationQosPolicy */


/* Begin STRUCT: TimeBasedFilterQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::TimeBasedFilterQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.minimum_separation, size, padding);
}

bool operator<<(Serializer& strm, const DDS::TimeBasedFilterQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.minimum_separation);
}

bool operator>>(Serializer& strm, DDS::TimeBasedFilterQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.minimum_separation);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::TimeBasedFilterQosPolicy> : MetaStruct {
  typedef DDS::TimeBasedFilterQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::TimeBasedFilterQosPolicy& typed = *static_cast<const DDS::TimeBasedFilterQosPolicy*>(stru);
    if (std::strncmp(field, "minimum_separation.", 19) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(&typed.minimum_separation, field + 19);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TimeBasedFilterQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "minimum_separation.", 19) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(ser, field + 19);
    } else {
      gen_skip_over(ser, static_cast<DDS::Duration_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::TimeBasedFilterQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "minimum_separation.", 19) == 0) {
      return make_struct_cmp(&T::minimum_separation, getMetaStruct<DDS::Duration_t>().create_qc_comparator(field + 19), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TimeBasedFilterQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"minimum_separation", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "minimum_separation") == 0) {
      return &static_cast<const T*>(stru)->minimum_separation;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TimeBasedFilterQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "minimum_separation") == 0) {
      static_cast<T*>(lhs)->minimum_separation = *static_cast<const DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TimeBasedFilterQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TimeBasedFilterQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::TimeBasedFilterQosPolicy>()
{
  static MetaStructImpl<DDS::TimeBasedFilterQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::TimeBasedFilterQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::TimeBasedFilterQosPolicy>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TimeBasedFilterQosPolicy */


/* Begin STRUCT: TopicQos */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::TopicQos& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.topic_data, size, padding);
  gen_find_size(stru.durability, size, padding);
  gen_find_size(stru.durability_service, size, padding);
  gen_find_size(stru.deadline, size, padding);
  gen_find_size(stru.latency_budget, size, padding);
  gen_find_size(stru.liveliness, size, padding);
  gen_find_size(stru.reliability, size, padding);
  gen_find_size(stru.destination_order, size, padding);
  gen_find_size(stru.history, size, padding);
  gen_find_size(stru.resource_limits, size, padding);
  gen_find_size(stru.transport_priority, size, padding);
  gen_find_size(stru.lifespan, size, padding);
  gen_find_size(stru.ownership, size, padding);
}

bool operator<<(Serializer& strm, const DDS::TopicQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.topic_data)
    && (strm << stru.durability)
    && (strm << stru.durability_service)
    && (strm << stru.deadline)
    && (strm << stru.latency_budget)
    && (strm << stru.liveliness)
    && (strm << stru.reliability)
    && (strm << stru.destination_order)
    && (strm << stru.history)
    && (strm << stru.resource_limits)
    && (strm << stru.transport_priority)
    && (strm << stru.lifespan)
    && (strm << stru.ownership);
}

bool operator>>(Serializer& strm, DDS::TopicQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.topic_data)
    && (strm >> stru.durability)
    && (strm >> stru.durability_service)
    && (strm >> stru.deadline)
    && (strm >> stru.latency_budget)
    && (strm >> stru.liveliness)
    && (strm >> stru.reliability)
    && (strm >> stru.destination_order)
    && (strm >> stru.history)
    && (strm >> stru.resource_limits)
    && (strm >> stru.transport_priority)
    && (strm >> stru.lifespan)
    && (strm >> stru.ownership);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::TopicQos> : MetaStruct {
  typedef DDS::TopicQos T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::TopicQos& typed = *static_cast<const DDS::TopicQos*>(stru);
    if (std::strncmp(field, "topic_data.", 11) == 0) {
      return getMetaStruct<DDS::TopicDataQosPolicy>().getValue(&typed.topic_data, field + 11);
    }
    if (std::strncmp(field, "durability.", 11) == 0) {
      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(&typed.durability, field + 11);
    }
    if (std::strncmp(field, "durability_service.", 19) == 0) {
      return getMetaStruct<DDS::DurabilityServiceQosPolicy>().getValue(&typed.durability_service, field + 19);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(&typed.deadline, field + 9);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(&typed.latency_budget, field + 15);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(&typed.liveliness, field + 11);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(&typed.reliability, field + 12);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(&typed.destination_order, field + 18);
    }
    if (std::strncmp(field, "history.", 8) == 0) {
      return getMetaStruct<DDS::HistoryQosPolicy>().getValue(&typed.history, field + 8);
    }
    if (std::strncmp(field, "resource_limits.", 16) == 0) {
      return getMetaStruct<DDS::ResourceLimitsQosPolicy>().getValue(&typed.resource_limits, field + 16);
    }
    if (std::strncmp(field, "transport_priority.", 19) == 0) {
      return getMetaStruct<DDS::TransportPriorityQosPolicy>().getValue(&typed.transport_priority, field + 19);
    }
    if (std::strncmp(field, "lifespan.", 9) == 0) {
      return getMetaStruct<DDS::LifespanQosPolicy>().getValue(&typed.lifespan, field + 9);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(&typed.ownership, field + 10);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TopicQos)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "topic_data.", 11) == 0) {
      return getMetaStruct<DDS::TopicDataQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::TopicDataQosPolicy*>(0));
    }
    if (std::strncmp(field, "durability.", 11) == 0) {
      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::DurabilityQosPolicy*>(0));
    }
    if (std::strncmp(field, "durability_service.", 19) == 0) {
      return getMetaStruct<DDS::DurabilityServiceQosPolicy>().getValue(ser, field + 19);
    } else {
      gen_skip_over(ser, static_cast<DDS::DurabilityServiceQosPolicy*>(0));
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<DDS::DeadlineQosPolicy*>(0));
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(ser, field + 15);
    } else {
      gen_skip_over(ser, static_cast<DDS::LatencyBudgetQosPolicy*>(0));
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::LivelinessQosPolicy*>(0));
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(ser, field + 12);
    } else {
      gen_skip_over(ser, static_cast<DDS::ReliabilityQosPolicy*>(0));
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(ser, field + 18);
    } else {
      gen_skip_over(ser, static_cast<DDS::DestinationOrderQosPolicy*>(0));
    }
    if (std::strncmp(field, "history.", 8) == 0) {
      return getMetaStruct<DDS::HistoryQosPolicy>().getValue(ser, field + 8);
    } else {
      gen_skip_over(ser, static_cast<DDS::HistoryQosPolicy*>(0));
    }
    if (std::strncmp(field, "resource_limits.", 16) == 0) {
      return getMetaStruct<DDS::ResourceLimitsQosPolicy>().getValue(ser, field + 16);
    } else {
      gen_skip_over(ser, static_cast<DDS::ResourceLimitsQosPolicy*>(0));
    }
    if (std::strncmp(field, "transport_priority.", 19) == 0) {
      return getMetaStruct<DDS::TransportPriorityQosPolicy>().getValue(ser, field + 19);
    } else {
      gen_skip_over(ser, static_cast<DDS::TransportPriorityQosPolicy*>(0));
    }
    if (std::strncmp(field, "lifespan.", 9) == 0) {
      return getMetaStruct<DDS::LifespanQosPolicy>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<DDS::LifespanQosPolicy*>(0));
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::OwnershipQosPolicy*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::TopicQos");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "topic_data.", 11) == 0) {
      return make_struct_cmp(&T::topic_data, getMetaStruct<DDS::TopicDataQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "durability.", 11) == 0) {
      return make_struct_cmp(&T::durability, getMetaStruct<DDS::DurabilityQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "durability_service.", 19) == 0) {
      return make_struct_cmp(&T::durability_service, getMetaStruct<DDS::DurabilityServiceQosPolicy>().create_qc_comparator(field + 19), next);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return make_struct_cmp(&T::deadline, getMetaStruct<DDS::DeadlineQosPolicy>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return make_struct_cmp(&T::latency_budget, getMetaStruct<DDS::LatencyBudgetQosPolicy>().create_qc_comparator(field + 15), next);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return make_struct_cmp(&T::liveliness, getMetaStruct<DDS::LivelinessQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return make_struct_cmp(&T::reliability, getMetaStruct<DDS::ReliabilityQosPolicy>().create_qc_comparator(field + 12), next);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return make_struct_cmp(&T::destination_order, getMetaStruct<DDS::DestinationOrderQosPolicy>().create_qc_comparator(field + 18), next);
    }
    if (std::strncmp(field, "history.", 8) == 0) {
      return make_struct_cmp(&T::history, getMetaStruct<DDS::HistoryQosPolicy>().create_qc_comparator(field + 8), next);
    }
    if (std::strncmp(field, "resource_limits.", 16) == 0) {
      return make_struct_cmp(&T::resource_limits, getMetaStruct<DDS::ResourceLimitsQosPolicy>().create_qc_comparator(field + 16), next);
    }
    if (std::strncmp(field, "transport_priority.", 19) == 0) {
      return make_struct_cmp(&T::transport_priority, getMetaStruct<DDS::TransportPriorityQosPolicy>().create_qc_comparator(field + 19), next);
    }
    if (std::strncmp(field, "lifespan.", 9) == 0) {
      return make_struct_cmp(&T::lifespan, getMetaStruct<DDS::LifespanQosPolicy>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return make_struct_cmp(&T::ownership, getMetaStruct<DDS::OwnershipQosPolicy>().create_qc_comparator(field + 10), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TopicQos)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"topic_data", "durability", "durability_service", "deadline", "latency_budget", "liveliness", "reliability", "destination_order", "history", "resource_limits", "transport_priority", "lifespan", "ownership", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "topic_data") == 0) {
      return &static_cast<const T*>(stru)->topic_data;
    }
    if (std::strcmp(field, "durability") == 0) {
      return &static_cast<const T*>(stru)->durability;
    }
    if (std::strcmp(field, "durability_service") == 0) {
      return &static_cast<const T*>(stru)->durability_service;
    }
    if (std::strcmp(field, "deadline") == 0) {
      return &static_cast<const T*>(stru)->deadline;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      return &static_cast<const T*>(stru)->latency_budget;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      return &static_cast<const T*>(stru)->liveliness;
    }
    if (std::strcmp(field, "reliability") == 0) {
      return &static_cast<const T*>(stru)->reliability;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      return &static_cast<const T*>(stru)->destination_order;
    }
    if (std::strcmp(field, "history") == 0) {
      return &static_cast<const T*>(stru)->history;
    }
    if (std::strcmp(field, "resource_limits") == 0) {
      return &static_cast<const T*>(stru)->resource_limits;
    }
    if (std::strcmp(field, "transport_priority") == 0) {
      return &static_cast<const T*>(stru)->transport_priority;
    }
    if (std::strcmp(field, "lifespan") == 0) {
      return &static_cast<const T*>(stru)->lifespan;
    }
    if (std::strcmp(field, "ownership") == 0) {
      return &static_cast<const T*>(stru)->ownership;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TopicQos)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "topic_data") == 0) {
      static_cast<T*>(lhs)->topic_data = *static_cast<const DDS::TopicDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "durability") == 0) {
      static_cast<T*>(lhs)->durability = *static_cast<const DDS::DurabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "durability_service") == 0) {
      static_cast<T*>(lhs)->durability_service = *static_cast<const DDS::DurabilityServiceQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "deadline") == 0) {
      static_cast<T*>(lhs)->deadline = *static_cast<const DDS::DeadlineQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      static_cast<T*>(lhs)->latency_budget = *static_cast<const DDS::LatencyBudgetQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      static_cast<T*>(lhs)->liveliness = *static_cast<const DDS::LivelinessQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "reliability") == 0) {
      static_cast<T*>(lhs)->reliability = *static_cast<const DDS::ReliabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      static_cast<T*>(lhs)->destination_order = *static_cast<const DDS::DestinationOrderQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "history") == 0) {
      static_cast<T*>(lhs)->history = *static_cast<const DDS::HistoryQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "resource_limits") == 0) {
      static_cast<T*>(lhs)->resource_limits = *static_cast<const DDS::ResourceLimitsQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "transport_priority") == 0) {
      static_cast<T*>(lhs)->transport_priority = *static_cast<const DDS::TransportPriorityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "lifespan") == 0) {
      static_cast<T*>(lhs)->lifespan = *static_cast<const DDS::LifespanQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ownership") == 0) {
      static_cast<T*>(lhs)->ownership = *static_cast<const DDS::OwnershipQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TopicQos)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TopicQos)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::TopicQos>()
{
  static MetaStructImpl<DDS::TopicQos> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::TopicQos*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::TopicQos>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TopicQos */


/* Begin STRUCT: WriterDataLifecycleQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::WriterDataLifecycleQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_boolean(stru.autodispose_unregistered_instances));
}

bool operator<<(Serializer& strm, const DDS::WriterDataLifecycleQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << ACE_OutputCDR::from_boolean(stru.autodispose_unregistered_instances));
}

bool operator>>(Serializer& strm, DDS::WriterDataLifecycleQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> ACE_InputCDR::to_boolean(stru.autodispose_unregistered_instances));
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::WriterDataLifecycleQosPolicy> : MetaStruct {
  typedef DDS::WriterDataLifecycleQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::WriterDataLifecycleQosPolicy& typed = *static_cast<const DDS::WriterDataLifecycleQosPolicy*>(stru);
    if (std::strcmp(field, "autodispose_unregistered_instances") == 0) {
      return typed.autodispose_unregistered_instances;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::WriterDataLifecycleQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "autodispose_unregistered_instances") == 0) {
      ACE_CDR::Boolean val;
      if (!(ser >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'autodispose_unregistered_instances' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 1);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::WriterDataLifecycleQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "autodispose_unregistered_instances") == 0) {
      return make_field_cmp(&T::autodispose_unregistered_instances, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::WriterDataLifecycleQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"autodispose_unregistered_instances", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "autodispose_unregistered_instances") == 0) {
      return &static_cast<const T*>(stru)->autodispose_unregistered_instances;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::WriterDataLifecycleQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "autodispose_unregistered_instances") == 0) {
      static_cast<T*>(lhs)->autodispose_unregistered_instances = *static_cast<const CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::WriterDataLifecycleQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "autodispose_unregistered_instances") == 0) {
      return static_cast<const T*>(lhs)->autodispose_unregistered_instances == static_cast<const T*>(rhs)->autodispose_unregistered_instances;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::WriterDataLifecycleQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::WriterDataLifecycleQosPolicy>()
{
  static MetaStructImpl<DDS::WriterDataLifecycleQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::WriterDataLifecycleQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::WriterDataLifecycleQosPolicy>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: WriterDataLifecycleQosPolicy */


/* Begin STRUCT: DataWriterQos */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::DataWriterQos& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.durability, size, padding);
  gen_find_size(stru.durability_service, size, padding);
  gen_find_size(stru.deadline, size, padding);
  gen_find_size(stru.latency_budget, size, padding);
  gen_find_size(stru.liveliness, size, padding);
  gen_find_size(stru.reliability, size, padding);
  gen_find_size(stru.destination_order, size, padding);
  gen_find_size(stru.history, size, padding);
  gen_find_size(stru.resource_limits, size, padding);
  gen_find_size(stru.transport_priority, size, padding);
  gen_find_size(stru.lifespan, size, padding);
  gen_find_size(stru.user_data, size, padding);
  gen_find_size(stru.ownership, size, padding);
  gen_find_size(stru.ownership_strength, size, padding);
  gen_find_size(stru.writer_data_lifecycle, size, padding);
}

bool operator<<(Serializer& strm, const DDS::DataWriterQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.durability)
    && (strm << stru.durability_service)
    && (strm << stru.deadline)
    && (strm << stru.latency_budget)
    && (strm << stru.liveliness)
    && (strm << stru.reliability)
    && (strm << stru.destination_order)
    && (strm << stru.history)
    && (strm << stru.resource_limits)
    && (strm << stru.transport_priority)
    && (strm << stru.lifespan)
    && (strm << stru.user_data)
    && (strm << stru.ownership)
    && (strm << stru.ownership_strength)
    && (strm << stru.writer_data_lifecycle);
}

bool operator>>(Serializer& strm, DDS::DataWriterQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.durability)
    && (strm >> stru.durability_service)
    && (strm >> stru.deadline)
    && (strm >> stru.latency_budget)
    && (strm >> stru.liveliness)
    && (strm >> stru.reliability)
    && (strm >> stru.destination_order)
    && (strm >> stru.history)
    && (strm >> stru.resource_limits)
    && (strm >> stru.transport_priority)
    && (strm >> stru.lifespan)
    && (strm >> stru.user_data)
    && (strm >> stru.ownership)
    && (strm >> stru.ownership_strength)
    && (strm >> stru.writer_data_lifecycle);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::DataWriterQos> : MetaStruct {
  typedef DDS::DataWriterQos T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::DataWriterQos& typed = *static_cast<const DDS::DataWriterQos*>(stru);
    if (std::strncmp(field, "durability.", 11) == 0) {
      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(&typed.durability, field + 11);
    }
    if (std::strncmp(field, "durability_service.", 19) == 0) {
      return getMetaStruct<DDS::DurabilityServiceQosPolicy>().getValue(&typed.durability_service, field + 19);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(&typed.deadline, field + 9);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(&typed.latency_budget, field + 15);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(&typed.liveliness, field + 11);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(&typed.reliability, field + 12);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(&typed.destination_order, field + 18);
    }
    if (std::strncmp(field, "history.", 8) == 0) {
      return getMetaStruct<DDS::HistoryQosPolicy>().getValue(&typed.history, field + 8);
    }
    if (std::strncmp(field, "resource_limits.", 16) == 0) {
      return getMetaStruct<DDS::ResourceLimitsQosPolicy>().getValue(&typed.resource_limits, field + 16);
    }
    if (std::strncmp(field, "transport_priority.", 19) == 0) {
      return getMetaStruct<DDS::TransportPriorityQosPolicy>().getValue(&typed.transport_priority, field + 19);
    }
    if (std::strncmp(field, "lifespan.", 9) == 0) {
      return getMetaStruct<DDS::LifespanQosPolicy>().getValue(&typed.lifespan, field + 9);
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(&typed.user_data, field + 10);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(&typed.ownership, field + 10);
    }
    if (std::strncmp(field, "ownership_strength.", 19) == 0) {
      return getMetaStruct<DDS::OwnershipStrengthQosPolicy>().getValue(&typed.ownership_strength, field + 19);
    }
    if (std::strncmp(field, "writer_data_lifecycle.", 22) == 0) {
      return getMetaStruct<DDS::WriterDataLifecycleQosPolicy>().getValue(&typed.writer_data_lifecycle, field + 22);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DataWriterQos)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "durability.", 11) == 0) {
      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::DurabilityQosPolicy*>(0));
    }
    if (std::strncmp(field, "durability_service.", 19) == 0) {
      return getMetaStruct<DDS::DurabilityServiceQosPolicy>().getValue(ser, field + 19);
    } else {
      gen_skip_over(ser, static_cast<DDS::DurabilityServiceQosPolicy*>(0));
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<DDS::DeadlineQosPolicy*>(0));
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(ser, field + 15);
    } else {
      gen_skip_over(ser, static_cast<DDS::LatencyBudgetQosPolicy*>(0));
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::LivelinessQosPolicy*>(0));
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(ser, field + 12);
    } else {
      gen_skip_over(ser, static_cast<DDS::ReliabilityQosPolicy*>(0));
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(ser, field + 18);
    } else {
      gen_skip_over(ser, static_cast<DDS::DestinationOrderQosPolicy*>(0));
    }
    if (std::strncmp(field, "history.", 8) == 0) {
      return getMetaStruct<DDS::HistoryQosPolicy>().getValue(ser, field + 8);
    } else {
      gen_skip_over(ser, static_cast<DDS::HistoryQosPolicy*>(0));
    }
    if (std::strncmp(field, "resource_limits.", 16) == 0) {
      return getMetaStruct<DDS::ResourceLimitsQosPolicy>().getValue(ser, field + 16);
    } else {
      gen_skip_over(ser, static_cast<DDS::ResourceLimitsQosPolicy*>(0));
    }
    if (std::strncmp(field, "transport_priority.", 19) == 0) {
      return getMetaStruct<DDS::TransportPriorityQosPolicy>().getValue(ser, field + 19);
    } else {
      gen_skip_over(ser, static_cast<DDS::TransportPriorityQosPolicy*>(0));
    }
    if (std::strncmp(field, "lifespan.", 9) == 0) {
      return getMetaStruct<DDS::LifespanQosPolicy>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<DDS::LifespanQosPolicy*>(0));
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::UserDataQosPolicy*>(0));
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::OwnershipQosPolicy*>(0));
    }
    if (std::strncmp(field, "ownership_strength.", 19) == 0) {
      return getMetaStruct<DDS::OwnershipStrengthQosPolicy>().getValue(ser, field + 19);
    } else {
      gen_skip_over(ser, static_cast<DDS::OwnershipStrengthQosPolicy*>(0));
    }
    if (std::strncmp(field, "writer_data_lifecycle.", 22) == 0) {
      return getMetaStruct<DDS::WriterDataLifecycleQosPolicy>().getValue(ser, field + 22);
    } else {
      gen_skip_over(ser, static_cast<DDS::WriterDataLifecycleQosPolicy*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::DataWriterQos");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "durability.", 11) == 0) {
      return make_struct_cmp(&T::durability, getMetaStruct<DDS::DurabilityQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "durability_service.", 19) == 0) {
      return make_struct_cmp(&T::durability_service, getMetaStruct<DDS::DurabilityServiceQosPolicy>().create_qc_comparator(field + 19), next);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return make_struct_cmp(&T::deadline, getMetaStruct<DDS::DeadlineQosPolicy>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return make_struct_cmp(&T::latency_budget, getMetaStruct<DDS::LatencyBudgetQosPolicy>().create_qc_comparator(field + 15), next);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return make_struct_cmp(&T::liveliness, getMetaStruct<DDS::LivelinessQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return make_struct_cmp(&T::reliability, getMetaStruct<DDS::ReliabilityQosPolicy>().create_qc_comparator(field + 12), next);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return make_struct_cmp(&T::destination_order, getMetaStruct<DDS::DestinationOrderQosPolicy>().create_qc_comparator(field + 18), next);
    }
    if (std::strncmp(field, "history.", 8) == 0) {
      return make_struct_cmp(&T::history, getMetaStruct<DDS::HistoryQosPolicy>().create_qc_comparator(field + 8), next);
    }
    if (std::strncmp(field, "resource_limits.", 16) == 0) {
      return make_struct_cmp(&T::resource_limits, getMetaStruct<DDS::ResourceLimitsQosPolicy>().create_qc_comparator(field + 16), next);
    }
    if (std::strncmp(field, "transport_priority.", 19) == 0) {
      return make_struct_cmp(&T::transport_priority, getMetaStruct<DDS::TransportPriorityQosPolicy>().create_qc_comparator(field + 19), next);
    }
    if (std::strncmp(field, "lifespan.", 9) == 0) {
      return make_struct_cmp(&T::lifespan, getMetaStruct<DDS::LifespanQosPolicy>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return make_struct_cmp(&T::user_data, getMetaStruct<DDS::UserDataQosPolicy>().create_qc_comparator(field + 10), next);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return make_struct_cmp(&T::ownership, getMetaStruct<DDS::OwnershipQosPolicy>().create_qc_comparator(field + 10), next);
    }
    if (std::strncmp(field, "ownership_strength.", 19) == 0) {
      return make_struct_cmp(&T::ownership_strength, getMetaStruct<DDS::OwnershipStrengthQosPolicy>().create_qc_comparator(field + 19), next);
    }
    if (std::strncmp(field, "writer_data_lifecycle.", 22) == 0) {
      return make_struct_cmp(&T::writer_data_lifecycle, getMetaStruct<DDS::WriterDataLifecycleQosPolicy>().create_qc_comparator(field + 22), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DataWriterQos)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"durability", "durability_service", "deadline", "latency_budget", "liveliness", "reliability", "destination_order", "history", "resource_limits", "transport_priority", "lifespan", "user_data", "ownership", "ownership_strength", "writer_data_lifecycle", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "durability") == 0) {
      return &static_cast<const T*>(stru)->durability;
    }
    if (std::strcmp(field, "durability_service") == 0) {
      return &static_cast<const T*>(stru)->durability_service;
    }
    if (std::strcmp(field, "deadline") == 0) {
      return &static_cast<const T*>(stru)->deadline;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      return &static_cast<const T*>(stru)->latency_budget;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      return &static_cast<const T*>(stru)->liveliness;
    }
    if (std::strcmp(field, "reliability") == 0) {
      return &static_cast<const T*>(stru)->reliability;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      return &static_cast<const T*>(stru)->destination_order;
    }
    if (std::strcmp(field, "history") == 0) {
      return &static_cast<const T*>(stru)->history;
    }
    if (std::strcmp(field, "resource_limits") == 0) {
      return &static_cast<const T*>(stru)->resource_limits;
    }
    if (std::strcmp(field, "transport_priority") == 0) {
      return &static_cast<const T*>(stru)->transport_priority;
    }
    if (std::strcmp(field, "lifespan") == 0) {
      return &static_cast<const T*>(stru)->lifespan;
    }
    if (std::strcmp(field, "user_data") == 0) {
      return &static_cast<const T*>(stru)->user_data;
    }
    if (std::strcmp(field, "ownership") == 0) {
      return &static_cast<const T*>(stru)->ownership;
    }
    if (std::strcmp(field, "ownership_strength") == 0) {
      return &static_cast<const T*>(stru)->ownership_strength;
    }
    if (std::strcmp(field, "writer_data_lifecycle") == 0) {
      return &static_cast<const T*>(stru)->writer_data_lifecycle;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DataWriterQos)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "durability") == 0) {
      static_cast<T*>(lhs)->durability = *static_cast<const DDS::DurabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "durability_service") == 0) {
      static_cast<T*>(lhs)->durability_service = *static_cast<const DDS::DurabilityServiceQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "deadline") == 0) {
      static_cast<T*>(lhs)->deadline = *static_cast<const DDS::DeadlineQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      static_cast<T*>(lhs)->latency_budget = *static_cast<const DDS::LatencyBudgetQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      static_cast<T*>(lhs)->liveliness = *static_cast<const DDS::LivelinessQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "reliability") == 0) {
      static_cast<T*>(lhs)->reliability = *static_cast<const DDS::ReliabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      static_cast<T*>(lhs)->destination_order = *static_cast<const DDS::DestinationOrderQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "history") == 0) {
      static_cast<T*>(lhs)->history = *static_cast<const DDS::HistoryQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "resource_limits") == 0) {
      static_cast<T*>(lhs)->resource_limits = *static_cast<const DDS::ResourceLimitsQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "transport_priority") == 0) {
      static_cast<T*>(lhs)->transport_priority = *static_cast<const DDS::TransportPriorityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "lifespan") == 0) {
      static_cast<T*>(lhs)->lifespan = *static_cast<const DDS::LifespanQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "user_data") == 0) {
      static_cast<T*>(lhs)->user_data = *static_cast<const DDS::UserDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ownership") == 0) {
      static_cast<T*>(lhs)->ownership = *static_cast<const DDS::OwnershipQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ownership_strength") == 0) {
      static_cast<T*>(lhs)->ownership_strength = *static_cast<const DDS::OwnershipStrengthQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writer_data_lifecycle") == 0) {
      static_cast<T*>(lhs)->writer_data_lifecycle = *static_cast<const DDS::WriterDataLifecycleQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DataWriterQos)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DataWriterQos)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::DataWriterQos>()
{
  static MetaStructImpl<DDS::DataWriterQos> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::DataWriterQos*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::DataWriterQos>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataWriterQos */


/* Begin STRUCT: EntityFactoryQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::EntityFactoryQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_boolean(stru.autoenable_created_entities));
}

bool operator<<(Serializer& strm, const DDS::EntityFactoryQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << ACE_OutputCDR::from_boolean(stru.autoenable_created_entities));
}

bool operator>>(Serializer& strm, DDS::EntityFactoryQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> ACE_InputCDR::to_boolean(stru.autoenable_created_entities));
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::EntityFactoryQosPolicy> : MetaStruct {
  typedef DDS::EntityFactoryQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::EntityFactoryQosPolicy& typed = *static_cast<const DDS::EntityFactoryQosPolicy*>(stru);
    if (std::strcmp(field, "autoenable_created_entities") == 0) {
      return typed.autoenable_created_entities;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::EntityFactoryQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "autoenable_created_entities") == 0) {
      ACE_CDR::Boolean val;
      if (!(ser >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'autoenable_created_entities' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 1);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::EntityFactoryQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "autoenable_created_entities") == 0) {
      return make_field_cmp(&T::autoenable_created_entities, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::EntityFactoryQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"autoenable_created_entities", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "autoenable_created_entities") == 0) {
      return &static_cast<const T*>(stru)->autoenable_created_entities;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::EntityFactoryQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "autoenable_created_entities") == 0) {
      static_cast<T*>(lhs)->autoenable_created_entities = *static_cast<const CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::EntityFactoryQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "autoenable_created_entities") == 0) {
      return static_cast<const T*>(lhs)->autoenable_created_entities == static_cast<const T*>(rhs)->autoenable_created_entities;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::EntityFactoryQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::EntityFactoryQosPolicy>()
{
  static MetaStructImpl<DDS::EntityFactoryQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::EntityFactoryQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::EntityFactoryQosPolicy>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: EntityFactoryQosPolicy */


/* Begin STRUCT: PublisherQos */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::PublisherQos& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.presentation, size, padding);
  gen_find_size(stru.partition, size, padding);
  gen_find_size(stru.group_data, size, padding);
  gen_find_size(stru.entity_factory, size, padding);
}

bool operator<<(Serializer& strm, const DDS::PublisherQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.presentation)
    && (strm << stru.partition)
    && (strm << stru.group_data)
    && (strm << stru.entity_factory);
}

bool operator>>(Serializer& strm, DDS::PublisherQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.presentation)
    && (strm >> stru.partition)
    && (strm >> stru.group_data)
    && (strm >> stru.entity_factory);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::PublisherQos> : MetaStruct {
  typedef DDS::PublisherQos T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::PublisherQos& typed = *static_cast<const DDS::PublisherQos*>(stru);
    if (std::strncmp(field, "presentation.", 13) == 0) {
      return getMetaStruct<DDS::PresentationQosPolicy>().getValue(&typed.presentation, field + 13);
    }
    if (std::strncmp(field, "partition.", 10) == 0) {
      return getMetaStruct<DDS::PartitionQosPolicy>().getValue(&typed.partition, field + 10);
    }
    if (std::strncmp(field, "group_data.", 11) == 0) {
      return getMetaStruct<DDS::GroupDataQosPolicy>().getValue(&typed.group_data, field + 11);
    }
    if (std::strncmp(field, "entity_factory.", 15) == 0) {
      return getMetaStruct<DDS::EntityFactoryQosPolicy>().getValue(&typed.entity_factory, field + 15);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PublisherQos)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "presentation.", 13) == 0) {
      return getMetaStruct<DDS::PresentationQosPolicy>().getValue(ser, field + 13);
    } else {
      gen_skip_over(ser, static_cast<DDS::PresentationQosPolicy*>(0));
    }
    if (std::strncmp(field, "partition.", 10) == 0) {
      return getMetaStruct<DDS::PartitionQosPolicy>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::PartitionQosPolicy*>(0));
    }
    if (std::strncmp(field, "group_data.", 11) == 0) {
      return getMetaStruct<DDS::GroupDataQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::GroupDataQosPolicy*>(0));
    }
    if (std::strncmp(field, "entity_factory.", 15) == 0) {
      return getMetaStruct<DDS::EntityFactoryQosPolicy>().getValue(ser, field + 15);
    } else {
      gen_skip_over(ser, static_cast<DDS::EntityFactoryQosPolicy*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::PublisherQos");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "presentation.", 13) == 0) {
      return make_struct_cmp(&T::presentation, getMetaStruct<DDS::PresentationQosPolicy>().create_qc_comparator(field + 13), next);
    }
    if (std::strncmp(field, "partition.", 10) == 0) {
      return make_struct_cmp(&T::partition, getMetaStruct<DDS::PartitionQosPolicy>().create_qc_comparator(field + 10), next);
    }
    if (std::strncmp(field, "group_data.", 11) == 0) {
      return make_struct_cmp(&T::group_data, getMetaStruct<DDS::GroupDataQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "entity_factory.", 15) == 0) {
      return make_struct_cmp(&T::entity_factory, getMetaStruct<DDS::EntityFactoryQosPolicy>().create_qc_comparator(field + 15), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PublisherQos)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"presentation", "partition", "group_data", "entity_factory", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "presentation") == 0) {
      return &static_cast<const T*>(stru)->presentation;
    }
    if (std::strcmp(field, "partition") == 0) {
      return &static_cast<const T*>(stru)->partition;
    }
    if (std::strcmp(field, "group_data") == 0) {
      return &static_cast<const T*>(stru)->group_data;
    }
    if (std::strcmp(field, "entity_factory") == 0) {
      return &static_cast<const T*>(stru)->entity_factory;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PublisherQos)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "presentation") == 0) {
      static_cast<T*>(lhs)->presentation = *static_cast<const DDS::PresentationQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "partition") == 0) {
      static_cast<T*>(lhs)->partition = *static_cast<const DDS::PartitionQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "group_data") == 0) {
      static_cast<T*>(lhs)->group_data = *static_cast<const DDS::GroupDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "entity_factory") == 0) {
      static_cast<T*>(lhs)->entity_factory = *static_cast<const DDS::EntityFactoryQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PublisherQos)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PublisherQos)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::PublisherQos>()
{
  static MetaStructImpl<DDS::PublisherQos> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::PublisherQos*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::PublisherQos>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PublisherQos */


/* Begin STRUCT: ReaderDataLifecycleQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::ReaderDataLifecycleQosPolicy& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.autopurge_nowriter_samples_delay, size, padding);
  gen_find_size(stru.autopurge_disposed_samples_delay, size, padding);
}

bool operator<<(Serializer& strm, const DDS::ReaderDataLifecycleQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.autopurge_nowriter_samples_delay)
    && (strm << stru.autopurge_disposed_samples_delay);
}

bool operator>>(Serializer& strm, DDS::ReaderDataLifecycleQosPolicy& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.autopurge_nowriter_samples_delay)
    && (strm >> stru.autopurge_disposed_samples_delay);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::ReaderDataLifecycleQosPolicy> : MetaStruct {
  typedef DDS::ReaderDataLifecycleQosPolicy T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::ReaderDataLifecycleQosPolicy& typed = *static_cast<const DDS::ReaderDataLifecycleQosPolicy*>(stru);
    if (std::strncmp(field, "autopurge_nowriter_samples_delay.", 33) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(&typed.autopurge_nowriter_samples_delay, field + 33);
    }
    if (std::strncmp(field, "autopurge_disposed_samples_delay.", 33) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(&typed.autopurge_disposed_samples_delay, field + 33);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ReaderDataLifecycleQosPolicy)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "autopurge_nowriter_samples_delay.", 33) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(ser, field + 33);
    } else {
      gen_skip_over(ser, static_cast<DDS::Duration_t*>(0));
    }
    if (std::strncmp(field, "autopurge_disposed_samples_delay.", 33) == 0) {
      return getMetaStruct<DDS::Duration_t>().getValue(ser, field + 33);
    } else {
      gen_skip_over(ser, static_cast<DDS::Duration_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::ReaderDataLifecycleQosPolicy");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "autopurge_nowriter_samples_delay.", 33) == 0) {
      return make_struct_cmp(&T::autopurge_nowriter_samples_delay, getMetaStruct<DDS::Duration_t>().create_qc_comparator(field + 33), next);
    }
    if (std::strncmp(field, "autopurge_disposed_samples_delay.", 33) == 0) {
      return make_struct_cmp(&T::autopurge_disposed_samples_delay, getMetaStruct<DDS::Duration_t>().create_qc_comparator(field + 33), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ReaderDataLifecycleQosPolicy)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"autopurge_nowriter_samples_delay", "autopurge_disposed_samples_delay", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "autopurge_nowriter_samples_delay") == 0) {
      return &static_cast<const T*>(stru)->autopurge_nowriter_samples_delay;
    }
    if (std::strcmp(field, "autopurge_disposed_samples_delay") == 0) {
      return &static_cast<const T*>(stru)->autopurge_disposed_samples_delay;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ReaderDataLifecycleQosPolicy)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "autopurge_nowriter_samples_delay") == 0) {
      static_cast<T*>(lhs)->autopurge_nowriter_samples_delay = *static_cast<const DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "autopurge_disposed_samples_delay") == 0) {
      static_cast<T*>(lhs)->autopurge_disposed_samples_delay = *static_cast<const DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ReaderDataLifecycleQosPolicy)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ReaderDataLifecycleQosPolicy)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::ReaderDataLifecycleQosPolicy>()
{
  static MetaStructImpl<DDS::ReaderDataLifecycleQosPolicy> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::ReaderDataLifecycleQosPolicy*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::ReaderDataLifecycleQosPolicy>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ReaderDataLifecycleQosPolicy */


/* Begin STRUCT: DataReaderQos */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::DataReaderQos& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.durability, size, padding);
  gen_find_size(stru.deadline, size, padding);
  gen_find_size(stru.latency_budget, size, padding);
  gen_find_size(stru.liveliness, size, padding);
  gen_find_size(stru.reliability, size, padding);
  gen_find_size(stru.destination_order, size, padding);
  gen_find_size(stru.history, size, padding);
  gen_find_size(stru.resource_limits, size, padding);
  gen_find_size(stru.user_data, size, padding);
  gen_find_size(stru.ownership, size, padding);
  gen_find_size(stru.time_based_filter, size, padding);
  gen_find_size(stru.reader_data_lifecycle, size, padding);
}

bool operator<<(Serializer& strm, const DDS::DataReaderQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.durability)
    && (strm << stru.deadline)
    && (strm << stru.latency_budget)
    && (strm << stru.liveliness)
    && (strm << stru.reliability)
    && (strm << stru.destination_order)
    && (strm << stru.history)
    && (strm << stru.resource_limits)
    && (strm << stru.user_data)
    && (strm << stru.ownership)
    && (strm << stru.time_based_filter)
    && (strm << stru.reader_data_lifecycle);
}

bool operator>>(Serializer& strm, DDS::DataReaderQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.durability)
    && (strm >> stru.deadline)
    && (strm >> stru.latency_budget)
    && (strm >> stru.liveliness)
    && (strm >> stru.reliability)
    && (strm >> stru.destination_order)
    && (strm >> stru.history)
    && (strm >> stru.resource_limits)
    && (strm >> stru.user_data)
    && (strm >> stru.ownership)
    && (strm >> stru.time_based_filter)
    && (strm >> stru.reader_data_lifecycle);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::DataReaderQos> : MetaStruct {
  typedef DDS::DataReaderQos T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::DataReaderQos& typed = *static_cast<const DDS::DataReaderQos*>(stru);
    if (std::strncmp(field, "durability.", 11) == 0) {
      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(&typed.durability, field + 11);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(&typed.deadline, field + 9);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(&typed.latency_budget, field + 15);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(&typed.liveliness, field + 11);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(&typed.reliability, field + 12);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(&typed.destination_order, field + 18);
    }
    if (std::strncmp(field, "history.", 8) == 0) {
      return getMetaStruct<DDS::HistoryQosPolicy>().getValue(&typed.history, field + 8);
    }
    if (std::strncmp(field, "resource_limits.", 16) == 0) {
      return getMetaStruct<DDS::ResourceLimitsQosPolicy>().getValue(&typed.resource_limits, field + 16);
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(&typed.user_data, field + 10);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(&typed.ownership, field + 10);
    }
    if (std::strncmp(field, "time_based_filter.", 18) == 0) {
      return getMetaStruct<DDS::TimeBasedFilterQosPolicy>().getValue(&typed.time_based_filter, field + 18);
    }
    if (std::strncmp(field, "reader_data_lifecycle.", 22) == 0) {
      return getMetaStruct<DDS::ReaderDataLifecycleQosPolicy>().getValue(&typed.reader_data_lifecycle, field + 22);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DataReaderQos)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "durability.", 11) == 0) {
      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::DurabilityQosPolicy*>(0));
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<DDS::DeadlineQosPolicy*>(0));
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(ser, field + 15);
    } else {
      gen_skip_over(ser, static_cast<DDS::LatencyBudgetQosPolicy*>(0));
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::LivelinessQosPolicy*>(0));
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(ser, field + 12);
    } else {
      gen_skip_over(ser, static_cast<DDS::ReliabilityQosPolicy*>(0));
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(ser, field + 18);
    } else {
      gen_skip_over(ser, static_cast<DDS::DestinationOrderQosPolicy*>(0));
    }
    if (std::strncmp(field, "history.", 8) == 0) {
      return getMetaStruct<DDS::HistoryQosPolicy>().getValue(ser, field + 8);
    } else {
      gen_skip_over(ser, static_cast<DDS::HistoryQosPolicy*>(0));
    }
    if (std::strncmp(field, "resource_limits.", 16) == 0) {
      return getMetaStruct<DDS::ResourceLimitsQosPolicy>().getValue(ser, field + 16);
    } else {
      gen_skip_over(ser, static_cast<DDS::ResourceLimitsQosPolicy*>(0));
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::UserDataQosPolicy*>(0));
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::OwnershipQosPolicy*>(0));
    }
    if (std::strncmp(field, "time_based_filter.", 18) == 0) {
      return getMetaStruct<DDS::TimeBasedFilterQosPolicy>().getValue(ser, field + 18);
    } else {
      gen_skip_over(ser, static_cast<DDS::TimeBasedFilterQosPolicy*>(0));
    }
    if (std::strncmp(field, "reader_data_lifecycle.", 22) == 0) {
      return getMetaStruct<DDS::ReaderDataLifecycleQosPolicy>().getValue(ser, field + 22);
    } else {
      gen_skip_over(ser, static_cast<DDS::ReaderDataLifecycleQosPolicy*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::DataReaderQos");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "durability.", 11) == 0) {
      return make_struct_cmp(&T::durability, getMetaStruct<DDS::DurabilityQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return make_struct_cmp(&T::deadline, getMetaStruct<DDS::DeadlineQosPolicy>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return make_struct_cmp(&T::latency_budget, getMetaStruct<DDS::LatencyBudgetQosPolicy>().create_qc_comparator(field + 15), next);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return make_struct_cmp(&T::liveliness, getMetaStruct<DDS::LivelinessQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return make_struct_cmp(&T::reliability, getMetaStruct<DDS::ReliabilityQosPolicy>().create_qc_comparator(field + 12), next);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return make_struct_cmp(&T::destination_order, getMetaStruct<DDS::DestinationOrderQosPolicy>().create_qc_comparator(field + 18), next);
    }
    if (std::strncmp(field, "history.", 8) == 0) {
      return make_struct_cmp(&T::history, getMetaStruct<DDS::HistoryQosPolicy>().create_qc_comparator(field + 8), next);
    }
    if (std::strncmp(field, "resource_limits.", 16) == 0) {
      return make_struct_cmp(&T::resource_limits, getMetaStruct<DDS::ResourceLimitsQosPolicy>().create_qc_comparator(field + 16), next);
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return make_struct_cmp(&T::user_data, getMetaStruct<DDS::UserDataQosPolicy>().create_qc_comparator(field + 10), next);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return make_struct_cmp(&T::ownership, getMetaStruct<DDS::OwnershipQosPolicy>().create_qc_comparator(field + 10), next);
    }
    if (std::strncmp(field, "time_based_filter.", 18) == 0) {
      return make_struct_cmp(&T::time_based_filter, getMetaStruct<DDS::TimeBasedFilterQosPolicy>().create_qc_comparator(field + 18), next);
    }
    if (std::strncmp(field, "reader_data_lifecycle.", 22) == 0) {
      return make_struct_cmp(&T::reader_data_lifecycle, getMetaStruct<DDS::ReaderDataLifecycleQosPolicy>().create_qc_comparator(field + 22), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DataReaderQos)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"durability", "deadline", "latency_budget", "liveliness", "reliability", "destination_order", "history", "resource_limits", "user_data", "ownership", "time_based_filter", "reader_data_lifecycle", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "durability") == 0) {
      return &static_cast<const T*>(stru)->durability;
    }
    if (std::strcmp(field, "deadline") == 0) {
      return &static_cast<const T*>(stru)->deadline;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      return &static_cast<const T*>(stru)->latency_budget;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      return &static_cast<const T*>(stru)->liveliness;
    }
    if (std::strcmp(field, "reliability") == 0) {
      return &static_cast<const T*>(stru)->reliability;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      return &static_cast<const T*>(stru)->destination_order;
    }
    if (std::strcmp(field, "history") == 0) {
      return &static_cast<const T*>(stru)->history;
    }
    if (std::strcmp(field, "resource_limits") == 0) {
      return &static_cast<const T*>(stru)->resource_limits;
    }
    if (std::strcmp(field, "user_data") == 0) {
      return &static_cast<const T*>(stru)->user_data;
    }
    if (std::strcmp(field, "ownership") == 0) {
      return &static_cast<const T*>(stru)->ownership;
    }
    if (std::strcmp(field, "time_based_filter") == 0) {
      return &static_cast<const T*>(stru)->time_based_filter;
    }
    if (std::strcmp(field, "reader_data_lifecycle") == 0) {
      return &static_cast<const T*>(stru)->reader_data_lifecycle;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DataReaderQos)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "durability") == 0) {
      static_cast<T*>(lhs)->durability = *static_cast<const DDS::DurabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "deadline") == 0) {
      static_cast<T*>(lhs)->deadline = *static_cast<const DDS::DeadlineQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      static_cast<T*>(lhs)->latency_budget = *static_cast<const DDS::LatencyBudgetQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      static_cast<T*>(lhs)->liveliness = *static_cast<const DDS::LivelinessQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "reliability") == 0) {
      static_cast<T*>(lhs)->reliability = *static_cast<const DDS::ReliabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      static_cast<T*>(lhs)->destination_order = *static_cast<const DDS::DestinationOrderQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "history") == 0) {
      static_cast<T*>(lhs)->history = *static_cast<const DDS::HistoryQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "resource_limits") == 0) {
      static_cast<T*>(lhs)->resource_limits = *static_cast<const DDS::ResourceLimitsQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "user_data") == 0) {
      static_cast<T*>(lhs)->user_data = *static_cast<const DDS::UserDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ownership") == 0) {
      static_cast<T*>(lhs)->ownership = *static_cast<const DDS::OwnershipQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "time_based_filter") == 0) {
      static_cast<T*>(lhs)->time_based_filter = *static_cast<const DDS::TimeBasedFilterQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "reader_data_lifecycle") == 0) {
      static_cast<T*>(lhs)->reader_data_lifecycle = *static_cast<const DDS::ReaderDataLifecycleQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DataReaderQos)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DataReaderQos)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::DataReaderQos>()
{
  static MetaStructImpl<DDS::DataReaderQos> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::DataReaderQos*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::DataReaderQos>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataReaderQos */


/* Begin STRUCT: SubscriberQos */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::SubscriberQos& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.presentation, size, padding);
  gen_find_size(stru.partition, size, padding);
  gen_find_size(stru.group_data, size, padding);
  gen_find_size(stru.entity_factory, size, padding);
}

bool operator<<(Serializer& strm, const DDS::SubscriberQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.presentation)
    && (strm << stru.partition)
    && (strm << stru.group_data)
    && (strm << stru.entity_factory);
}

bool operator>>(Serializer& strm, DDS::SubscriberQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.presentation)
    && (strm >> stru.partition)
    && (strm >> stru.group_data)
    && (strm >> stru.entity_factory);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::SubscriberQos> : MetaStruct {
  typedef DDS::SubscriberQos T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::SubscriberQos& typed = *static_cast<const DDS::SubscriberQos*>(stru);
    if (std::strncmp(field, "presentation.", 13) == 0) {
      return getMetaStruct<DDS::PresentationQosPolicy>().getValue(&typed.presentation, field + 13);
    }
    if (std::strncmp(field, "partition.", 10) == 0) {
      return getMetaStruct<DDS::PartitionQosPolicy>().getValue(&typed.partition, field + 10);
    }
    if (std::strncmp(field, "group_data.", 11) == 0) {
      return getMetaStruct<DDS::GroupDataQosPolicy>().getValue(&typed.group_data, field + 11);
    }
    if (std::strncmp(field, "entity_factory.", 15) == 0) {
      return getMetaStruct<DDS::EntityFactoryQosPolicy>().getValue(&typed.entity_factory, field + 15);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::SubscriberQos)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "presentation.", 13) == 0) {
      return getMetaStruct<DDS::PresentationQosPolicy>().getValue(ser, field + 13);
    } else {
      gen_skip_over(ser, static_cast<DDS::PresentationQosPolicy*>(0));
    }
    if (std::strncmp(field, "partition.", 10) == 0) {
      return getMetaStruct<DDS::PartitionQosPolicy>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::PartitionQosPolicy*>(0));
    }
    if (std::strncmp(field, "group_data.", 11) == 0) {
      return getMetaStruct<DDS::GroupDataQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::GroupDataQosPolicy*>(0));
    }
    if (std::strncmp(field, "entity_factory.", 15) == 0) {
      return getMetaStruct<DDS::EntityFactoryQosPolicy>().getValue(ser, field + 15);
    } else {
      gen_skip_over(ser, static_cast<DDS::EntityFactoryQosPolicy*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::SubscriberQos");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "presentation.", 13) == 0) {
      return make_struct_cmp(&T::presentation, getMetaStruct<DDS::PresentationQosPolicy>().create_qc_comparator(field + 13), next);
    }
    if (std::strncmp(field, "partition.", 10) == 0) {
      return make_struct_cmp(&T::partition, getMetaStruct<DDS::PartitionQosPolicy>().create_qc_comparator(field + 10), next);
    }
    if (std::strncmp(field, "group_data.", 11) == 0) {
      return make_struct_cmp(&T::group_data, getMetaStruct<DDS::GroupDataQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "entity_factory.", 15) == 0) {
      return make_struct_cmp(&T::entity_factory, getMetaStruct<DDS::EntityFactoryQosPolicy>().create_qc_comparator(field + 15), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::SubscriberQos)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"presentation", "partition", "group_data", "entity_factory", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "presentation") == 0) {
      return &static_cast<const T*>(stru)->presentation;
    }
    if (std::strcmp(field, "partition") == 0) {
      return &static_cast<const T*>(stru)->partition;
    }
    if (std::strcmp(field, "group_data") == 0) {
      return &static_cast<const T*>(stru)->group_data;
    }
    if (std::strcmp(field, "entity_factory") == 0) {
      return &static_cast<const T*>(stru)->entity_factory;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::SubscriberQos)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "presentation") == 0) {
      static_cast<T*>(lhs)->presentation = *static_cast<const DDS::PresentationQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "partition") == 0) {
      static_cast<T*>(lhs)->partition = *static_cast<const DDS::PartitionQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "group_data") == 0) {
      static_cast<T*>(lhs)->group_data = *static_cast<const DDS::GroupDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "entity_factory") == 0) {
      static_cast<T*>(lhs)->entity_factory = *static_cast<const DDS::EntityFactoryQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::SubscriberQos)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::SubscriberQos)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::SubscriberQos>()
{
  static MetaStructImpl<DDS::SubscriberQos> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::SubscriberQos*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::SubscriberQos>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SubscriberQos */


/* Begin STRUCT: DomainParticipantFactoryQos */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::DomainParticipantFactoryQos& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.entity_factory, size, padding);
}

bool operator<<(Serializer& strm, const DDS::DomainParticipantFactoryQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.entity_factory);
}

bool operator>>(Serializer& strm, DDS::DomainParticipantFactoryQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.entity_factory);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::DomainParticipantFactoryQos> : MetaStruct {
  typedef DDS::DomainParticipantFactoryQos T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::DomainParticipantFactoryQos& typed = *static_cast<const DDS::DomainParticipantFactoryQos*>(stru);
    if (std::strncmp(field, "entity_factory.", 15) == 0) {
      return getMetaStruct<DDS::EntityFactoryQosPolicy>().getValue(&typed.entity_factory, field + 15);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DomainParticipantFactoryQos)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "entity_factory.", 15) == 0) {
      return getMetaStruct<DDS::EntityFactoryQosPolicy>().getValue(ser, field + 15);
    } else {
      gen_skip_over(ser, static_cast<DDS::EntityFactoryQosPolicy*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::DomainParticipantFactoryQos");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "entity_factory.", 15) == 0) {
      return make_struct_cmp(&T::entity_factory, getMetaStruct<DDS::EntityFactoryQosPolicy>().create_qc_comparator(field + 15), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DomainParticipantFactoryQos)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"entity_factory", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "entity_factory") == 0) {
      return &static_cast<const T*>(stru)->entity_factory;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DomainParticipantFactoryQos)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "entity_factory") == 0) {
      static_cast<T*>(lhs)->entity_factory = *static_cast<const DDS::EntityFactoryQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DomainParticipantFactoryQos)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DomainParticipantFactoryQos)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::DomainParticipantFactoryQos>()
{
  static MetaStructImpl<DDS::DomainParticipantFactoryQos> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::DomainParticipantFactoryQos*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::DomainParticipantFactoryQos>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DomainParticipantFactoryQos */


/* Begin STRUCT: DomainParticipantQos */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::DomainParticipantQos& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.user_data, size, padding);
  gen_find_size(stru.entity_factory, size, padding);
}

bool operator<<(Serializer& strm, const DDS::DomainParticipantQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.user_data)
    && (strm << stru.entity_factory);
}

bool operator>>(Serializer& strm, DDS::DomainParticipantQos& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.user_data)
    && (strm >> stru.entity_factory);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::DomainParticipantQos> : MetaStruct {
  typedef DDS::DomainParticipantQos T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::DomainParticipantQos& typed = *static_cast<const DDS::DomainParticipantQos*>(stru);
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(&typed.user_data, field + 10);
    }
    if (std::strncmp(field, "entity_factory.", 15) == 0) {
      return getMetaStruct<DDS::EntityFactoryQosPolicy>().getValue(&typed.entity_factory, field + 15);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DomainParticipantQos)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::UserDataQosPolicy*>(0));
    }
    if (std::strncmp(field, "entity_factory.", 15) == 0) {
      return getMetaStruct<DDS::EntityFactoryQosPolicy>().getValue(ser, field + 15);
    } else {
      gen_skip_over(ser, static_cast<DDS::EntityFactoryQosPolicy*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::DomainParticipantQos");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return make_struct_cmp(&T::user_data, getMetaStruct<DDS::UserDataQosPolicy>().create_qc_comparator(field + 10), next);
    }
    if (std::strncmp(field, "entity_factory.", 15) == 0) {
      return make_struct_cmp(&T::entity_factory, getMetaStruct<DDS::EntityFactoryQosPolicy>().create_qc_comparator(field + 15), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DomainParticipantQos)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"user_data", "entity_factory", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "user_data") == 0) {
      return &static_cast<const T*>(stru)->user_data;
    }
    if (std::strcmp(field, "entity_factory") == 0) {
      return &static_cast<const T*>(stru)->entity_factory;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DomainParticipantQos)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "user_data") == 0) {
      static_cast<T*>(lhs)->user_data = *static_cast<const DDS::UserDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "entity_factory") == 0) {
      static_cast<T*>(lhs)->entity_factory = *static_cast<const DDS::EntityFactoryQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DomainParticipantQos)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DomainParticipantQos)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::DomainParticipantQos>()
{
  static MetaStructImpl<DDS::DomainParticipantQos> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::DomainParticipantQos*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::DomainParticipantQos>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DomainParticipantQos */


/* Begin STRUCT: BuiltinTopicKey_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::BuiltinTopicKey_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  DDS::BuiltinTopicKeyValue_forany stru_value(const_cast<DDS::BuiltinTopicKeyValue_slice*>(stru.value));
  gen_find_size(stru_value, size, padding);
}

bool operator<<(Serializer& strm, const DDS::BuiltinTopicKey_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  DDS::BuiltinTopicKeyValue_forany stru_value(const_cast<DDS::BuiltinTopicKeyValue_slice*>(stru.value));
  return (strm << stru_value);
}

bool operator>>(Serializer& strm, DDS::BuiltinTopicKey_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  DDS::BuiltinTopicKeyValue_forany stru_value(const_cast<DDS::BuiltinTopicKeyValue_slice*>(stru.value));
  return (strm >> stru_value);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::BuiltinTopicKey_t> : MetaStruct {
  typedef DDS::BuiltinTopicKey_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::BuiltinTopicKey_t& typed = *static_cast<const DDS::BuiltinTopicKey_t*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::BuiltinTopicKey_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<DDS::BuiltinTopicKeyValue_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::BuiltinTopicKey_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::BuiltinTopicKey_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::BuiltinTopicKey_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      DDS::BuiltinTopicKeyValue* lhsArr = &static_cast<T*>(lhs)->value;
      const DDS::BuiltinTopicKeyValue* rhsArr = static_cast<const DDS::BuiltinTopicKeyValue*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 3; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::BuiltinTopicKey_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::BuiltinTopicKey_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::BuiltinTopicKey_t>()
{
  static MetaStructImpl<DDS::BuiltinTopicKey_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::BuiltinTopicKey_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::BuiltinTopicKey_t>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: BuiltinTopicKey_t */


/* Begin STRUCT: ParticipantBuiltinTopicData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::ParticipantBuiltinTopicData& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.key, size, padding);
  gen_find_size(stru.user_data, size, padding);
}

bool operator<<(Serializer& strm, const DDS::ParticipantBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.key)
    && (strm << stru.user_data);
}

bool operator>>(Serializer& strm, DDS::ParticipantBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.key)
    && (strm >> stru.user_data);
}

size_t gen_max_marshaled_size(const DDS::ParticipantBuiltinTopicData& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const DDS::ParticipantBuiltinTopicData> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 12;
}

void gen_find_size(KeyOnly<const DDS::ParticipantBuiltinTopicData> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.key.value[0]);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.key.value[1]);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.key.value[2]);
}

bool operator<<(Serializer& strm, KeyOnly<const DDS::ParticipantBuiltinTopicData> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.t.key.value[0])
    && (strm << stru.t.key.value[1])
    && (strm << stru.t.key.value[2]);
}

bool operator>>(Serializer& strm, KeyOnly<DDS::ParticipantBuiltinTopicData> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.t.key.value[0])
    && (strm >> stru.t.key.value[1])
    && (strm >> stru.t.key.value[2]);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace DDS {
::DDS::DataWriter_ptr ParticipantBuiltinTopicDataTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<ParticipantBuiltinTopicData> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr ParticipantBuiltinTopicDataTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<ParticipantBuiltinTopicData> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr ParticipantBuiltinTopicDataTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<ParticipantBuiltinTopicData> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<ParticipantBuiltinTopicData, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& ParticipantBuiltinTopicDataTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<ParticipantBuiltinTopicData>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool ParticipantBuiltinTopicDataTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* ParticipantBuiltinTopicDataTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
ParticipantBuiltinTopicDataTypeSupport::_ptr_type ParticipantBuiltinTopicDataTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::ParticipantBuiltinTopicData> : MetaStruct {
  typedef DDS::ParticipantBuiltinTopicData T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 3; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::ParticipantBuiltinTopicData& typed = *static_cast<const DDS::ParticipantBuiltinTopicData*>(stru);
    if (std::strncmp(field, "key.", 4) == 0) {
      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(&typed.key, field + 4);
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(&typed.user_data, field + 10);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ParticipantBuiltinTopicData)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "key.", 4) == 0) {
      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(ser, field + 4);
    } else {
      gen_skip_over(ser, static_cast<DDS::BuiltinTopicKey_t*>(0));
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::UserDataQosPolicy*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::ParticipantBuiltinTopicData");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "key.", 4) == 0) {
      return make_struct_cmp(&T::key, getMetaStruct<DDS::BuiltinTopicKey_t>().create_qc_comparator(field + 4), next);
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return make_struct_cmp(&T::user_data, getMetaStruct<DDS::UserDataQosPolicy>().create_qc_comparator(field + 10), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ParticipantBuiltinTopicData)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"key", "user_data", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "key") == 0) {
      return &static_cast<const T*>(stru)->key;
    }
    if (std::strcmp(field, "user_data") == 0) {
      return &static_cast<const T*>(stru)->user_data;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ParticipantBuiltinTopicData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "key") == 0) {
      static_cast<T*>(lhs)->key = *static_cast<const DDS::BuiltinTopicKey_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "user_data") == 0) {
      static_cast<T*>(lhs)->user_data = *static_cast<const DDS::UserDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ParticipantBuiltinTopicData)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ParticipantBuiltinTopicData)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::ParticipantBuiltinTopicData>()
{
  static MetaStructImpl<DDS::ParticipantBuiltinTopicData> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::ParticipantBuiltinTopicData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::ParticipantBuiltinTopicData>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ParticipantBuiltinTopicData */


/* Begin STRUCT: PublicationBuiltinTopicData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::PublicationBuiltinTopicData& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.key, size, padding);
  gen_find_size(stru.participant_key, size, padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.topic_name.in()) + 1;
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.type_name.in()) + 1;
  gen_find_size(stru.durability, size, padding);
  gen_find_size(stru.durability_service, size, padding);
  gen_find_size(stru.deadline, size, padding);
  gen_find_size(stru.latency_budget, size, padding);
  gen_find_size(stru.liveliness, size, padding);
  gen_find_size(stru.reliability, size, padding);
  gen_find_size(stru.lifespan, size, padding);
  gen_find_size(stru.user_data, size, padding);
  gen_find_size(stru.ownership, size, padding);
  gen_find_size(stru.ownership_strength, size, padding);
  gen_find_size(stru.destination_order, size, padding);
  gen_find_size(stru.presentation, size, padding);
  gen_find_size(stru.partition, size, padding);
  gen_find_size(stru.topic_data, size, padding);
  gen_find_size(stru.group_data, size, padding);
}

bool operator<<(Serializer& strm, const DDS::PublicationBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.key)
    && (strm << stru.participant_key)
    && (strm << stru.topic_name.in())
    && (strm << stru.type_name.in())
    && (strm << stru.durability)
    && (strm << stru.durability_service)
    && (strm << stru.deadline)
    && (strm << stru.latency_budget)
    && (strm << stru.liveliness)
    && (strm << stru.reliability)
    && (strm << stru.lifespan)
    && (strm << stru.user_data)
    && (strm << stru.ownership)
    && (strm << stru.ownership_strength)
    && (strm << stru.destination_order)
    && (strm << stru.presentation)
    && (strm << stru.partition)
    && (strm << stru.topic_data)
    && (strm << stru.group_data);
}

bool operator>>(Serializer& strm, DDS::PublicationBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.key)
    && (strm >> stru.participant_key)
    && (strm >> stru.topic_name.out())
    && (strm >> stru.type_name.out())
    && (strm >> stru.durability)
    && (strm >> stru.durability_service)
    && (strm >> stru.deadline)
    && (strm >> stru.latency_budget)
    && (strm >> stru.liveliness)
    && (strm >> stru.reliability)
    && (strm >> stru.lifespan)
    && (strm >> stru.user_data)
    && (strm >> stru.ownership)
    && (strm >> stru.ownership_strength)
    && (strm >> stru.destination_order)
    && (strm >> stru.presentation)
    && (strm >> stru.partition)
    && (strm >> stru.topic_data)
    && (strm >> stru.group_data);
}

size_t gen_max_marshaled_size(const DDS::PublicationBuiltinTopicData& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const DDS::PublicationBuiltinTopicData> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 12;
}

void gen_find_size(KeyOnly<const DDS::PublicationBuiltinTopicData> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.key.value[0]);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.key.value[1]);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.key.value[2]);
}

bool operator<<(Serializer& strm, KeyOnly<const DDS::PublicationBuiltinTopicData> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.t.key.value[0])
    && (strm << stru.t.key.value[1])
    && (strm << stru.t.key.value[2]);
}

bool operator>>(Serializer& strm, KeyOnly<DDS::PublicationBuiltinTopicData> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.t.key.value[0])
    && (strm >> stru.t.key.value[1])
    && (strm >> stru.t.key.value[2]);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace DDS {
::DDS::DataWriter_ptr PublicationBuiltinTopicDataTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<PublicationBuiltinTopicData> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr PublicationBuiltinTopicDataTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<PublicationBuiltinTopicData> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr PublicationBuiltinTopicDataTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<PublicationBuiltinTopicData> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<PublicationBuiltinTopicData, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& PublicationBuiltinTopicDataTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<PublicationBuiltinTopicData>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool PublicationBuiltinTopicDataTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* PublicationBuiltinTopicDataTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
PublicationBuiltinTopicDataTypeSupport::_ptr_type PublicationBuiltinTopicDataTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::PublicationBuiltinTopicData> : MetaStruct {
  typedef DDS::PublicationBuiltinTopicData T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 3; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::PublicationBuiltinTopicData& typed = *static_cast<const DDS::PublicationBuiltinTopicData*>(stru);
    if (std::strncmp(field, "key.", 4) == 0) {
      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(&typed.key, field + 4);
    }
    if (std::strncmp(field, "participant_key.", 16) == 0) {
      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(&typed.participant_key, field + 16);
    }
    if (std::strcmp(field, "topic_name") == 0) {
      return typed.topic_name.in();
    }
    if (std::strcmp(field, "type_name") == 0) {
      return typed.type_name.in();
    }
    if (std::strncmp(field, "durability.", 11) == 0) {
      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(&typed.durability, field + 11);
    }
    if (std::strncmp(field, "durability_service.", 19) == 0) {
      return getMetaStruct<DDS::DurabilityServiceQosPolicy>().getValue(&typed.durability_service, field + 19);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(&typed.deadline, field + 9);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(&typed.latency_budget, field + 15);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(&typed.liveliness, field + 11);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(&typed.reliability, field + 12);
    }
    if (std::strncmp(field, "lifespan.", 9) == 0) {
      return getMetaStruct<DDS::LifespanQosPolicy>().getValue(&typed.lifespan, field + 9);
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(&typed.user_data, field + 10);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(&typed.ownership, field + 10);
    }
    if (std::strncmp(field, "ownership_strength.", 19) == 0) {
      return getMetaStruct<DDS::OwnershipStrengthQosPolicy>().getValue(&typed.ownership_strength, field + 19);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(&typed.destination_order, field + 18);
    }
    if (std::strncmp(field, "presentation.", 13) == 0) {
      return getMetaStruct<DDS::PresentationQosPolicy>().getValue(&typed.presentation, field + 13);
    }
    if (std::strncmp(field, "partition.", 10) == 0) {
      return getMetaStruct<DDS::PartitionQosPolicy>().getValue(&typed.partition, field + 10);
    }
    if (std::strncmp(field, "topic_data.", 11) == 0) {
      return getMetaStruct<DDS::TopicDataQosPolicy>().getValue(&typed.topic_data, field + 11);
    }
    if (std::strncmp(field, "group_data.", 11) == 0) {
      return getMetaStruct<DDS::GroupDataQosPolicy>().getValue(&typed.group_data, field + 11);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PublicationBuiltinTopicData)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "key.", 4) == 0) {
      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(ser, field + 4);
    } else {
      gen_skip_over(ser, static_cast<DDS::BuiltinTopicKey_t*>(0));
    }
    if (std::strncmp(field, "participant_key.", 16) == 0) {
      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(ser, field + 16);
    } else {
      gen_skip_over(ser, static_cast<DDS::BuiltinTopicKey_t*>(0));
    }
    if (std::strcmp(field, "topic_name") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'topic_name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'topic_name' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strcmp(field, "type_name") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'type_name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'type_name' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strncmp(field, "durability.", 11) == 0) {
      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::DurabilityQosPolicy*>(0));
    }
    if (std::strncmp(field, "durability_service.", 19) == 0) {
      return getMetaStruct<DDS::DurabilityServiceQosPolicy>().getValue(ser, field + 19);
    } else {
      gen_skip_over(ser, static_cast<DDS::DurabilityServiceQosPolicy*>(0));
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<DDS::DeadlineQosPolicy*>(0));
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(ser, field + 15);
    } else {
      gen_skip_over(ser, static_cast<DDS::LatencyBudgetQosPolicy*>(0));
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::LivelinessQosPolicy*>(0));
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(ser, field + 12);
    } else {
      gen_skip_over(ser, static_cast<DDS::ReliabilityQosPolicy*>(0));
    }
    if (std::strncmp(field, "lifespan.", 9) == 0) {
      return getMetaStruct<DDS::LifespanQosPolicy>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<DDS::LifespanQosPolicy*>(0));
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::UserDataQosPolicy*>(0));
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::OwnershipQosPolicy*>(0));
    }
    if (std::strncmp(field, "ownership_strength.", 19) == 0) {
      return getMetaStruct<DDS::OwnershipStrengthQosPolicy>().getValue(ser, field + 19);
    } else {
      gen_skip_over(ser, static_cast<DDS::OwnershipStrengthQosPolicy*>(0));
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(ser, field + 18);
    } else {
      gen_skip_over(ser, static_cast<DDS::DestinationOrderQosPolicy*>(0));
    }
    if (std::strncmp(field, "presentation.", 13) == 0) {
      return getMetaStruct<DDS::PresentationQosPolicy>().getValue(ser, field + 13);
    } else {
      gen_skip_over(ser, static_cast<DDS::PresentationQosPolicy*>(0));
    }
    if (std::strncmp(field, "partition.", 10) == 0) {
      return getMetaStruct<DDS::PartitionQosPolicy>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::PartitionQosPolicy*>(0));
    }
    if (std::strncmp(field, "topic_data.", 11) == 0) {
      return getMetaStruct<DDS::TopicDataQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::TopicDataQosPolicy*>(0));
    }
    if (std::strncmp(field, "group_data.", 11) == 0) {
      return getMetaStruct<DDS::GroupDataQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::GroupDataQosPolicy*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::PublicationBuiltinTopicData");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "key.", 4) == 0) {
      return make_struct_cmp(&T::key, getMetaStruct<DDS::BuiltinTopicKey_t>().create_qc_comparator(field + 4), next);
    }
    if (std::strncmp(field, "participant_key.", 16) == 0) {
      return make_struct_cmp(&T::participant_key, getMetaStruct<DDS::BuiltinTopicKey_t>().create_qc_comparator(field + 16), next);
    }
    if (std::strcmp(field, "topic_name") == 0) {
      return make_field_cmp(&T::topic_name, next);
    }
    if (std::strcmp(field, "type_name") == 0) {
      return make_field_cmp(&T::type_name, next);
    }
    if (std::strncmp(field, "durability.", 11) == 0) {
      return make_struct_cmp(&T::durability, getMetaStruct<DDS::DurabilityQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "durability_service.", 19) == 0) {
      return make_struct_cmp(&T::durability_service, getMetaStruct<DDS::DurabilityServiceQosPolicy>().create_qc_comparator(field + 19), next);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return make_struct_cmp(&T::deadline, getMetaStruct<DDS::DeadlineQosPolicy>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return make_struct_cmp(&T::latency_budget, getMetaStruct<DDS::LatencyBudgetQosPolicy>().create_qc_comparator(field + 15), next);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return make_struct_cmp(&T::liveliness, getMetaStruct<DDS::LivelinessQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return make_struct_cmp(&T::reliability, getMetaStruct<DDS::ReliabilityQosPolicy>().create_qc_comparator(field + 12), next);
    }
    if (std::strncmp(field, "lifespan.", 9) == 0) {
      return make_struct_cmp(&T::lifespan, getMetaStruct<DDS::LifespanQosPolicy>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return make_struct_cmp(&T::user_data, getMetaStruct<DDS::UserDataQosPolicy>().create_qc_comparator(field + 10), next);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return make_struct_cmp(&T::ownership, getMetaStruct<DDS::OwnershipQosPolicy>().create_qc_comparator(field + 10), next);
    }
    if (std::strncmp(field, "ownership_strength.", 19) == 0) {
      return make_struct_cmp(&T::ownership_strength, getMetaStruct<DDS::OwnershipStrengthQosPolicy>().create_qc_comparator(field + 19), next);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return make_struct_cmp(&T::destination_order, getMetaStruct<DDS::DestinationOrderQosPolicy>().create_qc_comparator(field + 18), next);
    }
    if (std::strncmp(field, "presentation.", 13) == 0) {
      return make_struct_cmp(&T::presentation, getMetaStruct<DDS::PresentationQosPolicy>().create_qc_comparator(field + 13), next);
    }
    if (std::strncmp(field, "partition.", 10) == 0) {
      return make_struct_cmp(&T::partition, getMetaStruct<DDS::PartitionQosPolicy>().create_qc_comparator(field + 10), next);
    }
    if (std::strncmp(field, "topic_data.", 11) == 0) {
      return make_struct_cmp(&T::topic_data, getMetaStruct<DDS::TopicDataQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "group_data.", 11) == 0) {
      return make_struct_cmp(&T::group_data, getMetaStruct<DDS::GroupDataQosPolicy>().create_qc_comparator(field + 11), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PublicationBuiltinTopicData)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"key", "participant_key", "topic_name", "type_name", "durability", "durability_service", "deadline", "latency_budget", "liveliness", "reliability", "lifespan", "user_data", "ownership", "ownership_strength", "destination_order", "presentation", "partition", "topic_data", "group_data", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "key") == 0) {
      return &static_cast<const T*>(stru)->key;
    }
    if (std::strcmp(field, "participant_key") == 0) {
      return &static_cast<const T*>(stru)->participant_key;
    }
    if (std::strcmp(field, "topic_name") == 0) {
      return &static_cast<const T*>(stru)->topic_name;
    }
    if (std::strcmp(field, "type_name") == 0) {
      return &static_cast<const T*>(stru)->type_name;
    }
    if (std::strcmp(field, "durability") == 0) {
      return &static_cast<const T*>(stru)->durability;
    }
    if (std::strcmp(field, "durability_service") == 0) {
      return &static_cast<const T*>(stru)->durability_service;
    }
    if (std::strcmp(field, "deadline") == 0) {
      return &static_cast<const T*>(stru)->deadline;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      return &static_cast<const T*>(stru)->latency_budget;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      return &static_cast<const T*>(stru)->liveliness;
    }
    if (std::strcmp(field, "reliability") == 0) {
      return &static_cast<const T*>(stru)->reliability;
    }
    if (std::strcmp(field, "lifespan") == 0) {
      return &static_cast<const T*>(stru)->lifespan;
    }
    if (std::strcmp(field, "user_data") == 0) {
      return &static_cast<const T*>(stru)->user_data;
    }
    if (std::strcmp(field, "ownership") == 0) {
      return &static_cast<const T*>(stru)->ownership;
    }
    if (std::strcmp(field, "ownership_strength") == 0) {
      return &static_cast<const T*>(stru)->ownership_strength;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      return &static_cast<const T*>(stru)->destination_order;
    }
    if (std::strcmp(field, "presentation") == 0) {
      return &static_cast<const T*>(stru)->presentation;
    }
    if (std::strcmp(field, "partition") == 0) {
      return &static_cast<const T*>(stru)->partition;
    }
    if (std::strcmp(field, "topic_data") == 0) {
      return &static_cast<const T*>(stru)->topic_data;
    }
    if (std::strcmp(field, "group_data") == 0) {
      return &static_cast<const T*>(stru)->group_data;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PublicationBuiltinTopicData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "key") == 0) {
      static_cast<T*>(lhs)->key = *static_cast<const DDS::BuiltinTopicKey_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "participant_key") == 0) {
      static_cast<T*>(lhs)->participant_key = *static_cast<const DDS::BuiltinTopicKey_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "topic_name") == 0) {
      static_cast<T*>(lhs)->topic_name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "type_name") == 0) {
      static_cast<T*>(lhs)->type_name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "durability") == 0) {
      static_cast<T*>(lhs)->durability = *static_cast<const DDS::DurabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "durability_service") == 0) {
      static_cast<T*>(lhs)->durability_service = *static_cast<const DDS::DurabilityServiceQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "deadline") == 0) {
      static_cast<T*>(lhs)->deadline = *static_cast<const DDS::DeadlineQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      static_cast<T*>(lhs)->latency_budget = *static_cast<const DDS::LatencyBudgetQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      static_cast<T*>(lhs)->liveliness = *static_cast<const DDS::LivelinessQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "reliability") == 0) {
      static_cast<T*>(lhs)->reliability = *static_cast<const DDS::ReliabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "lifespan") == 0) {
      static_cast<T*>(lhs)->lifespan = *static_cast<const DDS::LifespanQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "user_data") == 0) {
      static_cast<T*>(lhs)->user_data = *static_cast<const DDS::UserDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ownership") == 0) {
      static_cast<T*>(lhs)->ownership = *static_cast<const DDS::OwnershipQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ownership_strength") == 0) {
      static_cast<T*>(lhs)->ownership_strength = *static_cast<const DDS::OwnershipStrengthQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      static_cast<T*>(lhs)->destination_order = *static_cast<const DDS::DestinationOrderQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "presentation") == 0) {
      static_cast<T*>(lhs)->presentation = *static_cast<const DDS::PresentationQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "partition") == 0) {
      static_cast<T*>(lhs)->partition = *static_cast<const DDS::PartitionQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "topic_data") == 0) {
      static_cast<T*>(lhs)->topic_data = *static_cast<const DDS::TopicDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "group_data") == 0) {
      static_cast<T*>(lhs)->group_data = *static_cast<const DDS::GroupDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PublicationBuiltinTopicData)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "topic_name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->topic_name.in(), static_cast<const T*>(rhs)->topic_name.in());
    }
    if (std::strcmp(field, "type_name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->type_name.in(), static_cast<const T*>(rhs)->type_name.in());
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PublicationBuiltinTopicData)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::PublicationBuiltinTopicData>()
{
  static MetaStructImpl<DDS::PublicationBuiltinTopicData> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::PublicationBuiltinTopicData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::PublicationBuiltinTopicData>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PublicationBuiltinTopicData */


/* Begin STRUCT: SubscriptionBuiltinTopicData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::SubscriptionBuiltinTopicData& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.key, size, padding);
  gen_find_size(stru.participant_key, size, padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.topic_name.in()) + 1;
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.type_name.in()) + 1;
  gen_find_size(stru.durability, size, padding);
  gen_find_size(stru.deadline, size, padding);
  gen_find_size(stru.latency_budget, size, padding);
  gen_find_size(stru.liveliness, size, padding);
  gen_find_size(stru.reliability, size, padding);
  gen_find_size(stru.ownership, size, padding);
  gen_find_size(stru.destination_order, size, padding);
  gen_find_size(stru.user_data, size, padding);
  gen_find_size(stru.time_based_filter, size, padding);
  gen_find_size(stru.presentation, size, padding);
  gen_find_size(stru.partition, size, padding);
  gen_find_size(stru.topic_data, size, padding);
  gen_find_size(stru.group_data, size, padding);
}

bool operator<<(Serializer& strm, const DDS::SubscriptionBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.key)
    && (strm << stru.participant_key)
    && (strm << stru.topic_name.in())
    && (strm << stru.type_name.in())
    && (strm << stru.durability)
    && (strm << stru.deadline)
    && (strm << stru.latency_budget)
    && (strm << stru.liveliness)
    && (strm << stru.reliability)
    && (strm << stru.ownership)
    && (strm << stru.destination_order)
    && (strm << stru.user_data)
    && (strm << stru.time_based_filter)
    && (strm << stru.presentation)
    && (strm << stru.partition)
    && (strm << stru.topic_data)
    && (strm << stru.group_data);
}

bool operator>>(Serializer& strm, DDS::SubscriptionBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.key)
    && (strm >> stru.participant_key)
    && (strm >> stru.topic_name.out())
    && (strm >> stru.type_name.out())
    && (strm >> stru.durability)
    && (strm >> stru.deadline)
    && (strm >> stru.latency_budget)
    && (strm >> stru.liveliness)
    && (strm >> stru.reliability)
    && (strm >> stru.ownership)
    && (strm >> stru.destination_order)
    && (strm >> stru.user_data)
    && (strm >> stru.time_based_filter)
    && (strm >> stru.presentation)
    && (strm >> stru.partition)
    && (strm >> stru.topic_data)
    && (strm >> stru.group_data);
}

size_t gen_max_marshaled_size(const DDS::SubscriptionBuiltinTopicData& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const DDS::SubscriptionBuiltinTopicData> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 12;
}

void gen_find_size(KeyOnly<const DDS::SubscriptionBuiltinTopicData> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.key.value[0]);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.key.value[1]);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.key.value[2]);
}

bool operator<<(Serializer& strm, KeyOnly<const DDS::SubscriptionBuiltinTopicData> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.t.key.value[0])
    && (strm << stru.t.key.value[1])
    && (strm << stru.t.key.value[2]);
}

bool operator>>(Serializer& strm, KeyOnly<DDS::SubscriptionBuiltinTopicData> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.t.key.value[0])
    && (strm >> stru.t.key.value[1])
    && (strm >> stru.t.key.value[2]);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace DDS {
::DDS::DataWriter_ptr SubscriptionBuiltinTopicDataTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<SubscriptionBuiltinTopicData> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr SubscriptionBuiltinTopicDataTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<SubscriptionBuiltinTopicData> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr SubscriptionBuiltinTopicDataTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<SubscriptionBuiltinTopicData> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<SubscriptionBuiltinTopicData, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& SubscriptionBuiltinTopicDataTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<SubscriptionBuiltinTopicData>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool SubscriptionBuiltinTopicDataTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* SubscriptionBuiltinTopicDataTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
SubscriptionBuiltinTopicDataTypeSupport::_ptr_type SubscriptionBuiltinTopicDataTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::SubscriptionBuiltinTopicData> : MetaStruct {
  typedef DDS::SubscriptionBuiltinTopicData T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 3; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::SubscriptionBuiltinTopicData& typed = *static_cast<const DDS::SubscriptionBuiltinTopicData*>(stru);
    if (std::strncmp(field, "key.", 4) == 0) {
      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(&typed.key, field + 4);
    }
    if (std::strncmp(field, "participant_key.", 16) == 0) {
      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(&typed.participant_key, field + 16);
    }
    if (std::strcmp(field, "topic_name") == 0) {
      return typed.topic_name.in();
    }
    if (std::strcmp(field, "type_name") == 0) {
      return typed.type_name.in();
    }
    if (std::strncmp(field, "durability.", 11) == 0) {
      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(&typed.durability, field + 11);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(&typed.deadline, field + 9);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(&typed.latency_budget, field + 15);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(&typed.liveliness, field + 11);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(&typed.reliability, field + 12);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(&typed.ownership, field + 10);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(&typed.destination_order, field + 18);
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(&typed.user_data, field + 10);
    }
    if (std::strncmp(field, "time_based_filter.", 18) == 0) {
      return getMetaStruct<DDS::TimeBasedFilterQosPolicy>().getValue(&typed.time_based_filter, field + 18);
    }
    if (std::strncmp(field, "presentation.", 13) == 0) {
      return getMetaStruct<DDS::PresentationQosPolicy>().getValue(&typed.presentation, field + 13);
    }
    if (std::strncmp(field, "partition.", 10) == 0) {
      return getMetaStruct<DDS::PartitionQosPolicy>().getValue(&typed.partition, field + 10);
    }
    if (std::strncmp(field, "topic_data.", 11) == 0) {
      return getMetaStruct<DDS::TopicDataQosPolicy>().getValue(&typed.topic_data, field + 11);
    }
    if (std::strncmp(field, "group_data.", 11) == 0) {
      return getMetaStruct<DDS::GroupDataQosPolicy>().getValue(&typed.group_data, field + 11);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::SubscriptionBuiltinTopicData)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "key.", 4) == 0) {
      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(ser, field + 4);
    } else {
      gen_skip_over(ser, static_cast<DDS::BuiltinTopicKey_t*>(0));
    }
    if (std::strncmp(field, "participant_key.", 16) == 0) {
      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(ser, field + 16);
    } else {
      gen_skip_over(ser, static_cast<DDS::BuiltinTopicKey_t*>(0));
    }
    if (std::strcmp(field, "topic_name") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'topic_name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'topic_name' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strcmp(field, "type_name") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'type_name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'type_name' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strncmp(field, "durability.", 11) == 0) {
      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::DurabilityQosPolicy*>(0));
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<DDS::DeadlineQosPolicy*>(0));
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(ser, field + 15);
    } else {
      gen_skip_over(ser, static_cast<DDS::LatencyBudgetQosPolicy*>(0));
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::LivelinessQosPolicy*>(0));
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(ser, field + 12);
    } else {
      gen_skip_over(ser, static_cast<DDS::ReliabilityQosPolicy*>(0));
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::OwnershipQosPolicy*>(0));
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(ser, field + 18);
    } else {
      gen_skip_over(ser, static_cast<DDS::DestinationOrderQosPolicy*>(0));
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::UserDataQosPolicy*>(0));
    }
    if (std::strncmp(field, "time_based_filter.", 18) == 0) {
      return getMetaStruct<DDS::TimeBasedFilterQosPolicy>().getValue(ser, field + 18);
    } else {
      gen_skip_over(ser, static_cast<DDS::TimeBasedFilterQosPolicy*>(0));
    }
    if (std::strncmp(field, "presentation.", 13) == 0) {
      return getMetaStruct<DDS::PresentationQosPolicy>().getValue(ser, field + 13);
    } else {
      gen_skip_over(ser, static_cast<DDS::PresentationQosPolicy*>(0));
    }
    if (std::strncmp(field, "partition.", 10) == 0) {
      return getMetaStruct<DDS::PartitionQosPolicy>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::PartitionQosPolicy*>(0));
    }
    if (std::strncmp(field, "topic_data.", 11) == 0) {
      return getMetaStruct<DDS::TopicDataQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::TopicDataQosPolicy*>(0));
    }
    if (std::strncmp(field, "group_data.", 11) == 0) {
      return getMetaStruct<DDS::GroupDataQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::GroupDataQosPolicy*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::SubscriptionBuiltinTopicData");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "key.", 4) == 0) {
      return make_struct_cmp(&T::key, getMetaStruct<DDS::BuiltinTopicKey_t>().create_qc_comparator(field + 4), next);
    }
    if (std::strncmp(field, "participant_key.", 16) == 0) {
      return make_struct_cmp(&T::participant_key, getMetaStruct<DDS::BuiltinTopicKey_t>().create_qc_comparator(field + 16), next);
    }
    if (std::strcmp(field, "topic_name") == 0) {
      return make_field_cmp(&T::topic_name, next);
    }
    if (std::strcmp(field, "type_name") == 0) {
      return make_field_cmp(&T::type_name, next);
    }
    if (std::strncmp(field, "durability.", 11) == 0) {
      return make_struct_cmp(&T::durability, getMetaStruct<DDS::DurabilityQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return make_struct_cmp(&T::deadline, getMetaStruct<DDS::DeadlineQosPolicy>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return make_struct_cmp(&T::latency_budget, getMetaStruct<DDS::LatencyBudgetQosPolicy>().create_qc_comparator(field + 15), next);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return make_struct_cmp(&T::liveliness, getMetaStruct<DDS::LivelinessQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return make_struct_cmp(&T::reliability, getMetaStruct<DDS::ReliabilityQosPolicy>().create_qc_comparator(field + 12), next);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return make_struct_cmp(&T::ownership, getMetaStruct<DDS::OwnershipQosPolicy>().create_qc_comparator(field + 10), next);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return make_struct_cmp(&T::destination_order, getMetaStruct<DDS::DestinationOrderQosPolicy>().create_qc_comparator(field + 18), next);
    }
    if (std::strncmp(field, "user_data.", 10) == 0) {
      return make_struct_cmp(&T::user_data, getMetaStruct<DDS::UserDataQosPolicy>().create_qc_comparator(field + 10), next);
    }
    if (std::strncmp(field, "time_based_filter.", 18) == 0) {
      return make_struct_cmp(&T::time_based_filter, getMetaStruct<DDS::TimeBasedFilterQosPolicy>().create_qc_comparator(field + 18), next);
    }
    if (std::strncmp(field, "presentation.", 13) == 0) {
      return make_struct_cmp(&T::presentation, getMetaStruct<DDS::PresentationQosPolicy>().create_qc_comparator(field + 13), next);
    }
    if (std::strncmp(field, "partition.", 10) == 0) {
      return make_struct_cmp(&T::partition, getMetaStruct<DDS::PartitionQosPolicy>().create_qc_comparator(field + 10), next);
    }
    if (std::strncmp(field, "topic_data.", 11) == 0) {
      return make_struct_cmp(&T::topic_data, getMetaStruct<DDS::TopicDataQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "group_data.", 11) == 0) {
      return make_struct_cmp(&T::group_data, getMetaStruct<DDS::GroupDataQosPolicy>().create_qc_comparator(field + 11), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::SubscriptionBuiltinTopicData)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"key", "participant_key", "topic_name", "type_name", "durability", "deadline", "latency_budget", "liveliness", "reliability", "ownership", "destination_order", "user_data", "time_based_filter", "presentation", "partition", "topic_data", "group_data", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "key") == 0) {
      return &static_cast<const T*>(stru)->key;
    }
    if (std::strcmp(field, "participant_key") == 0) {
      return &static_cast<const T*>(stru)->participant_key;
    }
    if (std::strcmp(field, "topic_name") == 0) {
      return &static_cast<const T*>(stru)->topic_name;
    }
    if (std::strcmp(field, "type_name") == 0) {
      return &static_cast<const T*>(stru)->type_name;
    }
    if (std::strcmp(field, "durability") == 0) {
      return &static_cast<const T*>(stru)->durability;
    }
    if (std::strcmp(field, "deadline") == 0) {
      return &static_cast<const T*>(stru)->deadline;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      return &static_cast<const T*>(stru)->latency_budget;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      return &static_cast<const T*>(stru)->liveliness;
    }
    if (std::strcmp(field, "reliability") == 0) {
      return &static_cast<const T*>(stru)->reliability;
    }
    if (std::strcmp(field, "ownership") == 0) {
      return &static_cast<const T*>(stru)->ownership;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      return &static_cast<const T*>(stru)->destination_order;
    }
    if (std::strcmp(field, "user_data") == 0) {
      return &static_cast<const T*>(stru)->user_data;
    }
    if (std::strcmp(field, "time_based_filter") == 0) {
      return &static_cast<const T*>(stru)->time_based_filter;
    }
    if (std::strcmp(field, "presentation") == 0) {
      return &static_cast<const T*>(stru)->presentation;
    }
    if (std::strcmp(field, "partition") == 0) {
      return &static_cast<const T*>(stru)->partition;
    }
    if (std::strcmp(field, "topic_data") == 0) {
      return &static_cast<const T*>(stru)->topic_data;
    }
    if (std::strcmp(field, "group_data") == 0) {
      return &static_cast<const T*>(stru)->group_data;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::SubscriptionBuiltinTopicData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "key") == 0) {
      static_cast<T*>(lhs)->key = *static_cast<const DDS::BuiltinTopicKey_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "participant_key") == 0) {
      static_cast<T*>(lhs)->participant_key = *static_cast<const DDS::BuiltinTopicKey_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "topic_name") == 0) {
      static_cast<T*>(lhs)->topic_name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "type_name") == 0) {
      static_cast<T*>(lhs)->type_name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "durability") == 0) {
      static_cast<T*>(lhs)->durability = *static_cast<const DDS::DurabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "deadline") == 0) {
      static_cast<T*>(lhs)->deadline = *static_cast<const DDS::DeadlineQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      static_cast<T*>(lhs)->latency_budget = *static_cast<const DDS::LatencyBudgetQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      static_cast<T*>(lhs)->liveliness = *static_cast<const DDS::LivelinessQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "reliability") == 0) {
      static_cast<T*>(lhs)->reliability = *static_cast<const DDS::ReliabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ownership") == 0) {
      static_cast<T*>(lhs)->ownership = *static_cast<const DDS::OwnershipQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      static_cast<T*>(lhs)->destination_order = *static_cast<const DDS::DestinationOrderQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "user_data") == 0) {
      static_cast<T*>(lhs)->user_data = *static_cast<const DDS::UserDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "time_based_filter") == 0) {
      static_cast<T*>(lhs)->time_based_filter = *static_cast<const DDS::TimeBasedFilterQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "presentation") == 0) {
      static_cast<T*>(lhs)->presentation = *static_cast<const DDS::PresentationQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "partition") == 0) {
      static_cast<T*>(lhs)->partition = *static_cast<const DDS::PartitionQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "topic_data") == 0) {
      static_cast<T*>(lhs)->topic_data = *static_cast<const DDS::TopicDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "group_data") == 0) {
      static_cast<T*>(lhs)->group_data = *static_cast<const DDS::GroupDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::SubscriptionBuiltinTopicData)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "topic_name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->topic_name.in(), static_cast<const T*>(rhs)->topic_name.in());
    }
    if (std::strcmp(field, "type_name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->type_name.in(), static_cast<const T*>(rhs)->type_name.in());
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::SubscriptionBuiltinTopicData)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::SubscriptionBuiltinTopicData>()
{
  static MetaStructImpl<DDS::SubscriptionBuiltinTopicData> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::SubscriptionBuiltinTopicData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::SubscriptionBuiltinTopicData>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SubscriptionBuiltinTopicData */


/* Begin STRUCT: TopicBuiltinTopicData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::TopicBuiltinTopicData& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.key, size, padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.name.in()) + 1;
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.type_name.in()) + 1;
  gen_find_size(stru.durability, size, padding);
  gen_find_size(stru.durability_service, size, padding);
  gen_find_size(stru.deadline, size, padding);
  gen_find_size(stru.latency_budget, size, padding);
  gen_find_size(stru.liveliness, size, padding);
  gen_find_size(stru.reliability, size, padding);
  gen_find_size(stru.transport_priority, size, padding);
  gen_find_size(stru.lifespan, size, padding);
  gen_find_size(stru.destination_order, size, padding);
  gen_find_size(stru.history, size, padding);
  gen_find_size(stru.resource_limits, size, padding);
  gen_find_size(stru.ownership, size, padding);
  gen_find_size(stru.topic_data, size, padding);
}

bool operator<<(Serializer& strm, const DDS::TopicBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.key)
    && (strm << stru.name.in())
    && (strm << stru.type_name.in())
    && (strm << stru.durability)
    && (strm << stru.durability_service)
    && (strm << stru.deadline)
    && (strm << stru.latency_budget)
    && (strm << stru.liveliness)
    && (strm << stru.reliability)
    && (strm << stru.transport_priority)
    && (strm << stru.lifespan)
    && (strm << stru.destination_order)
    && (strm << stru.history)
    && (strm << stru.resource_limits)
    && (strm << stru.ownership)
    && (strm << stru.topic_data);
}

bool operator>>(Serializer& strm, DDS::TopicBuiltinTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.key)
    && (strm >> stru.name.out())
    && (strm >> stru.type_name.out())
    && (strm >> stru.durability)
    && (strm >> stru.durability_service)
    && (strm >> stru.deadline)
    && (strm >> stru.latency_budget)
    && (strm >> stru.liveliness)
    && (strm >> stru.reliability)
    && (strm >> stru.transport_priority)
    && (strm >> stru.lifespan)
    && (strm >> stru.destination_order)
    && (strm >> stru.history)
    && (strm >> stru.resource_limits)
    && (strm >> stru.ownership)
    && (strm >> stru.topic_data);
}

size_t gen_max_marshaled_size(const DDS::TopicBuiltinTopicData& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const DDS::TopicBuiltinTopicData> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 12;
}

void gen_find_size(KeyOnly<const DDS::TopicBuiltinTopicData> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.key.value[0]);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.key.value[1]);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.key.value[2]);
}

bool operator<<(Serializer& strm, KeyOnly<const DDS::TopicBuiltinTopicData> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.t.key.value[0])
    && (strm << stru.t.key.value[1])
    && (strm << stru.t.key.value[2]);
}

bool operator>>(Serializer& strm, KeyOnly<DDS::TopicBuiltinTopicData> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.t.key.value[0])
    && (strm >> stru.t.key.value[1])
    && (strm >> stru.t.key.value[2]);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace DDS {
::DDS::DataWriter_ptr TopicBuiltinTopicDataTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<TopicBuiltinTopicData> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr TopicBuiltinTopicDataTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<TopicBuiltinTopicData> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr TopicBuiltinTopicDataTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<TopicBuiltinTopicData> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<TopicBuiltinTopicData, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& TopicBuiltinTopicDataTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<TopicBuiltinTopicData>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool TopicBuiltinTopicDataTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* TopicBuiltinTopicDataTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
TopicBuiltinTopicDataTypeSupport::_ptr_type TopicBuiltinTopicDataTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::TopicBuiltinTopicData> : MetaStruct {
  typedef DDS::TopicBuiltinTopicData T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 3; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::TopicBuiltinTopicData& typed = *static_cast<const DDS::TopicBuiltinTopicData*>(stru);
    if (std::strncmp(field, "key.", 4) == 0) {
      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(&typed.key, field + 4);
    }
    if (std::strcmp(field, "name") == 0) {
      return typed.name.in();
    }
    if (std::strcmp(field, "type_name") == 0) {
      return typed.type_name.in();
    }
    if (std::strncmp(field, "durability.", 11) == 0) {
      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(&typed.durability, field + 11);
    }
    if (std::strncmp(field, "durability_service.", 19) == 0) {
      return getMetaStruct<DDS::DurabilityServiceQosPolicy>().getValue(&typed.durability_service, field + 19);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(&typed.deadline, field + 9);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(&typed.latency_budget, field + 15);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(&typed.liveliness, field + 11);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(&typed.reliability, field + 12);
    }
    if (std::strncmp(field, "transport_priority.", 19) == 0) {
      return getMetaStruct<DDS::TransportPriorityQosPolicy>().getValue(&typed.transport_priority, field + 19);
    }
    if (std::strncmp(field, "lifespan.", 9) == 0) {
      return getMetaStruct<DDS::LifespanQosPolicy>().getValue(&typed.lifespan, field + 9);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(&typed.destination_order, field + 18);
    }
    if (std::strncmp(field, "history.", 8) == 0) {
      return getMetaStruct<DDS::HistoryQosPolicy>().getValue(&typed.history, field + 8);
    }
    if (std::strncmp(field, "resource_limits.", 16) == 0) {
      return getMetaStruct<DDS::ResourceLimitsQosPolicy>().getValue(&typed.resource_limits, field + 16);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(&typed.ownership, field + 10);
    }
    if (std::strncmp(field, "topic_data.", 11) == 0) {
      return getMetaStruct<DDS::TopicDataQosPolicy>().getValue(&typed.topic_data, field + 11);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TopicBuiltinTopicData)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "key.", 4) == 0) {
      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(ser, field + 4);
    } else {
      gen_skip_over(ser, static_cast<DDS::BuiltinTopicKey_t*>(0));
    }
    if (std::strcmp(field, "name") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'name' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strcmp(field, "type_name") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'type_name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'type_name' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strncmp(field, "durability.", 11) == 0) {
      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::DurabilityQosPolicy*>(0));
    }
    if (std::strncmp(field, "durability_service.", 19) == 0) {
      return getMetaStruct<DDS::DurabilityServiceQosPolicy>().getValue(ser, field + 19);
    } else {
      gen_skip_over(ser, static_cast<DDS::DurabilityServiceQosPolicy*>(0));
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<DDS::DeadlineQosPolicy*>(0));
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(ser, field + 15);
    } else {
      gen_skip_over(ser, static_cast<DDS::LatencyBudgetQosPolicy*>(0));
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::LivelinessQosPolicy*>(0));
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(ser, field + 12);
    } else {
      gen_skip_over(ser, static_cast<DDS::ReliabilityQosPolicy*>(0));
    }
    if (std::strncmp(field, "transport_priority.", 19) == 0) {
      return getMetaStruct<DDS::TransportPriorityQosPolicy>().getValue(ser, field + 19);
    } else {
      gen_skip_over(ser, static_cast<DDS::TransportPriorityQosPolicy*>(0));
    }
    if (std::strncmp(field, "lifespan.", 9) == 0) {
      return getMetaStruct<DDS::LifespanQosPolicy>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<DDS::LifespanQosPolicy*>(0));
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(ser, field + 18);
    } else {
      gen_skip_over(ser, static_cast<DDS::DestinationOrderQosPolicy*>(0));
    }
    if (std::strncmp(field, "history.", 8) == 0) {
      return getMetaStruct<DDS::HistoryQosPolicy>().getValue(ser, field + 8);
    } else {
      gen_skip_over(ser, static_cast<DDS::HistoryQosPolicy*>(0));
    }
    if (std::strncmp(field, "resource_limits.", 16) == 0) {
      return getMetaStruct<DDS::ResourceLimitsQosPolicy>().getValue(ser, field + 16);
    } else {
      gen_skip_over(ser, static_cast<DDS::ResourceLimitsQosPolicy*>(0));
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<DDS::OwnershipQosPolicy*>(0));
    }
    if (std::strncmp(field, "topic_data.", 11) == 0) {
      return getMetaStruct<DDS::TopicDataQosPolicy>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<DDS::TopicDataQosPolicy*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::TopicBuiltinTopicData");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "key.", 4) == 0) {
      return make_struct_cmp(&T::key, getMetaStruct<DDS::BuiltinTopicKey_t>().create_qc_comparator(field + 4), next);
    }
    if (std::strcmp(field, "name") == 0) {
      return make_field_cmp(&T::name, next);
    }
    if (std::strcmp(field, "type_name") == 0) {
      return make_field_cmp(&T::type_name, next);
    }
    if (std::strncmp(field, "durability.", 11) == 0) {
      return make_struct_cmp(&T::durability, getMetaStruct<DDS::DurabilityQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "durability_service.", 19) == 0) {
      return make_struct_cmp(&T::durability_service, getMetaStruct<DDS::DurabilityServiceQosPolicy>().create_qc_comparator(field + 19), next);
    }
    if (std::strncmp(field, "deadline.", 9) == 0) {
      return make_struct_cmp(&T::deadline, getMetaStruct<DDS::DeadlineQosPolicy>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "latency_budget.", 15) == 0) {
      return make_struct_cmp(&T::latency_budget, getMetaStruct<DDS::LatencyBudgetQosPolicy>().create_qc_comparator(field + 15), next);
    }
    if (std::strncmp(field, "liveliness.", 11) == 0) {
      return make_struct_cmp(&T::liveliness, getMetaStruct<DDS::LivelinessQosPolicy>().create_qc_comparator(field + 11), next);
    }
    if (std::strncmp(field, "reliability.", 12) == 0) {
      return make_struct_cmp(&T::reliability, getMetaStruct<DDS::ReliabilityQosPolicy>().create_qc_comparator(field + 12), next);
    }
    if (std::strncmp(field, "transport_priority.", 19) == 0) {
      return make_struct_cmp(&T::transport_priority, getMetaStruct<DDS::TransportPriorityQosPolicy>().create_qc_comparator(field + 19), next);
    }
    if (std::strncmp(field, "lifespan.", 9) == 0) {
      return make_struct_cmp(&T::lifespan, getMetaStruct<DDS::LifespanQosPolicy>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "destination_order.", 18) == 0) {
      return make_struct_cmp(&T::destination_order, getMetaStruct<DDS::DestinationOrderQosPolicy>().create_qc_comparator(field + 18), next);
    }
    if (std::strncmp(field, "history.", 8) == 0) {
      return make_struct_cmp(&T::history, getMetaStruct<DDS::HistoryQosPolicy>().create_qc_comparator(field + 8), next);
    }
    if (std::strncmp(field, "resource_limits.", 16) == 0) {
      return make_struct_cmp(&T::resource_limits, getMetaStruct<DDS::ResourceLimitsQosPolicy>().create_qc_comparator(field + 16), next);
    }
    if (std::strncmp(field, "ownership.", 10) == 0) {
      return make_struct_cmp(&T::ownership, getMetaStruct<DDS::OwnershipQosPolicy>().create_qc_comparator(field + 10), next);
    }
    if (std::strncmp(field, "topic_data.", 11) == 0) {
      return make_struct_cmp(&T::topic_data, getMetaStruct<DDS::TopicDataQosPolicy>().create_qc_comparator(field + 11), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TopicBuiltinTopicData)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"key", "name", "type_name", "durability", "durability_service", "deadline", "latency_budget", "liveliness", "reliability", "transport_priority", "lifespan", "destination_order", "history", "resource_limits", "ownership", "topic_data", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "key") == 0) {
      return &static_cast<const T*>(stru)->key;
    }
    if (std::strcmp(field, "name") == 0) {
      return &static_cast<const T*>(stru)->name;
    }
    if (std::strcmp(field, "type_name") == 0) {
      return &static_cast<const T*>(stru)->type_name;
    }
    if (std::strcmp(field, "durability") == 0) {
      return &static_cast<const T*>(stru)->durability;
    }
    if (std::strcmp(field, "durability_service") == 0) {
      return &static_cast<const T*>(stru)->durability_service;
    }
    if (std::strcmp(field, "deadline") == 0) {
      return &static_cast<const T*>(stru)->deadline;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      return &static_cast<const T*>(stru)->latency_budget;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      return &static_cast<const T*>(stru)->liveliness;
    }
    if (std::strcmp(field, "reliability") == 0) {
      return &static_cast<const T*>(stru)->reliability;
    }
    if (std::strcmp(field, "transport_priority") == 0) {
      return &static_cast<const T*>(stru)->transport_priority;
    }
    if (std::strcmp(field, "lifespan") == 0) {
      return &static_cast<const T*>(stru)->lifespan;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      return &static_cast<const T*>(stru)->destination_order;
    }
    if (std::strcmp(field, "history") == 0) {
      return &static_cast<const T*>(stru)->history;
    }
    if (std::strcmp(field, "resource_limits") == 0) {
      return &static_cast<const T*>(stru)->resource_limits;
    }
    if (std::strcmp(field, "ownership") == 0) {
      return &static_cast<const T*>(stru)->ownership;
    }
    if (std::strcmp(field, "topic_data") == 0) {
      return &static_cast<const T*>(stru)->topic_data;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TopicBuiltinTopicData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "key") == 0) {
      static_cast<T*>(lhs)->key = *static_cast<const DDS::BuiltinTopicKey_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "name") == 0) {
      static_cast<T*>(lhs)->name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "type_name") == 0) {
      static_cast<T*>(lhs)->type_name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "durability") == 0) {
      static_cast<T*>(lhs)->durability = *static_cast<const DDS::DurabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "durability_service") == 0) {
      static_cast<T*>(lhs)->durability_service = *static_cast<const DDS::DurabilityServiceQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "deadline") == 0) {
      static_cast<T*>(lhs)->deadline = *static_cast<const DDS::DeadlineQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "latency_budget") == 0) {
      static_cast<T*>(lhs)->latency_budget = *static_cast<const DDS::LatencyBudgetQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "liveliness") == 0) {
      static_cast<T*>(lhs)->liveliness = *static_cast<const DDS::LivelinessQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "reliability") == 0) {
      static_cast<T*>(lhs)->reliability = *static_cast<const DDS::ReliabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "transport_priority") == 0) {
      static_cast<T*>(lhs)->transport_priority = *static_cast<const DDS::TransportPriorityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "lifespan") == 0) {
      static_cast<T*>(lhs)->lifespan = *static_cast<const DDS::LifespanQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "destination_order") == 0) {
      static_cast<T*>(lhs)->destination_order = *static_cast<const DDS::DestinationOrderQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "history") == 0) {
      static_cast<T*>(lhs)->history = *static_cast<const DDS::HistoryQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "resource_limits") == 0) {
      static_cast<T*>(lhs)->resource_limits = *static_cast<const DDS::ResourceLimitsQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ownership") == 0) {
      static_cast<T*>(lhs)->ownership = *static_cast<const DDS::OwnershipQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "topic_data") == 0) {
      static_cast<T*>(lhs)->topic_data = *static_cast<const DDS::TopicDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TopicBuiltinTopicData)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->name.in(), static_cast<const T*>(rhs)->name.in());
    }
    if (std::strcmp(field, "type_name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->type_name.in(), static_cast<const T*>(rhs)->type_name.in());
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TopicBuiltinTopicData)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::TopicBuiltinTopicData>()
{
  static MetaStructImpl<DDS::TopicBuiltinTopicData> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::TopicBuiltinTopicData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::TopicBuiltinTopicData>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TopicBuiltinTopicData */


/* Begin TYPEDEF: SampleStateKind */


/* End TYPEDEF: SampleStateKind */


/* Begin CONST: READ_SAMPLE_STATE */


/* End CONST: READ_SAMPLE_STATE */


/* Begin CONST: NOT_READ_SAMPLE_STATE */


/* End CONST: NOT_READ_SAMPLE_STATE */


/* Begin TYPEDEF: SampleStateMask */


/* End TYPEDEF: SampleStateMask */


/* Begin CONST: ANY_SAMPLE_STATE */


/* End CONST: ANY_SAMPLE_STATE */


/* Begin TYPEDEF: ViewStateKind */


/* End TYPEDEF: ViewStateKind */


/* Begin CONST: NEW_VIEW_STATE */


/* End CONST: NEW_VIEW_STATE */


/* Begin CONST: NOT_NEW_VIEW_STATE */


/* End CONST: NOT_NEW_VIEW_STATE */


/* Begin TYPEDEF: ViewStateMask */


/* End TYPEDEF: ViewStateMask */


/* Begin CONST: ANY_VIEW_STATE */


/* End CONST: ANY_VIEW_STATE */


/* Begin TYPEDEF: InstanceStateKind */


/* End TYPEDEF: InstanceStateKind */


/* Begin CONST: ALIVE_INSTANCE_STATE */


/* End CONST: ALIVE_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* Begin TYPEDEF: InstanceStateMask */


/* End TYPEDEF: InstanceStateMask */


/* Begin CONST: ANY_INSTANCE_STATE */


/* End CONST: ANY_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_INSTANCE_STATE */


/* Begin STRUCT: Time_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::Time_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.sec);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.nanosec);
}

bool operator<<(Serializer& strm, const DDS::Time_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.sec)
    && (strm << stru.nanosec);
}

bool operator>>(Serializer& strm, DDS::Time_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.sec)
    && (strm >> stru.nanosec);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::Time_t> : MetaStruct {
  typedef DDS::Time_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::Time_t& typed = *static_cast<const DDS::Time_t*>(stru);
    if (std::strcmp(field, "sec") == 0) {
      return typed.sec;
    }
    if (std::strcmp(field, "nanosec") == 0) {
      return typed.nanosec;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::Time_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "sec") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'sec' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "nanosec") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'nanosec' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::Time_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "sec") == 0) {
      return make_field_cmp(&T::sec, next);
    }
    if (std::strcmp(field, "nanosec") == 0) {
      return make_field_cmp(&T::nanosec, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::Time_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"sec", "nanosec", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "sec") == 0) {
      return &static_cast<const T*>(stru)->sec;
    }
    if (std::strcmp(field, "nanosec") == 0) {
      return &static_cast<const T*>(stru)->nanosec;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::Time_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "sec") == 0) {
      static_cast<T*>(lhs)->sec = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "nanosec") == 0) {
      static_cast<T*>(lhs)->nanosec = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::Time_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "sec") == 0) {
      return static_cast<const T*>(lhs)->sec == static_cast<const T*>(rhs)->sec;
    }
    if (std::strcmp(field, "nanosec") == 0) {
      return static_cast<const T*>(lhs)->nanosec == static_cast<const T*>(rhs)->nanosec;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::Time_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::Time_t>()
{
  static MetaStructImpl<DDS::Time_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::Time_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::Time_t>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Time_t */


/* Begin STRUCT: SampleInfo */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::SampleInfo& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.sample_state);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.view_state);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.instance_state);
  gen_find_size(stru.source_timestamp, size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.instance_handle);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.publication_handle);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.disposed_generation_count);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.no_writers_generation_count);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.sample_rank);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.generation_rank);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.absolute_generation_rank);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_boolean(stru.valid_data));
  if ((size + padding) % 8) {
    padding += 8 - ((size + padding) % 8);
  }
  size += gen_max_marshaled_size(stru.opendds_reserved_publication_seq);
}

bool operator<<(Serializer& strm, const DDS::SampleInfo& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.sample_state)
    && (strm << stru.view_state)
    && (strm << stru.instance_state)
    && (strm << stru.source_timestamp)
    && (strm << stru.instance_handle)
    && (strm << stru.publication_handle)
    && (strm << stru.disposed_generation_count)
    && (strm << stru.no_writers_generation_count)
    && (strm << stru.sample_rank)
    && (strm << stru.generation_rank)
    && (strm << stru.absolute_generation_rank)
    && (strm << ACE_OutputCDR::from_boolean(stru.valid_data))
    && (strm << stru.opendds_reserved_publication_seq);
}

bool operator>>(Serializer& strm, DDS::SampleInfo& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.sample_state)
    && (strm >> stru.view_state)
    && (strm >> stru.instance_state)
    && (strm >> stru.source_timestamp)
    && (strm >> stru.instance_handle)
    && (strm >> stru.publication_handle)
    && (strm >> stru.disposed_generation_count)
    && (strm >> stru.no_writers_generation_count)
    && (strm >> stru.sample_rank)
    && (strm >> stru.generation_rank)
    && (strm >> stru.absolute_generation_rank)
    && (strm >> ACE_InputCDR::to_boolean(stru.valid_data))
    && (strm >> stru.opendds_reserved_publication_seq);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<DDS::SampleInfo> : MetaStruct {
  typedef DDS::SampleInfo T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const DDS::SampleInfo& typed = *static_cast<const DDS::SampleInfo*>(stru);
    if (std::strcmp(field, "sample_state") == 0) {
      return typed.sample_state;
    }
    if (std::strcmp(field, "view_state") == 0) {
      return typed.view_state;
    }
    if (std::strcmp(field, "instance_state") == 0) {
      return typed.instance_state;
    }
    if (std::strncmp(field, "source_timestamp.", 17) == 0) {
      return getMetaStruct<DDS::Time_t>().getValue(&typed.source_timestamp, field + 17);
    }
    if (std::strcmp(field, "instance_handle") == 0) {
      return typed.instance_handle;
    }
    if (std::strcmp(field, "publication_handle") == 0) {
      return typed.publication_handle;
    }
    if (std::strcmp(field, "disposed_generation_count") == 0) {
      return typed.disposed_generation_count;
    }
    if (std::strcmp(field, "no_writers_generation_count") == 0) {
      return typed.no_writers_generation_count;
    }
    if (std::strcmp(field, "sample_rank") == 0) {
      return typed.sample_rank;
    }
    if (std::strcmp(field, "generation_rank") == 0) {
      return typed.generation_rank;
    }
    if (std::strcmp(field, "absolute_generation_rank") == 0) {
      return typed.absolute_generation_rank;
    }
    if (std::strcmp(field, "valid_data") == 0) {
      return typed.valid_data;
    }
    if (std::strcmp(field, "opendds_reserved_publication_seq") == 0) {
      return typed.opendds_reserved_publication_seq;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::SampleInfo)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "sample_state") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'sample_state' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "view_state") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'view_state' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "instance_state") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'instance_state' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strncmp(field, "source_timestamp.", 17) == 0) {
      return getMetaStruct<DDS::Time_t>().getValue(ser, field + 17);
    } else {
      gen_skip_over(ser, static_cast<DDS::Time_t*>(0));
    }
    if (std::strcmp(field, "instance_handle") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'instance_handle' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "publication_handle") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'publication_handle' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "disposed_generation_count") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'disposed_generation_count' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "no_writers_generation_count") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'no_writers_generation_count' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "sample_rank") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'sample_rank' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "generation_rank") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'generation_rank' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "absolute_generation_rank") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'absolute_generation_rank' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "valid_data") == 0) {
      ACE_CDR::Boolean val;
      if (!(ser >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'valid_data' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 1);
    }
    if (std::strcmp(field, "opendds_reserved_publication_seq") == 0) {
      ACE_CDR::LongLong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'opendds_reserved_publication_seq' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 8);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::SampleInfo");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "sample_state") == 0) {
      return make_field_cmp(&T::sample_state, next);
    }
    if (std::strcmp(field, "view_state") == 0) {
      return make_field_cmp(&T::view_state, next);
    }
    if (std::strcmp(field, "instance_state") == 0) {
      return make_field_cmp(&T::instance_state, next);
    }
    if (std::strncmp(field, "source_timestamp.", 17) == 0) {
      return make_struct_cmp(&T::source_timestamp, getMetaStruct<DDS::Time_t>().create_qc_comparator(field + 17), next);
    }
    if (std::strcmp(field, "instance_handle") == 0) {
      return make_field_cmp(&T::instance_handle, next);
    }
    if (std::strcmp(field, "publication_handle") == 0) {
      return make_field_cmp(&T::publication_handle, next);
    }
    if (std::strcmp(field, "disposed_generation_count") == 0) {
      return make_field_cmp(&T::disposed_generation_count, next);
    }
    if (std::strcmp(field, "no_writers_generation_count") == 0) {
      return make_field_cmp(&T::no_writers_generation_count, next);
    }
    if (std::strcmp(field, "sample_rank") == 0) {
      return make_field_cmp(&T::sample_rank, next);
    }
    if (std::strcmp(field, "generation_rank") == 0) {
      return make_field_cmp(&T::generation_rank, next);
    }
    if (std::strcmp(field, "absolute_generation_rank") == 0) {
      return make_field_cmp(&T::absolute_generation_rank, next);
    }
    if (std::strcmp(field, "valid_data") == 0) {
      return make_field_cmp(&T::valid_data, next);
    }
    if (std::strcmp(field, "opendds_reserved_publication_seq") == 0) {
      return make_field_cmp(&T::opendds_reserved_publication_seq, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::SampleInfo)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"sample_state", "view_state", "instance_state", "source_timestamp", "instance_handle", "publication_handle", "disposed_generation_count", "no_writers_generation_count", "sample_rank", "generation_rank", "absolute_generation_rank", "valid_data", "opendds_reserved_publication_seq", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "sample_state") == 0) {
      return &static_cast<const T*>(stru)->sample_state;
    }
    if (std::strcmp(field, "view_state") == 0) {
      return &static_cast<const T*>(stru)->view_state;
    }
    if (std::strcmp(field, "instance_state") == 0) {
      return &static_cast<const T*>(stru)->instance_state;
    }
    if (std::strcmp(field, "source_timestamp") == 0) {
      return &static_cast<const T*>(stru)->source_timestamp;
    }
    if (std::strcmp(field, "instance_handle") == 0) {
      return &static_cast<const T*>(stru)->instance_handle;
    }
    if (std::strcmp(field, "publication_handle") == 0) {
      return &static_cast<const T*>(stru)->publication_handle;
    }
    if (std::strcmp(field, "disposed_generation_count") == 0) {
      return &static_cast<const T*>(stru)->disposed_generation_count;
    }
    if (std::strcmp(field, "no_writers_generation_count") == 0) {
      return &static_cast<const T*>(stru)->no_writers_generation_count;
    }
    if (std::strcmp(field, "sample_rank") == 0) {
      return &static_cast<const T*>(stru)->sample_rank;
    }
    if (std::strcmp(field, "generation_rank") == 0) {
      return &static_cast<const T*>(stru)->generation_rank;
    }
    if (std::strcmp(field, "absolute_generation_rank") == 0) {
      return &static_cast<const T*>(stru)->absolute_generation_rank;
    }
    if (std::strcmp(field, "valid_data") == 0) {
      return &static_cast<const T*>(stru)->valid_data;
    }
    if (std::strcmp(field, "opendds_reserved_publication_seq") == 0) {
      return &static_cast<const T*>(stru)->opendds_reserved_publication_seq;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::SampleInfo)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "sample_state") == 0) {
      static_cast<T*>(lhs)->sample_state = *static_cast<const DDS::SampleStateKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "view_state") == 0) {
      static_cast<T*>(lhs)->view_state = *static_cast<const DDS::ViewStateKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "instance_state") == 0) {
      static_cast<T*>(lhs)->instance_state = *static_cast<const DDS::InstanceStateKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "source_timestamp") == 0) {
      static_cast<T*>(lhs)->source_timestamp = *static_cast<const DDS::Time_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "instance_handle") == 0) {
      static_cast<T*>(lhs)->instance_handle = *static_cast<const DDS::InstanceHandle_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "publication_handle") == 0) {
      static_cast<T*>(lhs)->publication_handle = *static_cast<const DDS::InstanceHandle_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "disposed_generation_count") == 0) {
      static_cast<T*>(lhs)->disposed_generation_count = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "no_writers_generation_count") == 0) {
      static_cast<T*>(lhs)->no_writers_generation_count = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "sample_rank") == 0) {
      static_cast<T*>(lhs)->sample_rank = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "generation_rank") == 0) {
      static_cast<T*>(lhs)->generation_rank = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "absolute_generation_rank") == 0) {
      static_cast<T*>(lhs)->absolute_generation_rank = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "valid_data") == 0) {
      static_cast<T*>(lhs)->valid_data = *static_cast<const CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "opendds_reserved_publication_seq") == 0) {
      static_cast<T*>(lhs)->opendds_reserved_publication_seq = *static_cast<const CORBA::LongLong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::SampleInfo)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "sample_state") == 0) {
      return static_cast<const T*>(lhs)->sample_state == static_cast<const T*>(rhs)->sample_state;
    }
    if (std::strcmp(field, "view_state") == 0) {
      return static_cast<const T*>(lhs)->view_state == static_cast<const T*>(rhs)->view_state;
    }
    if (std::strcmp(field, "instance_state") == 0) {
      return static_cast<const T*>(lhs)->instance_state == static_cast<const T*>(rhs)->instance_state;
    }
    if (std::strcmp(field, "instance_handle") == 0) {
      return static_cast<const T*>(lhs)->instance_handle == static_cast<const T*>(rhs)->instance_handle;
    }
    if (std::strcmp(field, "publication_handle") == 0) {
      return static_cast<const T*>(lhs)->publication_handle == static_cast<const T*>(rhs)->publication_handle;
    }
    if (std::strcmp(field, "disposed_generation_count") == 0) {
      return static_cast<const T*>(lhs)->disposed_generation_count == static_cast<const T*>(rhs)->disposed_generation_count;
    }
    if (std::strcmp(field, "no_writers_generation_count") == 0) {
      return static_cast<const T*>(lhs)->no_writers_generation_count == static_cast<const T*>(rhs)->no_writers_generation_count;
    }
    if (std::strcmp(field, "sample_rank") == 0) {
      return static_cast<const T*>(lhs)->sample_rank == static_cast<const T*>(rhs)->sample_rank;
    }
    if (std::strcmp(field, "generation_rank") == 0) {
      return static_cast<const T*>(lhs)->generation_rank == static_cast<const T*>(rhs)->generation_rank;
    }
    if (std::strcmp(field, "absolute_generation_rank") == 0) {
      return static_cast<const T*>(lhs)->absolute_generation_rank == static_cast<const T*>(rhs)->absolute_generation_rank;
    }
    if (std::strcmp(field, "valid_data") == 0) {
      return static_cast<const T*>(lhs)->valid_data == static_cast<const T*>(rhs)->valid_data;
    }
    if (std::strcmp(field, "opendds_reserved_publication_seq") == 0) {
      return static_cast<const T*>(lhs)->opendds_reserved_publication_seq == static_cast<const T*>(rhs)->opendds_reserved_publication_seq;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::SampleInfo)");
  }
};

template<>
const MetaStruct& getMetaStruct<DDS::SampleInfo>()
{
  static MetaStructImpl<DDS::SampleInfo> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, DDS::SampleInfo*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<DDS::SampleInfo>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SampleInfo */


/* Begin TYPEDEF: SampleInfoSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const DDS::SampleInfoSeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const DDS::SampleInfoSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, DDS::SampleInfoSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, DDS::SampleInfoSeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<DDS::SampleInfo*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SampleInfoSeq */

/* End MODULE: DDS */
