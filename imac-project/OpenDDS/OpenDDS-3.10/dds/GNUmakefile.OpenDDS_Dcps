# -*- Makefile -*-
#----------------------------------------------------------------------------
#       GNU Makefile
#
# @file GNUmakefile.OpenDDS_Dcps
#
# $Id: gnu.mpd 2866 2016-09-08 21:53:48Z huangh $
#
# This file was automatically generated by MPC.  Any changes made directly to
# this file will be lost the next time it is generated.
#
#----------------------------------------------------------------------------
MAKEFILE         = GNUmakefile.OpenDDS_Dcps
DEPENDENCY_FILE  = .depend.OpenDDS_Dcps

IDL_DEPENDENCY_FILE1 = .depend.OpenDDS_Dcps_Idl1
IDL_DEPENDENCY_FILE2 = .depend.OpenDDS_Dcps_Idl2
IDL_DEPENDENCY_FILE3 = .depend.OpenDDS_Dcps_Idl3
IDL_DEPENDENCY_FILE4 = .depend.OpenDDS_Dcps_Idl4
IDL_DEPENDENCY_FILE5 = .depend.OpenDDS_Dcps_Idl5
IDL_DEPENDENCY_FILE6 = .depend.OpenDDS_Dcps_Idl6
IDL_DEPENDENCY_FILE7 = .depend.OpenDDS_Dcps_Idl7
IDL_DEPENDENCY_FILE8 = .depend.OpenDDS_Dcps_Idl8
IDL_DEPENDENCY_FILE9 = .depend.OpenDDS_Dcps_Idl9
IDL_DEPENDENCY_FILE10 = .depend.OpenDDS_Dcps_Idl10
IDL_DEPENDENCY_FILE11 = .depend.OpenDDS_Dcps_Idl11
IDL_DEPENDENCY_FILE12 = .depend.OpenDDS_Dcps_Idl12
IDL_DEPENDENCY_FILE13 = .depend.OpenDDS_Dcps_Idl13
IDL_DEPENDENCY_FILE14 = .depend.OpenDDS_Dcps_Idl14
IDL_DEPENDENCY_FILE15 = .depend.OpenDDS_Dcps_Idl15
IDL_DEPENDENCY_FILE16 = .depend.OpenDDS_Dcps_Idl16

IDL_DEPENDENCY_FILES += \
	.depend.OpenDDS_Dcps_Idl1 \
	.depend.OpenDDS_Dcps_Idl2 \
	.depend.OpenDDS_Dcps_Idl3 \
	.depend.OpenDDS_Dcps_Idl4 \
	.depend.OpenDDS_Dcps_Idl5 \
	.depend.OpenDDS_Dcps_Idl6 \
	.depend.OpenDDS_Dcps_Idl7 \
	.depend.OpenDDS_Dcps_Idl8 \
	.depend.OpenDDS_Dcps_Idl9 \
	.depend.OpenDDS_Dcps_Idl10 \
	.depend.OpenDDS_Dcps_Idl11 \
	.depend.OpenDDS_Dcps_Idl12 \
	.depend.OpenDDS_Dcps_Idl13 \
	.depend.OpenDDS_Dcps_Idl14 \
	.depend.OpenDDS_Dcps_Idl15 \
	.depend.OpenDDS_Dcps_Idl16

LIB_PREFIX      ?= lib

## LIB_CHECKED may be set to empty later on in this file
LIB_UNCHECKED    = $(LIB_PREFIX)OpenDDS_Dcps.$(LIBEXT)
LIB_CHECKED      = $(LIB_UNCHECKED)
LIB_NAME         = $(LIB_PREFIX)OpenDDS_Dcps

## SHLIB may be set to empty later on in this file
SHLIB_UNCHECKED  = $(LIB_PREFIX)OpenDDS_Dcps.$(SOEXT)
SHLIB            = $(SHLIB_UNCHECKED)

TAO_ROOT  ?= $(ACE_ROOT)/TAO

FILES = \
  DdsDcpsGuidTypeSupportImpl.cpp \
  DdsDcpsCoreTypeSupportImpl.cpp \
  DdsDcpsInfrastructureTypeSupportImpl.cpp \
  DdsDcpsInfoUtilsTypeSupportImpl.cpp \
  CorbaSeq/BooleanSeqTypeSupportImpl.cpp \
  CorbaSeq/CharSeqTypeSupportImpl.cpp \
  CorbaSeq/DoubleSeqTypeSupportImpl.cpp \
  CorbaSeq/FloatSeqTypeSupportImpl.cpp \
  CorbaSeq/LongDoubleSeqTypeSupportImpl.cpp \
  CorbaSeq/LongLongSeqTypeSupportImpl.cpp \
  CorbaSeq/LongSeqTypeSupportImpl.cpp \
  CorbaSeq/OctetSeqTypeSupportImpl.cpp \
  CorbaSeq/ShortSeqTypeSupportImpl.cpp \
  CorbaSeq/StringSeqTypeSupportImpl.cpp \
  CorbaSeq/ULongLongSeqTypeSupportImpl.cpp \
  CorbaSeq/ULongSeqTypeSupportImpl.cpp \
  CorbaSeq/UShortSeqTypeSupportImpl.cpp \
  CorbaSeq/WCharSeqTypeSupportImpl.cpp \
  CorbaSeq/WStringSeqTypeSupportImpl.cpp \
  DdsDcpsGuidC.cpp \
  DdsDcpsCoreC.cpp \
  DdsDcpsInfoUtilsC.cpp \
  DdsDcpsConditionSeqC.cpp \
  DdsDcpsDataReaderSeqC.cpp \
  DdsDcpsGuidTypeSupportC.cpp \
  DdsDcpsCoreTypeSupportC.cpp \
  DdsDcpsInfrastructureTypeSupportC.cpp \
  DdsDcpsC.cpp \
  DdsDcpsDomainC.cpp \
  DdsDcpsInfrastructureC.cpp \
  DdsDcpsPublicationC.cpp \
  DdsDcpsSubscriptionC.cpp \
  DdsDcpsSubscriptionExtC.cpp \
  DdsDcpsTopicC.cpp \
  DdsDcpsTypeSupportExtC.cpp \
  DCPS/BitPubListenerImpl.cpp \
  DCPS/BuiltInTopicUtils.cpp \
  DCPS/CoherentChangeControl.cpp \
  DCPS/ConditionImpl.cpp \
  DCPS/ConfigUtils.cpp \
  DCPS/ContentFilteredTopicImpl.cpp \
  DCPS/DataDurabilityCache.cpp \
  DCPS/DataReaderImpl.cpp \
  DCPS/DataSampleElement.cpp \
  DCPS/DataSampleHeader.cpp \
  DCPS/DataWriterImpl.cpp \
  DCPS/DCPS_Utils.cpp \
  DCPS/debug.cpp \
  DCPS/Discovery.cpp \
  DCPS/DisjointSequence.cpp \
  DCPS/DomainParticipantFactoryImpl.cpp \
  DCPS/DomainParticipantImpl.cpp \
  DCPS/EntityImpl.cpp \
  DCPS/FileSystemStorage.cpp \
  DCPS/FilterEvaluator.cpp \
  DCPS/GroupRakeData.cpp \
  DCPS/GuardCondition.cpp \
  DCPS/GuidBuilder.cpp \
  DCPS/GuidConverter.cpp \
  DCPS/GuidUtils.cpp \
  DCPS/InstanceDataSampleList.cpp \
  DCPS/InstanceHandle.cpp \
  DCPS/InstanceState.cpp \
  DCPS/Marked_Default_Qos.cpp \
  DCPS/MemoryPool.cpp \
  DCPS/MessageTracker.cpp \
  DCPS/MonitorFactory.cpp \
  DCPS/MultiTopicDataReaderBase.cpp \
  DCPS/MultiTopicImpl.cpp \
  DCPS/OfferedDeadlineWatchdog.cpp \
  DCPS/OwnershipManager.cpp \
  DCPS/PublisherImpl.cpp \
  DCPS/Qos_Helper.cpp \
  DCPS/QueryConditionImpl.cpp \
  DCPS/RawDataSample.cpp \
  DCPS/ReactorInterceptor.cpp \
  DCPS/ReadConditionImpl.cpp \
  DCPS/ReceivedDataElementList.cpp \
  DCPS/ReceivedDataStrategy.cpp \
  DCPS/Recorder.cpp \
  DCPS/RecorderImpl.cpp \
  DCPS/Registered_Data_Types.cpp \
  DCPS/Replayer.cpp \
  DCPS/ReplayerImpl.cpp \
  DCPS/RepoIdBuilder.cpp \
  DCPS/RepoIdConverter.cpp \
  DCPS/RepoIdGenerator.cpp \
  DCPS/RequestedDeadlineWatchdog.cpp \
  DCPS/SafetyProfilePool.cpp \
  DCPS/SafetyProfileStreams.cpp \
  DCPS/SendStateDataSampleList.cpp \
  DCPS/Serializer.cpp \
  DCPS/Service_Participant.cpp \
  DCPS/StaticDiscovery.cpp \
  DCPS/StatusConditionImpl.cpp \
  DCPS/SubscriberImpl.cpp \
  DCPS/TopicDescriptionImpl.cpp \
  DCPS/TopicImpl.cpp \
  DCPS/Transient_Kludge.cpp \
  DCPS/TypeSupportImpl.cpp \
  DCPS/WaitSet.cpp \
  DCPS/Watchdog.cpp \
  DCPS/WriteDataContainer.cpp \
  DCPS/WriterDataSampleList.cpp \
  DCPS/WriterInfo.cpp \
  DCPS/transport/framework/BuildChainVisitor.cpp \
  DCPS/transport/framework/CopyChainVisitor.cpp \
  DCPS/transport/framework/DataLink.cpp \
  DCPS/transport/framework/DataLinkCleanupTask.cpp \
  DCPS/transport/framework/DataLinkSet.cpp \
  DCPS/transport/framework/DirectPriorityMapper.cpp \
  DCPS/transport/framework/NetworkAddress.cpp \
  DCPS/transport/framework/NullSynch.cpp \
  DCPS/transport/framework/NullSynchStrategy.cpp \
  DCPS/transport/framework/PacketRemoveVisitor.cpp \
  DCPS/transport/framework/PerConnectionSynch.cpp \
  DCPS/transport/framework/PerConnectionSynchStrategy.cpp \
  DCPS/transport/framework/PoolSynch.cpp \
  DCPS/transport/framework/PoolSynchStrategy.cpp \
  DCPS/transport/framework/PriorityKey.cpp \
  DCPS/transport/framework/PriorityMapper.cpp \
  DCPS/transport/framework/QueueRemoveVisitor.cpp \
  DCPS/transport/framework/ReactorSynch.cpp \
  DCPS/transport/framework/ReactorSynchStrategy.cpp \
  DCPS/transport/framework/ReceivedDataSample.cpp \
  DCPS/transport/framework/ReceiveListenerSet.cpp \
  DCPS/transport/framework/ReceiveListenerSetMap.cpp \
  DCPS/transport/framework/RemoveAllVisitor.cpp \
  DCPS/transport/framework/ScheduleOutputHandler.cpp \
  DCPS/transport/framework/SendResponseListener.cpp \
  DCPS/transport/framework/ThreadPerConnectionSendTask.cpp \
  DCPS/transport/framework/ThreadPerConRemoveVisitor.cpp \
  DCPS/transport/framework/ThreadSynch.cpp \
  DCPS/transport/framework/ThreadSynchResource.cpp \
  DCPS/transport/framework/ThreadSynchStrategy.cpp \
  DCPS/transport/framework/ThreadSynchWorker.cpp \
  DCPS/transport/framework/TransportClient.cpp \
  DCPS/transport/framework/TransportConfig.cpp \
  DCPS/transport/framework/TransportControlElement.cpp \
  DCPS/transport/framework/TransportCustomizedElement.cpp \
  DCPS/transport/framework/TransportDebug.cpp \
  DCPS/transport/framework/TransportHeader.cpp \
  DCPS/transport/framework/TransportImpl.cpp \
  DCPS/transport/framework/TransportInst.cpp \
  DCPS/transport/framework/TransportQueueElement.cpp \
  DCPS/transport/framework/TransportReactorTask.cpp \
  DCPS/transport/framework/TransportReassembly.cpp \
  DCPS/transport/framework/TransportReceiveListener.cpp \
  DCPS/transport/framework/TransportRegistry.cpp \
  DCPS/transport/framework/TransportReplacedElement.cpp \
  DCPS/transport/framework/TransportRetainedElement.cpp \
  DCPS/transport/framework/TransportSendBuffer.cpp \
  DCPS/transport/framework/TransportSendControlElement.cpp \
  DCPS/transport/framework/TransportSendElement.cpp \
  DCPS/transport/framework/TransportSendListener.cpp \
  DCPS/transport/framework/TransportSendStrategy.cpp \
  DCPS/transport/framework/TransportStrategy.cpp \
  DCPS/transport/framework/TransportType.cpp

IDL_DEPS_FLAGS1 = $(TAO_IDLFLAGS) -Sa -St -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_include=dds/Versioned_Namespace.h -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -SS -I..
IDL_DEPS1 = DdsDcpsGuid.idl

IDL_DEPS_FLAGS2 = $(TAO_IDLFLAGS) -Sa -St -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_include=dds/Versioned_Namespace.h -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -SS -I..
IDL_DEPS2 = DdsDcpsCore.idl

IDL_DEPS_FLAGS3 = $(TAO_IDLFLAGS) -Sa -St -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_include=dds/Versioned_Namespace.h -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -SS -I..
IDL_DEPS3 = DdsDcpsInfoUtils.idl

IDL_DEPS_FLAGS4 = $(TAO_IDLFLAGS) -Sa -St -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_include=dds/Versioned_Namespace.h -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -SS -I..
IDL_DEPS4 = DdsDcpsConditionSeq.idl

IDL_DEPS_FLAGS5 = $(TAO_IDLFLAGS) -Sa -St -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_include=dds/Versioned_Namespace.h -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -SS -I..
IDL_DEPS5 = DdsDcpsDataReaderSeq.idl

IDL_DEPS_FLAGS6 = $(TAO_IDLFLAGS) -Sa -St -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_include=dds/Versioned_Namespace.h -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -SS -I..
IDL_DEPS6 = DdsDcpsGuidTypeSupport.idl

IDL_DEPS_FLAGS7 = $(TAO_IDLFLAGS) -Sa -St -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_include=dds/Versioned_Namespace.h -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -SS -I..
IDL_DEPS7 = DdsDcpsCoreTypeSupport.idl

IDL_DEPS_FLAGS8 = $(TAO_IDLFLAGS) -Sa -St -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_include=dds/Versioned_Namespace.h -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -SS -I..
IDL_DEPS8 = DdsDcpsInfrastructureTypeSupport.idl

IDL_DEPS_FLAGS9 = $(TAO_IDLFLAGS) -Sa -St -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_include=dds/Versioned_Namespace.h -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -SS -I..
IDL_DEPS9 = DdsDcps.idl

IDL_DEPS_FLAGS10 = $(TAO_IDLFLAGS) -Sa -St -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_include=dds/Versioned_Namespace.h -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -SS -I..
IDL_DEPS10 = DdsDcpsDomain.idl

IDL_DEPS_FLAGS11 = $(TAO_IDLFLAGS) -Sa -St -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_include=dds/Versioned_Namespace.h -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -SS -I..
IDL_DEPS11 = DdsDcpsInfrastructure.idl

IDL_DEPS_FLAGS12 = $(TAO_IDLFLAGS) -Sa -St -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_include=dds/Versioned_Namespace.h -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -SS -I..
IDL_DEPS12 = DdsDcpsPublication.idl

IDL_DEPS_FLAGS13 = $(TAO_IDLFLAGS) -Sa -St -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_include=dds/Versioned_Namespace.h -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -SS -I..
IDL_DEPS13 = DdsDcpsSubscription.idl

IDL_DEPS_FLAGS14 = $(TAO_IDLFLAGS) -Sa -St -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_include=dds/Versioned_Namespace.h -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -SS -I..
IDL_DEPS14 = DdsDcpsSubscriptionExt.idl

IDL_DEPS_FLAGS15 = $(TAO_IDLFLAGS) -Sa -St -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_include=dds/Versioned_Namespace.h -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -SS -I..
IDL_DEPS15 = DdsDcpsTopic.idl

IDL_DEPS_FLAGS16 = $(TAO_IDLFLAGS) -Sa -St -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_include=dds/Versioned_Namespace.h -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -SS -I..
IDL_DEPS16 = DdsDcpsTypeSupportExt.idl


VPATH = .:DCPS/transport/framework:DCPS:CorbaSeq


LIBPATHS := . "$(ACE_ROOT)/lib"

#----------------------------------------------------------------------------
#       Include macros and targets
#----------------------------------------------------------------------------
ACE_SHLIBS = -lTAO_PortableServer -lTAO_BiDirGIOP -lTAO_PI -lTAO_CodecFactory -lTAO_AnyTypeCode -lTAO -lACE
TAO_IDL = $(ACE_ROOT)/bin/tao_idl
TAO_IDL_DEP = $(ACE_ROOT)/bin/tao_idl$(EXEEXT)
TAO_IDLFLAGS = -Wb,pre_include=ace/pre.h -Wb,post_include=ace/post.h -I$(TAO_ROOT)$(if $(ARCH), -g $(call ADD_QUOTE,$(call ADD_ARCH,$(ACE_ROOT)/bin/ace_gperf)))

PRJ_TYPE = library

COLLAPSE_SLASHES = $(if $(findstring //,$(1)),$(call COLLAPSE_SLASHES,$(subst //,/,$(1))),$(1))
INSLIB ?= $(call COLLAPSE_SLASHES,../lib)
ifeq ($(INSLIB),.)
  ifeq ($(CURDIR),)
    ifeq ($(PWD),)
      PWD=$(shell pwd)
    endif
  else
    PWD=$(CURDIR)
  endif
  INSLIB = $(PWD)
endif
OUTPUT_DIRECTORY = $(INSLIB)

include $(ACE_ROOT)/include/makeinclude/wrapper_macros.GNU

include $(DDS_ROOT)/rules.dds.GNU

include $(TAO_ROOT)/rules.tao.GNU

GNUACE_PROJECT_VERSION ?= $(ACE_VERSION)

ifneq (,$(RC))
RESOURCES += \
  OpenDDS_DCPS.rc

RC_INCLUDE_FLAG ?= --include-dir=
RCFLAGS = \
        $(RC_INCLUDE_FLAG)$(ACE_ROOT) \
        $(RC_INCLUDE_FLAG)$(TAO_ROOT) \
        $(RC_INCLUDE_FLAG).. \
        $(RC_INCLUDE_FLAG)../dds
endif

# To build multiple targets in the same directory on AIX, it works
# best to have a template directory per project.
# The compiler/linker isn't too smart about instantiating templates...
ifdef TEMPINCDIR
TEMPINCDIR := $(TEMPINCDIR)/OpenDDS_Dcps
all: $(TEMPINCDIR)
endif

ifneq ($(OUTPUT_DIRECTORY),)
.PHONY: create_output_directory.local
all: create_output_directory.local
create_output_directory.local:
	-@$(MKDIR) "$(OUTPUT_DIRECTORY)" $(ACE_NUL_STDERR)
endif

# turn off libcheck if doing a dry run
ifeq ($(findstring n, $(MAKEFLAGS)),n)
  LIBCHECK = 1
else
  # turn off libcheck if keep going was passed too
  ifeq ($(findstring k, $(MAKEFLAGS)),k)
    LIBCHECK = 1
  else
    LIBCHECK ?= $(filter-out $(foreach lib,TAO_PortableServer TAO_BiDirGIOP TAO_PI TAO_CodecFactory TAO_AnyTypeCode TAO ACE,$(findstring $(lib),$(foreach libpath,. $(if $(ARCH),./$(ARCH)) $(ACE_ROOT)/lib $(if $(ARCH),$(ACE_ROOT)/lib/$(ARCH)) /usr/lib /usr/lib64 $(INSLIB),$(wildcard $(libpath)/$(LIB_PREFIX)$(lib).* $(libpath)/$(lib).lib)))),TAO_PortableServer TAO_BiDirGIOP TAO_PI TAO_CodecFactory TAO_AnyTypeCode TAO ACE)
    ifeq ($(LIBCHECK),)
      LIBCHECK = 1
    endif
  endif
endif
ifneq ($(LIBCHECK), 1)
  LIB_CHECKED   =
  SHLIB =
  all: lib_warning
endif

LSRC   = $(FILES)

include $(ACE_ROOT)/include/makeinclude/macros.GNU
include $(ACE_ROOT)/include/makeinclude/rules.common.GNU
include $(ACE_ROOT)/include/makeinclude/rules.nonested.GNU
include $(ACE_ROOT)/include/makeinclude/rules.lib.GNU

ACE_PCH_SOURCE = DCPS/DdsDcps_pch.cpp
ACE_PCH_FILE   = DdsDcps_pch.h.gch

ifeq ($(pchsupport),1)
CPPFLAGS += -DUSING_PCH

$(addprefix $(VDIR), $(OBJS)): $(VDIR)$(ACE_PCH_FILE)
$(VSHOBJS): $(VSHDIR)$(ACE_PCH_FILE)
endif

include $(ACE_ROOT)/include/makeinclude/rules.local.GNU
ifeq ($(VXWORKSLINK),1)
include $(TGT_DIR)/h/make/rules.$(PRJ_TYPE)
endif

ifeq ($(VXWORKSLINK),1)
LDLIBPATH     = -L. -L$(ACE_ROOT)/lib
else
LDFLAGS      += -L. $(if $(ARCH),-L./$(ARCH)) -L$(ACE_ROOT)/lib $(if $(ARCH),-L$(ACE_ROOT)/lib/$(ARCH))
endif
CPPFLAGS     += -I$(ACE_ROOT) -I$(TAO_ROOT) -I.. -I../dds
CPPFLAGS     += -DNOMINMAX
ifeq ($(shared_libs),1)
  ifneq ($(SHLIB),)
    CPPFLAGS += -DOPENDDS_DCPS_BUILD_DLL
  endif
endif
ifeq ($(static_libs),1)
  CPPFLAGS += -DACE_AS_STATIC_LIBS -DTAO_AS_STATIC_LIBS
endif

#----------------------------------------------------------------------------
#       Local targets
#----------------------------------------------------------------------------
lib_warning:
	@echo OpenDDS_Dcps will not be built due to the following missing library: $(LIBCHECK) >&2

## Some OS's have /bin/test others only have /usr/bin/test
ifeq ($(wildcard /bin/test), /bin/test)
  TEST_EXE = /bin/test
else
ifeq ($(wildcard /usr/bin/test), /usr/bin/test)
  TEST_EXE = /usr/bin/test
endif
endif

SPACE = $(should_be_unset) $(should_be_unset)
DYLD_LIBRARY_PATH := $(DYLD_LIBRARY_PATH):$(ACE_ROOT)/lib$(if $(ARCH),:$(ACE_ROOT)/lib/$(ARCH))
LD_LIBRARY_PATH   := $(LD_LIBRARY_PATH):$(ACE_ROOT)/lib$(if $(ARCH),:$(ACE_ROOT)/lib/$(ARCH))
SHLIB_PATH        := $(SHLIB_PATH):$(ACE_ROOT)/lib$(if $(ARCH),:$(ACE_ROOT)/lib/$(ARCH))
LIBPATH           := $(LIBPATH):$(ACE_ROOT)/lib$(if $(ARCH),:$(ACE_ROOT)/lib/$(ARCH))
PATH              := $(PATH):$(ACE_ROOT)/lib$(if $(ARCH),:$(ACE_ROOT)/lib/$(ARCH))

GENERATED_DIRTY += DdsDcpsGuidS.h DdsDcpsGuidC.h DdsDcpsGuidC.cpp DdsDcpsGuidC.inl
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "DdsDcpsGuid.idl" -nt "DdsDcpsGuidS.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsGuid.idl" -nt "DdsDcpsGuidC.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsGuid.idl" -nt "DdsDcpsGuidC.cpp" 2> /dev/null || $(TEST_EXE) "DdsDcpsGuid.idl" -nt "DdsDcpsGuidC.inl" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsGuidS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsGuidC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsGuidC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsGuidC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsGuidS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsGuidC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsGuidC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsGuidC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsGuidS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsGuidC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsGuidC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsGuidC.inl" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
DdsDcpsGuidS.h DdsDcpsGuidC.h DdsDcpsGuidC.cpp DdsDcpsGuidC.inl: DdsDcpsGuid.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Sa -St -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_include=dds/Versioned_Namespace.h -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -SS -I.. DdsDcpsGuid.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
DdsDcpsGuidS.h DdsDcpsGuidC.h DdsDcpsGuidC.cpp DdsDcpsGuidC.inl: $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))) $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT)))
endif
endif

GENERATED_DIRTY += DdsDcpsCoreS.h DdsDcpsCoreC.h DdsDcpsCoreC.cpp DdsDcpsCoreC.inl
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "DdsDcpsCore.idl" -nt "DdsDcpsCoreS.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsCore.idl" -nt "DdsDcpsCoreC.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsCore.idl" -nt "DdsDcpsCoreC.cpp" 2> /dev/null || $(TEST_EXE) "DdsDcpsCore.idl" -nt "DdsDcpsCoreC.inl" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsCoreS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsCoreC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsCoreC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsCoreC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsCoreS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsCoreC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsCoreC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsCoreC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsCoreS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsCoreC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsCoreC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsCoreC.inl" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
DdsDcpsCoreS.h DdsDcpsCoreC.h DdsDcpsCoreC.cpp DdsDcpsCoreC.inl: DdsDcpsCore.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Sa -St -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_include=dds/Versioned_Namespace.h -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -SS -I.. DdsDcpsCore.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
DdsDcpsCoreS.h DdsDcpsCoreC.h DdsDcpsCoreC.cpp DdsDcpsCoreC.inl: $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))) $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT)))
endif
endif

GENERATED_DIRTY += DdsDcpsInfoUtilsS.h DdsDcpsInfoUtilsC.h DdsDcpsInfoUtilsC.cpp DdsDcpsInfoUtilsC.inl
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "DdsDcpsInfoUtils.idl" -nt "DdsDcpsInfoUtilsS.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsInfoUtils.idl" -nt "DdsDcpsInfoUtilsC.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsInfoUtils.idl" -nt "DdsDcpsInfoUtilsC.cpp" 2> /dev/null || $(TEST_EXE) "DdsDcpsInfoUtils.idl" -nt "DdsDcpsInfoUtilsC.inl" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsInfoUtilsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsInfoUtilsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsInfoUtilsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsInfoUtilsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsInfoUtilsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsInfoUtilsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsInfoUtilsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsInfoUtilsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsInfoUtilsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsInfoUtilsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsInfoUtilsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsInfoUtilsC.inl" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
DdsDcpsInfoUtilsS.h DdsDcpsInfoUtilsC.h DdsDcpsInfoUtilsC.cpp DdsDcpsInfoUtilsC.inl: DdsDcpsInfoUtils.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Sa -St -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_include=dds/Versioned_Namespace.h -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -SS -I.. DdsDcpsInfoUtils.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
DdsDcpsInfoUtilsS.h DdsDcpsInfoUtilsC.h DdsDcpsInfoUtilsC.cpp DdsDcpsInfoUtilsC.inl: $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))) $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT)))
endif
endif

GENERATED_DIRTY += DdsDcpsConditionSeqS.h DdsDcpsConditionSeqC.h DdsDcpsConditionSeqC.cpp DdsDcpsConditionSeqC.inl
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "DdsDcpsConditionSeq.idl" -nt "DdsDcpsConditionSeqS.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsConditionSeq.idl" -nt "DdsDcpsConditionSeqC.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsConditionSeq.idl" -nt "DdsDcpsConditionSeqC.cpp" 2> /dev/null || $(TEST_EXE) "DdsDcpsConditionSeq.idl" -nt "DdsDcpsConditionSeqC.inl" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsConditionSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsConditionSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsConditionSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsConditionSeqC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsConditionSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsConditionSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsConditionSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsConditionSeqC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsConditionSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsConditionSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsConditionSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsConditionSeqC.inl" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
DdsDcpsConditionSeqS.h DdsDcpsConditionSeqC.h DdsDcpsConditionSeqC.cpp DdsDcpsConditionSeqC.inl: DdsDcpsConditionSeq.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Sa -St -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_include=dds/Versioned_Namespace.h -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -SS -I.. DdsDcpsConditionSeq.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
DdsDcpsConditionSeqS.h DdsDcpsConditionSeqC.h DdsDcpsConditionSeqC.cpp DdsDcpsConditionSeqC.inl: $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))) $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT)))
endif
endif

GENERATED_DIRTY += DdsDcpsDataReaderSeqS.h DdsDcpsDataReaderSeqC.h DdsDcpsDataReaderSeqC.cpp DdsDcpsDataReaderSeqC.inl
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "DdsDcpsDataReaderSeq.idl" -nt "DdsDcpsDataReaderSeqS.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsDataReaderSeq.idl" -nt "DdsDcpsDataReaderSeqC.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsDataReaderSeq.idl" -nt "DdsDcpsDataReaderSeqC.cpp" 2> /dev/null || $(TEST_EXE) "DdsDcpsDataReaderSeq.idl" -nt "DdsDcpsDataReaderSeqC.inl" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsDataReaderSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsDataReaderSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsDataReaderSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsDataReaderSeqC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsDataReaderSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsDataReaderSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsDataReaderSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsDataReaderSeqC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsDataReaderSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsDataReaderSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsDataReaderSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsDataReaderSeqC.inl" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
DdsDcpsDataReaderSeqS.h DdsDcpsDataReaderSeqC.h DdsDcpsDataReaderSeqC.cpp DdsDcpsDataReaderSeqC.inl: DdsDcpsDataReaderSeq.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Sa -St -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_include=dds/Versioned_Namespace.h -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -SS -I.. DdsDcpsDataReaderSeq.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
DdsDcpsDataReaderSeqS.h DdsDcpsDataReaderSeqC.h DdsDcpsDataReaderSeqC.cpp DdsDcpsDataReaderSeqC.inl: $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))) $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT)))
endif
endif

GENERATED_DIRTY += DdsDcpsGuidTypeSupportS.h DdsDcpsGuidTypeSupportC.h DdsDcpsGuidTypeSupportC.cpp DdsDcpsGuidTypeSupportC.inl
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "DdsDcpsGuidTypeSupport.idl" -nt "DdsDcpsGuidTypeSupportS.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsGuidTypeSupport.idl" -nt "DdsDcpsGuidTypeSupportC.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsGuidTypeSupport.idl" -nt "DdsDcpsGuidTypeSupportC.cpp" 2> /dev/null || $(TEST_EXE) "DdsDcpsGuidTypeSupport.idl" -nt "DdsDcpsGuidTypeSupportC.inl" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsGuidTypeSupportS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsGuidTypeSupportC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsGuidTypeSupportC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsGuidTypeSupportC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsGuidTypeSupportS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsGuidTypeSupportC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsGuidTypeSupportC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsGuidTypeSupportC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsGuidTypeSupportS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsGuidTypeSupportC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsGuidTypeSupportC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsGuidTypeSupportC.inl" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
DdsDcpsGuidTypeSupportS.h DdsDcpsGuidTypeSupportC.h DdsDcpsGuidTypeSupportC.cpp DdsDcpsGuidTypeSupportC.inl: DdsDcpsGuidTypeSupport.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Sa -St -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_include=dds/Versioned_Namespace.h -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -SS -I.. DdsDcpsGuidTypeSupport.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
DdsDcpsGuidTypeSupportS.h DdsDcpsGuidTypeSupportC.h DdsDcpsGuidTypeSupportC.cpp DdsDcpsGuidTypeSupportC.inl: $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))) $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT)))
endif
endif

GENERATED_DIRTY += DdsDcpsCoreTypeSupportS.h DdsDcpsCoreTypeSupportC.h DdsDcpsCoreTypeSupportC.cpp DdsDcpsCoreTypeSupportC.inl
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "DdsDcpsCoreTypeSupport.idl" -nt "DdsDcpsCoreTypeSupportS.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsCoreTypeSupport.idl" -nt "DdsDcpsCoreTypeSupportC.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsCoreTypeSupport.idl" -nt "DdsDcpsCoreTypeSupportC.cpp" 2> /dev/null || $(TEST_EXE) "DdsDcpsCoreTypeSupport.idl" -nt "DdsDcpsCoreTypeSupportC.inl" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsCoreTypeSupportS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsCoreTypeSupportC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsCoreTypeSupportC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsCoreTypeSupportC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsCoreTypeSupportS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsCoreTypeSupportC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsCoreTypeSupportC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsCoreTypeSupportC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsCoreTypeSupportS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsCoreTypeSupportC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsCoreTypeSupportC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsCoreTypeSupportC.inl" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
DdsDcpsCoreTypeSupportS.h DdsDcpsCoreTypeSupportC.h DdsDcpsCoreTypeSupportC.cpp DdsDcpsCoreTypeSupportC.inl: DdsDcpsCoreTypeSupport.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Sa -St -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_include=dds/Versioned_Namespace.h -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -SS -I.. DdsDcpsCoreTypeSupport.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
DdsDcpsCoreTypeSupportS.h DdsDcpsCoreTypeSupportC.h DdsDcpsCoreTypeSupportC.cpp DdsDcpsCoreTypeSupportC.inl: $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))) $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT)))
endif
endif

GENERATED_DIRTY += DdsDcpsInfrastructureTypeSupportS.h DdsDcpsInfrastructureTypeSupportC.h DdsDcpsInfrastructureTypeSupportC.cpp DdsDcpsInfrastructureTypeSupportC.inl
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "DdsDcpsInfrastructureTypeSupport.idl" -nt "DdsDcpsInfrastructureTypeSupportS.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsInfrastructureTypeSupport.idl" -nt "DdsDcpsInfrastructureTypeSupportC.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsInfrastructureTypeSupport.idl" -nt "DdsDcpsInfrastructureTypeSupportC.cpp" 2> /dev/null || $(TEST_EXE) "DdsDcpsInfrastructureTypeSupport.idl" -nt "DdsDcpsInfrastructureTypeSupportC.inl" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsInfrastructureTypeSupportS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsInfrastructureTypeSupportC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsInfrastructureTypeSupportC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsInfrastructureTypeSupportC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsInfrastructureTypeSupportS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsInfrastructureTypeSupportC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsInfrastructureTypeSupportC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsInfrastructureTypeSupportC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsInfrastructureTypeSupportS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsInfrastructureTypeSupportC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsInfrastructureTypeSupportC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsInfrastructureTypeSupportC.inl" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
DdsDcpsInfrastructureTypeSupportS.h DdsDcpsInfrastructureTypeSupportC.h DdsDcpsInfrastructureTypeSupportC.cpp DdsDcpsInfrastructureTypeSupportC.inl: DdsDcpsInfrastructureTypeSupport.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Sa -St -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_include=dds/Versioned_Namespace.h -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -SS -I.. DdsDcpsInfrastructureTypeSupport.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
DdsDcpsInfrastructureTypeSupportS.h DdsDcpsInfrastructureTypeSupportC.h DdsDcpsInfrastructureTypeSupportC.cpp DdsDcpsInfrastructureTypeSupportC.inl: $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))) $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT)))
endif
endif

GENERATED_DIRTY += DdsDcpsS.h DdsDcpsC.h DdsDcpsC.cpp DdsDcpsC.inl
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "DdsDcps.idl" -nt "DdsDcpsS.h" 2> /dev/null || $(TEST_EXE) "DdsDcps.idl" -nt "DdsDcpsC.h" 2> /dev/null || $(TEST_EXE) "DdsDcps.idl" -nt "DdsDcpsC.cpp" 2> /dev/null || $(TEST_EXE) "DdsDcps.idl" -nt "DdsDcpsC.inl" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsC.inl" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
DdsDcpsS.h DdsDcpsC.h DdsDcpsC.cpp DdsDcpsC.inl: DdsDcps.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Sa -St -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_include=dds/Versioned_Namespace.h -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -SS -I.. DdsDcps.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
DdsDcpsS.h DdsDcpsC.h DdsDcpsC.cpp DdsDcpsC.inl: $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))) $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT)))
endif
endif

GENERATED_DIRTY += DdsDcpsDomainS.h DdsDcpsDomainC.h DdsDcpsDomainC.cpp DdsDcpsDomainC.inl
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "DdsDcpsDomain.idl" -nt "DdsDcpsDomainS.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsDomain.idl" -nt "DdsDcpsDomainC.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsDomain.idl" -nt "DdsDcpsDomainC.cpp" 2> /dev/null || $(TEST_EXE) "DdsDcpsDomain.idl" -nt "DdsDcpsDomainC.inl" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsDomainS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsDomainC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsDomainC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsDomainC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsDomainS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsDomainC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsDomainC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsDomainC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsDomainS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsDomainC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsDomainC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsDomainC.inl" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
DdsDcpsDomainS.h DdsDcpsDomainC.h DdsDcpsDomainC.cpp DdsDcpsDomainC.inl: DdsDcpsDomain.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Sa -St -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_include=dds/Versioned_Namespace.h -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -SS -I.. DdsDcpsDomain.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
DdsDcpsDomainS.h DdsDcpsDomainC.h DdsDcpsDomainC.cpp DdsDcpsDomainC.inl: $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))) $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT)))
endif
endif

GENERATED_DIRTY += DdsDcpsInfrastructureS.h DdsDcpsInfrastructureC.h DdsDcpsInfrastructureC.cpp DdsDcpsInfrastructureC.inl
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "DdsDcpsInfrastructure.idl" -nt "DdsDcpsInfrastructureS.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsInfrastructure.idl" -nt "DdsDcpsInfrastructureC.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsInfrastructure.idl" -nt "DdsDcpsInfrastructureC.cpp" 2> /dev/null || $(TEST_EXE) "DdsDcpsInfrastructure.idl" -nt "DdsDcpsInfrastructureC.inl" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsInfrastructureS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsInfrastructureC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsInfrastructureC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsInfrastructureC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsInfrastructureS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsInfrastructureC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsInfrastructureC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsInfrastructureC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsInfrastructureS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsInfrastructureC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsInfrastructureC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsInfrastructureC.inl" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
DdsDcpsInfrastructureS.h DdsDcpsInfrastructureC.h DdsDcpsInfrastructureC.cpp DdsDcpsInfrastructureC.inl: DdsDcpsInfrastructure.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Sa -St -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_include=dds/Versioned_Namespace.h -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -SS -I.. DdsDcpsInfrastructure.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
DdsDcpsInfrastructureS.h DdsDcpsInfrastructureC.h DdsDcpsInfrastructureC.cpp DdsDcpsInfrastructureC.inl: $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))) $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT)))
endif
endif

GENERATED_DIRTY += DdsDcpsPublicationS.h DdsDcpsPublicationC.h DdsDcpsPublicationC.cpp DdsDcpsPublicationC.inl
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "DdsDcpsPublication.idl" -nt "DdsDcpsPublicationS.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsPublication.idl" -nt "DdsDcpsPublicationC.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsPublication.idl" -nt "DdsDcpsPublicationC.cpp" 2> /dev/null || $(TEST_EXE) "DdsDcpsPublication.idl" -nt "DdsDcpsPublicationC.inl" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsPublicationS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsPublicationC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsPublicationC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsPublicationC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsPublicationS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsPublicationC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsPublicationC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsPublicationC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsPublicationS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsPublicationC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsPublicationC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsPublicationC.inl" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
DdsDcpsPublicationS.h DdsDcpsPublicationC.h DdsDcpsPublicationC.cpp DdsDcpsPublicationC.inl: DdsDcpsPublication.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Sa -St -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_include=dds/Versioned_Namespace.h -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -SS -I.. DdsDcpsPublication.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
DdsDcpsPublicationS.h DdsDcpsPublicationC.h DdsDcpsPublicationC.cpp DdsDcpsPublicationC.inl: $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))) $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT)))
endif
endif

GENERATED_DIRTY += DdsDcpsSubscriptionS.h DdsDcpsSubscriptionC.h DdsDcpsSubscriptionC.cpp DdsDcpsSubscriptionC.inl
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "DdsDcpsSubscription.idl" -nt "DdsDcpsSubscriptionS.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsSubscription.idl" -nt "DdsDcpsSubscriptionC.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsSubscription.idl" -nt "DdsDcpsSubscriptionC.cpp" 2> /dev/null || $(TEST_EXE) "DdsDcpsSubscription.idl" -nt "DdsDcpsSubscriptionC.inl" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsSubscriptionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsSubscriptionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsSubscriptionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsSubscriptionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsSubscriptionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsSubscriptionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsSubscriptionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsSubscriptionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsSubscriptionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsSubscriptionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsSubscriptionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsSubscriptionC.inl" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
DdsDcpsSubscriptionS.h DdsDcpsSubscriptionC.h DdsDcpsSubscriptionC.cpp DdsDcpsSubscriptionC.inl: DdsDcpsSubscription.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Sa -St -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_include=dds/Versioned_Namespace.h -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -SS -I.. DdsDcpsSubscription.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
DdsDcpsSubscriptionS.h DdsDcpsSubscriptionC.h DdsDcpsSubscriptionC.cpp DdsDcpsSubscriptionC.inl: $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))) $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT)))
endif
endif

GENERATED_DIRTY += DdsDcpsSubscriptionExtS.h DdsDcpsSubscriptionExtC.h DdsDcpsSubscriptionExtC.cpp DdsDcpsSubscriptionExtC.inl
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "DdsDcpsSubscriptionExt.idl" -nt "DdsDcpsSubscriptionExtS.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsSubscriptionExt.idl" -nt "DdsDcpsSubscriptionExtC.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsSubscriptionExt.idl" -nt "DdsDcpsSubscriptionExtC.cpp" 2> /dev/null || $(TEST_EXE) "DdsDcpsSubscriptionExt.idl" -nt "DdsDcpsSubscriptionExtC.inl" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsSubscriptionExtS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsSubscriptionExtC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsSubscriptionExtC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsSubscriptionExtC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsSubscriptionExtS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsSubscriptionExtC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsSubscriptionExtC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsSubscriptionExtC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsSubscriptionExtS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsSubscriptionExtC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsSubscriptionExtC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsSubscriptionExtC.inl" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
DdsDcpsSubscriptionExtS.h DdsDcpsSubscriptionExtC.h DdsDcpsSubscriptionExtC.cpp DdsDcpsSubscriptionExtC.inl: DdsDcpsSubscriptionExt.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Sa -St -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_include=dds/Versioned_Namespace.h -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -SS -I.. DdsDcpsSubscriptionExt.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
DdsDcpsSubscriptionExtS.h DdsDcpsSubscriptionExtC.h DdsDcpsSubscriptionExtC.cpp DdsDcpsSubscriptionExtC.inl: $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))) $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT)))
endif
endif

GENERATED_DIRTY += DdsDcpsTopicS.h DdsDcpsTopicC.h DdsDcpsTopicC.cpp DdsDcpsTopicC.inl
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "DdsDcpsTopic.idl" -nt "DdsDcpsTopicS.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsTopic.idl" -nt "DdsDcpsTopicC.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsTopic.idl" -nt "DdsDcpsTopicC.cpp" 2> /dev/null || $(TEST_EXE) "DdsDcpsTopic.idl" -nt "DdsDcpsTopicC.inl" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsTopicS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsTopicC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsTopicC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsTopicC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsTopicS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsTopicC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsTopicC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsTopicC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsTopicS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsTopicC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsTopicC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsTopicC.inl" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
DdsDcpsTopicS.h DdsDcpsTopicC.h DdsDcpsTopicC.cpp DdsDcpsTopicC.inl: DdsDcpsTopic.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Sa -St -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_include=dds/Versioned_Namespace.h -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -SS -I.. DdsDcpsTopic.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
DdsDcpsTopicS.h DdsDcpsTopicC.h DdsDcpsTopicC.cpp DdsDcpsTopicC.inl: $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))) $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT)))
endif
endif

GENERATED_DIRTY += DdsDcpsTypeSupportExtS.h DdsDcpsTypeSupportExtC.h DdsDcpsTypeSupportExtC.cpp DdsDcpsTypeSupportExtC.inl
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "DdsDcpsTypeSupportExt.idl" -nt "DdsDcpsTypeSupportExtS.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsTypeSupportExt.idl" -nt "DdsDcpsTypeSupportExtC.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsTypeSupportExt.idl" -nt "DdsDcpsTypeSupportExtC.cpp" 2> /dev/null || $(TEST_EXE) "DdsDcpsTypeSupportExt.idl" -nt "DdsDcpsTypeSupportExtC.inl" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsTypeSupportExtS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsTypeSupportExtC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsTypeSupportExtC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DdsDcpsTypeSupportExtC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsTypeSupportExtS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsTypeSupportExtC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsTypeSupportExtC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DdsDcpsTypeSupportExtC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsTypeSupportExtS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsTypeSupportExtC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsTypeSupportExtC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DdsDcpsTypeSupportExtC.inl" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
DdsDcpsTypeSupportExtS.h DdsDcpsTypeSupportExtC.h DdsDcpsTypeSupportExtC.cpp DdsDcpsTypeSupportExtC.inl: DdsDcpsTypeSupportExt.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Sa -St -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_include=dds/Versioned_Namespace.h -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -SS -I.. DdsDcpsTypeSupportExt.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
DdsDcpsTypeSupportExtS.h DdsDcpsTypeSupportExtC.h DdsDcpsTypeSupportExtC.cpp DdsDcpsTypeSupportExtC.inl: $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))) $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(ACE_ROOT)/lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT)))
endif
endif

DYLD_LIBRARY_PATH := $(DYLD_LIBRARY_PATH):$(ACE_ROOT)/lib$(if $(ARCH),:$(ACE_ROOT)/lib/$(ARCH))
LD_LIBRARY_PATH   := $(LD_LIBRARY_PATH):$(ACE_ROOT)/lib$(if $(ARCH),:$(ACE_ROOT)/lib/$(ARCH))
SHLIB_PATH        := $(SHLIB_PATH):$(ACE_ROOT)/lib$(if $(ARCH),:$(ACE_ROOT)/lib/$(ARCH))
LIBPATH           := $(LIBPATH):$(ACE_ROOT)/lib$(if $(ARCH),:$(ACE_ROOT)/lib/$(ARCH))
PATH              := $(PATH):$(ACE_ROOT)/lib$(if $(ARCH),:$(ACE_ROOT)/lib/$(ARCH))

GENERATED_DIRTY += DdsDcpsGuidTypeSupportImpl.h DdsDcpsGuidTypeSupportImpl.cpp DdsDcpsGuidTypeSupport.idl
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "DdsDcpsGuid.idl" -nt "DdsDcpsGuidTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsGuid.idl" -nt "DdsDcpsGuidTypeSupportImpl.cpp" 2> /dev/null || $(TEST_EXE) "DdsDcpsGuid.idl" -nt "DdsDcpsGuidTypeSupport.idl" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "DdsDcpsGuidTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "DdsDcpsGuidTypeSupportImpl.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "DdsDcpsGuidTypeSupport.idl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "DdsDcpsGuidTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "DdsDcpsGuidTypeSupportImpl.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "DdsDcpsGuidTypeSupport.idl" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
DdsDcpsGuidTypeSupportImpl.h DdsDcpsGuidTypeSupportImpl.cpp DdsDcpsGuidTypeSupport.idl: DdsDcpsGuid.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(OPENDDS_IDL_DEP))) $(call ADD_ARCH,../dds/idl/IDLTemplate.txt)
	$(if $(findstring ",$(OPENDDS_IDL)),$(OPENDDS_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(OPENDDS_IDL)))) -Sa -St -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_name=OPENDDS_VERSIONED_NAMESPACE_NAME DdsDcpsGuid.idl


GENERATED_DIRTY += DdsDcpsCoreTypeSupportImpl.h DdsDcpsCoreTypeSupportImpl.cpp DdsDcpsCoreTypeSupport.idl
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "DdsDcpsCore.idl" -nt "DdsDcpsCoreTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsCore.idl" -nt "DdsDcpsCoreTypeSupportImpl.cpp" 2> /dev/null || $(TEST_EXE) "DdsDcpsCore.idl" -nt "DdsDcpsCoreTypeSupport.idl" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "DdsDcpsCoreTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "DdsDcpsCoreTypeSupportImpl.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "DdsDcpsCoreTypeSupport.idl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "DdsDcpsCoreTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "DdsDcpsCoreTypeSupportImpl.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "DdsDcpsCoreTypeSupport.idl" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
DdsDcpsCoreTypeSupportImpl.h DdsDcpsCoreTypeSupportImpl.cpp DdsDcpsCoreTypeSupport.idl: DdsDcpsCore.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(OPENDDS_IDL_DEP))) $(call ADD_ARCH,../dds/idl/IDLTemplate.txt)
	$(if $(findstring ",$(OPENDDS_IDL)),$(OPENDDS_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(OPENDDS_IDL)))) -Sa -St -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_name=OPENDDS_VERSIONED_NAMESPACE_NAME DdsDcpsCore.idl


GENERATED_DIRTY += DdsDcpsInfrastructureTypeSupportImpl.h DdsDcpsInfrastructureTypeSupportImpl.cpp DdsDcpsInfrastructureTypeSupport.idl
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "DdsDcpsInfrastructure.idl" -nt "DdsDcpsInfrastructureTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsInfrastructure.idl" -nt "DdsDcpsInfrastructureTypeSupportImpl.cpp" 2> /dev/null || $(TEST_EXE) "DdsDcpsInfrastructure.idl" -nt "DdsDcpsInfrastructureTypeSupport.idl" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "DdsDcpsInfrastructureTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "DdsDcpsInfrastructureTypeSupportImpl.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "DdsDcpsInfrastructureTypeSupport.idl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "DdsDcpsInfrastructureTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "DdsDcpsInfrastructureTypeSupportImpl.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "DdsDcpsInfrastructureTypeSupport.idl" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
DdsDcpsInfrastructureTypeSupportImpl.h DdsDcpsInfrastructureTypeSupportImpl.cpp DdsDcpsInfrastructureTypeSupport.idl: DdsDcpsInfrastructure.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(OPENDDS_IDL_DEP))) $(call ADD_ARCH,../dds/idl/IDLTemplate.txt)
	$(if $(findstring ",$(OPENDDS_IDL)),$(OPENDDS_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(OPENDDS_IDL)))) -Sa -St -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_name=OPENDDS_VERSIONED_NAMESPACE_NAME DdsDcpsInfrastructure.idl


GENERATED_DIRTY += DdsDcpsInfoUtilsTypeSupportImpl.h DdsDcpsInfoUtilsTypeSupportImpl.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "DdsDcpsInfoUtils.idl" -nt "DdsDcpsInfoUtilsTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "DdsDcpsInfoUtils.idl" -nt "DdsDcpsInfoUtilsTypeSupportImpl.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "DdsDcpsInfoUtilsTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "DdsDcpsInfoUtilsTypeSupportImpl.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "DdsDcpsInfoUtilsTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "DdsDcpsInfoUtilsTypeSupportImpl.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
DdsDcpsInfoUtilsTypeSupportImpl.h DdsDcpsInfoUtilsTypeSupportImpl.cpp: DdsDcpsInfoUtils.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(OPENDDS_IDL_DEP))) $(call ADD_ARCH,../dds/idl/IDLTemplate.txt)
	$(if $(findstring ",$(OPENDDS_IDL)),$(OPENDDS_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(OPENDDS_IDL)))) -Sa -St -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_name=OPENDDS_VERSIONED_NAMESPACE_NAME -SI DdsDcpsInfoUtils.idl


GENERATED_DIRTY += CorbaSeq/BooleanSeqTypeSupportImpl.h CorbaSeq/BooleanSeqTypeSupportImpl.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "CorbaSeq/BooleanSeq.idl" -nt "CorbaSeq/BooleanSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "CorbaSeq/BooleanSeq.idl" -nt "CorbaSeq/BooleanSeqTypeSupportImpl.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "CorbaSeq/BooleanSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "CorbaSeq/BooleanSeqTypeSupportImpl.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "CorbaSeq/BooleanSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "CorbaSeq/BooleanSeqTypeSupportImpl.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
CorbaSeq/BooleanSeqTypeSupportImpl.h CorbaSeq/BooleanSeqTypeSupportImpl.cpp: CorbaSeq/BooleanSeq.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(OPENDDS_IDL_DEP))) $(call ADD_ARCH,../dds/idl/IDLTemplate.txt)
	$(MKDIR) CorbaSeq
	$(if $(findstring ",$(OPENDDS_IDL)),$(OPENDDS_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(OPENDDS_IDL)))) -Sa -St -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_name=OPENDDS_VERSIONED_NAMESPACE_NAME -o CorbaSeq -SI -Wb,tao_include_prefix=tao/ CorbaSeq/BooleanSeq.idl


GENERATED_DIRTY += CorbaSeq/CharSeqTypeSupportImpl.h CorbaSeq/CharSeqTypeSupportImpl.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "CorbaSeq/CharSeq.idl" -nt "CorbaSeq/CharSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "CorbaSeq/CharSeq.idl" -nt "CorbaSeq/CharSeqTypeSupportImpl.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "CorbaSeq/CharSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "CorbaSeq/CharSeqTypeSupportImpl.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "CorbaSeq/CharSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "CorbaSeq/CharSeqTypeSupportImpl.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
CorbaSeq/CharSeqTypeSupportImpl.h CorbaSeq/CharSeqTypeSupportImpl.cpp: CorbaSeq/CharSeq.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(OPENDDS_IDL_DEP))) $(call ADD_ARCH,../dds/idl/IDLTemplate.txt)
	$(MKDIR) CorbaSeq
	$(if $(findstring ",$(OPENDDS_IDL)),$(OPENDDS_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(OPENDDS_IDL)))) -Sa -St -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_name=OPENDDS_VERSIONED_NAMESPACE_NAME -o CorbaSeq -SI -Wb,tao_include_prefix=tao/ CorbaSeq/CharSeq.idl


GENERATED_DIRTY += CorbaSeq/DoubleSeqTypeSupportImpl.h CorbaSeq/DoubleSeqTypeSupportImpl.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "CorbaSeq/DoubleSeq.idl" -nt "CorbaSeq/DoubleSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "CorbaSeq/DoubleSeq.idl" -nt "CorbaSeq/DoubleSeqTypeSupportImpl.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "CorbaSeq/DoubleSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "CorbaSeq/DoubleSeqTypeSupportImpl.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "CorbaSeq/DoubleSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "CorbaSeq/DoubleSeqTypeSupportImpl.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
CorbaSeq/DoubleSeqTypeSupportImpl.h CorbaSeq/DoubleSeqTypeSupportImpl.cpp: CorbaSeq/DoubleSeq.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(OPENDDS_IDL_DEP))) $(call ADD_ARCH,../dds/idl/IDLTemplate.txt)
	$(MKDIR) CorbaSeq
	$(if $(findstring ",$(OPENDDS_IDL)),$(OPENDDS_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(OPENDDS_IDL)))) -Sa -St -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_name=OPENDDS_VERSIONED_NAMESPACE_NAME -o CorbaSeq -SI -Wb,tao_include_prefix=tao/ CorbaSeq/DoubleSeq.idl


GENERATED_DIRTY += CorbaSeq/FloatSeqTypeSupportImpl.h CorbaSeq/FloatSeqTypeSupportImpl.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "CorbaSeq/FloatSeq.idl" -nt "CorbaSeq/FloatSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "CorbaSeq/FloatSeq.idl" -nt "CorbaSeq/FloatSeqTypeSupportImpl.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "CorbaSeq/FloatSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "CorbaSeq/FloatSeqTypeSupportImpl.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "CorbaSeq/FloatSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "CorbaSeq/FloatSeqTypeSupportImpl.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
CorbaSeq/FloatSeqTypeSupportImpl.h CorbaSeq/FloatSeqTypeSupportImpl.cpp: CorbaSeq/FloatSeq.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(OPENDDS_IDL_DEP))) $(call ADD_ARCH,../dds/idl/IDLTemplate.txt)
	$(MKDIR) CorbaSeq
	$(if $(findstring ",$(OPENDDS_IDL)),$(OPENDDS_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(OPENDDS_IDL)))) -Sa -St -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_name=OPENDDS_VERSIONED_NAMESPACE_NAME -o CorbaSeq -SI -Wb,tao_include_prefix=tao/ CorbaSeq/FloatSeq.idl


GENERATED_DIRTY += CorbaSeq/LongDoubleSeqTypeSupportImpl.h CorbaSeq/LongDoubleSeqTypeSupportImpl.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "CorbaSeq/LongDoubleSeq.idl" -nt "CorbaSeq/LongDoubleSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "CorbaSeq/LongDoubleSeq.idl" -nt "CorbaSeq/LongDoubleSeqTypeSupportImpl.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "CorbaSeq/LongDoubleSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "CorbaSeq/LongDoubleSeqTypeSupportImpl.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "CorbaSeq/LongDoubleSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "CorbaSeq/LongDoubleSeqTypeSupportImpl.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
CorbaSeq/LongDoubleSeqTypeSupportImpl.h CorbaSeq/LongDoubleSeqTypeSupportImpl.cpp: CorbaSeq/LongDoubleSeq.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(OPENDDS_IDL_DEP))) $(call ADD_ARCH,../dds/idl/IDLTemplate.txt)
	$(MKDIR) CorbaSeq
	$(if $(findstring ",$(OPENDDS_IDL)),$(OPENDDS_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(OPENDDS_IDL)))) -Sa -St -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_name=OPENDDS_VERSIONED_NAMESPACE_NAME -o CorbaSeq -SI -Wb,tao_include_prefix=tao/ CorbaSeq/LongDoubleSeq.idl


GENERATED_DIRTY += CorbaSeq/LongLongSeqTypeSupportImpl.h CorbaSeq/LongLongSeqTypeSupportImpl.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "CorbaSeq/LongLongSeq.idl" -nt "CorbaSeq/LongLongSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "CorbaSeq/LongLongSeq.idl" -nt "CorbaSeq/LongLongSeqTypeSupportImpl.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "CorbaSeq/LongLongSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "CorbaSeq/LongLongSeqTypeSupportImpl.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "CorbaSeq/LongLongSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "CorbaSeq/LongLongSeqTypeSupportImpl.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
CorbaSeq/LongLongSeqTypeSupportImpl.h CorbaSeq/LongLongSeqTypeSupportImpl.cpp: CorbaSeq/LongLongSeq.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(OPENDDS_IDL_DEP))) $(call ADD_ARCH,../dds/idl/IDLTemplate.txt)
	$(MKDIR) CorbaSeq
	$(if $(findstring ",$(OPENDDS_IDL)),$(OPENDDS_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(OPENDDS_IDL)))) -Sa -St -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_name=OPENDDS_VERSIONED_NAMESPACE_NAME -o CorbaSeq -SI -Wb,tao_include_prefix=tao/ CorbaSeq/LongLongSeq.idl


GENERATED_DIRTY += CorbaSeq/LongSeqTypeSupportImpl.h CorbaSeq/LongSeqTypeSupportImpl.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "CorbaSeq/LongSeq.idl" -nt "CorbaSeq/LongSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "CorbaSeq/LongSeq.idl" -nt "CorbaSeq/LongSeqTypeSupportImpl.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "CorbaSeq/LongSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "CorbaSeq/LongSeqTypeSupportImpl.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "CorbaSeq/LongSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "CorbaSeq/LongSeqTypeSupportImpl.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
CorbaSeq/LongSeqTypeSupportImpl.h CorbaSeq/LongSeqTypeSupportImpl.cpp: CorbaSeq/LongSeq.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(OPENDDS_IDL_DEP))) $(call ADD_ARCH,../dds/idl/IDLTemplate.txt)
	$(MKDIR) CorbaSeq
	$(if $(findstring ",$(OPENDDS_IDL)),$(OPENDDS_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(OPENDDS_IDL)))) -Sa -St -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_name=OPENDDS_VERSIONED_NAMESPACE_NAME -o CorbaSeq -SI -Wb,tao_include_prefix=tao/ CorbaSeq/LongSeq.idl


GENERATED_DIRTY += CorbaSeq/OctetSeqTypeSupportImpl.h CorbaSeq/OctetSeqTypeSupportImpl.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "CorbaSeq/OctetSeq.idl" -nt "CorbaSeq/OctetSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "CorbaSeq/OctetSeq.idl" -nt "CorbaSeq/OctetSeqTypeSupportImpl.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "CorbaSeq/OctetSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "CorbaSeq/OctetSeqTypeSupportImpl.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "CorbaSeq/OctetSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "CorbaSeq/OctetSeqTypeSupportImpl.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
CorbaSeq/OctetSeqTypeSupportImpl.h CorbaSeq/OctetSeqTypeSupportImpl.cpp: CorbaSeq/OctetSeq.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(OPENDDS_IDL_DEP))) $(call ADD_ARCH,../dds/idl/IDLTemplate.txt)
	$(MKDIR) CorbaSeq
	$(if $(findstring ",$(OPENDDS_IDL)),$(OPENDDS_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(OPENDDS_IDL)))) -Sa -St -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_name=OPENDDS_VERSIONED_NAMESPACE_NAME -o CorbaSeq -SI -Wb,tao_include_prefix=tao/ CorbaSeq/OctetSeq.idl


GENERATED_DIRTY += CorbaSeq/ShortSeqTypeSupportImpl.h CorbaSeq/ShortSeqTypeSupportImpl.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "CorbaSeq/ShortSeq.idl" -nt "CorbaSeq/ShortSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "CorbaSeq/ShortSeq.idl" -nt "CorbaSeq/ShortSeqTypeSupportImpl.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "CorbaSeq/ShortSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "CorbaSeq/ShortSeqTypeSupportImpl.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "CorbaSeq/ShortSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "CorbaSeq/ShortSeqTypeSupportImpl.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
CorbaSeq/ShortSeqTypeSupportImpl.h CorbaSeq/ShortSeqTypeSupportImpl.cpp: CorbaSeq/ShortSeq.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(OPENDDS_IDL_DEP))) $(call ADD_ARCH,../dds/idl/IDLTemplate.txt)
	$(MKDIR) CorbaSeq
	$(if $(findstring ",$(OPENDDS_IDL)),$(OPENDDS_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(OPENDDS_IDL)))) -Sa -St -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_name=OPENDDS_VERSIONED_NAMESPACE_NAME -o CorbaSeq -SI -Wb,tao_include_prefix=tao/ CorbaSeq/ShortSeq.idl


GENERATED_DIRTY += CorbaSeq/StringSeqTypeSupportImpl.h CorbaSeq/StringSeqTypeSupportImpl.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "CorbaSeq/StringSeq.idl" -nt "CorbaSeq/StringSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "CorbaSeq/StringSeq.idl" -nt "CorbaSeq/StringSeqTypeSupportImpl.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "CorbaSeq/StringSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "CorbaSeq/StringSeqTypeSupportImpl.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "CorbaSeq/StringSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "CorbaSeq/StringSeqTypeSupportImpl.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
CorbaSeq/StringSeqTypeSupportImpl.h CorbaSeq/StringSeqTypeSupportImpl.cpp: CorbaSeq/StringSeq.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(OPENDDS_IDL_DEP))) $(call ADD_ARCH,../dds/idl/IDLTemplate.txt)
	$(MKDIR) CorbaSeq
	$(if $(findstring ",$(OPENDDS_IDL)),$(OPENDDS_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(OPENDDS_IDL)))) -Sa -St -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_name=OPENDDS_VERSIONED_NAMESPACE_NAME -o CorbaSeq -SI -Wb,tao_include_prefix=tao/ CorbaSeq/StringSeq.idl


GENERATED_DIRTY += CorbaSeq/ULongLongSeqTypeSupportImpl.h CorbaSeq/ULongLongSeqTypeSupportImpl.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "CorbaSeq/ULongLongSeq.idl" -nt "CorbaSeq/ULongLongSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "CorbaSeq/ULongLongSeq.idl" -nt "CorbaSeq/ULongLongSeqTypeSupportImpl.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "CorbaSeq/ULongLongSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "CorbaSeq/ULongLongSeqTypeSupportImpl.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "CorbaSeq/ULongLongSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "CorbaSeq/ULongLongSeqTypeSupportImpl.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
CorbaSeq/ULongLongSeqTypeSupportImpl.h CorbaSeq/ULongLongSeqTypeSupportImpl.cpp: CorbaSeq/ULongLongSeq.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(OPENDDS_IDL_DEP))) $(call ADD_ARCH,../dds/idl/IDLTemplate.txt)
	$(MKDIR) CorbaSeq
	$(if $(findstring ",$(OPENDDS_IDL)),$(OPENDDS_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(OPENDDS_IDL)))) -Sa -St -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_name=OPENDDS_VERSIONED_NAMESPACE_NAME -o CorbaSeq -SI -Wb,tao_include_prefix=tao/ CorbaSeq/ULongLongSeq.idl


GENERATED_DIRTY += CorbaSeq/ULongSeqTypeSupportImpl.h CorbaSeq/ULongSeqTypeSupportImpl.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "CorbaSeq/ULongSeq.idl" -nt "CorbaSeq/ULongSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "CorbaSeq/ULongSeq.idl" -nt "CorbaSeq/ULongSeqTypeSupportImpl.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "CorbaSeq/ULongSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "CorbaSeq/ULongSeqTypeSupportImpl.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "CorbaSeq/ULongSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "CorbaSeq/ULongSeqTypeSupportImpl.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
CorbaSeq/ULongSeqTypeSupportImpl.h CorbaSeq/ULongSeqTypeSupportImpl.cpp: CorbaSeq/ULongSeq.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(OPENDDS_IDL_DEP))) $(call ADD_ARCH,../dds/idl/IDLTemplate.txt)
	$(MKDIR) CorbaSeq
	$(if $(findstring ",$(OPENDDS_IDL)),$(OPENDDS_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(OPENDDS_IDL)))) -Sa -St -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_name=OPENDDS_VERSIONED_NAMESPACE_NAME -o CorbaSeq -SI -Wb,tao_include_prefix=tao/ CorbaSeq/ULongSeq.idl


GENERATED_DIRTY += CorbaSeq/UShortSeqTypeSupportImpl.h CorbaSeq/UShortSeqTypeSupportImpl.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "CorbaSeq/UShortSeq.idl" -nt "CorbaSeq/UShortSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "CorbaSeq/UShortSeq.idl" -nt "CorbaSeq/UShortSeqTypeSupportImpl.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "CorbaSeq/UShortSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "CorbaSeq/UShortSeqTypeSupportImpl.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "CorbaSeq/UShortSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "CorbaSeq/UShortSeqTypeSupportImpl.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
CorbaSeq/UShortSeqTypeSupportImpl.h CorbaSeq/UShortSeqTypeSupportImpl.cpp: CorbaSeq/UShortSeq.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(OPENDDS_IDL_DEP))) $(call ADD_ARCH,../dds/idl/IDLTemplate.txt)
	$(MKDIR) CorbaSeq
	$(if $(findstring ",$(OPENDDS_IDL)),$(OPENDDS_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(OPENDDS_IDL)))) -Sa -St -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_name=OPENDDS_VERSIONED_NAMESPACE_NAME -o CorbaSeq -SI -Wb,tao_include_prefix=tao/ CorbaSeq/UShortSeq.idl


GENERATED_DIRTY += CorbaSeq/WCharSeqTypeSupportImpl.h CorbaSeq/WCharSeqTypeSupportImpl.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "CorbaSeq/WCharSeq.idl" -nt "CorbaSeq/WCharSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "CorbaSeq/WCharSeq.idl" -nt "CorbaSeq/WCharSeqTypeSupportImpl.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "CorbaSeq/WCharSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "CorbaSeq/WCharSeqTypeSupportImpl.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "CorbaSeq/WCharSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "CorbaSeq/WCharSeqTypeSupportImpl.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
CorbaSeq/WCharSeqTypeSupportImpl.h CorbaSeq/WCharSeqTypeSupportImpl.cpp: CorbaSeq/WCharSeq.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(OPENDDS_IDL_DEP))) $(call ADD_ARCH,../dds/idl/IDLTemplate.txt)
	$(MKDIR) CorbaSeq
	$(if $(findstring ",$(OPENDDS_IDL)),$(OPENDDS_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(OPENDDS_IDL)))) -Sa -St -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_name=OPENDDS_VERSIONED_NAMESPACE_NAME -o CorbaSeq -SI -Wb,tao_include_prefix=tao/ CorbaSeq/WCharSeq.idl


GENERATED_DIRTY += CorbaSeq/WStringSeqTypeSupportImpl.h CorbaSeq/WStringSeqTypeSupportImpl.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "CorbaSeq/WStringSeq.idl" -nt "CorbaSeq/WStringSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "CorbaSeq/WStringSeq.idl" -nt "CorbaSeq/WStringSeqTypeSupportImpl.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "CorbaSeq/WStringSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(OPENDDS_IDL_DEP))" -nt "CorbaSeq/WStringSeqTypeSupportImpl.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "CorbaSeq/WStringSeqTypeSupportImpl.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../dds/idl/IDLTemplate.txt)" -nt "CorbaSeq/WStringSeqTypeSupportImpl.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
CorbaSeq/WStringSeqTypeSupportImpl.h CorbaSeq/WStringSeqTypeSupportImpl.cpp: CorbaSeq/WStringSeq.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(OPENDDS_IDL_DEP))) $(call ADD_ARCH,../dds/idl/IDLTemplate.txt)
	$(MKDIR) CorbaSeq
	$(if $(findstring ",$(OPENDDS_IDL)),$(OPENDDS_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(OPENDDS_IDL)))) -Sa -St -Wb,pch_include=DCPS/DdsDcps_pch.h -Wb,export_macro=OpenDDS_Dcps_Export -Wb,export_include=dds/DCPS/dcps_export.h -Wb,versioning_begin=OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=OPENDDS_END_VERSIONED_NAMESPACE_DECL -Wb,versioning_name=OPENDDS_VERSIONED_NAMESPACE_NAME -o CorbaSeq -SI -Wb,tao_include_prefix=tao/ CorbaSeq/WStringSeq.idl


ifneq ($(GENERATED_DIRTY),)
.PRECIOUS: $(GENERATED_DIRTY)
## If the generated files are anything but source files, we need to
## ensure that those files are generated before we attempt to build anything
## else.
ifeq ($(OBJS_DEPEND_ON_GENERATED),1)
$(VDIR)$(ACE_PCH_FILE) $(addprefix $(VDIR), $(OBJS)): $(GENERATED_DIRTY)
$(VSHDIR)$(ACE_PCH_FILE) $(VSHOBJS): $(GENERATED_DIRTY)
endif
endif

ADDITIONAL_IDL_TARGETS += DdsDcpsGuid$(IDL_CLIENT_HDR_EXT) DdsDcpsCore$(IDL_CLIENT_HDR_EXT) DdsDcpsInfoUtils$(IDL_CLIENT_HDR_EXT) DdsDcpsConditionSeq$(IDL_CLIENT_HDR_EXT) DdsDcpsDataReaderSeq$(IDL_CLIENT_HDR_EXT) DdsDcpsGuidTypeSupport$(IDL_CLIENT_HDR_EXT) DdsDcpsCoreTypeSupport$(IDL_CLIENT_HDR_EXT) DdsDcpsInfrastructureTypeSupport$(IDL_CLIENT_HDR_EXT) DdsDcps$(IDL_CLIENT_HDR_EXT) DdsDcpsDomain$(IDL_CLIENT_HDR_EXT) DdsDcpsInfrastructure$(IDL_CLIENT_HDR_EXT) DdsDcpsPublication$(IDL_CLIENT_HDR_EXT) DdsDcpsSubscription$(IDL_CLIENT_HDR_EXT) DdsDcpsSubscriptionExt$(IDL_CLIENT_HDR_EXT) DdsDcpsTopic$(IDL_CLIENT_HDR_EXT) DdsDcpsTypeSupportExt$(IDL_CLIENT_HDR_EXT)
idl_stubs: $(ADDITIONAL_IDL_TARGETS)

# This assignment forces make to run the idl_stubs
# target before building any of the source files.
FORCED_IDL_STUBS = DdsDcpsGuidTypeSupportImpl.cpp DdsDcpsCoreTypeSupportImpl.cpp DdsDcpsInfrastructureTypeSupportImpl.cpp DdsDcpsInfoUtilsTypeSupportImpl.cpp CorbaSeq/BooleanSeqTypeSupportImpl.cpp CorbaSeq/CharSeqTypeSupportImpl.cpp CorbaSeq/DoubleSeqTypeSupportImpl.cpp CorbaSeq/FloatSeqTypeSupportImpl.cpp CorbaSeq/LongDoubleSeqTypeSupportImpl.cpp CorbaSeq/LongLongSeqTypeSupportImpl.cpp CorbaSeq/LongSeqTypeSupportImpl.cpp CorbaSeq/OctetSeqTypeSupportImpl.cpp CorbaSeq/ShortSeqTypeSupportImpl.cpp CorbaSeq/StringSeqTypeSupportImpl.cpp CorbaSeq/ULongLongSeqTypeSupportImpl.cpp CorbaSeq/ULongSeqTypeSupportImpl.cpp CorbaSeq/UShortSeqTypeSupportImpl.cpp CorbaSeq/WCharSeqTypeSupportImpl.cpp CorbaSeq/WStringSeqTypeSupportImpl.cpp DdsDcpsGuidC.cpp DdsDcpsCoreC.cpp DdsDcpsInfoUtilsC.cpp DdsDcpsConditionSeqC.cpp DdsDcpsDataReaderSeqC.cpp DdsDcpsGuidTypeSupportC.cpp DdsDcpsCoreTypeSupportC.cpp DdsDcpsInfrastructureTypeSupportC.cpp DdsDcpsC.cpp DdsDcpsDomainC.cpp DdsDcpsInfrastructureC.cpp DdsDcpsPublicationC.cpp DdsDcpsSubscriptionC.cpp DdsDcpsSubscriptionExtC.cpp DdsDcpsTopicC.cpp DdsDcpsTypeSupportExtC.cpp DCPS/BitPubListenerImpl.cpp DCPS/BuiltInTopicUtils.cpp DCPS/CoherentChangeControl.cpp DCPS/ConditionImpl.cpp DCPS/ConfigUtils.cpp DCPS/ContentFilteredTopicImpl.cpp DCPS/DataDurabilityCache.cpp DCPS/DataReaderImpl.cpp DCPS/DataSampleElement.cpp DCPS/DataSampleHeader.cpp DCPS/DataWriterImpl.cpp DCPS/DCPS_Utils.cpp DCPS/debug.cpp DCPS/Discovery.cpp DCPS/DisjointSequence.cpp DCPS/DomainParticipantFactoryImpl.cpp DCPS/DomainParticipantImpl.cpp DCPS/EntityImpl.cpp DCPS/FileSystemStorage.cpp DCPS/FilterEvaluator.cpp DCPS/GroupRakeData.cpp DCPS/GuardCondition.cpp DCPS/GuidBuilder.cpp DCPS/GuidConverter.cpp DCPS/GuidUtils.cpp DCPS/InstanceDataSampleList.cpp DCPS/InstanceHandle.cpp DCPS/InstanceState.cpp DCPS/Marked_Default_Qos.cpp DCPS/MemoryPool.cpp DCPS/MessageTracker.cpp DCPS/MonitorFactory.cpp DCPS/MultiTopicDataReaderBase.cpp DCPS/MultiTopicImpl.cpp DCPS/OfferedDeadlineWatchdog.cpp DCPS/OwnershipManager.cpp DCPS/PublisherImpl.cpp DCPS/Qos_Helper.cpp DCPS/QueryConditionImpl.cpp DCPS/RawDataSample.cpp DCPS/ReactorInterceptor.cpp DCPS/ReadConditionImpl.cpp DCPS/ReceivedDataElementList.cpp DCPS/ReceivedDataStrategy.cpp DCPS/Recorder.cpp DCPS/RecorderImpl.cpp DCPS/Registered_Data_Types.cpp DCPS/Replayer.cpp DCPS/ReplayerImpl.cpp DCPS/RepoIdBuilder.cpp DCPS/RepoIdConverter.cpp DCPS/RepoIdGenerator.cpp DCPS/RequestedDeadlineWatchdog.cpp DCPS/SafetyProfilePool.cpp DCPS/SafetyProfileStreams.cpp DCPS/SendStateDataSampleList.cpp DCPS/Serializer.cpp DCPS/Service_Participant.cpp DCPS/StaticDiscovery.cpp DCPS/StatusConditionImpl.cpp DCPS/SubscriberImpl.cpp DCPS/TopicDescriptionImpl.cpp DCPS/TopicImpl.cpp DCPS/Transient_Kludge.cpp DCPS/TypeSupportImpl.cpp DCPS/WaitSet.cpp DCPS/Watchdog.cpp DCPS/WriteDataContainer.cpp DCPS/WriterDataSampleList.cpp DCPS/WriterInfo.cpp DCPS/transport/framework/BuildChainVisitor.cpp DCPS/transport/framework/CopyChainVisitor.cpp DCPS/transport/framework/DataLink.cpp DCPS/transport/framework/DataLinkCleanupTask.cpp DCPS/transport/framework/DataLinkSet.cpp DCPS/transport/framework/DirectPriorityMapper.cpp DCPS/transport/framework/NetworkAddress.cpp DCPS/transport/framework/NullSynch.cpp DCPS/transport/framework/NullSynchStrategy.cpp DCPS/transport/framework/PacketRemoveVisitor.cpp DCPS/transport/framework/PerConnectionSynch.cpp DCPS/transport/framework/PerConnectionSynchStrategy.cpp DCPS/transport/framework/PoolSynch.cpp DCPS/transport/framework/PoolSynchStrategy.cpp DCPS/transport/framework/PriorityKey.cpp DCPS/transport/framework/PriorityMapper.cpp DCPS/transport/framework/QueueRemoveVisitor.cpp DCPS/transport/framework/ReactorSynch.cpp DCPS/transport/framework/ReactorSynchStrategy.cpp DCPS/transport/framework/ReceivedDataSample.cpp DCPS/transport/framework/ReceiveListenerSet.cpp DCPS/transport/framework/ReceiveListenerSetMap.cpp DCPS/transport/framework/RemoveAllVisitor.cpp DCPS/transport/framework/ScheduleOutputHandler.cpp DCPS/transport/framework/SendResponseListener.cpp DCPS/transport/framework/ThreadPerConnectionSendTask.cpp DCPS/transport/framework/ThreadPerConRemoveVisitor.cpp DCPS/transport/framework/ThreadSynch.cpp DCPS/transport/framework/ThreadSynchResource.cpp DCPS/transport/framework/ThreadSynchStrategy.cpp DCPS/transport/framework/ThreadSynchWorker.cpp DCPS/transport/framework/TransportClient.cpp DCPS/transport/framework/TransportConfig.cpp DCPS/transport/framework/TransportControlElement.cpp DCPS/transport/framework/TransportCustomizedElement.cpp DCPS/transport/framework/TransportDebug.cpp DCPS/transport/framework/TransportHeader.cpp DCPS/transport/framework/TransportImpl.cpp DCPS/transport/framework/TransportInst.cpp DCPS/transport/framework/TransportQueueElement.cpp DCPS/transport/framework/TransportReactorTask.cpp DCPS/transport/framework/TransportReassembly.cpp DCPS/transport/framework/TransportReceiveListener.cpp DCPS/transport/framework/TransportRegistry.cpp DCPS/transport/framework/TransportReplacedElement.cpp DCPS/transport/framework/TransportRetainedElement.cpp DCPS/transport/framework/TransportSendBuffer.cpp DCPS/transport/framework/TransportSendControlElement.cpp DCPS/transport/framework/TransportSendElement.cpp DCPS/transport/framework/TransportSendListener.cpp DCPS/transport/framework/TransportSendStrategy.cpp DCPS/transport/framework/TransportStrategy.cpp DCPS/transport/framework/TransportType.cpp  $(ACE_PCH_SOURCE)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:DdsDcpsGuidC.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:DdsDcpsCoreC.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:DdsDcpsInfoUtilsC.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:DdsDcpsConditionSeqC.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:DdsDcpsDataReaderSeqC.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:DdsDcpsGuidTypeSupportC.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:DdsDcpsCoreTypeSupportC.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:DdsDcpsInfrastructureTypeSupportC.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:DdsDcpsC.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:DdsDcpsDomainC.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:DdsDcpsInfrastructureC.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:DdsDcpsPublicationC.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:DdsDcpsSubscriptionC.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:DdsDcpsSubscriptionExtC.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:DdsDcpsTopicC.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:DdsDcpsTypeSupportExtC.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:DdsDcpsGuidTypeSupportImpl.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:DdsDcpsCoreTypeSupportImpl.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:DdsDcpsInfrastructureTypeSupportImpl.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:DdsDcpsInfoUtilsTypeSupportImpl.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:CorbaSeq/BooleanSeqTypeSupportImpl.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:CorbaSeq/CharSeqTypeSupportImpl.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:CorbaSeq/DoubleSeqTypeSupportImpl.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:CorbaSeq/FloatSeqTypeSupportImpl.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:CorbaSeq/LongDoubleSeqTypeSupportImpl.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:CorbaSeq/LongLongSeqTypeSupportImpl.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:CorbaSeq/LongSeqTypeSupportImpl.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:CorbaSeq/OctetSeqTypeSupportImpl.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:CorbaSeq/ShortSeqTypeSupportImpl.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:CorbaSeq/StringSeqTypeSupportImpl.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:CorbaSeq/ULongLongSeqTypeSupportImpl.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:CorbaSeq/ULongSeqTypeSupportImpl.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:CorbaSeq/UShortSeqTypeSupportImpl.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:CorbaSeq/WCharSeqTypeSupportImpl.cpp=)
FORCED_IDL_STUBS := $(FORCED_IDL_STUBS:CorbaSeq/WStringSeqTypeSupportImpl.cpp=)

ifneq ($(FORCED_IDL_STUBS),)
$(FORCED_IDL_STUBS): idl_stubs
endif

incremental_depend_idl::
	@$(RM) $(IDL_DEPENDENCY_FILE1)_idl.old
	@cp $(IDL_DEPENDENCY_FILE1) $(IDL_DEPENDENCY_FILE1)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE1) \
	$(IDL_DEPS_FLAGS1) -t gnuidl -DMAKEDEPEND $(IDL_DEPS1)
	@if cmp -s $(IDL_DEPENDENCY_FILE1) $(IDL_DEPENDENCY_FILE1)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS1)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS1)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE1)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE2)_idl.old
	@cp $(IDL_DEPENDENCY_FILE2) $(IDL_DEPENDENCY_FILE2)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE2) \
	$(IDL_DEPS_FLAGS2) -t gnuidl -DMAKEDEPEND $(IDL_DEPS2)
	@if cmp -s $(IDL_DEPENDENCY_FILE2) $(IDL_DEPENDENCY_FILE2)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS2)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS2)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE2)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE3)_idl.old
	@cp $(IDL_DEPENDENCY_FILE3) $(IDL_DEPENDENCY_FILE3)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE3) \
	$(IDL_DEPS_FLAGS3) -t gnuidl -DMAKEDEPEND $(IDL_DEPS3)
	@if cmp -s $(IDL_DEPENDENCY_FILE3) $(IDL_DEPENDENCY_FILE3)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS3)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS3)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE3)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE4)_idl.old
	@cp $(IDL_DEPENDENCY_FILE4) $(IDL_DEPENDENCY_FILE4)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE4) \
	$(IDL_DEPS_FLAGS4) -t gnuidl -DMAKEDEPEND $(IDL_DEPS4)
	@if cmp -s $(IDL_DEPENDENCY_FILE4) $(IDL_DEPENDENCY_FILE4)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS4)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS4)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE4)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE5)_idl.old
	@cp $(IDL_DEPENDENCY_FILE5) $(IDL_DEPENDENCY_FILE5)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE5) \
	$(IDL_DEPS_FLAGS5) -t gnuidl -DMAKEDEPEND $(IDL_DEPS5)
	@if cmp -s $(IDL_DEPENDENCY_FILE5) $(IDL_DEPENDENCY_FILE5)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS5)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS5)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE5)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE6)_idl.old
	@cp $(IDL_DEPENDENCY_FILE6) $(IDL_DEPENDENCY_FILE6)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE6) \
	$(IDL_DEPS_FLAGS6) -t gnuidl -DMAKEDEPEND $(IDL_DEPS6)
	@if cmp -s $(IDL_DEPENDENCY_FILE6) $(IDL_DEPENDENCY_FILE6)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS6)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS6)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE6)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE7)_idl.old
	@cp $(IDL_DEPENDENCY_FILE7) $(IDL_DEPENDENCY_FILE7)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE7) \
	$(IDL_DEPS_FLAGS7) -t gnuidl -DMAKEDEPEND $(IDL_DEPS7)
	@if cmp -s $(IDL_DEPENDENCY_FILE7) $(IDL_DEPENDENCY_FILE7)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS7)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS7)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE7)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE8)_idl.old
	@cp $(IDL_DEPENDENCY_FILE8) $(IDL_DEPENDENCY_FILE8)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE8) \
	$(IDL_DEPS_FLAGS8) -t gnuidl -DMAKEDEPEND $(IDL_DEPS8)
	@if cmp -s $(IDL_DEPENDENCY_FILE8) $(IDL_DEPENDENCY_FILE8)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS8)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS8)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE8)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE9)_idl.old
	@cp $(IDL_DEPENDENCY_FILE9) $(IDL_DEPENDENCY_FILE9)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE9) \
	$(IDL_DEPS_FLAGS9) -t gnuidl -DMAKEDEPEND $(IDL_DEPS9)
	@if cmp -s $(IDL_DEPENDENCY_FILE9) $(IDL_DEPENDENCY_FILE9)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS9)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS9)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE9)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE10)_idl.old
	@cp $(IDL_DEPENDENCY_FILE10) $(IDL_DEPENDENCY_FILE10)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE10) \
	$(IDL_DEPS_FLAGS10) -t gnuidl -DMAKEDEPEND $(IDL_DEPS10)
	@if cmp -s $(IDL_DEPENDENCY_FILE10) $(IDL_DEPENDENCY_FILE10)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS10)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS10)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE10)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE11)_idl.old
	@cp $(IDL_DEPENDENCY_FILE11) $(IDL_DEPENDENCY_FILE11)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE11) \
	$(IDL_DEPS_FLAGS11) -t gnuidl -DMAKEDEPEND $(IDL_DEPS11)
	@if cmp -s $(IDL_DEPENDENCY_FILE11) $(IDL_DEPENDENCY_FILE11)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS11)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS11)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE11)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE12)_idl.old
	@cp $(IDL_DEPENDENCY_FILE12) $(IDL_DEPENDENCY_FILE12)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE12) \
	$(IDL_DEPS_FLAGS12) -t gnuidl -DMAKEDEPEND $(IDL_DEPS12)
	@if cmp -s $(IDL_DEPENDENCY_FILE12) $(IDL_DEPENDENCY_FILE12)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS12)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS12)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE12)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE13)_idl.old
	@cp $(IDL_DEPENDENCY_FILE13) $(IDL_DEPENDENCY_FILE13)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE13) \
	$(IDL_DEPS_FLAGS13) -t gnuidl -DMAKEDEPEND $(IDL_DEPS13)
	@if cmp -s $(IDL_DEPENDENCY_FILE13) $(IDL_DEPENDENCY_FILE13)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS13)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS13)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE13)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE14)_idl.old
	@cp $(IDL_DEPENDENCY_FILE14) $(IDL_DEPENDENCY_FILE14)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE14) \
	$(IDL_DEPS_FLAGS14) -t gnuidl -DMAKEDEPEND $(IDL_DEPS14)
	@if cmp -s $(IDL_DEPENDENCY_FILE14) $(IDL_DEPENDENCY_FILE14)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS14)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS14)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE14)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE15)_idl.old
	@cp $(IDL_DEPENDENCY_FILE15) $(IDL_DEPENDENCY_FILE15)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE15) \
	$(IDL_DEPS_FLAGS15) -t gnuidl -DMAKEDEPEND $(IDL_DEPS15)
	@if cmp -s $(IDL_DEPENDENCY_FILE15) $(IDL_DEPENDENCY_FILE15)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS15)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS15)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE15)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE16)_idl.old
	@cp $(IDL_DEPENDENCY_FILE16) $(IDL_DEPENDENCY_FILE16)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE16) \
	$(IDL_DEPS_FLAGS16) -t gnuidl -DMAKEDEPEND $(IDL_DEPS16)
	@if cmp -s $(IDL_DEPENDENCY_FILE16) $(IDL_DEPENDENCY_FILE16)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS16)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS16)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE16)_idl.old ;

realclean: clean
ifneq ($(GENERATED_DIRTY),)
	-$(RM) -r $(GENERATED_DIRTY)
endif

__prebuild__:
	@-:


.PHONY: install
install: all
INSTALL_LIB ?= lib
ifneq ($(INSTALL_PREFIX),)
ifneq ($(install_rpath),0)
LDFLAGS += -Wl,-R$(INSTALL_PREFIX)/$(INSTALL_LIB) $(LD_RPATH_FLAGS)
endif
endif

PRJINST_OPTIONS ?=
INST_DIR ?= /$(notdir $(PWD))
COMMA = ,
SPACE = $(should_be_unset) $(should_be_unset)
INSTALLER ?= $(MPC_ROOT)/prj_install.pl
CUSTOM_INST_TAGS = $(sort  idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files typesupport_files typesupport_files typesupport_files typesupport_files typesupport_files typesupport_files typesupport_files typesupport_files typesupport_files typesupport_files typesupport_files typesupport_files typesupport_files typesupport_files typesupport_files typesupport_files typesupport_files typesupport_files typesupport_files )

LIB_INST_TAGS = header_files template_files inline_files$(if $(CUSTOM_INST_TAGS), $(CUSTOM_INST_TAGS))
LIB_INST_LOCATIONS = $(foreach tag,$(LIB_INST_TAGS),-b $(tag)=include$(INST_DIR))

INST_TAGS = lib_output$(if $(LIB_INST_TAGS), $(LIB_INST_TAGS))
INST_LOCATIONS = $(LIB_INST_LOCATIONS) -o lib_output=$(INSTALL_LIB)

DATA_INST_TAGS = installdata_files
INST_LOCATIONS += $(if $(DATA_INST_TAGS),-x installdata_files -b installdata_files=share$(INST_DIR))
INST_TAGS := $(INST_TAGS)$(if $(DATA_INST_TAGS), $(DATA_INST_TAGS))

ifeq ($(INSTALLER),/prj_install.pl)
INSTALLER = $(ACE_ROOT)/MPC/prj_install.pl
endif

ifeq ($(LIBCHECK),1)
install:
ifeq ($(INST_TAGS),)
	@echo Nothing to install.
else
ifeq ($(INSTALL_PREFIX),)
	@echo The variable INSTALL_PREFIX must be set to install.
	@echo If binaries are already built and you want to use RPATH,
	@echo they must be rebuilt after changing INSTALL_PREFIX.
	@false
else
	perl -ne'if (/^#END MPC-Generated Install Info/) {exit 0}' \
	  -e'elsif (/^#BEGIN MPC-Generated Install Info/) {$$ok=1}' \
	  -e'elsif ($$ok && s/^#//) {print}' $(MAKEFILE) | \
	$(INSTALLER) -i -s $(subst $(SPACE),$(COMMA),$(INST_TAGS)) \
	  $(INST_LOCATIONS) $(if $(ARCH),-d $(ARCH)) $(PRJINST_OPTIONS) \
	  $(DESTDIR)$(INSTALL_PREFIX)
	echo export DDS_ROOT=$(DESTDIR)$(INSTALL_PREFIX)/share/dds> $(DESTDIR)$(INSTALL_PREFIX)/share/dds/dds-devel.sh
	@$(MKDIR) $(DESTDIR)$(INSTALL_PREFIX)/share/dds/dds
	ln -sf $(DESTDIR)$(INSTALL_PREFIX)/include/dds/Version.h $(DESTDIR)$(INSTALL_PREFIX)/share/dds/dds

endif
endif
endif

#BEGIN MPC-Generated Install Info
#header_files:
#DdsDcpsConditionSeqS.h
#DdsDcpsCoreS.h
#DdsDcpsDataReaderSeqS.h
#DdsDcpsGuidTypeSupportS.h
#DdsDcpsCoreTypeSupportS.h
#DdsDcpsInfrastructureTypeSupportS.h
#Version.h
#Versioned_Namespace.h
#DCPS/AssociationData.h
#DCPS/AstNodeWrapper.h
#DCPS/BitPubListenerImpl.h
#DCPS/BuiltInTopicUtils.h
#DCPS/Cached_Allocator_With_Overflow_T.h
#DCPS/CoherentChangeControl.h
#DCPS/Comparator_T.h
#DCPS/ConditionImpl.h
#DCPS/ConfigUtils.h
#DCPS/ContentFilteredTopicImpl.h
#DCPS/DataBlockLockPool.h
#DCPS/DataCollector_T.h
#DCPS/DataDurabilityCache.h
#DCPS/DataReaderCallbacks.h
#DCPS/DataReaderImpl.h
#DCPS/DataReaderImpl_T.h
#DCPS/DataSampleElement.h
#DCPS/DataSampleHeader.h
#DCPS/DataWriterCallbacks.h
#DCPS/DataWriterImpl.h
#DCPS/DataWriterImpl_T.h
#DCPS/dcps_export.h
#DCPS/DCPS_Utils.h
#DCPS/debug.h
#DCPS/Definitions.h
#DCPS/Discovery.h
#DCPS/DiscoveryBase.h
#DCPS/DiscoveryListener.h
#DCPS/DisjointSequence.h
#DCPS/DomainParticipantFactoryImpl.h
#DCPS/DomainParticipantImpl.h
#DCPS/DurabilityArray.h
#DCPS/DurabilityQueue.h
#DCPS/Dynamic_Cached_Allocator_With_Overflow_T.h
#DCPS/EntityImpl.h
#DCPS/FeatureDisabledQosCheck.h
#DCPS/FileSystemStorage.h
#DCPS/FilterEvaluator.h
#DCPS/FilterExpressionGrammar.h
#DCPS/GroupRakeData.h
#DCPS/GuardCondition.h
#DCPS/GuidBuilder.h
#DCPS/GuidConverter.h
#DCPS/GuidUtils.h
#DCPS/InstanceDataSampleList.h
#DCPS/InstanceHandle.h
#DCPS/InstanceState.h
#DCPS/Loaner.h
#DCPS/LocalObject.h
#DCPS/Marked_Default_Qos.h
#DCPS/MemoryPool.h
#DCPS/MessageTracker.h
#DCPS/MonitorFactory.h
#DCPS/MultiTopicDataReader_T.h
#DCPS/MultiTopicDataReaderBase.h
#DCPS/MultiTopicImpl.h
#DCPS/OfferedDeadlineWatchdog.h
#DCPS/OwnershipManager.h
#DCPS/PoolAllocationBase.h
#DCPS/PoolAllocator.h
#DCPS/PublicationInstance.h
#DCPS/PublisherImpl.h
#DCPS/Qos_Helper.h
#DCPS/QueryConditionImpl.h
#DCPS/RakeData.h
#DCPS/RakeResults_T.h
#DCPS/RawDataSample.h
#DCPS/RcEventHandler.h
#DCPS/RcHandle_T.h
#DCPS/RcObject_T.h
#DCPS/ReactorInterceptor.h
#DCPS/ReadConditionImpl.h
#DCPS/ReceivedDataElementList.h
#DCPS/ReceivedDataStrategy.h
#DCPS/Recorder.h
#DCPS/RecorderImpl.h
#DCPS/Registered_Data_Types.h
#DCPS/RemoveAssociationSweeper.h
#DCPS/Replayer.h
#DCPS/ReplayerImpl.h
#DCPS/RepoIdBuilder.h
#DCPS/RepoIdConverter.h
#DCPS/RepoIdGenerator.h
#DCPS/RequestedDeadlineWatchdog.h
#DCPS/SafetyProfilePool.h
#DCPS/SafetyProfileSequence.h
#DCPS/SafetyProfileSequenceVar.h
#DCPS/SafetyProfileStreams.h
#DCPS/scoped_ptr.h
#DCPS/SendStateDataSampleList.h
#DCPS/Serializer.h
#DCPS/Service_Participant.h
#DCPS/StaticDiscovery.h
#DCPS/StaticIncludes.h
#DCPS/Stats_T.h
#DCPS/StatusConditionImpl.h
#DCPS/SubscriberImpl.h
#DCPS/SubscriptionInstance.h
#DCPS/TopicDescriptionImpl.h
#DCPS/TopicExpressionGrammar.h
#DCPS/TopicImpl.h
#DCPS/Transient_Kludge.h
#DCPS/TypeSupportImpl.h
#DCPS/Util.h
#DCPS/V8TypeConverter.h
#DCPS/WaitSet.h
#DCPS/Watchdog.h
#DCPS/WriteDataContainer.h
#DCPS/WriterDataSampleList.h
#DCPS/WriterInfo.h
#DCPS/ZeroCopyAllocator_T.h
#DCPS/ZeroCopyInfoSeq_T.h
#DCPS/ZeroCopySeq_T.h
#DCPS/ZeroCopySeqBase.h
#DCPS/transport/framework/BasicQueue_T.h
#DCPS/transport/framework/BasicQueueLink_T.h
#DCPS/transport/framework/BasicQueueLinkAllocator_T.h
#DCPS/transport/framework/BasicQueueLinkChunk_T.h
#DCPS/transport/framework/BasicQueueLinkPool_T.h
#DCPS/transport/framework/BasicQueueVisitor_T.h
#DCPS/transport/framework/BuildChainVisitor.h
#DCPS/transport/framework/CopyChainVisitor.h
#DCPS/transport/framework/DataLink.h
#DCPS/transport/framework/DataLink_rch.h
#DCPS/transport/framework/DataLinkCleanupTask.h
#DCPS/transport/framework/DataLinkSet.h
#DCPS/transport/framework/DataLinkSet_rch.h
#DCPS/transport/framework/DataLinkWatchdog_T.h
#DCPS/transport/framework/DirectPriorityMapper.h
#DCPS/transport/framework/EntryExit.h
#DCPS/transport/framework/NetworkAddress.h
#DCPS/transport/framework/NullSynch.h
#DCPS/transport/framework/NullSynchStrategy.h
#DCPS/transport/framework/PacketRemoveVisitor.h
#DCPS/transport/framework/PerConnectionSynch.h
#DCPS/transport/framework/PerConnectionSynchStrategy.h
#DCPS/transport/framework/PoolSynch.h
#DCPS/transport/framework/PoolSynchStrategy.h
#DCPS/transport/framework/PriorityKey.h
#DCPS/transport/framework/PriorityMapper.h
#DCPS/transport/framework/QueueRemoveVisitor.h
#DCPS/transport/framework/QueueTaskBase_T.h
#DCPS/transport/framework/ReactorSynch.h
#DCPS/transport/framework/ReactorSynchStrategy.h
#DCPS/transport/framework/ReceivedDataSample.h
#DCPS/transport/framework/ReceiveListenerSet.h
#DCPS/transport/framework/ReceiveListenerSet_rch.h
#DCPS/transport/framework/ReceiveListenerSetMap.h
#DCPS/transport/framework/RemoveAllVisitor.h
#DCPS/transport/framework/ScheduleOutputHandler.h
#DCPS/transport/framework/SendResponseListener.h
#DCPS/transport/framework/ThreadPerConnectionSendTask.h
#DCPS/transport/framework/ThreadPerConRemoveVisitor.h
#DCPS/transport/framework/ThreadSynch.h
#DCPS/transport/framework/ThreadSynchResource.h
#DCPS/transport/framework/ThreadSynchStrategy.h
#DCPS/transport/framework/ThreadSynchStrategy_rch.h
#DCPS/transport/framework/ThreadSynchWorker.h
#DCPS/transport/framework/TransportClient.h
#DCPS/transport/framework/TransportConfig.h
#DCPS/transport/framework/TransportConfig_rch.h
#DCPS/transport/framework/TransportControlElement.h
#DCPS/transport/framework/TransportCustomizedElement.h
#DCPS/transport/framework/TransportDebug.h
#DCPS/transport/framework/TransportDefs.h
#DCPS/transport/framework/TransportExceptions.h
#DCPS/transport/framework/TransportHeader.h
#DCPS/transport/framework/TransportImpl.h
#DCPS/transport/framework/TransportImpl_rch.h
#DCPS/transport/framework/TransportInst.h
#DCPS/transport/framework/TransportInst_rch.h
#DCPS/transport/framework/TransportQueueElement.h
#DCPS/transport/framework/TransportReactorTask.h
#DCPS/transport/framework/TransportReactorTask_rch.h
#DCPS/transport/framework/TransportReassembly.h
#DCPS/transport/framework/TransportReceiveListener.h
#DCPS/transport/framework/TransportReceiveStrategy_rch.h
#DCPS/transport/framework/TransportReceiveStrategy_T.h
#DCPS/transport/framework/TransportRegistry.h
#DCPS/transport/framework/TransportReplacedElement.h
#DCPS/transport/framework/TransportRetainedElement.h
#DCPS/transport/framework/TransportSendBuffer.h
#DCPS/transport/framework/TransportSendControlElement.h
#DCPS/transport/framework/TransportSendElement.h
#DCPS/transport/framework/TransportSendListener.h
#DCPS/transport/framework/TransportSendStrategy.h
#DCPS/transport/framework/TransportSendStrategy_rch.h
#DCPS/transport/framework/TransportStrategy.h
#DCPS/transport/framework/TransportStrategy_rch.h
#DCPS/transport/framework/TransportType.h
#DCPS/transport/framework/TransportType_rch.h
#DCPS/yard/yard_base_grammar.hpp
#DCPS/yard/yard_char_set.hpp
#DCPS/yard/yard_parser.hpp
#DCPS/yard/yard_text_grammar.hpp
#DCPS/yard/yard_tree.hpp
#DdsDcpsS.h
#DdsDcpsDomainS.h
#DdsDcpsGuidS.h
#DdsDcpsInfoUtilsS.h
#DdsDcpsInfrastructureS.h
#DdsDcpsPublicationS.h
#DdsDcpsSubscriptionS.h
#DdsDcpsSubscriptionExtS.h
#DdsDcpsTopicS.h
#DdsDcpsTypeSupportExtS.h
#CorbaSeq/WCharSeqTypeSupportImpl.h
#DdsDcpsGuidC.h
#DdsDcpsTopicC.h
#CorbaSeq/UShortSeqTypeSupportImpl.h
#CorbaSeq/ULongSeqTypeSupportImpl.h
#DdsDcpsInfoUtilsC.h
#CorbaSeq/ShortSeqTypeSupportImpl.h
#DdsDcpsInfrastructureTypeSupportImpl.h
#CorbaSeq/ULongLongSeqTypeSupportImpl.h
#CorbaSeq/FloatSeqTypeSupportImpl.h
#CorbaSeq/LongSeqTypeSupportImpl.h
#DdsDcpsCoreC.h
#CorbaSeq/StringSeqTypeSupportImpl.h
#CorbaSeq/OctetSeqTypeSupportImpl.h
#DdsDcpsCoreTypeSupportC.h
#DdsDcpsSubscriptionExtC.h
#DdsDcpsInfrastructureC.h
#DdsDcpsSubscriptionC.h
#DdsDcpsDomainC.h
#DdsDcpsConditionSeqC.h
#CorbaSeq/CharSeqTypeSupportImpl.h
#CorbaSeq/LongDoubleSeqTypeSupportImpl.h
#CorbaSeq/LongLongSeqTypeSupportImpl.h
#DdsDcpsGuidTypeSupportImpl.h
#CorbaSeq/BooleanSeqTypeSupportImpl.h
#DdsDcpsCoreTypeSupportImpl.h
#DdsDcpsInfoUtilsTypeSupportImpl.h
#DdsDcpsTypeSupportExtC.h
#CorbaSeq/WStringSeqTypeSupportImpl.h
#DdsDcpsC.h
#DdsDcpsPublicationC.h
#DdsDcpsInfrastructureTypeSupportC.h
#DdsDcpsGuidTypeSupportC.h
#DdsDcpsDataReaderSeqC.h
#CorbaSeq/DoubleSeqTypeSupportImpl.h
#
#source_files:
#DdsDcpsGuidTypeSupportImpl.cpp
#DdsDcpsCoreTypeSupportImpl.cpp
#DdsDcpsInfrastructureTypeSupportImpl.cpp
#DdsDcpsInfoUtilsTypeSupportImpl.cpp
#CorbaSeq/BooleanSeqTypeSupportImpl.cpp
#CorbaSeq/CharSeqTypeSupportImpl.cpp
#CorbaSeq/DoubleSeqTypeSupportImpl.cpp
#CorbaSeq/FloatSeqTypeSupportImpl.cpp
#CorbaSeq/LongDoubleSeqTypeSupportImpl.cpp
#CorbaSeq/LongLongSeqTypeSupportImpl.cpp
#CorbaSeq/LongSeqTypeSupportImpl.cpp
#CorbaSeq/OctetSeqTypeSupportImpl.cpp
#CorbaSeq/ShortSeqTypeSupportImpl.cpp
#CorbaSeq/StringSeqTypeSupportImpl.cpp
#CorbaSeq/ULongLongSeqTypeSupportImpl.cpp
#CorbaSeq/ULongSeqTypeSupportImpl.cpp
#CorbaSeq/UShortSeqTypeSupportImpl.cpp
#CorbaSeq/WCharSeqTypeSupportImpl.cpp
#CorbaSeq/WStringSeqTypeSupportImpl.cpp
#DdsDcpsGuidC.cpp
#DdsDcpsCoreC.cpp
#DdsDcpsInfoUtilsC.cpp
#DdsDcpsConditionSeqC.cpp
#DdsDcpsDataReaderSeqC.cpp
#DdsDcpsGuidTypeSupportC.cpp
#DdsDcpsCoreTypeSupportC.cpp
#DdsDcpsInfrastructureTypeSupportC.cpp
#DdsDcpsC.cpp
#DdsDcpsDomainC.cpp
#DdsDcpsInfrastructureC.cpp
#DdsDcpsPublicationC.cpp
#DdsDcpsSubscriptionC.cpp
#DdsDcpsSubscriptionExtC.cpp
#DdsDcpsTopicC.cpp
#DdsDcpsTypeSupportExtC.cpp
#DCPS/BitPubListenerImpl.cpp
#DCPS/BuiltInTopicUtils.cpp
#DCPS/CoherentChangeControl.cpp
#DCPS/ConditionImpl.cpp
#DCPS/ConfigUtils.cpp
#DCPS/ContentFilteredTopicImpl.cpp
#DCPS/DataDurabilityCache.cpp
#DCPS/DataReaderImpl.cpp
#DCPS/DataSampleElement.cpp
#DCPS/DataSampleHeader.cpp
#DCPS/DataWriterImpl.cpp
#DCPS/DCPS_Utils.cpp
#DCPS/debug.cpp
#DCPS/Discovery.cpp
#DCPS/DisjointSequence.cpp
#DCPS/DomainParticipantFactoryImpl.cpp
#DCPS/DomainParticipantImpl.cpp
#DCPS/EntityImpl.cpp
#DCPS/FileSystemStorage.cpp
#DCPS/FilterEvaluator.cpp
#DCPS/GroupRakeData.cpp
#DCPS/GuardCondition.cpp
#DCPS/GuidBuilder.cpp
#DCPS/GuidConverter.cpp
#DCPS/GuidUtils.cpp
#DCPS/InstanceDataSampleList.cpp
#DCPS/InstanceHandle.cpp
#DCPS/InstanceState.cpp
#DCPS/Marked_Default_Qos.cpp
#DCPS/MemoryPool.cpp
#DCPS/MessageTracker.cpp
#DCPS/MonitorFactory.cpp
#DCPS/MultiTopicDataReaderBase.cpp
#DCPS/MultiTopicImpl.cpp
#DCPS/OfferedDeadlineWatchdog.cpp
#DCPS/OwnershipManager.cpp
#DCPS/PublisherImpl.cpp
#DCPS/Qos_Helper.cpp
#DCPS/QueryConditionImpl.cpp
#DCPS/RawDataSample.cpp
#DCPS/ReactorInterceptor.cpp
#DCPS/ReadConditionImpl.cpp
#DCPS/ReceivedDataElementList.cpp
#DCPS/ReceivedDataStrategy.cpp
#DCPS/Recorder.cpp
#DCPS/RecorderImpl.cpp
#DCPS/Registered_Data_Types.cpp
#DCPS/Replayer.cpp
#DCPS/ReplayerImpl.cpp
#DCPS/RepoIdBuilder.cpp
#DCPS/RepoIdConverter.cpp
#DCPS/RepoIdGenerator.cpp
#DCPS/RequestedDeadlineWatchdog.cpp
#DCPS/SafetyProfilePool.cpp
#DCPS/SafetyProfileStreams.cpp
#DCPS/SendStateDataSampleList.cpp
#DCPS/Serializer.cpp
#DCPS/Service_Participant.cpp
#DCPS/StaticDiscovery.cpp
#DCPS/StatusConditionImpl.cpp
#DCPS/SubscriberImpl.cpp
#DCPS/TopicDescriptionImpl.cpp
#DCPS/TopicImpl.cpp
#DCPS/Transient_Kludge.cpp
#DCPS/TypeSupportImpl.cpp
#DCPS/WaitSet.cpp
#DCPS/Watchdog.cpp
#DCPS/WriteDataContainer.cpp
#DCPS/WriterDataSampleList.cpp
#DCPS/WriterInfo.cpp
#DCPS/transport/framework/BuildChainVisitor.cpp
#DCPS/transport/framework/CopyChainVisitor.cpp
#DCPS/transport/framework/DataLink.cpp
#DCPS/transport/framework/DataLinkCleanupTask.cpp
#DCPS/transport/framework/DataLinkSet.cpp
#DCPS/transport/framework/DirectPriorityMapper.cpp
#DCPS/transport/framework/NetworkAddress.cpp
#DCPS/transport/framework/NullSynch.cpp
#DCPS/transport/framework/NullSynchStrategy.cpp
#DCPS/transport/framework/PacketRemoveVisitor.cpp
#DCPS/transport/framework/PerConnectionSynch.cpp
#DCPS/transport/framework/PerConnectionSynchStrategy.cpp
#DCPS/transport/framework/PoolSynch.cpp
#DCPS/transport/framework/PoolSynchStrategy.cpp
#DCPS/transport/framework/PriorityKey.cpp
#DCPS/transport/framework/PriorityMapper.cpp
#DCPS/transport/framework/QueueRemoveVisitor.cpp
#DCPS/transport/framework/ReactorSynch.cpp
#DCPS/transport/framework/ReactorSynchStrategy.cpp
#DCPS/transport/framework/ReceivedDataSample.cpp
#DCPS/transport/framework/ReceiveListenerSet.cpp
#DCPS/transport/framework/ReceiveListenerSetMap.cpp
#DCPS/transport/framework/RemoveAllVisitor.cpp
#DCPS/transport/framework/ScheduleOutputHandler.cpp
#DCPS/transport/framework/SendResponseListener.cpp
#DCPS/transport/framework/ThreadPerConnectionSendTask.cpp
#DCPS/transport/framework/ThreadPerConRemoveVisitor.cpp
#DCPS/transport/framework/ThreadSynch.cpp
#DCPS/transport/framework/ThreadSynchResource.cpp
#DCPS/transport/framework/ThreadSynchStrategy.cpp
#DCPS/transport/framework/ThreadSynchWorker.cpp
#DCPS/transport/framework/TransportClient.cpp
#DCPS/transport/framework/TransportConfig.cpp
#DCPS/transport/framework/TransportControlElement.cpp
#DCPS/transport/framework/TransportCustomizedElement.cpp
#DCPS/transport/framework/TransportDebug.cpp
#DCPS/transport/framework/TransportHeader.cpp
#DCPS/transport/framework/TransportImpl.cpp
#DCPS/transport/framework/TransportInst.cpp
#DCPS/transport/framework/TransportQueueElement.cpp
#DCPS/transport/framework/TransportReactorTask.cpp
#DCPS/transport/framework/TransportReassembly.cpp
#DCPS/transport/framework/TransportReceiveListener.cpp
#DCPS/transport/framework/TransportRegistry.cpp
#DCPS/transport/framework/TransportReplacedElement.cpp
#DCPS/transport/framework/TransportRetainedElement.cpp
#DCPS/transport/framework/TransportSendBuffer.cpp
#DCPS/transport/framework/TransportSendControlElement.cpp
#DCPS/transport/framework/TransportSendElement.cpp
#DCPS/transport/framework/TransportSendListener.cpp
#DCPS/transport/framework/TransportSendStrategy.cpp
#DCPS/transport/framework/TransportStrategy.cpp
#DCPS/transport/framework/TransportType.cpp
#
#idl_files:
#DdsDcpsGuid.idl
#DdsDcpsCore.idl
#DdsDcpsInfoUtils.idl
#DdsDcpsConditionSeq.idl
#DdsDcpsDataReaderSeq.idl
#DdsDcpsGuidTypeSupport.idl
#DdsDcpsCoreTypeSupport.idl
#DdsDcpsInfrastructureTypeSupport.idl
#DdsDcps.idl
#DdsDcpsDomain.idl
#DdsDcpsInfrastructure.idl
#DdsDcpsPublication.idl
#DdsDcpsSubscription.idl
#DdsDcpsSubscriptionExt.idl
#DdsDcpsTopic.idl
#DdsDcpsTypeSupportExt.idl
#
#typesupport_files:
#DdsDcpsGuid.idl
#DdsDcpsCore.idl
#DdsDcpsInfrastructure.idl
#DdsDcpsInfoUtils.idl
#CorbaSeq/BooleanSeq.idl CorbaSeq
#CorbaSeq/CharSeq.idl CorbaSeq
#CorbaSeq/DoubleSeq.idl CorbaSeq
#CorbaSeq/FloatSeq.idl CorbaSeq
#CorbaSeq/LongDoubleSeq.idl CorbaSeq
#CorbaSeq/LongLongSeq.idl CorbaSeq
#CorbaSeq/LongSeq.idl CorbaSeq
#CorbaSeq/OctetSeq.idl CorbaSeq
#CorbaSeq/ShortSeq.idl CorbaSeq
#CorbaSeq/StringSeq.idl CorbaSeq
#CorbaSeq/ULongLongSeq.idl CorbaSeq
#CorbaSeq/ULongSeq.idl CorbaSeq
#CorbaSeq/UShortSeq.idl CorbaSeq
#CorbaSeq/WCharSeq.idl CorbaSeq
#CorbaSeq/WStringSeq.idl CorbaSeq
#
#template_files:
#DCPS/DataCollector_T.cpp
#DCPS/MultiTopicDataReader_T.cpp
#DCPS/RakeResults_T.cpp
#DCPS/ZeroCopyAllocator_T.cpp
#DCPS/ZeroCopySeq_T.cpp
#DCPS/transport/framework/TransportReceiveStrategy_T.cpp
#
#installdata_files:
#../MPC .
#../AUTHORS .
#../README.md .
#../VERSION .
#../LICENSE .
#../NEWS.md .
#../rules.dds.GNU .
#../bin/PerlDDS bin
#
#resource_files:
#OpenDDS_DCPS.rc
#
#build_files:
#DdsDcps.mpc
#dcps_optional_safety.mpb
#
#inline_files:
#DCPS/CoherentChangeControl.inl
#DCPS/InstanceDataSampleList.inl
#DCPS/transport/framework/ReceivedDataSample.inl
#DCPS/ZeroCopyAllocator_T.inl
#DCPS/Qos_Helper.inl
#DCPS/transport/framework/TransportImpl.inl
#DdsDcpsGuidC.inl
#DCPS/Service_Participant.inl
#DCPS/transport/framework/RemoveAllVisitor.inl
#DCPS/transport/framework/QueueRemoveVisitor.inl
#DdsDcpsTopicC.inl
#DCPS/transport/framework/DataLink.inl
#DCPS/transport/framework/TransportRegistry.inl
#DdsDcpsInfoUtilsC.inl
#DCPS/transport/framework/TransportReceiveStrategy_T.inl
#DCPS/transport/framework/TransportHeader.inl
#DCPS/transport/framework/PerConnectionSynch.inl
#DCPS/transport/framework/ReactorSynchStrategy.inl
#DCPS/ReceivedDataElementList.inl
#DCPS/DataSampleHeader.inl
#DdsDcpsCoreC.inl
#DCPS/transport/framework/ReceiveListenerSet.inl
#DCPS/transport/framework/PoolSynch.inl
#DCPS/transport/framework/ReactorSynch.inl
#DCPS/transport/framework/ThreadSynchResource.inl
#DCPS/DataReaderImpl.inl
#DCPS/InstanceState.inl
#DCPS/transport/framework/PerConnectionSynchStrategy.inl
#DCPS/transport/framework/PoolSynchStrategy.inl
#DCPS/transport/framework/BuildChainVisitor.inl
#DCPS/transport/framework/ReceiveListenerSetMap.inl
#DCPS/transport/framework/ThreadSynch.inl
#DCPS/Serializer.inl
#DCPS/transport/framework/TransportSendControlElement.inl
#DCPS/transport/framework/ThreadPerConRemoveVisitor.inl
#DCPS/transport/framework/NullSynch.inl
#DCPS/transport/framework/ThreadSynchStrategy.inl
#DCPS/transport/framework/ThreadSynchWorker.inl
#DCPS/transport/framework/ScheduleOutputHandler.inl
#DCPS/DisjointSequence.inl
#DCPS/transport/framework/PacketRemoveVisitor.inl
#DCPS/GuidBuilder.inl
#DCPS/transport/framework/DataLinkSet.inl
#DdsDcpsCoreTypeSupportC.inl
#DdsDcpsSubscriptionExtC.inl
#DdsDcpsInfrastructureC.inl
#DdsDcpsSubscriptionC.inl
#DdsDcpsDomainC.inl
#DCPS/transport/framework/PriorityKey.inl
#DCPS/DataCollector_T.inl
#DCPS/transport/framework/PriorityMapper.inl
#DdsDcpsConditionSeqC.inl
#DCPS/DataSampleElement.inl
#DCPS/transport/framework/TransportControlElement.inl
#DdsDcpsTypeSupportExtC.inl
#DCPS/transport/framework/TransportReactorTask.inl
#DCPS/transport/framework/TransportReplacedElement.inl
#DCPS/transport/framework/TransportSendElement.inl
#DCPS/transport/framework/TransportSendBuffer.inl
#DdsDcpsC.inl
#DCPS/ZeroCopySeq_T.inl
#DCPS/WriterDataSampleList.inl
#DCPS/transport/framework/CopyChainVisitor.inl
#DdsDcpsPublicationC.inl
#DdsDcpsInfrastructureTypeSupportC.inl
#DCPS/SendStateDataSampleList.inl
#DdsDcpsGuidTypeSupportC.inl
#DCPS/transport/framework/TransportQueueElement.inl
#DCPS/transport/framework/TransportInst.inl
#DCPS/transport/framework/NetworkAddress.inl
#DCPS/Transient_Kludge.inl
#DdsDcpsDataReaderSeqC.inl
#DCPS/transport/framework/TransportSendStrategy.inl
#DCPS/transport/framework/TransportRetainedElement.inl
#DCPS/transport/framework/TransportCustomizedElement.inl
#DCPS/transport/framework/DirectPriorityMapper.inl
#DCPS/RepoIdBuilder.inl
#
#lib_output:
#../lib OpenDDS_Dcps

#END MPC-Generated Install Info

idl_stubs: $(foreach f,$(wildcard CorbaSeq/*.idl),$(f:.idl=TypeSupportImpl.h))

