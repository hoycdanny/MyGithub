/* Generated by /Users/yc/MyGithub/imac-project/OpenDDS/OpenDDS-3.10/bin/opendds_idl version 3.10 (ACE version 6.2a_p11) running on input file monitor.idl */
#include "monitorTypeSupportImpl.h"

#include <cstring>
#include <stdexcept>
#include "dds/DCPS/BuiltInTopicUtils.h"
#include "dds/DCPS/ContentFilteredTopicImpl.h"
#include "dds/DCPS/DataReaderImpl_T.h"
#include "dds/DCPS/DataWriterImpl_T.h"
#include "dds/DCPS/FilterEvaluator.h"
#include "dds/DCPS/MultiTopicDataReader_T.h"
#include "dds/DCPS/PoolAllocator.h"
#include "dds/DCPS/PublicationInstance.h"
#include "dds/DCPS/PublisherImpl.h"
#include "dds/DCPS/Qos_Helper.h"
#include "dds/DCPS/RakeData.h"
#include "dds/DCPS/RakeResults_T.h"
#include "dds/DCPS/ReceivedDataElementList.h"
#include "dds/DCPS/Registered_Data_Types.h"
#include "dds/DCPS/Service_Participant.h"
#include "dds/DCPS/SubscriberImpl.h"
#include "dds/DCPS/Util.h"
#include "dds/DCPS/debug.h"
#include "dds/DdsDcpsDomainC.h"
#include "dds/CorbaSeq/ULongSeqTypeSupportImpl.h"
#include "dds/DdsDcpsCoreTypeSupportImpl.h"
#include "dds/DdsDcpsGuidTypeSupportImpl.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: LongSeq */


/* End TYPEDEF: LongSeq */

/* End MODULE: CORBA */


/* Begin MODULE: DDS */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */


/* Begin TYPEDEF: InstanceHandle_t */


/* End TYPEDEF: InstanceHandle_t */


/* Begin TYPEDEF: BuiltinTopicKeyValue */


/* End TYPEDEF: BuiltinTopicKeyValue */


/* Begin TYPEDEF: InstanceHandleSeq */


/* End TYPEDEF: InstanceHandleSeq */


/* Begin TYPEDEF: QosPolicyId_t */


/* End TYPEDEF: QosPolicyId_t */


/* Begin STRUCT: QosPolicyCount */


/* End STRUCT: QosPolicyCount */


/* Begin TYPEDEF: QosPolicyCountSeq */


/* End TYPEDEF: QosPolicyCountSeq */


/* Begin TYPEDEF: OctetSeq */


/* End TYPEDEF: OctetSeq */


/* Begin STRUCT: Duration_t */


/* End STRUCT: Duration_t */


/* Begin STRUCT: UserDataQosPolicy */


/* End STRUCT: UserDataQosPolicy */


/* Begin STRUCT: GroupDataQosPolicy */


/* End STRUCT: GroupDataQosPolicy */


/* Begin STRUCT: TopicDataQosPolicy */


/* End STRUCT: TopicDataQosPolicy */


/* Begin STRUCT: PartitionQosPolicy */


/* End STRUCT: PartitionQosPolicy */


/* Begin ENUM: HistoryQosPolicyKind */


/* End ENUM: HistoryQosPolicyKind */


/* Begin ENUM: DurabilityQosPolicyKind */


/* End ENUM: DurabilityQosPolicyKind */


/* Begin STRUCT: DurabilityQosPolicy */


/* End STRUCT: DurabilityQosPolicy */


/* Begin STRUCT: DurabilityServiceQosPolicy */


/* End STRUCT: DurabilityServiceQosPolicy */


/* Begin STRUCT: DeadlineQosPolicy */


/* End STRUCT: DeadlineQosPolicy */


/* Begin STRUCT: LatencyBudgetQosPolicy */


/* End STRUCT: LatencyBudgetQosPolicy */


/* Begin ENUM: LivelinessQosPolicyKind */


/* End ENUM: LivelinessQosPolicyKind */


/* Begin STRUCT: LivelinessQosPolicy */


/* End STRUCT: LivelinessQosPolicy */


/* Begin ENUM: ReliabilityQosPolicyKind */


/* End ENUM: ReliabilityQosPolicyKind */


/* Begin STRUCT: ReliabilityQosPolicy */


/* End STRUCT: ReliabilityQosPolicy */


/* Begin ENUM: DestinationOrderQosPolicyKind */


/* End ENUM: DestinationOrderQosPolicyKind */


/* Begin STRUCT: DestinationOrderQosPolicy */


/* End STRUCT: DestinationOrderQosPolicy */


/* Begin STRUCT: HistoryQosPolicy */


/* End STRUCT: HistoryQosPolicy */


/* Begin STRUCT: ResourceLimitsQosPolicy */


/* End STRUCT: ResourceLimitsQosPolicy */


/* Begin STRUCT: TransportPriorityQosPolicy */


/* End STRUCT: TransportPriorityQosPolicy */


/* Begin STRUCT: LifespanQosPolicy */


/* End STRUCT: LifespanQosPolicy */


/* Begin ENUM: OwnershipQosPolicyKind */


/* End ENUM: OwnershipQosPolicyKind */


/* Begin STRUCT: OwnershipQosPolicy */


/* End STRUCT: OwnershipQosPolicy */


/* Begin STRUCT: OwnershipStrengthQosPolicy */


/* End STRUCT: OwnershipStrengthQosPolicy */


/* Begin ENUM: PresentationQosPolicyAccessScopeKind */


/* End ENUM: PresentationQosPolicyAccessScopeKind */


/* Begin STRUCT: PresentationQosPolicy */


/* End STRUCT: PresentationQosPolicy */


/* Begin STRUCT: TimeBasedFilterQosPolicy */


/* End STRUCT: TimeBasedFilterQosPolicy */


/* Begin STRUCT: TopicQos */


/* End STRUCT: TopicQos */


/* Begin STRUCT: WriterDataLifecycleQosPolicy */


/* End STRUCT: WriterDataLifecycleQosPolicy */


/* Begin STRUCT: DataWriterQos */


/* End STRUCT: DataWriterQos */


/* Begin STRUCT: EntityFactoryQosPolicy */


/* End STRUCT: EntityFactoryQosPolicy */


/* Begin STRUCT: PublisherQos */


/* End STRUCT: PublisherQos */


/* Begin STRUCT: ReaderDataLifecycleQosPolicy */


/* End STRUCT: ReaderDataLifecycleQosPolicy */


/* Begin STRUCT: DataReaderQos */


/* End STRUCT: DataReaderQos */


/* Begin STRUCT: SubscriberQos */


/* End STRUCT: SubscriberQos */


/* Begin STRUCT: DomainParticipantFactoryQos */


/* End STRUCT: DomainParticipantFactoryQos */


/* Begin STRUCT: DomainParticipantQos */


/* End STRUCT: DomainParticipantQos */


/* Begin STRUCT: BuiltinTopicKey_t */


/* End STRUCT: BuiltinTopicKey_t */


/* Begin STRUCT: ParticipantBuiltinTopicData */


/* End STRUCT: ParticipantBuiltinTopicData */


/* Begin STRUCT: PublicationBuiltinTopicData */


/* End STRUCT: PublicationBuiltinTopicData */


/* Begin STRUCT: SubscriptionBuiltinTopicData */


/* End STRUCT: SubscriptionBuiltinTopicData */


/* Begin STRUCT: TopicBuiltinTopicData */


/* End STRUCT: TopicBuiltinTopicData */


/* Begin TYPEDEF: SampleStateKind */


/* End TYPEDEF: SampleStateKind */


/* Begin CONST: READ_SAMPLE_STATE */


/* End CONST: READ_SAMPLE_STATE */


/* Begin CONST: NOT_READ_SAMPLE_STATE */


/* End CONST: NOT_READ_SAMPLE_STATE */


/* Begin TYPEDEF: SampleStateMask */


/* End TYPEDEF: SampleStateMask */


/* Begin CONST: ANY_SAMPLE_STATE */


/* End CONST: ANY_SAMPLE_STATE */


/* Begin TYPEDEF: ViewStateKind */


/* End TYPEDEF: ViewStateKind */


/* Begin CONST: NEW_VIEW_STATE */


/* End CONST: NEW_VIEW_STATE */


/* Begin CONST: NOT_NEW_VIEW_STATE */


/* End CONST: NOT_NEW_VIEW_STATE */


/* Begin TYPEDEF: ViewStateMask */


/* End TYPEDEF: ViewStateMask */


/* Begin CONST: ANY_VIEW_STATE */


/* End CONST: ANY_VIEW_STATE */


/* Begin TYPEDEF: InstanceStateKind */


/* End TYPEDEF: InstanceStateKind */


/* Begin CONST: ALIVE_INSTANCE_STATE */


/* End CONST: ALIVE_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* Begin TYPEDEF: InstanceStateMask */


/* End TYPEDEF: InstanceStateMask */


/* Begin CONST: ANY_INSTANCE_STATE */


/* End CONST: ANY_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_INSTANCE_STATE */


/* Begin STRUCT: Time_t */


/* End STRUCT: Time_t */


/* Begin STRUCT: SampleInfo */


/* End STRUCT: SampleInfo */


/* Begin TYPEDEF: SampleInfoSeq */


/* End TYPEDEF: SampleInfoSeq */

/* End MODULE: DDS */


/* Begin MODULE: DDS */



/* Begin INTERFACE-FWD: Condition */


/* End INTERFACE-FWD: Condition */


/* Begin TYPEDEF: ConditionSeq */


/* End TYPEDEF: ConditionSeq */

/* End MODULE: DDS */


/* Begin MODULE: DDS */



/* Begin TYPEDEF: DomainId_t */


/* End TYPEDEF: DomainId_t */


/* Begin TYPEDEF: ReturnCode_t */


/* End TYPEDEF: ReturnCode_t */


/* Begin CONST: HANDLE_NIL */


/* End CONST: HANDLE_NIL */


/* Begin CONST: LENGTH_UNLIMITED */


/* End CONST: LENGTH_UNLIMITED */


/* Begin CONST: DURATION_INFINITE_SEC */


/* End CONST: DURATION_INFINITE_SEC */


/* Begin CONST: DURATION_INFINITE_NSEC */


/* End CONST: DURATION_INFINITE_NSEC */


/* Begin CONST: DURATION_ZERO_SEC */


/* End CONST: DURATION_ZERO_SEC */


/* Begin CONST: DURATION_ZERO_NSEC */


/* End CONST: DURATION_ZERO_NSEC */


/* Begin CONST: TIME_INVALID_SEC */


/* End CONST: TIME_INVALID_SEC */


/* Begin CONST: TIME_INVALID_NSEC */


/* End CONST: TIME_INVALID_NSEC */


/* Begin CONST: RETCODE_OK */


/* End CONST: RETCODE_OK */


/* Begin CONST: RETCODE_ERROR */


/* End CONST: RETCODE_ERROR */


/* Begin CONST: RETCODE_UNSUPPORTED */


/* End CONST: RETCODE_UNSUPPORTED */


/* Begin CONST: RETCODE_BAD_PARAMETER */


/* End CONST: RETCODE_BAD_PARAMETER */


/* Begin CONST: RETCODE_PRECONDITION_NOT_MET */


/* End CONST: RETCODE_PRECONDITION_NOT_MET */


/* Begin CONST: RETCODE_OUT_OF_RESOURCES */


/* End CONST: RETCODE_OUT_OF_RESOURCES */


/* Begin CONST: RETCODE_NOT_ENABLED */


/* End CONST: RETCODE_NOT_ENABLED */


/* Begin CONST: RETCODE_IMMUTABLE_POLICY */


/* End CONST: RETCODE_IMMUTABLE_POLICY */


/* Begin CONST: RETCODE_INCONSISTENT_POLICY */


/* End CONST: RETCODE_INCONSISTENT_POLICY */


/* Begin CONST: RETCODE_ALREADY_DELETED */


/* End CONST: RETCODE_ALREADY_DELETED */


/* Begin CONST: RETCODE_TIMEOUT */


/* End CONST: RETCODE_TIMEOUT */


/* Begin CONST: RETCODE_NO_DATA */


/* End CONST: RETCODE_NO_DATA */


/* Begin CONST: RETCODE_ILLEGAL_OPERATION */


/* End CONST: RETCODE_ILLEGAL_OPERATION */


/* Begin TYPEDEF: StatusKind */


/* End TYPEDEF: StatusKind */


/* Begin TYPEDEF: StatusMask */


/* End TYPEDEF: StatusMask */


/* Begin CONST: INCONSISTENT_TOPIC_STATUS */


/* End CONST: INCONSISTENT_TOPIC_STATUS */


/* Begin CONST: OFFERED_DEADLINE_MISSED_STATUS */


/* End CONST: OFFERED_DEADLINE_MISSED_STATUS */


/* Begin CONST: REQUESTED_DEADLINE_MISSED_STATUS */


/* End CONST: REQUESTED_DEADLINE_MISSED_STATUS */


/* Begin CONST: OFFERED_INCOMPATIBLE_QOS_STATUS */


/* End CONST: OFFERED_INCOMPATIBLE_QOS_STATUS */


/* Begin CONST: REQUESTED_INCOMPATIBLE_QOS_STATUS */


/* End CONST: REQUESTED_INCOMPATIBLE_QOS_STATUS */


/* Begin CONST: SAMPLE_LOST_STATUS */


/* End CONST: SAMPLE_LOST_STATUS */


/* Begin CONST: SAMPLE_REJECTED_STATUS */


/* End CONST: SAMPLE_REJECTED_STATUS */


/* Begin CONST: DATA_ON_READERS_STATUS */


/* End CONST: DATA_ON_READERS_STATUS */


/* Begin CONST: DATA_AVAILABLE_STATUS */


/* End CONST: DATA_AVAILABLE_STATUS */


/* Begin CONST: LIVELINESS_LOST_STATUS */


/* End CONST: LIVELINESS_LOST_STATUS */


/* Begin CONST: LIVELINESS_CHANGED_STATUS */


/* End CONST: LIVELINESS_CHANGED_STATUS */


/* Begin CONST: PUBLICATION_MATCHED_STATUS */


/* End CONST: PUBLICATION_MATCHED_STATUS */


/* Begin CONST: SUBSCRIPTION_MATCHED_STATUS */


/* End CONST: SUBSCRIPTION_MATCHED_STATUS */


/* Begin STRUCT: InconsistentTopicStatus */


/* End STRUCT: InconsistentTopicStatus */


/* Begin STRUCT: SampleLostStatus */


/* End STRUCT: SampleLostStatus */


/* Begin ENUM: SampleRejectedStatusKind */


/* End ENUM: SampleRejectedStatusKind */


/* Begin STRUCT: SampleRejectedStatus */


/* End STRUCT: SampleRejectedStatus */


/* Begin STRUCT: LivelinessLostStatus */


/* End STRUCT: LivelinessLostStatus */


/* Begin STRUCT: LivelinessChangedStatus */


/* End STRUCT: LivelinessChangedStatus */


/* Begin STRUCT: OfferedDeadlineMissedStatus */


/* End STRUCT: OfferedDeadlineMissedStatus */


/* Begin STRUCT: RequestedDeadlineMissedStatus */


/* End STRUCT: RequestedDeadlineMissedStatus */


/* Begin STRUCT: OfferedIncompatibleQosStatus */


/* End STRUCT: OfferedIncompatibleQosStatus */


/* Begin STRUCT: RequestedIncompatibleQosStatus */


/* End STRUCT: RequestedIncompatibleQosStatus */


/* Begin STRUCT: PublicationMatchedStatus */


/* End STRUCT: PublicationMatchedStatus */


/* Begin STRUCT: SubscriptionMatchedStatus */


/* End STRUCT: SubscriptionMatchedStatus */


/* Begin INTERFACE-FWD: Listener */


/* End INTERFACE-FWD: Listener */


/* Begin INTERFACE-FWD: Entity */


/* End INTERFACE-FWD: Entity */


/* Begin INTERFACE: Listener */


/* End INTERFACE: Listener */


/* Begin INTERFACE: Condition */


/* End INTERFACE: Condition */


/* Begin INTERFACE: WaitSetInterf */


/* End INTERFACE: WaitSetInterf */


/* Begin INTERFACE: GuardConditionInterf */


/* End INTERFACE: GuardConditionInterf */


/* Begin INTERFACE: StatusCondition */


/* End INTERFACE: StatusCondition */


/* Begin CONST: USERDATA_QOS_POLICY_NAME */


/* End CONST: USERDATA_QOS_POLICY_NAME */


/* Begin CONST: DURABILITY_QOS_POLICY_NAME */


/* End CONST: DURABILITY_QOS_POLICY_NAME */


/* Begin CONST: PRESENTATION_QOS_POLICY_NAME */


/* End CONST: PRESENTATION_QOS_POLICY_NAME */


/* Begin CONST: DEADLINE_QOS_POLICY_NAME */


/* End CONST: DEADLINE_QOS_POLICY_NAME */


/* Begin CONST: LATENCYBUDGET_QOS_POLICY_NAME */


/* End CONST: LATENCYBUDGET_QOS_POLICY_NAME */


/* Begin CONST: OWNERSHIP_QOS_POLICY_NAME */


/* End CONST: OWNERSHIP_QOS_POLICY_NAME */


/* Begin CONST: OWNERSHIPSTRENGTH_QOS_POLICY_NAME */


/* End CONST: OWNERSHIPSTRENGTH_QOS_POLICY_NAME */


/* Begin CONST: LIVELINESS_QOS_POLICY_NAME */


/* End CONST: LIVELINESS_QOS_POLICY_NAME */


/* Begin CONST: TIMEBASEDFILTER_QOS_POLICY_NAME */


/* End CONST: TIMEBASEDFILTER_QOS_POLICY_NAME */


/* Begin CONST: PARTITION_QOS_POLICY_NAME */


/* End CONST: PARTITION_QOS_POLICY_NAME */


/* Begin CONST: RELIABILITY_QOS_POLICY_NAME */


/* End CONST: RELIABILITY_QOS_POLICY_NAME */


/* Begin CONST: DESTINATIONORDER_QOS_POLICY_NAME */


/* End CONST: DESTINATIONORDER_QOS_POLICY_NAME */


/* Begin CONST: HISTORY_QOS_POLICY_NAME */


/* End CONST: HISTORY_QOS_POLICY_NAME */


/* Begin CONST: RESOURCELIMITS_QOS_POLICY_NAME */


/* End CONST: RESOURCELIMITS_QOS_POLICY_NAME */


/* Begin CONST: ENTITYFACTORY_QOS_POLICY_NAME */


/* End CONST: ENTITYFACTORY_QOS_POLICY_NAME */


/* Begin CONST: WRITERDATALIFECYCLE_QOS_POLICY_NAME */


/* End CONST: WRITERDATALIFECYCLE_QOS_POLICY_NAME */


/* Begin CONST: READERDATALIFECYCLE_QOS_POLICY_NAME */


/* End CONST: READERDATALIFECYCLE_QOS_POLICY_NAME */


/* Begin CONST: TOPICDATA_QOS_POLICY_NAME */


/* End CONST: TOPICDATA_QOS_POLICY_NAME */


/* Begin CONST: GROUPDATA_QOS_POLICY_NAME */


/* End CONST: GROUPDATA_QOS_POLICY_NAME */


/* Begin CONST: TRANSPORTPRIORITY_QOS_POLICY_NAME */


/* End CONST: TRANSPORTPRIORITY_QOS_POLICY_NAME */


/* Begin CONST: LIFESPAN_QOS_POLICY_NAME */


/* End CONST: LIFESPAN_QOS_POLICY_NAME */


/* Begin CONST: DURABILITYSERVICE_POLICY_NAME */


/* End CONST: DURABILITYSERVICE_POLICY_NAME */


/* Begin CONST: INVALID_QOS_POLICY_ID */


/* End CONST: INVALID_QOS_POLICY_ID */


/* Begin CONST: USERDATA_QOS_POLICY_ID */


/* End CONST: USERDATA_QOS_POLICY_ID */


/* Begin CONST: DURABILITY_QOS_POLICY_ID */


/* End CONST: DURABILITY_QOS_POLICY_ID */


/* Begin CONST: PRESENTATION_QOS_POLICY_ID */


/* End CONST: PRESENTATION_QOS_POLICY_ID */


/* Begin CONST: DEADLINE_QOS_POLICY_ID */


/* End CONST: DEADLINE_QOS_POLICY_ID */


/* Begin CONST: LATENCYBUDGET_QOS_POLICY_ID */


/* End CONST: LATENCYBUDGET_QOS_POLICY_ID */


/* Begin CONST: OWNERSHIP_QOS_POLICY_ID */


/* End CONST: OWNERSHIP_QOS_POLICY_ID */


/* Begin CONST: OWNERSHIPSTRENGTH_QOS_POLICY_ID */


/* End CONST: OWNERSHIPSTRENGTH_QOS_POLICY_ID */


/* Begin CONST: LIVELINESS_QOS_POLICY_ID */


/* End CONST: LIVELINESS_QOS_POLICY_ID */


/* Begin CONST: TIMEBASEDFILTER_QOS_POLICY_ID */


/* End CONST: TIMEBASEDFILTER_QOS_POLICY_ID */


/* Begin CONST: PARTITION_QOS_POLICY_ID */


/* End CONST: PARTITION_QOS_POLICY_ID */


/* Begin CONST: RELIABILITY_QOS_POLICY_ID */


/* End CONST: RELIABILITY_QOS_POLICY_ID */


/* Begin CONST: DESTINATIONORDER_QOS_POLICY_ID */


/* End CONST: DESTINATIONORDER_QOS_POLICY_ID */


/* Begin CONST: HISTORY_QOS_POLICY_ID */


/* End CONST: HISTORY_QOS_POLICY_ID */


/* Begin CONST: RESOURCELIMITS_QOS_POLICY_ID */


/* End CONST: RESOURCELIMITS_QOS_POLICY_ID */


/* Begin CONST: ENTITYFACTORY_QOS_POLICY_ID */


/* End CONST: ENTITYFACTORY_QOS_POLICY_ID */


/* Begin CONST: WRITERDATALIFECYCLE_QOS_POLICY_ID */


/* End CONST: WRITERDATALIFECYCLE_QOS_POLICY_ID */


/* Begin CONST: READERDATALIFECYCLE_QOS_POLICY_ID */


/* End CONST: READERDATALIFECYCLE_QOS_POLICY_ID */


/* Begin CONST: TOPICDATA_QOS_POLICY_ID */


/* End CONST: TOPICDATA_QOS_POLICY_ID */


/* Begin CONST: GROUPDATA_QOS_POLICY_ID */


/* End CONST: GROUPDATA_QOS_POLICY_ID */


/* Begin CONST: TRANSPORTPRIORITY_QOS_POLICY_ID */


/* End CONST: TRANSPORTPRIORITY_QOS_POLICY_ID */


/* Begin CONST: LIFESPAN_QOS_POLICY_ID */


/* End CONST: LIFESPAN_QOS_POLICY_ID */


/* Begin CONST: DURABILITYSERVICE_QOS_POLICY_ID */


/* End CONST: DURABILITYSERVICE_QOS_POLICY_ID */


/* Begin INTERFACE: Entity */


/* End INTERFACE: Entity */

/* End MODULE: DDS */


/* Begin MODULE: OpenDDS */



/* Begin CONST: TRANSPORTTYPE_QOS_POLICY_NAME */


/* End CONST: TRANSPORTTYPE_QOS_POLICY_NAME */


/* Begin CONST: TRANSPORTTYPE_QOS_POLICY_ID */


/* End CONST: TRANSPORTTYPE_QOS_POLICY_ID */


/* Begin CONST: MAX_USER_DOMAINID */


/* End CONST: MAX_USER_DOMAINID */


/* Begin MODULE: DCPS */



/* Begin CONST: ALL_STATUS_MASK */


/* End CONST: ALL_STATUS_MASK */


/* Begin CONST: NO_STATUS_MASK */


/* End CONST: NO_STATUS_MASK */


/* Begin CONST: DEFAULT_STATUS_MASK */


/* End CONST: DEFAULT_STATUS_MASK */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin TYPEDEF: GuidVendorId_t */


/* End TYPEDEF: GuidVendorId_t */


/* Begin TYPEDEF: GuidPrefix_t */


/* End TYPEDEF: GuidPrefix_t */


/* Begin TYPEDEF: EntityKey_t */


/* End TYPEDEF: EntityKey_t */


/* Begin STRUCT: EntityId_t */


/* End STRUCT: EntityId_t */


/* Begin CONST: ENTITYKIND_BUILTIN_UNKNOWN */


/* End CONST: ENTITYKIND_BUILTIN_UNKNOWN */


/* Begin CONST: ENTITYKIND_BUILTIN_PARTICIPANT */


/* End CONST: ENTITYKIND_BUILTIN_PARTICIPANT */


/* Begin CONST: ENTITYKIND_BUILTIN_WRITER_WITH_KEY */


/* End CONST: ENTITYKIND_BUILTIN_WRITER_WITH_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_WRITER_NO_KEY */


/* End CONST: ENTITYKIND_BUILTIN_WRITER_NO_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_READER_NO_KEY */


/* End CONST: ENTITYKIND_BUILTIN_READER_NO_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_READER_WITH_KEY */


/* End CONST: ENTITYKIND_BUILTIN_READER_WITH_KEY */


/* Begin CONST: ENTITYKIND_USER_UNKNOWN */


/* End CONST: ENTITYKIND_USER_UNKNOWN */


/* Begin CONST: ENTITYKIND_USER_WRITER_WITH_KEY */


/* End CONST: ENTITYKIND_USER_WRITER_WITH_KEY */


/* Begin CONST: ENTITYKIND_USER_WRITER_NO_KEY */


/* End CONST: ENTITYKIND_USER_WRITER_NO_KEY */


/* Begin CONST: ENTITYKIND_USER_READER_NO_KEY */


/* End CONST: ENTITYKIND_USER_READER_NO_KEY */


/* Begin CONST: ENTITYKIND_USER_READER_WITH_KEY */


/* End CONST: ENTITYKIND_USER_READER_WITH_KEY */


/* Begin CONST: ENTITYKIND_OPENDDS_SUBSCRIBER */


/* End CONST: ENTITYKIND_OPENDDS_SUBSCRIBER */


/* Begin CONST: ENTITYKIND_OPENDDS_PUBLISHER */


/* End CONST: ENTITYKIND_OPENDDS_PUBLISHER */


/* Begin CONST: ENTITYKIND_OPENDDS_TOPIC */


/* End CONST: ENTITYKIND_OPENDDS_TOPIC */


/* Begin CONST: ENTITYKIND_OPENDDS_USER */


/* End CONST: ENTITYKIND_OPENDDS_USER */


/* Begin CONST: ENTITYKIND_OPENDDS_NIL_WRITER */


/* End CONST: ENTITYKIND_OPENDDS_NIL_WRITER */


/* Begin STRUCT: GUID_t */


/* End STRUCT: GUID_t */


/* Begin TYPEDEF: GUIDSeq */


/* End TYPEDEF: GUIDSeq */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: ULongSeq */


/* End TYPEDEF: ULongSeq */

/* End MODULE: CORBA */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin CONST: MONITOR_DOMAIN_ID */


/* End CONST: MONITOR_DOMAIN_ID */


/* Begin CONST: MONITOR_TRANSPORT_ID */


/* End CONST: MONITOR_TRANSPORT_ID */


/* Begin CONST: SERVICE_PARTICIPANT_MONITOR_TOPIC */


/* End CONST: SERVICE_PARTICIPANT_MONITOR_TOPIC */


/* Begin CONST: DOMAIN_PARTICIPANT_MONITOR_TOPIC */


/* End CONST: DOMAIN_PARTICIPANT_MONITOR_TOPIC */


/* Begin CONST: TOPIC_MONITOR_TOPIC */


/* End CONST: TOPIC_MONITOR_TOPIC */


/* Begin CONST: PUBLISHER_MONITOR_TOPIC */


/* End CONST: PUBLISHER_MONITOR_TOPIC */


/* Begin CONST: SUBSCRIBER_MONITOR_TOPIC */


/* End CONST: SUBSCRIBER_MONITOR_TOPIC */


/* Begin CONST: DATA_WRITER_MONITOR_TOPIC */


/* End CONST: DATA_WRITER_MONITOR_TOPIC */


/* Begin CONST: DATA_WRITER_PERIODIC_MONITOR_TOPIC */


/* End CONST: DATA_WRITER_PERIODIC_MONITOR_TOPIC */


/* Begin CONST: DATA_READER_MONITOR_TOPIC */


/* End CONST: DATA_READER_MONITOR_TOPIC */


/* Begin CONST: DATA_READER_PERIODIC_MONITOR_TOPIC */


/* End CONST: DATA_READER_PERIODIC_MONITOR_TOPIC */


/* Begin CONST: TRANSPORT_MONITOR_TOPIC */


/* End CONST: TRANSPORT_MONITOR_TOPIC */


/* Begin STRUCT: Statistics */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::Statistics& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.n);
  if ((size + padding) % 8) {
    padding += 8 - ((size + padding) % 8);
  }
  size += gen_max_marshaled_size(stru.maximum);
  if ((size + padding) % 8) {
    padding += 8 - ((size + padding) % 8);
  }
  size += gen_max_marshaled_size(stru.minimum);
  if ((size + padding) % 8) {
    padding += 8 - ((size + padding) % 8);
  }
  size += gen_max_marshaled_size(stru.mean);
  if ((size + padding) % 8) {
    padding += 8 - ((size + padding) % 8);
  }
  size += gen_max_marshaled_size(stru.variance);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::Statistics& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.n)
    && (strm << stru.maximum)
    && (strm << stru.minimum)
    && (strm << stru.mean)
    && (strm << stru.variance);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::Statistics& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.n)
    && (strm >> stru.maximum)
    && (strm >> stru.minimum)
    && (strm >> stru.mean)
    && (strm >> stru.variance);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::Statistics> : MetaStruct {
  typedef OpenDDS::DCPS::Statistics T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::Statistics& typed = *static_cast<const OpenDDS::DCPS::Statistics*>(stru);
    if (std::strcmp(field, "n") == 0) {
      return typed.n;
    }
    if (std::strcmp(field, "maximum") == 0) {
      return typed.maximum;
    }
    if (std::strcmp(field, "minimum") == 0) {
      return typed.minimum;
    }
    if (std::strcmp(field, "mean") == 0) {
      return typed.mean;
    }
    if (std::strcmp(field, "variance") == 0) {
      return typed.variance;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::Statistics)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "n") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'n' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "maximum") == 0) {
      ACE_CDR::Double val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'maximum' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 8);
    }
    if (std::strcmp(field, "minimum") == 0) {
      ACE_CDR::Double val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'minimum' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 8);
    }
    if (std::strcmp(field, "mean") == 0) {
      ACE_CDR::Double val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'mean' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 8);
    }
    if (std::strcmp(field, "variance") == 0) {
      ACE_CDR::Double val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'variance' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 8);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::Statistics");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "n") == 0) {
      return make_field_cmp(&T::n, next);
    }
    if (std::strcmp(field, "maximum") == 0) {
      return make_field_cmp(&T::maximum, next);
    }
    if (std::strcmp(field, "minimum") == 0) {
      return make_field_cmp(&T::minimum, next);
    }
    if (std::strcmp(field, "mean") == 0) {
      return make_field_cmp(&T::mean, next);
    }
    if (std::strcmp(field, "variance") == 0) {
      return make_field_cmp(&T::variance, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::Statistics)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"n", "maximum", "minimum", "mean", "variance", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "n") == 0) {
      return &static_cast<const T*>(stru)->n;
    }
    if (std::strcmp(field, "maximum") == 0) {
      return &static_cast<const T*>(stru)->maximum;
    }
    if (std::strcmp(field, "minimum") == 0) {
      return &static_cast<const T*>(stru)->minimum;
    }
    if (std::strcmp(field, "mean") == 0) {
      return &static_cast<const T*>(stru)->mean;
    }
    if (std::strcmp(field, "variance") == 0) {
      return &static_cast<const T*>(stru)->variance;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::Statistics)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "n") == 0) {
      static_cast<T*>(lhs)->n = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "maximum") == 0) {
      static_cast<T*>(lhs)->maximum = *static_cast<const CORBA::Double*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "minimum") == 0) {
      static_cast<T*>(lhs)->minimum = *static_cast<const CORBA::Double*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "mean") == 0) {
      static_cast<T*>(lhs)->mean = *static_cast<const CORBA::Double*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "variance") == 0) {
      static_cast<T*>(lhs)->variance = *static_cast<const CORBA::Double*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::Statistics)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "n") == 0) {
      return static_cast<const T*>(lhs)->n == static_cast<const T*>(rhs)->n;
    }
    if (std::strcmp(field, "maximum") == 0) {
      return static_cast<const T*>(lhs)->maximum == static_cast<const T*>(rhs)->maximum;
    }
    if (std::strcmp(field, "minimum") == 0) {
      return static_cast<const T*>(lhs)->minimum == static_cast<const T*>(rhs)->minimum;
    }
    if (std::strcmp(field, "mean") == 0) {
      return static_cast<const T*>(lhs)->mean == static_cast<const T*>(rhs)->mean;
    }
    if (std::strcmp(field, "variance") == 0) {
      return static_cast<const T*>(lhs)->variance == static_cast<const T*>(rhs)->variance;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::Statistics)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::Statistics>()
{
  static MetaStructImpl<OpenDDS::DCPS::Statistics> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::Statistics*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::Statistics>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Statistics */


/* Begin ENUM: ValueEnumType */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const OpenDDS::DCPS::ValueEnumType& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::ValueEnumType& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    enumval = static_cast<OpenDDS::DCPS::ValueEnumType>(temp);
    return true;
  }
  return false;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

const char* gen_OpenDDS_DCPS_ValueEnumType_names[] = {
  "INTEGER_TYPE",
  "DOUBLE_TYPE",
  "STRING_TYPE",
  "STATISTICS_TYPE",
  "STRING_LIST_TYPE"
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End ENUM: ValueEnumType */


/* Begin UNION: ValueUnion */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::ValueUnion& uni, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(uni);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(uni._d());
  switch (uni._d()) {
  case OpenDDS::DCPS::INTEGER_TYPE:
    {
      if ((size + padding) % 4) {
        padding += 4 - ((size + padding) % 4);
      }
      size += gen_max_marshaled_size(uni.integer_value());
      break;
    }
  case OpenDDS::DCPS::DOUBLE_TYPE:
    {
      if ((size + padding) % 8) {
        padding += 8 - ((size + padding) % 8);
      }
      size += gen_max_marshaled_size(uni.double_value());
      break;
    }
  case OpenDDS::DCPS::STRING_TYPE:
    {
      find_size_ulong(size, padding);
      size += ACE_OS::strlen(uni.string_value()) + 1;
      break;
    }
  case OpenDDS::DCPS::STATISTICS_TYPE:
    {
      gen_find_size(uni.stat_value(), size, padding);
      break;
    }
  case OpenDDS::DCPS::STRING_LIST_TYPE:
    {
      gen_find_size(uni.string_seq_value(), size, padding);
      break;
    }
  default:
    break;
  }
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::ValueUnion& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  if (!(strm << uni._d())) {
    return false;
  }
  switch (uni._d()) {
  case OpenDDS::DCPS::INTEGER_TYPE:
    {
      return (strm << uni.integer_value());
    }
  case OpenDDS::DCPS::DOUBLE_TYPE:
    {
      return (strm << uni.double_value());
    }
  case OpenDDS::DCPS::STRING_TYPE:
    {
      return (strm << uni.string_value());
    }
  case OpenDDS::DCPS::STATISTICS_TYPE:
    {
      return (strm << uni.stat_value());
    }
  case OpenDDS::DCPS::STRING_LIST_TYPE:
    {
      return (strm << uni.string_seq_value());
    }
  default:
    break;
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::ValueUnion& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  OpenDDS::DCPS::ValueEnumType disc;
  if (!(strm >> disc)) {
    return false;
  }
  switch (disc) {
  case OpenDDS::DCPS::INTEGER_TYPE:
    {
      CORBA::Long tmp;
      if (strm >> tmp) {
        uni.integer_value(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case OpenDDS::DCPS::DOUBLE_TYPE:
    {
      CORBA::Double tmp;
      if (strm >> tmp) {
        uni.double_value(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case OpenDDS::DCPS::STRING_TYPE:
    {
      CORBA::String_var tmp;
      if (strm >> tmp.out()) {
        uni.string_value(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case OpenDDS::DCPS::STATISTICS_TYPE:
    {
      OpenDDS::DCPS::Statistics tmp;
      if (strm >> tmp) {
        uni.stat_value(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case OpenDDS::DCPS::STRING_LIST_TYPE:
    {
      DDS::StringSeq tmp;
      if (strm >> tmp) {
        uni.string_seq_value(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  default:
    uni._d(disc);
    break;
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::ValueUnion*)
{
  ACE_UNUSED_ARG(ser);
  OpenDDS::DCPS::ValueEnumType disc;
  if (!(ser >> disc)) {
    return;
  }
  switch (disc) {
  case OpenDDS::DCPS::INTEGER_TYPE:
    {
    ser.skip(1, 4);
      break;
    }
  case OpenDDS::DCPS::DOUBLE_TYPE:
    {
    ser.skip(1, 8);
      break;
    }
  case OpenDDS::DCPS::STRING_TYPE:
    {
      ACE_CDR::ULong len;
      ser >> len;
      ser.skip(len);
      break;
    }
  case OpenDDS::DCPS::STATISTICS_TYPE:
    {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::Statistics*>(0));
      break;
    }
  case OpenDDS::DCPS::STRING_LIST_TYPE:
    {
    gen_skip_over(ser, static_cast<DDS::StringSeq*>(0));
      break;
    }
  default:
    break;
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End UNION: ValueUnion */


/* Begin STRUCT: NameValuePair */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::NameValuePair& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.name.in()) + 1;
  gen_find_size(stru.value, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::NameValuePair& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.name.in())
    && (strm << stru.value);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::NameValuePair& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.name.out())
    && (strm >> stru.value);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::NameValuePair> : MetaStruct {
  typedef OpenDDS::DCPS::NameValuePair T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::NameValuePair& typed = *static_cast<const OpenDDS::DCPS::NameValuePair*>(stru);
    if (std::strcmp(field, "name") == 0) {
      return typed.name.in();
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::NameValuePair)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "name") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'name' length could not be deserialized");
      }
      ser.skip(len);
    }
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::ValueUnion*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::NameValuePair");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "name") == 0) {
      return make_field_cmp(&T::name, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::NameValuePair)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"name", "value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "name") == 0) {
      return &static_cast<const T*>(stru)->name;
    }
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::NameValuePair)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "name") == 0) {
      static_cast<T*>(lhs)->name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const OpenDDS::DCPS::ValueUnion*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::NameValuePair)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->name.in(), static_cast<const T*>(rhs)->name.in());
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::NameValuePair)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::NameValuePair>()
{
  static MetaStructImpl<OpenDDS::DCPS::NameValuePair> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::NameValuePair*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::NameValuePair>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: NameValuePair */


/* Begin TYPEDEF: NVPSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::NVPSeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::NVPSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::NVPSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::NVPSeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::NameValuePair*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: NVPSeq */


/* Begin STRUCT: ServiceParticipantReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::ServiceParticipantReport& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.host.in()) + 1;
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.pid);
  gen_find_size(stru.domain_participants, size, padding);
  gen_find_size(stru.transports, size, padding);
  gen_find_size(stru.values, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::ServiceParticipantReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.host.in())
    && (strm << stru.pid)
    && (strm << stru.domain_participants)
    && (strm << stru.transports)
    && (strm << stru.values);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::ServiceParticipantReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.host.out())
    && (strm >> stru.pid)
    && (strm >> stru.domain_participants)
    && (strm >> stru.transports)
    && (strm >> stru.values);
}

size_t gen_max_marshaled_size(const OpenDDS::DCPS::ServiceParticipantReport& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::ServiceParticipantReport> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const OpenDDS::DCPS::ServiceParticipantReport> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.t.host.in()) + 1;
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.pid);
}

bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::ServiceParticipantReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.t.host.in())
    && (strm << stru.t.pid);
}

bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::ServiceParticipantReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.t.host.out())
    && (strm >> stru.t.pid);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
::DDS::DataWriter_ptr ServiceParticipantReportTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<ServiceParticipantReport> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr ServiceParticipantReportTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<ServiceParticipantReport> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr ServiceParticipantReportTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<ServiceParticipantReport> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<ServiceParticipantReport, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& ServiceParticipantReportTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<ServiceParticipantReport>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool ServiceParticipantReportTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* ServiceParticipantReportTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
ServiceParticipantReportTypeSupport::_ptr_type ServiceParticipantReportTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::ServiceParticipantReport> : MetaStruct {
  typedef OpenDDS::DCPS::ServiceParticipantReport T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 2; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::ServiceParticipantReport& typed = *static_cast<const OpenDDS::DCPS::ServiceParticipantReport*>(stru);
    if (std::strcmp(field, "host") == 0) {
      return typed.host.in();
    }
    if (std::strcmp(field, "pid") == 0) {
      return typed.pid;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ServiceParticipantReport)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "host") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'host' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'host' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strcmp(field, "pid") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'pid' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUIDSeq*>(0));
    gen_skip_over(ser, static_cast<CORBA::ULongSeq*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::NVPSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::ServiceParticipantReport");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "host") == 0) {
      return make_field_cmp(&T::host, next);
    }
    if (std::strcmp(field, "pid") == 0) {
      return make_field_cmp(&T::pid, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ServiceParticipantReport)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"host", "pid", "domain_participants", "transports", "values", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "host") == 0) {
      return &static_cast<const T*>(stru)->host;
    }
    if (std::strcmp(field, "pid") == 0) {
      return &static_cast<const T*>(stru)->pid;
    }
    if (std::strcmp(field, "domain_participants") == 0) {
      return &static_cast<const T*>(stru)->domain_participants;
    }
    if (std::strcmp(field, "transports") == 0) {
      return &static_cast<const T*>(stru)->transports;
    }
    if (std::strcmp(field, "values") == 0) {
      return &static_cast<const T*>(stru)->values;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ServiceParticipantReport)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "host") == 0) {
      static_cast<T*>(lhs)->host = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "pid") == 0) {
      static_cast<T*>(lhs)->pid = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "domain_participants") == 0) {
      static_cast<T*>(lhs)->domain_participants = *static_cast<const OpenDDS::DCPS::GUIDSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "transports") == 0) {
      static_cast<T*>(lhs)->transports = *static_cast<const CORBA::ULongSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "values") == 0) {
      static_cast<T*>(lhs)->values = *static_cast<const OpenDDS::DCPS::NVPSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ServiceParticipantReport)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "host") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->host.in(), static_cast<const T*>(rhs)->host.in());
    }
    if (std::strcmp(field, "pid") == 0) {
      return static_cast<const T*>(lhs)->pid == static_cast<const T*>(rhs)->pid;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ServiceParticipantReport)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::ServiceParticipantReport>()
{
  static MetaStructImpl<OpenDDS::DCPS::ServiceParticipantReport> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::ServiceParticipantReport*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::ServiceParticipantReport>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ServiceParticipantReport */


/* Begin STRUCT: DomainParticipantReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::DomainParticipantReport& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.host.in()) + 1;
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.pid);
  gen_find_size(stru.dp_id, size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.domain_id);
  gen_find_size(stru.topics, size, padding);
  gen_find_size(stru.values, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::DomainParticipantReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.host.in())
    && (strm << stru.pid)
    && (strm << stru.dp_id)
    && (strm << stru.domain_id)
    && (strm << stru.topics)
    && (strm << stru.values);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::DomainParticipantReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.host.out())
    && (strm >> stru.pid)
    && (strm >> stru.dp_id)
    && (strm >> stru.domain_id)
    && (strm >> stru.topics)
    && (strm >> stru.values);
}

size_t gen_max_marshaled_size(const OpenDDS::DCPS::DomainParticipantReport& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::DomainParticipantReport> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 16;
}

void gen_find_size(KeyOnly<const OpenDDS::DCPS::DomainParticipantReport> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[11]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[10]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 9]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 8]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 7]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 6]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 5]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 4]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 3]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 2]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 1]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 0]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[2]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[1]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[0]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKind));
}

bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::DomainParticipantReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[11]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[10]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 9]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 8]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 7]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 6]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 5]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 4]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 3]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 2]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 1]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 0]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[2]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[1]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[0]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKind));
}

bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::DomainParticipantReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[11]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[10]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 9]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 8]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 7]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 6]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 5]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 4]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 3]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 2]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 1]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 0]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.entityId.entityKey[2]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.entityId.entityKey[1]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.entityId.entityKey[0]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.entityId.entityKind));
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
::DDS::DataWriter_ptr DomainParticipantReportTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<DomainParticipantReport> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr DomainParticipantReportTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<DomainParticipantReport> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr DomainParticipantReportTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<DomainParticipantReport> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<DomainParticipantReport, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& DomainParticipantReportTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<DomainParticipantReport>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool DomainParticipantReportTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* DomainParticipantReportTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
DomainParticipantReportTypeSupport::_ptr_type DomainParticipantReportTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::DomainParticipantReport> : MetaStruct {
  typedef OpenDDS::DCPS::DomainParticipantReport T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 16; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::DomainParticipantReport& typed = *static_cast<const OpenDDS::DCPS::DomainParticipantReport*>(stru);
    if (std::strcmp(field, "host") == 0) {
      return typed.host.in();
    }
    if (std::strcmp(field, "pid") == 0) {
      return typed.pid;
    }
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.dp_id, field + 6);
    }
    if (std::strcmp(field, "domain_id") == 0) {
      return typed.domain_id;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DomainParticipantReport)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "host") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'host' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'host' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strcmp(field, "pid") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'pid' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    if (std::strcmp(field, "domain_id") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'domain_id' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUIDSeq*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::NVPSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::DomainParticipantReport");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "host") == 0) {
      return make_field_cmp(&T::host, next);
    }
    if (std::strcmp(field, "pid") == 0) {
      return make_field_cmp(&T::pid, next);
    }
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return make_struct_cmp(&T::dp_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6), next);
    }
    if (std::strcmp(field, "domain_id") == 0) {
      return make_field_cmp(&T::domain_id, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DomainParticipantReport)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"host", "pid", "dp_id", "domain_id", "topics", "values", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "host") == 0) {
      return &static_cast<const T*>(stru)->host;
    }
    if (std::strcmp(field, "pid") == 0) {
      return &static_cast<const T*>(stru)->pid;
    }
    if (std::strcmp(field, "dp_id") == 0) {
      return &static_cast<const T*>(stru)->dp_id;
    }
    if (std::strcmp(field, "domain_id") == 0) {
      return &static_cast<const T*>(stru)->domain_id;
    }
    if (std::strcmp(field, "topics") == 0) {
      return &static_cast<const T*>(stru)->topics;
    }
    if (std::strcmp(field, "values") == 0) {
      return &static_cast<const T*>(stru)->values;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DomainParticipantReport)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "host") == 0) {
      static_cast<T*>(lhs)->host = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "pid") == 0) {
      static_cast<T*>(lhs)->pid = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "dp_id") == 0) {
      static_cast<T*>(lhs)->dp_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "domain_id") == 0) {
      static_cast<T*>(lhs)->domain_id = *static_cast<const DDS::DomainId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "topics") == 0) {
      static_cast<T*>(lhs)->topics = *static_cast<const OpenDDS::DCPS::GUIDSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "values") == 0) {
      static_cast<T*>(lhs)->values = *static_cast<const OpenDDS::DCPS::NVPSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DomainParticipantReport)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "host") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->host.in(), static_cast<const T*>(rhs)->host.in());
    }
    if (std::strcmp(field, "pid") == 0) {
      return static_cast<const T*>(lhs)->pid == static_cast<const T*>(rhs)->pid;
    }
    if (std::strcmp(field, "domain_id") == 0) {
      return static_cast<const T*>(lhs)->domain_id == static_cast<const T*>(rhs)->domain_id;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DomainParticipantReport)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DomainParticipantReport>()
{
  static MetaStructImpl<OpenDDS::DCPS::DomainParticipantReport> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DomainParticipantReport*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::DomainParticipantReport>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DomainParticipantReport */


/* Begin STRUCT: TopicReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::TopicReport& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.dp_id, size, padding);
  gen_find_size(stru.topic_id, size, padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.topic_name.in()) + 1;
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.type_name.in()) + 1;
  gen_find_size(stru.values, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::TopicReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.dp_id)
    && (strm << stru.topic_id)
    && (strm << stru.topic_name.in())
    && (strm << stru.type_name.in())
    && (strm << stru.values);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::TopicReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.dp_id)
    && (strm >> stru.topic_id)
    && (strm >> stru.topic_name.out())
    && (strm >> stru.type_name.out())
    && (strm >> stru.values);
}

size_t gen_max_marshaled_size(const OpenDDS::DCPS::TopicReport& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::TopicReport> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 16;
}

void gen_find_size(KeyOnly<const OpenDDS::DCPS::TopicReport> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[11]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[10]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 9]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 8]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 7]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 6]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 5]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 4]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 3]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 2]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 1]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 0]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.topic_id.entityId.entityKey[2]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.topic_id.entityId.entityKey[1]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.topic_id.entityId.entityKey[0]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.topic_id.entityId.entityKind));
}

bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::TopicReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[11]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[10]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 9]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 8]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 7]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 6]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 5]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 4]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 3]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 2]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 1]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.topic_id.guidPrefix[ 0]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.topic_id.entityId.entityKey[2]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.topic_id.entityId.entityKey[1]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.topic_id.entityId.entityKey[0]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.topic_id.entityId.entityKind));
}

bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::TopicReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> ACE_InputCDR::to_octet(stru.t.topic_id.guidPrefix[11]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.topic_id.guidPrefix[10]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.topic_id.guidPrefix[ 9]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.topic_id.guidPrefix[ 8]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.topic_id.guidPrefix[ 7]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.topic_id.guidPrefix[ 6]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.topic_id.guidPrefix[ 5]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.topic_id.guidPrefix[ 4]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.topic_id.guidPrefix[ 3]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.topic_id.guidPrefix[ 2]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.topic_id.guidPrefix[ 1]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.topic_id.guidPrefix[ 0]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.topic_id.entityId.entityKey[2]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.topic_id.entityId.entityKey[1]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.topic_id.entityId.entityKey[0]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.topic_id.entityId.entityKind));
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
::DDS::DataWriter_ptr TopicReportTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<TopicReport> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr TopicReportTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<TopicReport> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr TopicReportTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<TopicReport> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<TopicReport, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& TopicReportTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<TopicReport>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool TopicReportTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* TopicReportTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
TopicReportTypeSupport::_ptr_type TopicReportTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::TopicReport> : MetaStruct {
  typedef OpenDDS::DCPS::TopicReport T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 16; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::TopicReport& typed = *static_cast<const OpenDDS::DCPS::TopicReport*>(stru);
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.dp_id, field + 6);
    }
    if (std::strncmp(field, "topic_id.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.topic_id, field + 9);
    }
    if (std::strcmp(field, "topic_name") == 0) {
      return typed.topic_name.in();
    }
    if (std::strcmp(field, "type_name") == 0) {
      return typed.type_name.in();
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TopicReport)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    if (std::strncmp(field, "topic_id.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    if (std::strcmp(field, "topic_name") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'topic_name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'topic_name' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strcmp(field, "type_name") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'type_name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'type_name' length could not be deserialized");
      }
      ser.skip(len);
    }
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::NVPSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::TopicReport");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return make_struct_cmp(&T::dp_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6), next);
    }
    if (std::strncmp(field, "topic_id.", 9) == 0) {
      return make_struct_cmp(&T::topic_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strcmp(field, "topic_name") == 0) {
      return make_field_cmp(&T::topic_name, next);
    }
    if (std::strcmp(field, "type_name") == 0) {
      return make_field_cmp(&T::type_name, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TopicReport)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"dp_id", "topic_id", "topic_name", "type_name", "values", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "dp_id") == 0) {
      return &static_cast<const T*>(stru)->dp_id;
    }
    if (std::strcmp(field, "topic_id") == 0) {
      return &static_cast<const T*>(stru)->topic_id;
    }
    if (std::strcmp(field, "topic_name") == 0) {
      return &static_cast<const T*>(stru)->topic_name;
    }
    if (std::strcmp(field, "type_name") == 0) {
      return &static_cast<const T*>(stru)->type_name;
    }
    if (std::strcmp(field, "values") == 0) {
      return &static_cast<const T*>(stru)->values;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TopicReport)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "dp_id") == 0) {
      static_cast<T*>(lhs)->dp_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "topic_id") == 0) {
      static_cast<T*>(lhs)->topic_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "topic_name") == 0) {
      static_cast<T*>(lhs)->topic_name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "type_name") == 0) {
      static_cast<T*>(lhs)->type_name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "values") == 0) {
      static_cast<T*>(lhs)->values = *static_cast<const OpenDDS::DCPS::NVPSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TopicReport)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "topic_name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->topic_name.in(), static_cast<const T*>(rhs)->topic_name.in());
    }
    if (std::strcmp(field, "type_name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->type_name.in(), static_cast<const T*>(rhs)->type_name.in());
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TopicReport)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::TopicReport>()
{
  static MetaStructImpl<OpenDDS::DCPS::TopicReport> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::TopicReport*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::TopicReport>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TopicReport */


/* Begin STRUCT: PublisherReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::PublisherReport& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.handle);
  gen_find_size(stru.dp_id, size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.transport_id);
  gen_find_size(stru.writers, size, padding);
  gen_find_size(stru.values, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::PublisherReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.handle)
    && (strm << stru.dp_id)
    && (strm << stru.transport_id)
    && (strm << stru.writers)
    && (strm << stru.values);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::PublisherReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.handle)
    && (strm >> stru.dp_id)
    && (strm >> stru.transport_id)
    && (strm >> stru.writers)
    && (strm >> stru.values);
}

size_t gen_max_marshaled_size(const OpenDDS::DCPS::PublisherReport& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::PublisherReport> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 20;
}

void gen_find_size(KeyOnly<const OpenDDS::DCPS::PublisherReport> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.handle);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[11]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[10]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 9]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 8]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 7]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 6]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 5]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 4]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 3]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 2]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 1]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 0]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[2]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[1]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[0]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKind));
}

bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::PublisherReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.t.handle)
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[11]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[10]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 9]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 8]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 7]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 6]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 5]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 4]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 3]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 2]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 1]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 0]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[2]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[1]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[0]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKind));
}

bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::PublisherReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.t.handle)
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[11]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[10]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 9]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 8]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 7]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 6]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 5]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 4]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 3]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 2]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 1]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 0]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.entityId.entityKey[2]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.entityId.entityKey[1]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.entityId.entityKey[0]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.entityId.entityKind));
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
::DDS::DataWriter_ptr PublisherReportTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<PublisherReport> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr PublisherReportTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<PublisherReport> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr PublisherReportTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<PublisherReport> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<PublisherReport, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& PublisherReportTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<PublisherReport>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool PublisherReportTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* PublisherReportTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
PublisherReportTypeSupport::_ptr_type PublisherReportTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::PublisherReport> : MetaStruct {
  typedef OpenDDS::DCPS::PublisherReport T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 17; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::PublisherReport& typed = *static_cast<const OpenDDS::DCPS::PublisherReport*>(stru);
    if (std::strcmp(field, "handle") == 0) {
      return typed.handle;
    }
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.dp_id, field + 6);
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return typed.transport_id;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::PublisherReport)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "handle") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'handle' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    if (std::strcmp(field, "transport_id") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'transport_id' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUIDSeq*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::NVPSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::PublisherReport");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "handle") == 0) {
      return make_field_cmp(&T::handle, next);
    }
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return make_struct_cmp(&T::dp_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6), next);
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return make_field_cmp(&T::transport_id, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::PublisherReport)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"handle", "dp_id", "transport_id", "writers", "values", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "handle") == 0) {
      return &static_cast<const T*>(stru)->handle;
    }
    if (std::strcmp(field, "dp_id") == 0) {
      return &static_cast<const T*>(stru)->dp_id;
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return &static_cast<const T*>(stru)->transport_id;
    }
    if (std::strcmp(field, "writers") == 0) {
      return &static_cast<const T*>(stru)->writers;
    }
    if (std::strcmp(field, "values") == 0) {
      return &static_cast<const T*>(stru)->values;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::PublisherReport)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "handle") == 0) {
      static_cast<T*>(lhs)->handle = *static_cast<const DDS::InstanceHandle_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "dp_id") == 0) {
      static_cast<T*>(lhs)->dp_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "transport_id") == 0) {
      static_cast<T*>(lhs)->transport_id = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writers") == 0) {
      static_cast<T*>(lhs)->writers = *static_cast<const OpenDDS::DCPS::GUIDSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "values") == 0) {
      static_cast<T*>(lhs)->values = *static_cast<const OpenDDS::DCPS::NVPSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::PublisherReport)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "handle") == 0) {
      return static_cast<const T*>(lhs)->handle == static_cast<const T*>(rhs)->handle;
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return static_cast<const T*>(lhs)->transport_id == static_cast<const T*>(rhs)->transport_id;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::PublisherReport)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::PublisherReport>()
{
  static MetaStructImpl<OpenDDS::DCPS::PublisherReport> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::PublisherReport*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::PublisherReport>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PublisherReport */


/* Begin STRUCT: SubscriberReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::SubscriberReport& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.handle);
  gen_find_size(stru.dp_id, size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.transport_id);
  gen_find_size(stru.readers, size, padding);
  gen_find_size(stru.values, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::SubscriberReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.handle)
    && (strm << stru.dp_id)
    && (strm << stru.transport_id)
    && (strm << stru.readers)
    && (strm << stru.values);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::SubscriberReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.handle)
    && (strm >> stru.dp_id)
    && (strm >> stru.transport_id)
    && (strm >> stru.readers)
    && (strm >> stru.values);
}

size_t gen_max_marshaled_size(const OpenDDS::DCPS::SubscriberReport& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::SubscriberReport> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 20;
}

void gen_find_size(KeyOnly<const OpenDDS::DCPS::SubscriberReport> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.handle);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[11]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[10]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 9]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 8]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 7]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 6]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 5]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 4]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 3]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 2]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 1]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 0]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[2]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[1]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[0]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKind));
}

bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::SubscriberReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.t.handle)
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[11]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[10]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 9]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 8]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 7]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 6]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 5]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 4]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 3]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 2]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 1]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.guidPrefix[ 0]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[2]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[1]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKey[0]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dp_id.entityId.entityKind));
}

bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::SubscriberReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.t.handle)
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[11]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[10]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 9]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 8]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 7]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 6]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 5]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 4]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 3]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 2]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 1]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.guidPrefix[ 0]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.entityId.entityKey[2]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.entityId.entityKey[1]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.entityId.entityKey[0]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dp_id.entityId.entityKind));
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
::DDS::DataWriter_ptr SubscriberReportTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<SubscriberReport> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr SubscriberReportTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<SubscriberReport> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr SubscriberReportTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<SubscriberReport> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<SubscriberReport, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& SubscriberReportTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<SubscriberReport>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool SubscriberReportTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* SubscriberReportTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
SubscriberReportTypeSupport::_ptr_type SubscriberReportTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::SubscriberReport> : MetaStruct {
  typedef OpenDDS::DCPS::SubscriberReport T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 17; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::SubscriberReport& typed = *static_cast<const OpenDDS::DCPS::SubscriberReport*>(stru);
    if (std::strcmp(field, "handle") == 0) {
      return typed.handle;
    }
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.dp_id, field + 6);
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return typed.transport_id;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::SubscriberReport)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "handle") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'handle' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    if (std::strcmp(field, "transport_id") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'transport_id' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUIDSeq*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::NVPSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::SubscriberReport");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "handle") == 0) {
      return make_field_cmp(&T::handle, next);
    }
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return make_struct_cmp(&T::dp_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6), next);
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return make_field_cmp(&T::transport_id, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::SubscriberReport)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"handle", "dp_id", "transport_id", "readers", "values", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "handle") == 0) {
      return &static_cast<const T*>(stru)->handle;
    }
    if (std::strcmp(field, "dp_id") == 0) {
      return &static_cast<const T*>(stru)->dp_id;
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return &static_cast<const T*>(stru)->transport_id;
    }
    if (std::strcmp(field, "readers") == 0) {
      return &static_cast<const T*>(stru)->readers;
    }
    if (std::strcmp(field, "values") == 0) {
      return &static_cast<const T*>(stru)->values;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::SubscriberReport)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "handle") == 0) {
      static_cast<T*>(lhs)->handle = *static_cast<const DDS::InstanceHandle_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "dp_id") == 0) {
      static_cast<T*>(lhs)->dp_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "transport_id") == 0) {
      static_cast<T*>(lhs)->transport_id = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readers") == 0) {
      static_cast<T*>(lhs)->readers = *static_cast<const OpenDDS::DCPS::GUIDSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "values") == 0) {
      static_cast<T*>(lhs)->values = *static_cast<const OpenDDS::DCPS::NVPSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::SubscriberReport)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "handle") == 0) {
      return static_cast<const T*>(lhs)->handle == static_cast<const T*>(rhs)->handle;
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return static_cast<const T*>(lhs)->transport_id == static_cast<const T*>(rhs)->transport_id;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::SubscriberReport)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::SubscriberReport>()
{
  static MetaStructImpl<OpenDDS::DCPS::SubscriberReport> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::SubscriberReport*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::SubscriberReport>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SubscriberReport */


/* Begin STRUCT: DataWriterAssociation */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::DataWriterAssociation& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.dr_id, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::DataWriterAssociation& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.dr_id);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::DataWriterAssociation& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.dr_id);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::DataWriterAssociation> : MetaStruct {
  typedef OpenDDS::DCPS::DataWriterAssociation T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::DataWriterAssociation& typed = *static_cast<const OpenDDS::DCPS::DataWriterAssociation*>(stru);
    if (std::strncmp(field, "dr_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.dr_id, field + 6);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterAssociation)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "dr_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::DataWriterAssociation");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "dr_id.", 6) == 0) {
      return make_struct_cmp(&T::dr_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterAssociation)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"dr_id", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "dr_id") == 0) {
      return &static_cast<const T*>(stru)->dr_id;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterAssociation)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "dr_id") == 0) {
      static_cast<T*>(lhs)->dr_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterAssociation)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterAssociation)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DataWriterAssociation>()
{
  static MetaStructImpl<OpenDDS::DCPS::DataWriterAssociation> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DataWriterAssociation*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::DataWriterAssociation>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataWriterAssociation */


/* Begin TYPEDEF: DWAssociations */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::DWAssociations& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::DWAssociations& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::DWAssociations& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DWAssociations*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::DataWriterAssociation*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: DWAssociations */


/* Begin STRUCT: DataWriterReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::DataWriterReport& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.dp_id, size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.pub_handle);
  gen_find_size(stru.dw_id, size, padding);
  gen_find_size(stru.topic_id, size, padding);
  gen_find_size(stru.instances, size, padding);
  gen_find_size(stru.associations, size, padding);
  gen_find_size(stru.values, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::DataWriterReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.dp_id)
    && (strm << stru.pub_handle)
    && (strm << stru.dw_id)
    && (strm << stru.topic_id)
    && (strm << stru.instances)
    && (strm << stru.associations)
    && (strm << stru.values);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::DataWriterReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.dp_id)
    && (strm >> stru.pub_handle)
    && (strm >> stru.dw_id)
    && (strm >> stru.topic_id)
    && (strm >> stru.instances)
    && (strm >> stru.associations)
    && (strm >> stru.values);
}

size_t gen_max_marshaled_size(const OpenDDS::DCPS::DataWriterReport& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::DataWriterReport> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 16;
}

void gen_find_size(KeyOnly<const OpenDDS::DCPS::DataWriterReport> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[11]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[10]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 9]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 8]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 7]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 6]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 5]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 4]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 3]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 2]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 1]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 0]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.entityId.entityKey[2]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.entityId.entityKey[1]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.entityId.entityKey[0]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.entityId.entityKind));
}

bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::DataWriterReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[11]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[10]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 9]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 8]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 7]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 6]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 5]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 4]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 3]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 2]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 1]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 0]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.entityId.entityKey[2]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.entityId.entityKey[1]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.entityId.entityKey[0]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.entityId.entityKind));
}

bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::DataWriterReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[11]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[10]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 9]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 8]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 7]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 6]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 5]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 4]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 3]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 2]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 1]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 0]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.entityId.entityKey[2]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.entityId.entityKey[1]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.entityId.entityKey[0]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.entityId.entityKind));
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
::DDS::DataWriter_ptr DataWriterReportTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<DataWriterReport> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr DataWriterReportTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<DataWriterReport> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr DataWriterReportTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<DataWriterReport> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<DataWriterReport, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& DataWriterReportTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<DataWriterReport>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool DataWriterReportTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* DataWriterReportTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
DataWriterReportTypeSupport::_ptr_type DataWriterReportTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::DataWriterReport> : MetaStruct {
  typedef OpenDDS::DCPS::DataWriterReport T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 16; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::DataWriterReport& typed = *static_cast<const OpenDDS::DCPS::DataWriterReport*>(stru);
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.dp_id, field + 6);
    }
    if (std::strcmp(field, "pub_handle") == 0) {
      return typed.pub_handle;
    }
    if (std::strncmp(field, "dw_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.dw_id, field + 6);
    }
    if (std::strncmp(field, "topic_id.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.topic_id, field + 9);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterReport)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    if (std::strcmp(field, "pub_handle") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'pub_handle' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strncmp(field, "dw_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    if (std::strncmp(field, "topic_id.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    gen_skip_over(ser, static_cast<DDS::InstanceHandleSeq*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::DWAssociations*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::NVPSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::DataWriterReport");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return make_struct_cmp(&T::dp_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6), next);
    }
    if (std::strcmp(field, "pub_handle") == 0) {
      return make_field_cmp(&T::pub_handle, next);
    }
    if (std::strncmp(field, "dw_id.", 6) == 0) {
      return make_struct_cmp(&T::dw_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6), next);
    }
    if (std::strncmp(field, "topic_id.", 9) == 0) {
      return make_struct_cmp(&T::topic_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 9), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterReport)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"dp_id", "pub_handle", "dw_id", "topic_id", "instances", "associations", "values", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "dp_id") == 0) {
      return &static_cast<const T*>(stru)->dp_id;
    }
    if (std::strcmp(field, "pub_handle") == 0) {
      return &static_cast<const T*>(stru)->pub_handle;
    }
    if (std::strcmp(field, "dw_id") == 0) {
      return &static_cast<const T*>(stru)->dw_id;
    }
    if (std::strcmp(field, "topic_id") == 0) {
      return &static_cast<const T*>(stru)->topic_id;
    }
    if (std::strcmp(field, "instances") == 0) {
      return &static_cast<const T*>(stru)->instances;
    }
    if (std::strcmp(field, "associations") == 0) {
      return &static_cast<const T*>(stru)->associations;
    }
    if (std::strcmp(field, "values") == 0) {
      return &static_cast<const T*>(stru)->values;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterReport)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "dp_id") == 0) {
      static_cast<T*>(lhs)->dp_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "pub_handle") == 0) {
      static_cast<T*>(lhs)->pub_handle = *static_cast<const DDS::InstanceHandle_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "dw_id") == 0) {
      static_cast<T*>(lhs)->dw_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "topic_id") == 0) {
      static_cast<T*>(lhs)->topic_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "instances") == 0) {
      static_cast<T*>(lhs)->instances = *static_cast<const DDS::InstanceHandleSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "associations") == 0) {
      static_cast<T*>(lhs)->associations = *static_cast<const OpenDDS::DCPS::DWAssociations*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "values") == 0) {
      static_cast<T*>(lhs)->values = *static_cast<const OpenDDS::DCPS::NVPSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterReport)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "pub_handle") == 0) {
      return static_cast<const T*>(lhs)->pub_handle == static_cast<const T*>(rhs)->pub_handle;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterReport)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DataWriterReport>()
{
  static MetaStructImpl<OpenDDS::DCPS::DataWriterReport> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DataWriterReport*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::DataWriterReport>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataWriterReport */


/* Begin STRUCT: DataWriterAssociationPeriodic */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::DataWriterAssociationPeriodic& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.dr_id, size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.sequence_number);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::DataWriterAssociationPeriodic& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.dr_id)
    && (strm << stru.sequence_number);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::DataWriterAssociationPeriodic& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.dr_id)
    && (strm >> stru.sequence_number);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::DataWriterAssociationPeriodic> : MetaStruct {
  typedef OpenDDS::DCPS::DataWriterAssociationPeriodic T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::DataWriterAssociationPeriodic& typed = *static_cast<const OpenDDS::DCPS::DataWriterAssociationPeriodic*>(stru);
    if (std::strncmp(field, "dr_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.dr_id, field + 6);
    }
    if (std::strcmp(field, "sequence_number") == 0) {
      return typed.sequence_number;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterAssociationPeriodic)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "dr_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    if (std::strcmp(field, "sequence_number") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'sequence_number' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::DataWriterAssociationPeriodic");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "dr_id.", 6) == 0) {
      return make_struct_cmp(&T::dr_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6), next);
    }
    if (std::strcmp(field, "sequence_number") == 0) {
      return make_field_cmp(&T::sequence_number, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterAssociationPeriodic)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"dr_id", "sequence_number", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "dr_id") == 0) {
      return &static_cast<const T*>(stru)->dr_id;
    }
    if (std::strcmp(field, "sequence_number") == 0) {
      return &static_cast<const T*>(stru)->sequence_number;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterAssociationPeriodic)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "dr_id") == 0) {
      static_cast<T*>(lhs)->dr_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "sequence_number") == 0) {
      static_cast<T*>(lhs)->sequence_number = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterAssociationPeriodic)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "sequence_number") == 0) {
      return static_cast<const T*>(lhs)->sequence_number == static_cast<const T*>(rhs)->sequence_number;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterAssociationPeriodic)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DataWriterAssociationPeriodic>()
{
  static MetaStructImpl<OpenDDS::DCPS::DataWriterAssociationPeriodic> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DataWriterAssociationPeriodic*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::DataWriterAssociationPeriodic>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataWriterAssociationPeriodic */


/* Begin TYPEDEF: DWAssociationsPeriodic */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::DWAssociationsPeriodic& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::DWAssociationsPeriodic& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::DWAssociationsPeriodic& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DWAssociationsPeriodic*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::DataWriterAssociationPeriodic*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: DWAssociationsPeriodic */


/* Begin STRUCT: DataWriterPeriodicReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::DataWriterPeriodicReport& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.dw_id, size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.data_dropped_count);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.data_delivered_count);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.control_dropped_count);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.control_delivered_count);
  gen_find_size(stru.associations, size, padding);
  gen_find_size(stru.values, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::DataWriterPeriodicReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.dw_id)
    && (strm << stru.data_dropped_count)
    && (strm << stru.data_delivered_count)
    && (strm << stru.control_dropped_count)
    && (strm << stru.control_delivered_count)
    && (strm << stru.associations)
    && (strm << stru.values);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::DataWriterPeriodicReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.dw_id)
    && (strm >> stru.data_dropped_count)
    && (strm >> stru.data_delivered_count)
    && (strm >> stru.control_dropped_count)
    && (strm >> stru.control_delivered_count)
    && (strm >> stru.associations)
    && (strm >> stru.values);
}

size_t gen_max_marshaled_size(const OpenDDS::DCPS::DataWriterPeriodicReport& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::DataWriterPeriodicReport> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 16;
}

void gen_find_size(KeyOnly<const OpenDDS::DCPS::DataWriterPeriodicReport> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[11]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[10]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 9]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 8]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 7]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 6]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 5]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 4]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 3]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 2]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 1]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 0]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.entityId.entityKey[2]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.entityId.entityKey[1]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.entityId.entityKey[0]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dw_id.entityId.entityKind));
}

bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::DataWriterPeriodicReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[11]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[10]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 9]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 8]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 7]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 6]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 5]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 4]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 3]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 2]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 1]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.guidPrefix[ 0]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.entityId.entityKey[2]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.entityId.entityKey[1]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.entityId.entityKey[0]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dw_id.entityId.entityKind));
}

bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::DataWriterPeriodicReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[11]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[10]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 9]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 8]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 7]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 6]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 5]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 4]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 3]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 2]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 1]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.guidPrefix[ 0]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.entityId.entityKey[2]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.entityId.entityKey[1]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.entityId.entityKey[0]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dw_id.entityId.entityKind));
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
::DDS::DataWriter_ptr DataWriterPeriodicReportTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<DataWriterPeriodicReport> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr DataWriterPeriodicReportTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<DataWriterPeriodicReport> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr DataWriterPeriodicReportTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<DataWriterPeriodicReport> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<DataWriterPeriodicReport, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& DataWriterPeriodicReportTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<DataWriterPeriodicReport>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool DataWriterPeriodicReportTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* DataWriterPeriodicReportTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
DataWriterPeriodicReportTypeSupport::_ptr_type DataWriterPeriodicReportTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::DataWriterPeriodicReport> : MetaStruct {
  typedef OpenDDS::DCPS::DataWriterPeriodicReport T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 16; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::DataWriterPeriodicReport& typed = *static_cast<const OpenDDS::DCPS::DataWriterPeriodicReport*>(stru);
    if (std::strncmp(field, "dw_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.dw_id, field + 6);
    }
    if (std::strcmp(field, "data_dropped_count") == 0) {
      return typed.data_dropped_count;
    }
    if (std::strcmp(field, "data_delivered_count") == 0) {
      return typed.data_delivered_count;
    }
    if (std::strcmp(field, "control_dropped_count") == 0) {
      return typed.control_dropped_count;
    }
    if (std::strcmp(field, "control_delivered_count") == 0) {
      return typed.control_delivered_count;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterPeriodicReport)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "dw_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    if (std::strcmp(field, "data_dropped_count") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'data_dropped_count' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "data_delivered_count") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'data_delivered_count' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "control_dropped_count") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'control_dropped_count' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "control_delivered_count") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'control_delivered_count' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::DWAssociationsPeriodic*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::NVPSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::DataWriterPeriodicReport");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "dw_id.", 6) == 0) {
      return make_struct_cmp(&T::dw_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6), next);
    }
    if (std::strcmp(field, "data_dropped_count") == 0) {
      return make_field_cmp(&T::data_dropped_count, next);
    }
    if (std::strcmp(field, "data_delivered_count") == 0) {
      return make_field_cmp(&T::data_delivered_count, next);
    }
    if (std::strcmp(field, "control_dropped_count") == 0) {
      return make_field_cmp(&T::control_dropped_count, next);
    }
    if (std::strcmp(field, "control_delivered_count") == 0) {
      return make_field_cmp(&T::control_delivered_count, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterPeriodicReport)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"dw_id", "data_dropped_count", "data_delivered_count", "control_dropped_count", "control_delivered_count", "associations", "values", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "dw_id") == 0) {
      return &static_cast<const T*>(stru)->dw_id;
    }
    if (std::strcmp(field, "data_dropped_count") == 0) {
      return &static_cast<const T*>(stru)->data_dropped_count;
    }
    if (std::strcmp(field, "data_delivered_count") == 0) {
      return &static_cast<const T*>(stru)->data_delivered_count;
    }
    if (std::strcmp(field, "control_dropped_count") == 0) {
      return &static_cast<const T*>(stru)->control_dropped_count;
    }
    if (std::strcmp(field, "control_delivered_count") == 0) {
      return &static_cast<const T*>(stru)->control_delivered_count;
    }
    if (std::strcmp(field, "associations") == 0) {
      return &static_cast<const T*>(stru)->associations;
    }
    if (std::strcmp(field, "values") == 0) {
      return &static_cast<const T*>(stru)->values;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterPeriodicReport)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "dw_id") == 0) {
      static_cast<T*>(lhs)->dw_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "data_dropped_count") == 0) {
      static_cast<T*>(lhs)->data_dropped_count = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "data_delivered_count") == 0) {
      static_cast<T*>(lhs)->data_delivered_count = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "control_dropped_count") == 0) {
      static_cast<T*>(lhs)->control_dropped_count = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "control_delivered_count") == 0) {
      static_cast<T*>(lhs)->control_delivered_count = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "associations") == 0) {
      static_cast<T*>(lhs)->associations = *static_cast<const OpenDDS::DCPS::DWAssociationsPeriodic*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "values") == 0) {
      static_cast<T*>(lhs)->values = *static_cast<const OpenDDS::DCPS::NVPSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterPeriodicReport)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "data_dropped_count") == 0) {
      return static_cast<const T*>(lhs)->data_dropped_count == static_cast<const T*>(rhs)->data_dropped_count;
    }
    if (std::strcmp(field, "data_delivered_count") == 0) {
      return static_cast<const T*>(lhs)->data_delivered_count == static_cast<const T*>(rhs)->data_delivered_count;
    }
    if (std::strcmp(field, "control_dropped_count") == 0) {
      return static_cast<const T*>(lhs)->control_dropped_count == static_cast<const T*>(rhs)->control_dropped_count;
    }
    if (std::strcmp(field, "control_delivered_count") == 0) {
      return static_cast<const T*>(lhs)->control_delivered_count == static_cast<const T*>(rhs)->control_delivered_count;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataWriterPeriodicReport)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DataWriterPeriodicReport>()
{
  static MetaStructImpl<OpenDDS::DCPS::DataWriterPeriodicReport> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DataWriterPeriodicReport*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::DataWriterPeriodicReport>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataWriterPeriodicReport */


/* Begin STRUCT: DataReaderAssociation */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::DataReaderAssociation& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.dw_id, size, padding);
  if ((size + padding) % 2) {
    padding += 2 - ((size + padding) % 2);
  }
  size += gen_max_marshaled_size(stru.state);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::DataReaderAssociation& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.dw_id)
    && (strm << stru.state);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::DataReaderAssociation& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.dw_id)
    && (strm >> stru.state);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::DataReaderAssociation> : MetaStruct {
  typedef OpenDDS::DCPS::DataReaderAssociation T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::DataReaderAssociation& typed = *static_cast<const OpenDDS::DCPS::DataReaderAssociation*>(stru);
    if (std::strncmp(field, "dw_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.dw_id, field + 6);
    }
    if (std::strcmp(field, "state") == 0) {
      return typed.state;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderAssociation)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "dw_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    if (std::strcmp(field, "state") == 0) {
      ACE_CDR::Short val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'state' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 2);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::DataReaderAssociation");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "dw_id.", 6) == 0) {
      return make_struct_cmp(&T::dw_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6), next);
    }
    if (std::strcmp(field, "state") == 0) {
      return make_field_cmp(&T::state, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderAssociation)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"dw_id", "state", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "dw_id") == 0) {
      return &static_cast<const T*>(stru)->dw_id;
    }
    if (std::strcmp(field, "state") == 0) {
      return &static_cast<const T*>(stru)->state;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderAssociation)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "dw_id") == 0) {
      static_cast<T*>(lhs)->dw_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "state") == 0) {
      static_cast<T*>(lhs)->state = *static_cast<const CORBA::Short*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderAssociation)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "state") == 0) {
      return static_cast<const T*>(lhs)->state == static_cast<const T*>(rhs)->state;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderAssociation)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DataReaderAssociation>()
{
  static MetaStructImpl<OpenDDS::DCPS::DataReaderAssociation> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DataReaderAssociation*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::DataReaderAssociation>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataReaderAssociation */


/* Begin TYPEDEF: DRAssociations */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::DRAssociations& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::DRAssociations& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::DRAssociations& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DRAssociations*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::DataReaderAssociation*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: DRAssociations */


/* Begin STRUCT: DataReaderReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::DataReaderReport& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.dp_id, size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.sub_handle);
  gen_find_size(stru.dr_id, size, padding);
  gen_find_size(stru.topic_id, size, padding);
  gen_find_size(stru.instances, size, padding);
  gen_find_size(stru.associations, size, padding);
  gen_find_size(stru.values, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::DataReaderReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.dp_id)
    && (strm << stru.sub_handle)
    && (strm << stru.dr_id)
    && (strm << stru.topic_id)
    && (strm << stru.instances)
    && (strm << stru.associations)
    && (strm << stru.values);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::DataReaderReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.dp_id)
    && (strm >> stru.sub_handle)
    && (strm >> stru.dr_id)
    && (strm >> stru.topic_id)
    && (strm >> stru.instances)
    && (strm >> stru.associations)
    && (strm >> stru.values);
}

size_t gen_max_marshaled_size(const OpenDDS::DCPS::DataReaderReport& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::DataReaderReport> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 16;
}

void gen_find_size(KeyOnly<const OpenDDS::DCPS::DataReaderReport> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[11]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[10]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 9]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 8]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 7]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 6]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 5]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 4]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 3]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 2]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 1]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 0]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.entityId.entityKey[2]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.entityId.entityKey[1]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.entityId.entityKey[0]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.entityId.entityKind));
}

bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::DataReaderReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[11]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[10]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 9]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 8]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 7]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 6]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 5]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 4]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 3]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 2]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 1]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 0]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.entityId.entityKey[2]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.entityId.entityKey[1]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.entityId.entityKey[0]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.entityId.entityKind));
}

bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::DataReaderReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[11]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[10]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 9]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 8]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 7]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 6]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 5]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 4]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 3]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 2]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 1]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 0]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.entityId.entityKey[2]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.entityId.entityKey[1]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.entityId.entityKey[0]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.entityId.entityKind));
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
::DDS::DataWriter_ptr DataReaderReportTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<DataReaderReport> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr DataReaderReportTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<DataReaderReport> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr DataReaderReportTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<DataReaderReport> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<DataReaderReport, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& DataReaderReportTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<DataReaderReport>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool DataReaderReportTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* DataReaderReportTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
DataReaderReportTypeSupport::_ptr_type DataReaderReportTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::DataReaderReport> : MetaStruct {
  typedef OpenDDS::DCPS::DataReaderReport T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 16; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::DataReaderReport& typed = *static_cast<const OpenDDS::DCPS::DataReaderReport*>(stru);
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.dp_id, field + 6);
    }
    if (std::strcmp(field, "sub_handle") == 0) {
      return typed.sub_handle;
    }
    if (std::strncmp(field, "dr_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.dr_id, field + 6);
    }
    if (std::strncmp(field, "topic_id.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.topic_id, field + 9);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderReport)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    if (std::strcmp(field, "sub_handle") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'sub_handle' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strncmp(field, "dr_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    if (std::strncmp(field, "topic_id.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    gen_skip_over(ser, static_cast<DDS::InstanceHandleSeq*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::DRAssociations*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::NVPSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::DataReaderReport");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "dp_id.", 6) == 0) {
      return make_struct_cmp(&T::dp_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6), next);
    }
    if (std::strcmp(field, "sub_handle") == 0) {
      return make_field_cmp(&T::sub_handle, next);
    }
    if (std::strncmp(field, "dr_id.", 6) == 0) {
      return make_struct_cmp(&T::dr_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6), next);
    }
    if (std::strncmp(field, "topic_id.", 9) == 0) {
      return make_struct_cmp(&T::topic_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 9), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderReport)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"dp_id", "sub_handle", "dr_id", "topic_id", "instances", "associations", "values", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "dp_id") == 0) {
      return &static_cast<const T*>(stru)->dp_id;
    }
    if (std::strcmp(field, "sub_handle") == 0) {
      return &static_cast<const T*>(stru)->sub_handle;
    }
    if (std::strcmp(field, "dr_id") == 0) {
      return &static_cast<const T*>(stru)->dr_id;
    }
    if (std::strcmp(field, "topic_id") == 0) {
      return &static_cast<const T*>(stru)->topic_id;
    }
    if (std::strcmp(field, "instances") == 0) {
      return &static_cast<const T*>(stru)->instances;
    }
    if (std::strcmp(field, "associations") == 0) {
      return &static_cast<const T*>(stru)->associations;
    }
    if (std::strcmp(field, "values") == 0) {
      return &static_cast<const T*>(stru)->values;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderReport)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "dp_id") == 0) {
      static_cast<T*>(lhs)->dp_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "sub_handle") == 0) {
      static_cast<T*>(lhs)->sub_handle = *static_cast<const DDS::InstanceHandle_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "dr_id") == 0) {
      static_cast<T*>(lhs)->dr_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "topic_id") == 0) {
      static_cast<T*>(lhs)->topic_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "instances") == 0) {
      static_cast<T*>(lhs)->instances = *static_cast<const DDS::InstanceHandleSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "associations") == 0) {
      static_cast<T*>(lhs)->associations = *static_cast<const OpenDDS::DCPS::DRAssociations*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "values") == 0) {
      static_cast<T*>(lhs)->values = *static_cast<const OpenDDS::DCPS::NVPSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderReport)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "sub_handle") == 0) {
      return static_cast<const T*>(lhs)->sub_handle == static_cast<const T*>(rhs)->sub_handle;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderReport)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DataReaderReport>()
{
  static MetaStructImpl<OpenDDS::DCPS::DataReaderReport> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DataReaderReport*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::DataReaderReport>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataReaderReport */


/* Begin STRUCT: DataReaderAssociationPeriodic */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::DataReaderAssociationPeriodic& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.dw_id, size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.samples_available);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::DataReaderAssociationPeriodic& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.dw_id)
    && (strm << stru.samples_available);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::DataReaderAssociationPeriodic& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.dw_id)
    && (strm >> stru.samples_available);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::DataReaderAssociationPeriodic> : MetaStruct {
  typedef OpenDDS::DCPS::DataReaderAssociationPeriodic T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::DataReaderAssociationPeriodic& typed = *static_cast<const OpenDDS::DCPS::DataReaderAssociationPeriodic*>(stru);
    if (std::strncmp(field, "dw_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.dw_id, field + 6);
    }
    if (std::strcmp(field, "samples_available") == 0) {
      return typed.samples_available;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderAssociationPeriodic)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "dw_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    if (std::strcmp(field, "samples_available") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'samples_available' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::DataReaderAssociationPeriodic");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "dw_id.", 6) == 0) {
      return make_struct_cmp(&T::dw_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6), next);
    }
    if (std::strcmp(field, "samples_available") == 0) {
      return make_field_cmp(&T::samples_available, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderAssociationPeriodic)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"dw_id", "samples_available", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "dw_id") == 0) {
      return &static_cast<const T*>(stru)->dw_id;
    }
    if (std::strcmp(field, "samples_available") == 0) {
      return &static_cast<const T*>(stru)->samples_available;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderAssociationPeriodic)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "dw_id") == 0) {
      static_cast<T*>(lhs)->dw_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "samples_available") == 0) {
      static_cast<T*>(lhs)->samples_available = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderAssociationPeriodic)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "samples_available") == 0) {
      return static_cast<const T*>(lhs)->samples_available == static_cast<const T*>(rhs)->samples_available;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderAssociationPeriodic)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DataReaderAssociationPeriodic>()
{
  static MetaStructImpl<OpenDDS::DCPS::DataReaderAssociationPeriodic> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DataReaderAssociationPeriodic*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::DataReaderAssociationPeriodic>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataReaderAssociationPeriodic */


/* Begin TYPEDEF: DRAssociationsPeriodic */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::DRAssociationsPeriodic& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::DRAssociationsPeriodic& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::DRAssociationsPeriodic& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DRAssociationsPeriodic*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::DataReaderAssociationPeriodic*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: DRAssociationsPeriodic */


/* Begin STRUCT: DataReaderPeriodicReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::DataReaderPeriodicReport& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.dr_id, size, padding);
  gen_find_size(stru.associations, size, padding);
  gen_find_size(stru.values, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::DataReaderPeriodicReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.dr_id)
    && (strm << stru.associations)
    && (strm << stru.values);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::DataReaderPeriodicReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.dr_id)
    && (strm >> stru.associations)
    && (strm >> stru.values);
}

size_t gen_max_marshaled_size(const OpenDDS::DCPS::DataReaderPeriodicReport& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::DataReaderPeriodicReport> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 16;
}

void gen_find_size(KeyOnly<const OpenDDS::DCPS::DataReaderPeriodicReport> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[11]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[10]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 9]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 8]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 7]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 6]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 5]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 4]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 3]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 2]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 1]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 0]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.entityId.entityKey[2]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.entityId.entityKey[1]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.entityId.entityKey[0]));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.t.dr_id.entityId.entityKind));
}

bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::DataReaderPeriodicReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[11]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[10]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 9]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 8]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 7]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 6]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 5]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 4]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 3]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 2]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 1]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.guidPrefix[ 0]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.entityId.entityKey[2]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.entityId.entityKey[1]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.entityId.entityKey[0]))
    && (strm << ACE_OutputCDR::from_octet(stru.t.dr_id.entityId.entityKind));
}

bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::DataReaderPeriodicReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[11]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[10]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 9]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 8]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 7]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 6]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 5]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 4]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 3]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 2]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 1]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.guidPrefix[ 0]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.entityId.entityKey[2]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.entityId.entityKey[1]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.entityId.entityKey[0]))
    && (strm >> ACE_InputCDR::to_octet(stru.t.dr_id.entityId.entityKind));
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
::DDS::DataWriter_ptr DataReaderPeriodicReportTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<DataReaderPeriodicReport> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr DataReaderPeriodicReportTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<DataReaderPeriodicReport> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr DataReaderPeriodicReportTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<DataReaderPeriodicReport> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<DataReaderPeriodicReport, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& DataReaderPeriodicReportTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<DataReaderPeriodicReport>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool DataReaderPeriodicReportTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* DataReaderPeriodicReportTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
DataReaderPeriodicReportTypeSupport::_ptr_type DataReaderPeriodicReportTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::DataReaderPeriodicReport> : MetaStruct {
  typedef OpenDDS::DCPS::DataReaderPeriodicReport T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 16; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::DataReaderPeriodicReport& typed = *static_cast<const OpenDDS::DCPS::DataReaderPeriodicReport*>(stru);
    if (std::strncmp(field, "dr_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.dr_id, field + 6);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderPeriodicReport)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "dr_id.", 6) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::DRAssociationsPeriodic*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::NVPSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::DataReaderPeriodicReport");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "dr_id.", 6) == 0) {
      return make_struct_cmp(&T::dr_id, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 6), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderPeriodicReport)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"dr_id", "associations", "values", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "dr_id") == 0) {
      return &static_cast<const T*>(stru)->dr_id;
    }
    if (std::strcmp(field, "associations") == 0) {
      return &static_cast<const T*>(stru)->associations;
    }
    if (std::strcmp(field, "values") == 0) {
      return &static_cast<const T*>(stru)->values;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderPeriodicReport)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "dr_id") == 0) {
      static_cast<T*>(lhs)->dr_id = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "associations") == 0) {
      static_cast<T*>(lhs)->associations = *static_cast<const OpenDDS::DCPS::DRAssociationsPeriodic*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "values") == 0) {
      static_cast<T*>(lhs)->values = *static_cast<const OpenDDS::DCPS::NVPSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderPeriodicReport)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DataReaderPeriodicReport)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DataReaderPeriodicReport>()
{
  static MetaStructImpl<OpenDDS::DCPS::DataReaderPeriodicReport> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::DataReaderPeriodicReport*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::DataReaderPeriodicReport>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataReaderPeriodicReport */


/* Begin STRUCT: TransportReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::TransportReport& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.host.in()) + 1;
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.pid);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.transport_id);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.transport_type.in()) + 1;
  gen_find_size(stru.values, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::TransportReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.host.in())
    && (strm << stru.pid)
    && (strm << stru.transport_id)
    && (strm << stru.transport_type.in())
    && (strm << stru.values);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::TransportReport& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.host.out())
    && (strm >> stru.pid)
    && (strm >> stru.transport_id)
    && (strm >> stru.transport_type.out())
    && (strm >> stru.values);
}

size_t gen_max_marshaled_size(const OpenDDS::DCPS::TransportReport& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const OpenDDS::DCPS::TransportReport> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const OpenDDS::DCPS::TransportReport> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.t.host.in()) + 1;
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.pid);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.transport_id);
}

bool operator<<(Serializer& strm, KeyOnly<const OpenDDS::DCPS::TransportReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.t.host.in())
    && (strm << stru.t.pid)
    && (strm << stru.t.transport_id);
}

bool operator>>(Serializer& strm, KeyOnly<OpenDDS::DCPS::TransportReport> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.t.host.out())
    && (strm >> stru.t.pid)
    && (strm >> stru.t.transport_id);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
::DDS::DataWriter_ptr TransportReportTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<TransportReport> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}
::DDS::DataReader_ptr TransportReportTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<TransportReport> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}
#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr TransportReportTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<TransportReport> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<TransportReport, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& TransportReportTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<TransportReport>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
bool TransportReportTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}
const char* TransportReportTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}
TransportReportTypeSupport::_ptr_type TransportReportTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::TransportReport> : MetaStruct {
  typedef OpenDDS::DCPS::TransportReport T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 3; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::TransportReport& typed = *static_cast<const OpenDDS::DCPS::TransportReport*>(stru);
    if (std::strcmp(field, "host") == 0) {
      return typed.host.in();
    }
    if (std::strcmp(field, "pid") == 0) {
      return typed.pid;
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return typed.transport_id;
    }
    if (std::strcmp(field, "transport_type") == 0) {
      return typed.transport_type.in();
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TransportReport)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "host") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'host' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'host' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strcmp(field, "pid") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'pid' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "transport_id") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'transport_id' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "transport_type") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'transport_type' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'transport_type' length could not be deserialized");
      }
      ser.skip(len);
    }
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::NVPSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::TransportReport");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "host") == 0) {
      return make_field_cmp(&T::host, next);
    }
    if (std::strcmp(field, "pid") == 0) {
      return make_field_cmp(&T::pid, next);
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return make_field_cmp(&T::transport_id, next);
    }
    if (std::strcmp(field, "transport_type") == 0) {
      return make_field_cmp(&T::transport_type, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TransportReport)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"host", "pid", "transport_id", "transport_type", "values", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "host") == 0) {
      return &static_cast<const T*>(stru)->host;
    }
    if (std::strcmp(field, "pid") == 0) {
      return &static_cast<const T*>(stru)->pid;
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return &static_cast<const T*>(stru)->transport_id;
    }
    if (std::strcmp(field, "transport_type") == 0) {
      return &static_cast<const T*>(stru)->transport_type;
    }
    if (std::strcmp(field, "values") == 0) {
      return &static_cast<const T*>(stru)->values;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TransportReport)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "host") == 0) {
      static_cast<T*>(lhs)->host = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "pid") == 0) {
      static_cast<T*>(lhs)->pid = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "transport_id") == 0) {
      static_cast<T*>(lhs)->transport_id = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "transport_type") == 0) {
      static_cast<T*>(lhs)->transport_type = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "values") == 0) {
      static_cast<T*>(lhs)->values = *static_cast<const OpenDDS::DCPS::NVPSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TransportReport)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "host") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->host.in(), static_cast<const T*>(rhs)->host.in());
    }
    if (std::strcmp(field, "pid") == 0) {
      return static_cast<const T*>(lhs)->pid == static_cast<const T*>(rhs)->pid;
    }
    if (std::strcmp(field, "transport_id") == 0) {
      return static_cast<const T*>(lhs)->transport_id == static_cast<const T*>(rhs)->transport_id;
    }
    if (std::strcmp(field, "transport_type") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->transport_type.in(), static_cast<const T*>(rhs)->transport_type.in());
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TransportReport)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::TransportReport>()
{
  static MetaStructImpl<OpenDDS::DCPS::TransportReport> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::TransportReport*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::TransportReport>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TransportReport */


/* Begin ENUM: ReportType */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const OpenDDS::DCPS::ReportType& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::ReportType& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    enumval = static_cast<OpenDDS::DCPS::ReportType>(temp);
    return true;
  }
  return false;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

const char* gen_OpenDDS_DCPS_ReportType_names[] = {
  "SERVICE_PARTICIPANT_REPORT_TYPE",
  "DOMAIN_PARTICIPANT_REPORT_TYPE",
  "TOPIC_REPORT_TYPE",
  "PUBLISHER_REPORT_TYPE",
  "SUBSCRIBER_REPORT_TYPE",
  "DATA_WRITER_REPORT_TYPE",
  "DATA_WRITER_PERIODIC_REPORT_TYPE",
  "DATA_READER_REPORT_TYPE",
  "DATA_READER_PERIODIC_REPORT_TYPE",
  "TRANSPORT_REPORT_TYPE"
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End ENUM: ReportType */


/* Begin UNION: GenericReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::GenericReport& uni, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(uni);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(uni._d());
  switch (uni._d()) {
  case OpenDDS::DCPS::SERVICE_PARTICIPANT_REPORT_TYPE:
    {
      gen_find_size(uni.sp_report(), size, padding);
      break;
    }
  case OpenDDS::DCPS::DOMAIN_PARTICIPANT_REPORT_TYPE:
    {
      gen_find_size(uni.dp_report(), size, padding);
      break;
    }
  case OpenDDS::DCPS::TOPIC_REPORT_TYPE:
    {
      gen_find_size(uni.topic_report(), size, padding);
      break;
    }
  case OpenDDS::DCPS::PUBLISHER_REPORT_TYPE:
    {
      gen_find_size(uni.publisher_report(), size, padding);
      break;
    }
  case OpenDDS::DCPS::SUBSCRIBER_REPORT_TYPE:
    {
      gen_find_size(uni.subscriber_report(), size, padding);
      break;
    }
  case OpenDDS::DCPS::DATA_WRITER_REPORT_TYPE:
    {
      gen_find_size(uni.dw_report(), size, padding);
      break;
    }
  case OpenDDS::DCPS::DATA_WRITER_PERIODIC_REPORT_TYPE:
    {
      gen_find_size(uni.dw_per_report(), size, padding);
      break;
    }
  case OpenDDS::DCPS::DATA_READER_REPORT_TYPE:
    {
      gen_find_size(uni.dr_report(), size, padding);
      break;
    }
  case OpenDDS::DCPS::DATA_READER_PERIODIC_REPORT_TYPE:
    {
      gen_find_size(uni.dr_per_report(), size, padding);
      break;
    }
  case OpenDDS::DCPS::TRANSPORT_REPORT_TYPE:
    {
      gen_find_size(uni.transport_report(), size, padding);
      break;
    }
  default:
    break;
  }
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::GenericReport& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  if (!(strm << uni._d())) {
    return false;
  }
  switch (uni._d()) {
  case OpenDDS::DCPS::SERVICE_PARTICIPANT_REPORT_TYPE:
    {
      return (strm << uni.sp_report());
    }
  case OpenDDS::DCPS::DOMAIN_PARTICIPANT_REPORT_TYPE:
    {
      return (strm << uni.dp_report());
    }
  case OpenDDS::DCPS::TOPIC_REPORT_TYPE:
    {
      return (strm << uni.topic_report());
    }
  case OpenDDS::DCPS::PUBLISHER_REPORT_TYPE:
    {
      return (strm << uni.publisher_report());
    }
  case OpenDDS::DCPS::SUBSCRIBER_REPORT_TYPE:
    {
      return (strm << uni.subscriber_report());
    }
  case OpenDDS::DCPS::DATA_WRITER_REPORT_TYPE:
    {
      return (strm << uni.dw_report());
    }
  case OpenDDS::DCPS::DATA_WRITER_PERIODIC_REPORT_TYPE:
    {
      return (strm << uni.dw_per_report());
    }
  case OpenDDS::DCPS::DATA_READER_REPORT_TYPE:
    {
      return (strm << uni.dr_report());
    }
  case OpenDDS::DCPS::DATA_READER_PERIODIC_REPORT_TYPE:
    {
      return (strm << uni.dr_per_report());
    }
  case OpenDDS::DCPS::TRANSPORT_REPORT_TYPE:
    {
      return (strm << uni.transport_report());
    }
  default:
    break;
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::GenericReport& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  OpenDDS::DCPS::ReportType disc;
  if (!(strm >> disc)) {
    return false;
  }
  switch (disc) {
  case OpenDDS::DCPS::SERVICE_PARTICIPANT_REPORT_TYPE:
    {
      OpenDDS::DCPS::ServiceParticipantReport tmp;
      if (strm >> tmp) {
        uni.sp_report(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case OpenDDS::DCPS::DOMAIN_PARTICIPANT_REPORT_TYPE:
    {
      OpenDDS::DCPS::DomainParticipantReport tmp;
      if (strm >> tmp) {
        uni.dp_report(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case OpenDDS::DCPS::TOPIC_REPORT_TYPE:
    {
      OpenDDS::DCPS::TopicReport tmp;
      if (strm >> tmp) {
        uni.topic_report(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case OpenDDS::DCPS::PUBLISHER_REPORT_TYPE:
    {
      OpenDDS::DCPS::PublisherReport tmp;
      if (strm >> tmp) {
        uni.publisher_report(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case OpenDDS::DCPS::SUBSCRIBER_REPORT_TYPE:
    {
      OpenDDS::DCPS::SubscriberReport tmp;
      if (strm >> tmp) {
        uni.subscriber_report(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case OpenDDS::DCPS::DATA_WRITER_REPORT_TYPE:
    {
      OpenDDS::DCPS::DataWriterReport tmp;
      if (strm >> tmp) {
        uni.dw_report(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case OpenDDS::DCPS::DATA_WRITER_PERIODIC_REPORT_TYPE:
    {
      OpenDDS::DCPS::DataWriterPeriodicReport tmp;
      if (strm >> tmp) {
        uni.dw_per_report(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case OpenDDS::DCPS::DATA_READER_REPORT_TYPE:
    {
      OpenDDS::DCPS::DataReaderReport tmp;
      if (strm >> tmp) {
        uni.dr_report(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case OpenDDS::DCPS::DATA_READER_PERIODIC_REPORT_TYPE:
    {
      OpenDDS::DCPS::DataReaderPeriodicReport tmp;
      if (strm >> tmp) {
        uni.dr_per_report(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case OpenDDS::DCPS::TRANSPORT_REPORT_TYPE:
    {
      OpenDDS::DCPS::TransportReport tmp;
      if (strm >> tmp) {
        uni.transport_report(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  default:
    uni._d(disc);
    break;
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::DCPS::GenericReport*)
{
  ACE_UNUSED_ARG(ser);
  OpenDDS::DCPS::ReportType disc;
  if (!(ser >> disc)) {
    return;
  }
  switch (disc) {
  case OpenDDS::DCPS::SERVICE_PARTICIPANT_REPORT_TYPE:
    {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::ServiceParticipantReport*>(0));
      break;
    }
  case OpenDDS::DCPS::DOMAIN_PARTICIPANT_REPORT_TYPE:
    {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::DomainParticipantReport*>(0));
      break;
    }
  case OpenDDS::DCPS::TOPIC_REPORT_TYPE:
    {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::TopicReport*>(0));
      break;
    }
  case OpenDDS::DCPS::PUBLISHER_REPORT_TYPE:
    {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::PublisherReport*>(0));
      break;
    }
  case OpenDDS::DCPS::SUBSCRIBER_REPORT_TYPE:
    {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::SubscriberReport*>(0));
      break;
    }
  case OpenDDS::DCPS::DATA_WRITER_REPORT_TYPE:
    {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::DataWriterReport*>(0));
      break;
    }
  case OpenDDS::DCPS::DATA_WRITER_PERIODIC_REPORT_TYPE:
    {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::DataWriterPeriodicReport*>(0));
      break;
    }
  case OpenDDS::DCPS::DATA_READER_REPORT_TYPE:
    {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::DataReaderReport*>(0));
      break;
    }
  case OpenDDS::DCPS::DATA_READER_PERIODIC_REPORT_TYPE:
    {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::DataReaderPeriodicReport*>(0));
      break;
    }
  case OpenDDS::DCPS::TRANSPORT_REPORT_TYPE:
    {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::TransportReport*>(0));
      break;
    }
  default:
    break;
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End UNION: GenericReport */


/* Begin INTERFACE: ProcessMonitor */


/* End INTERFACE: ProcessMonitor */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */
