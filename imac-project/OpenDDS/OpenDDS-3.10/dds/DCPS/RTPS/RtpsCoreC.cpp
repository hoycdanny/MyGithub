// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.2a_p11
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// be/be_codegen.cpp:376


#include "RtpsCoreC.h"
#include "tao/CDR.h"
#include "ace/OS_NS_string.h"

#if !defined (__ACE_INLINE__)
#include "RtpsCoreC.inl"
#endif /* !defined INLINE */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:97

OpenDDS::RTPS::OctetArray2_slice *
OpenDDS::RTPS::OctetArray2_dup (const OpenDDS::RTPS::OctetArray2_slice *_tao_src_array)
{
  OpenDDS::RTPS::OctetArray2_slice *_tao_dup_array =
    OpenDDS::RTPS::OctetArray2_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <OpenDDS::RTPS::OctetArray2_slice *> (0);
    }
  
  OpenDDS::RTPS::OctetArray2_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

OpenDDS::RTPS::OctetArray2_slice *
OpenDDS::RTPS::OctetArray2_alloc (void)
{
  OpenDDS::RTPS::OctetArray2_slice *retval = 0;
  ACE_NEW_RETURN (retval, ::CORBA::Octet[2], 0);
  return retval;
}

void
OpenDDS::RTPS::OctetArray2_free (
    OpenDDS::RTPS::OctetArray2_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
OpenDDS::RTPS::OctetArray2_copy (
    OpenDDS::RTPS::OctetArray2_slice * _tao_to,
    const OpenDDS::RTPS::OctetArray2_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 2; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:97

OpenDDS::RTPS::OctetArray4_slice *
OpenDDS::RTPS::OctetArray4_dup (const OpenDDS::RTPS::OctetArray4_slice *_tao_src_array)
{
  OpenDDS::RTPS::OctetArray4_slice *_tao_dup_array =
    OpenDDS::RTPS::OctetArray4_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <OpenDDS::RTPS::OctetArray4_slice *> (0);
    }
  
  OpenDDS::RTPS::OctetArray4_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

OpenDDS::RTPS::OctetArray4_slice *
OpenDDS::RTPS::OctetArray4_alloc (void)
{
  OpenDDS::RTPS::OctetArray4_slice *retval = 0;
  ACE_NEW_RETURN (retval, ::CORBA::Octet[4], 0);
  return retval;
}

void
OpenDDS::RTPS::OctetArray4_free (
    OpenDDS::RTPS::OctetArray4_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
OpenDDS::RTPS::OctetArray4_copy (
    OpenDDS::RTPS::OctetArray4_slice * _tao_to,
    const OpenDDS::RTPS::OctetArray4_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 4; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:97

OpenDDS::RTPS::FilterSignature_t_slice *
OpenDDS::RTPS::FilterSignature_t_dup (const OpenDDS::RTPS::FilterSignature_t_slice *_tao_src_array)
{
  OpenDDS::RTPS::FilterSignature_t_slice *_tao_dup_array =
    OpenDDS::RTPS::FilterSignature_t_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <OpenDDS::RTPS::FilterSignature_t_slice *> (0);
    }
  
  OpenDDS::RTPS::FilterSignature_t_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

OpenDDS::RTPS::FilterSignature_t_slice *
OpenDDS::RTPS::FilterSignature_t_alloc (void)
{
  OpenDDS::RTPS::FilterSignature_t_slice *retval = 0;
  ACE_NEW_RETURN (retval, ::CORBA::Long[4], 0);
  return retval;
}

void
OpenDDS::RTPS::FilterSignature_t_free (
    OpenDDS::RTPS::FilterSignature_t_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
OpenDDS::RTPS::FilterSignature_t_copy (
    OpenDDS::RTPS::FilterSignature_t_slice * _tao_to,
    const OpenDDS::RTPS::FilterSignature_t_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 4; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:73

#if !defined (_OPENDDS_RTPS_FILTERRESULT_T_CS_)
#define _OPENDDS_RTPS_FILTERRESULT_T_CS_

OpenDDS::RTPS::FilterResult_t::FilterResult_t (void)
{}

OpenDDS::RTPS::FilterResult_t::FilterResult_t (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Long
      > (max)
{}

OpenDDS::RTPS::FilterResult_t::FilterResult_t (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Long * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Long
      >
    (max, length, buffer, release)
{}

OpenDDS::RTPS::FilterResult_t::FilterResult_t (
    const FilterResult_t &seq)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Long
      > (seq)
{}

OpenDDS::RTPS::FilterResult_t::~FilterResult_t (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:73

#if !defined (_OPENDDS_RTPS_FILTERSIGNATURESEQ_CS_)
#define _OPENDDS_RTPS_FILTERSIGNATURESEQ_CS_

OpenDDS::RTPS::FilterSignatureSeq::FilterSignatureSeq (void)
{}

OpenDDS::RTPS::FilterSignatureSeq::FilterSignatureSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_array_sequence<
        FilterSignature_t,
        FilterSignature_t_slice,
        FilterSignature_t_tag
      > (max)
{}

OpenDDS::RTPS::FilterSignatureSeq::FilterSignatureSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    OpenDDS::RTPS::FilterSignature_t * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_array_sequence<
        FilterSignature_t,
        FilterSignature_t_slice,
        FilterSignature_t_tag
      >
    (max, length, buffer, release)
{}

OpenDDS::RTPS::FilterSignatureSeq::FilterSignatureSeq (
    const FilterSignatureSeq &seq)
  : ::TAO::unbounded_array_sequence<
        FilterSignature_t,
        FilterSignature_t_slice,
        FilterSignature_t_tag
      > (seq)
{}

OpenDDS::RTPS::FilterSignatureSeq::~FilterSignatureSeq (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:73

#if !defined (_OPENDDS_RTPS_PROPERTYSEQ_CS_)
#define _OPENDDS_RTPS_PROPERTYSEQ_CS_

OpenDDS::RTPS::PropertySeq::PropertySeq (void)
{}

OpenDDS::RTPS::PropertySeq::PropertySeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        Property_t
      > (max)
{}

OpenDDS::RTPS::PropertySeq::PropertySeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    OpenDDS::RTPS::Property_t * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        Property_t
      >
    (max, length, buffer, release)
{}

OpenDDS::RTPS::PropertySeq::PropertySeq (
    const PropertySeq &seq)
  : ::TAO::unbounded_value_sequence<
        Property_t
      > (seq)
{}

OpenDDS::RTPS::PropertySeq::~PropertySeq (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:73

#if !defined (_OPENDDS_RTPS_LONGSEQ8_CS_)
#define _OPENDDS_RTPS_LONGSEQ8_CS_

OpenDDS::RTPS::LongSeq8::LongSeq8 (void)
{}

OpenDDS::RTPS::LongSeq8::LongSeq8 (
    ::CORBA::ULong length,
    ::CORBA::Long * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::bounded_value_sequence<
        ::CORBA::Long,
        8
      >
    (length, buffer, release)
{}

OpenDDS::RTPS::LongSeq8::LongSeq8 (
    const LongSeq8 &seq)
  : ::TAO::bounded_value_sequence<
        ::CORBA::Long,
        8
      > (seq)
{}

OpenDDS::RTPS::LongSeq8::~LongSeq8 (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:73

#if !defined (_OPENDDS_RTPS_LOCATORLIST_CS_)
#define _OPENDDS_RTPS_LOCATORLIST_CS_

OpenDDS::RTPS::LocatorList::LocatorList (void)
{}

OpenDDS::RTPS::LocatorList::LocatorList (
    ::CORBA::ULong length,
    OpenDDS::DCPS::Locator_t * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::bounded_value_sequence<
        OpenDDS::DCPS::Locator_t,
        8
      >
    (length, buffer, release)
{}

OpenDDS::RTPS::LocatorList::LocatorList (
    const LocatorList &seq)
  : ::TAO::bounded_value_sequence<
        OpenDDS::DCPS::Locator_t,
        8
      > (seq)
{}

OpenDDS::RTPS::LocatorList::~LocatorList (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:73

#if !defined (_OPENDDS_RTPS_PARAMETERLIST_CS_)
#define _OPENDDS_RTPS_PARAMETERLIST_CS_

OpenDDS::RTPS::ParameterList::ParameterList (void)
{}

OpenDDS::RTPS::ParameterList::ParameterList (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        Parameter
      > (max)
{}

OpenDDS::RTPS::ParameterList::ParameterList (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    OpenDDS::RTPS::Parameter * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        Parameter
      >
    (max, length, buffer, release)
{}

OpenDDS::RTPS::ParameterList::ParameterList (
    const ParameterList &seq)
  : ::TAO::unbounded_value_sequence<
        Parameter
      > (seq)
{}

OpenDDS::RTPS::ParameterList::~ParameterList (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_union/union_cs.cpp:79

OpenDDS::RTPS::Parameter::Parameter (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = 0;
}

OpenDDS::RTPS::Parameter::Parameter (const ::OpenDDS::RTPS::Parameter &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case 5U:
    case 7U:
    {
      this->u_.string_data_ = ::CORBA::string_dup (u.u_.string_data_);
    }
    break;
    case 44U:
    {
      if (u.u_.user_data_ == 0)
        {
          this->u_.user_data_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.user_data_,
              DDS::UserDataQosPolicy (*u.u_.user_data_)
            );
        }
    }
    break;
    case 45U:
    {
      if (u.u_.group_data_ == 0)
        {
          this->u_.group_data_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.group_data_,
              DDS::GroupDataQosPolicy (*u.u_.group_data_)
            );
        }
    }
    break;
    case 46U:
    {
      if (u.u_.topic_data_ == 0)
        {
          this->u_.topic_data_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.topic_data_,
              DDS::TopicDataQosPolicy (*u.u_.topic_data_)
            );
        }
    }
    break;
    case 29U:
    {
      this->u_.durability_ = u.u_.durability_;
    }
    break;
    case 30U:
    {
      this->u_.durability_service_ = u.u_.durability_service_;
    }
    break;
    case 35U:
    {
      this->u_.deadline_ = u.u_.deadline_;
    }
    break;
    case 39U:
    {
      this->u_.latency_budget_ = u.u_.latency_budget_;
    }
    break;
    case 27U:
    {
      this->u_.liveliness_ = u.u_.liveliness_;
    }
    break;
    case 26U:
    {
      this->u_.reliability_ = u.u_.reliability_;
    }
    break;
    case 43U:
    {
      this->u_.lifespan_ = u.u_.lifespan_;
    }
    break;
    case 37U:
    {
      this->u_.destination_order_ = u.u_.destination_order_;
    }
    break;
    case 64U:
    {
      this->u_.history_ = u.u_.history_;
    }
    break;
    case 65U:
    {
      this->u_.resource_limits_ = u.u_.resource_limits_;
    }
    break;
    case 31U:
    {
      this->u_.ownership_ = u.u_.ownership_;
    }
    break;
    case 6U:
    {
      this->u_.ownership_strength_ = u.u_.ownership_strength_;
    }
    break;
    case 33U:
    {
      this->u_.presentation_ = u.u_.presentation_;
    }
    break;
    case 41U:
    {
      if (u.u_.partition_ == 0)
        {
          this->u_.partition_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.partition_,
              DDS::PartitionQosPolicy (*u.u_.partition_)
            );
        }
    }
    break;
    case 4U:
    {
      this->u_.time_based_filter_ = u.u_.time_based_filter_;
    }
    break;
    case 73U:
    {
      this->u_.transport_priority_ = u.u_.transport_priority_;
    }
    break;
    case 21U:
    {
      this->u_.version_ = u.u_.version_;
    }
    break;
    case 22U:
    {
      this->u_.vendor_ = u.u_.vendor_;
    }
    break;
    case 47U:
    case 48U:
    case 49U:
    case 72U:
    case 50U:
    case 51U:
    {
      this->u_.locator_ = u.u_.locator_;
    }
    break;
    case 17U:
    case 12U:
    case 69U:
    case 11U:
    {
      this->u_.ipv4_address_ = u.u_.ipv4_address_;
    }
    break;
    case 14U:
    case 13U:
    case 70U:
    {
      this->u_.udpv4_port_ = u.u_.udpv4_port_;
    }
    break;
    case 67U:
    {
      this->u_.expects_inline_qos_ = u.u_.expects_inline_qos_;
    }
    break;
    case 52U:
    {
      this->u_.count_ = u.u_.count_;
    }
    break;
    case 68U:
    {
      this->u_.participant_builtin_endpoints_ = u.u_.participant_builtin_endpoints_;
    }
    break;
    case 2U:
    {
      this->u_.duration_ = u.u_.duration_;
    }
    break;
    case 53U:
    {
      if (u.u_.content_filter_property_ == 0)
        {
          this->u_.content_filter_property_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.content_filter_property_,
              OpenDDS::DCPS::ContentFilterProperty_t (*u.u_.content_filter_property_)
            );
        }
    }
    break;
    case 80U:
    case 90U:
    case 82U:
    case 45058U:
    {
      this->u_.guid_ = u.u_.guid_;
    }
    break;
    case 81U:
    case 83U:
    {
      this->u_.entity_id_ = u.u_.entity_id_;
    }
    break;
    case 88U:
    {
      this->u_.builtin_endpoints_ = u.u_.builtin_endpoints_;
    }
    break;
    case 89U:
    {
      if (u.u_.properties_ == 0)
        {
          this->u_.properties_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.properties_,
              OpenDDS::RTPS::PropertySeq (*u.u_.properties_)
            );
        }
    }
    break;
    case 96U:
    {
      this->u_.type_max_size_serialized_ = u.u_.type_max_size_serialized_;
    }
    break;
    case 98U:
    {
      if (u.u_.entity_name_ == 0)
        {
          this->u_.entity_name_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.entity_name_,
              OpenDDS::RTPS::EntityName_t (*u.u_.entity_name_)
            );
        }
    }
    break;
    case 112U:
    {
      this->u_.key_hash_ = u.u_.key_hash_;
    }
    break;
    case 113U:
    {
      this->u_.status_info_ = u.u_.status_info_;
    }
    break;
    case 85U:
    {
      if (u.u_.content_filter_info_ == 0)
        {
          this->u_.content_filter_info_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.content_filter_info_,
              OpenDDS::RTPS::ContentFilterInfo_t (*u.u_.content_filter_info_)
            );
        }
    }
    break;
    case 86U:
    {
      this->u_.coherent_set_ = u.u_.coherent_set_;
    }
    break;
    case 87U:
    {
      if (u.u_.directed_write_ == 0)
        {
          this->u_.directed_write_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.directed_write_,
              OpenDDS::DCPS::GUIDSeq (*u.u_.directed_write_)
            );
        }
    }
    break;
    case 97U:
    {
      if (u.u_.original_writer_info_ == 0)
        {
          this->u_.original_writer_info_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.original_writer_info_,
              OpenDDS::RTPS::OriginalWriterInfo_t (*u.u_.original_writer_info_)
            );
        }
    }
    break;
    case 45057U:
    {
      if (u.u_.opendds_locator_ == 0)
        {
          this->u_.opendds_locator_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.opendds_locator_,
              OpenDDS::DCPS::TransportLocator (*u.u_.opendds_locator_)
            );
        }
    }
    break;
    default:
    {
      if (u.u_.unknown_data_ == 0)
        {
          this->u_.unknown_data_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.unknown_data_,
              DDS::OctetSeq (*u.u_.unknown_data_)
            );
        }
    }
    break;
  }
}

OpenDDS::RTPS::Parameter::~Parameter (void)
{
  // Finalize.
  this->_reset ();
}

OpenDDS::RTPS::Parameter &
OpenDDS::RTPS::Parameter::operator= (const ::OpenDDS::RTPS::Parameter &u)
{
  if (&u == this)
    {
      return *this;
    }
  
  this->_reset ();
  this->disc_ = u.disc_;

  switch (this->disc_)
  {
    case 5U:
    case 7U:
    {
      this->u_.string_data_ = ::CORBA::string_dup (u.u_.string_data_);
    }
    break;
    case 44U:
    {
      if (u.u_.user_data_ == 0)
        {
          this->u_.user_data_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.user_data_,
              DDS::UserDataQosPolicy (*u.u_.user_data_),
              *this
            );
        }
    }
    break;
    case 45U:
    {
      if (u.u_.group_data_ == 0)
        {
          this->u_.group_data_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.group_data_,
              DDS::GroupDataQosPolicy (*u.u_.group_data_),
              *this
            );
        }
    }
    break;
    case 46U:
    {
      if (u.u_.topic_data_ == 0)
        {
          this->u_.topic_data_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.topic_data_,
              DDS::TopicDataQosPolicy (*u.u_.topic_data_),
              *this
            );
        }
    }
    break;
    case 29U:
    {
      this->u_.durability_ = u.u_.durability_;
    }
    break;
    case 30U:
    {
      this->u_.durability_service_ = u.u_.durability_service_;
    }
    break;
    case 35U:
    {
      this->u_.deadline_ = u.u_.deadline_;
    }
    break;
    case 39U:
    {
      this->u_.latency_budget_ = u.u_.latency_budget_;
    }
    break;
    case 27U:
    {
      this->u_.liveliness_ = u.u_.liveliness_;
    }
    break;
    case 26U:
    {
      this->u_.reliability_ = u.u_.reliability_;
    }
    break;
    case 43U:
    {
      this->u_.lifespan_ = u.u_.lifespan_;
    }
    break;
    case 37U:
    {
      this->u_.destination_order_ = u.u_.destination_order_;
    }
    break;
    case 64U:
    {
      this->u_.history_ = u.u_.history_;
    }
    break;
    case 65U:
    {
      this->u_.resource_limits_ = u.u_.resource_limits_;
    }
    break;
    case 31U:
    {
      this->u_.ownership_ = u.u_.ownership_;
    }
    break;
    case 6U:
    {
      this->u_.ownership_strength_ = u.u_.ownership_strength_;
    }
    break;
    case 33U:
    {
      this->u_.presentation_ = u.u_.presentation_;
    }
    break;
    case 41U:
    {
      if (u.u_.partition_ == 0)
        {
          this->u_.partition_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.partition_,
              DDS::PartitionQosPolicy (*u.u_.partition_),
              *this
            );
        }
    }
    break;
    case 4U:
    {
      this->u_.time_based_filter_ = u.u_.time_based_filter_;
    }
    break;
    case 73U:
    {
      this->u_.transport_priority_ = u.u_.transport_priority_;
    }
    break;
    case 21U:
    {
      this->u_.version_ = u.u_.version_;
    }
    break;
    case 22U:
    {
      this->u_.vendor_ = u.u_.vendor_;
    }
    break;
    case 47U:
    case 48U:
    case 49U:
    case 72U:
    case 50U:
    case 51U:
    {
      this->u_.locator_ = u.u_.locator_;
    }
    break;
    case 17U:
    case 12U:
    case 69U:
    case 11U:
    {
      this->u_.ipv4_address_ = u.u_.ipv4_address_;
    }
    break;
    case 14U:
    case 13U:
    case 70U:
    {
      this->u_.udpv4_port_ = u.u_.udpv4_port_;
    }
    break;
    case 67U:
    {
      this->u_.expects_inline_qos_ = u.u_.expects_inline_qos_;
    }
    break;
    case 52U:
    {
      this->u_.count_ = u.u_.count_;
    }
    break;
    case 68U:
    {
      this->u_.participant_builtin_endpoints_ = u.u_.participant_builtin_endpoints_;
    }
    break;
    case 2U:
    {
      this->u_.duration_ = u.u_.duration_;
    }
    break;
    case 53U:
    {
      if (u.u_.content_filter_property_ == 0)
        {
          this->u_.content_filter_property_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.content_filter_property_,
              OpenDDS::DCPS::ContentFilterProperty_t (*u.u_.content_filter_property_),
              *this
            );
        }
    }
    break;
    case 80U:
    case 90U:
    case 82U:
    case 45058U:
    {
      this->u_.guid_ = u.u_.guid_;
    }
    break;
    case 81U:
    case 83U:
    {
      this->u_.entity_id_ = u.u_.entity_id_;
    }
    break;
    case 88U:
    {
      this->u_.builtin_endpoints_ = u.u_.builtin_endpoints_;
    }
    break;
    case 89U:
    {
      if (u.u_.properties_ == 0)
        {
          this->u_.properties_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.properties_,
              OpenDDS::RTPS::PropertySeq (*u.u_.properties_),
              *this
            );
        }
    }
    break;
    case 96U:
    {
      this->u_.type_max_size_serialized_ = u.u_.type_max_size_serialized_;
    }
    break;
    case 98U:
    {
      if (u.u_.entity_name_ == 0)
        {
          this->u_.entity_name_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.entity_name_,
              OpenDDS::RTPS::EntityName_t (*u.u_.entity_name_),
              *this
            );
        }
    }
    break;
    case 112U:
    {
      this->u_.key_hash_ = u.u_.key_hash_;
    }
    break;
    case 113U:
    {
      this->u_.status_info_ = u.u_.status_info_;
    }
    break;
    case 85U:
    {
      if (u.u_.content_filter_info_ == 0)
        {
          this->u_.content_filter_info_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.content_filter_info_,
              OpenDDS::RTPS::ContentFilterInfo_t (*u.u_.content_filter_info_),
              *this
            );
        }
    }
    break;
    case 86U:
    {
      this->u_.coherent_set_ = u.u_.coherent_set_;
    }
    break;
    case 87U:
    {
      if (u.u_.directed_write_ == 0)
        {
          this->u_.directed_write_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.directed_write_,
              OpenDDS::DCPS::GUIDSeq (*u.u_.directed_write_),
              *this
            );
        }
    }
    break;
    case 97U:
    {
      if (u.u_.original_writer_info_ == 0)
        {
          this->u_.original_writer_info_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.original_writer_info_,
              OpenDDS::RTPS::OriginalWriterInfo_t (*u.u_.original_writer_info_),
              *this
            );
        }
    }
    break;
    case 45057U:
    {
      if (u.u_.opendds_locator_ == 0)
        {
          this->u_.opendds_locator_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.opendds_locator_,
              OpenDDS::DCPS::TransportLocator (*u.u_.opendds_locator_),
              *this
            );
        }
    }
    break;
    default:
    {
      if (u.u_.unknown_data_ == 0)
        {
          this->u_.unknown_data_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.unknown_data_,
              DDS::OctetSeq (*u.u_.unknown_data_),
              *this
            );
        }
    }
    break;
  }
  
  return *this;
}

/// Reset method to reset old values of a union.
void OpenDDS::RTPS::Parameter::_reset (void)
{
  switch (this->disc_)
  {
    
    case 5U:
    case 7U:
      ::CORBA::string_free (this->u_.string_data_);
      this->u_.string_data_ = 0;
      
    break;
    
    case 44U:
      delete this->u_.user_data_;
      this->u_.user_data_ = 0;
      
    break;
    
    case 45U:
      delete this->u_.group_data_;
      this->u_.group_data_ = 0;
      
    break;
    
    case 46U:
      delete this->u_.topic_data_;
      this->u_.topic_data_ = 0;
      
    break;
    
    case 29U:
      
    break;
    
    case 30U:
      
    break;
    
    case 35U:
      
    break;
    
    case 39U:
      
    break;
    
    case 27U:
      
    break;
    
    case 26U:
      
    break;
    
    case 43U:
      
    break;
    
    case 37U:
      
    break;
    
    case 64U:
      
    break;
    
    case 65U:
      
    break;
    
    case 31U:
      
    break;
    
    case 6U:
      
    break;
    
    case 33U:
      
    break;
    
    case 41U:
      delete this->u_.partition_;
      this->u_.partition_ = 0;
      
    break;
    
    case 4U:
      
    break;
    
    case 73U:
      
    break;
    
    case 21U:
      
    break;
    
    case 22U:
      
    break;
    
    case 47U:
    case 48U:
    case 49U:
    case 72U:
    case 50U:
    case 51U:
      
    break;
    
    case 17U:
    case 12U:
    case 69U:
    case 11U:
      
    break;
    
    case 14U:
    case 13U:
    case 70U:
      
    break;
    
    case 67U:
      
    break;
    
    case 52U:
      
    break;
    
    case 68U:
      
    break;
    
    case 2U:
      
    break;
    
    case 53U:
      delete this->u_.content_filter_property_;
      this->u_.content_filter_property_ = 0;
      
    break;
    
    case 80U:
    case 90U:
    case 82U:
    case 45058U:
      
    break;
    
    case 81U:
    case 83U:
      
    break;
    
    case 88U:
      
    break;
    
    case 89U:
      delete this->u_.properties_;
      this->u_.properties_ = 0;
      
    break;
    
    case 96U:
      
    break;
    
    case 98U:
      delete this->u_.entity_name_;
      this->u_.entity_name_ = 0;
      
    break;
    
    case 112U:
      
    break;
    
    case 113U:
      
    break;
    
    case 85U:
      delete this->u_.content_filter_info_;
      this->u_.content_filter_info_ = 0;
      
    break;
    
    case 86U:
      
    break;
    
    case 87U:
      delete this->u_.directed_write_;
      this->u_.directed_write_ = 0;
      
    break;
    
    case 97U:
      delete this->u_.original_writer_info_;
      this->u_.original_writer_info_ = 0;
      
    break;
    
    case 45057U:
      delete this->u_.opendds_locator_;
      this->u_.opendds_locator_ = 0;
      
    break;
    
    default:
      delete this->u_.unknown_data_;
      this->u_.unknown_data_ = 0;
      
    break;
    
  }
}

// TAO_IDL - Generated from
// be/be_visitor_union/union_cs.cpp:79

OpenDDS::RTPS::Submessage::Submessage (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = OpenDDS::RTPS::RESERVED_0;
}

OpenDDS::RTPS::Submessage::Submessage (const ::OpenDDS::RTPS::Submessage &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case OpenDDS::RTPS::PAD:
    {
      this->u_.pad_sm_ = u.u_.pad_sm_;
    }
    break;
    case OpenDDS::RTPS::ACKNACK:
    {
      if (u.u_.acknack_sm_ == 0)
        {
          this->u_.acknack_sm_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.acknack_sm_,
              OpenDDS::RTPS::AckNackSubmessage (*u.u_.acknack_sm_)
            );
        }
    }
    break;
    case OpenDDS::RTPS::HEARTBEAT:
    {
      this->u_.heartbeat_sm_ = u.u_.heartbeat_sm_;
    }
    break;
    case OpenDDS::RTPS::GAP:
    {
      if (u.u_.gap_sm_ == 0)
        {
          this->u_.gap_sm_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.gap_sm_,
              OpenDDS::RTPS::GapSubmessage (*u.u_.gap_sm_)
            );
        }
    }
    break;
    case OpenDDS::RTPS::INFO_TS:
    {
      this->u_.info_ts_sm_ = u.u_.info_ts_sm_;
    }
    break;
    case OpenDDS::RTPS::INFO_SRC:
    {
      this->u_.info_src_sm_ = u.u_.info_src_sm_;
    }
    break;
    case OpenDDS::RTPS::INFO_REPLY_IP4:
    {
      this->u_.info_reply_ipv4_sm_ = u.u_.info_reply_ipv4_sm_;
    }
    break;
    case OpenDDS::RTPS::INFO_DST:
    {
      this->u_.info_dst_sm_ = u.u_.info_dst_sm_;
    }
    break;
    case OpenDDS::RTPS::INFO_REPLY:
    {
      if (u.u_.info_reply_sm_ == 0)
        {
          this->u_.info_reply_sm_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.info_reply_sm_,
              OpenDDS::RTPS::InfoReplySubmessage (*u.u_.info_reply_sm_)
            );
        }
    }
    break;
    case OpenDDS::RTPS::NACK_FRAG:
    {
      if (u.u_.nack_frag_sm_ == 0)
        {
          this->u_.nack_frag_sm_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.nack_frag_sm_,
              OpenDDS::RTPS::NackFragSubmessage (*u.u_.nack_frag_sm_)
            );
        }
    }
    break;
    case OpenDDS::RTPS::HEARTBEAT_FRAG:
    {
      this->u_.hb_frag_sm_ = u.u_.hb_frag_sm_;
    }
    break;
    case OpenDDS::RTPS::DATA:
    {
      if (u.u_.data_sm_ == 0)
        {
          this->u_.data_sm_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.data_sm_,
              OpenDDS::RTPS::DataSubmessage (*u.u_.data_sm_)
            );
        }
    }
    break;
    case OpenDDS::RTPS::DATA_FRAG:
    {
      if (u.u_.data_frag_sm_ == 0)
        {
          this->u_.data_frag_sm_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.data_frag_sm_,
              OpenDDS::RTPS::DataFragSubmessage (*u.u_.data_frag_sm_)
            );
        }
    }
    break;
    default:
    {
      this->u_.unknown_sm_ = u.u_.unknown_sm_;
    }
    break;
  }
}

OpenDDS::RTPS::Submessage::~Submessage (void)
{
  // Finalize.
  this->_reset ();
}

OpenDDS::RTPS::Submessage &
OpenDDS::RTPS::Submessage::operator= (const ::OpenDDS::RTPS::Submessage &u)
{
  if (&u == this)
    {
      return *this;
    }
  
  this->_reset ();
  this->disc_ = u.disc_;

  switch (this->disc_)
  {
    case OpenDDS::RTPS::PAD:
    {
      this->u_.pad_sm_ = u.u_.pad_sm_;
    }
    break;
    case OpenDDS::RTPS::ACKNACK:
    {
      if (u.u_.acknack_sm_ == 0)
        {
          this->u_.acknack_sm_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.acknack_sm_,
              OpenDDS::RTPS::AckNackSubmessage (*u.u_.acknack_sm_),
              *this
            );
        }
    }
    break;
    case OpenDDS::RTPS::HEARTBEAT:
    {
      this->u_.heartbeat_sm_ = u.u_.heartbeat_sm_;
    }
    break;
    case OpenDDS::RTPS::GAP:
    {
      if (u.u_.gap_sm_ == 0)
        {
          this->u_.gap_sm_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.gap_sm_,
              OpenDDS::RTPS::GapSubmessage (*u.u_.gap_sm_),
              *this
            );
        }
    }
    break;
    case OpenDDS::RTPS::INFO_TS:
    {
      this->u_.info_ts_sm_ = u.u_.info_ts_sm_;
    }
    break;
    case OpenDDS::RTPS::INFO_SRC:
    {
      this->u_.info_src_sm_ = u.u_.info_src_sm_;
    }
    break;
    case OpenDDS::RTPS::INFO_REPLY_IP4:
    {
      this->u_.info_reply_ipv4_sm_ = u.u_.info_reply_ipv4_sm_;
    }
    break;
    case OpenDDS::RTPS::INFO_DST:
    {
      this->u_.info_dst_sm_ = u.u_.info_dst_sm_;
    }
    break;
    case OpenDDS::RTPS::INFO_REPLY:
    {
      if (u.u_.info_reply_sm_ == 0)
        {
          this->u_.info_reply_sm_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.info_reply_sm_,
              OpenDDS::RTPS::InfoReplySubmessage (*u.u_.info_reply_sm_),
              *this
            );
        }
    }
    break;
    case OpenDDS::RTPS::NACK_FRAG:
    {
      if (u.u_.nack_frag_sm_ == 0)
        {
          this->u_.nack_frag_sm_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.nack_frag_sm_,
              OpenDDS::RTPS::NackFragSubmessage (*u.u_.nack_frag_sm_),
              *this
            );
        }
    }
    break;
    case OpenDDS::RTPS::HEARTBEAT_FRAG:
    {
      this->u_.hb_frag_sm_ = u.u_.hb_frag_sm_;
    }
    break;
    case OpenDDS::RTPS::DATA:
    {
      if (u.u_.data_sm_ == 0)
        {
          this->u_.data_sm_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.data_sm_,
              OpenDDS::RTPS::DataSubmessage (*u.u_.data_sm_),
              *this
            );
        }
    }
    break;
    case OpenDDS::RTPS::DATA_FRAG:
    {
      if (u.u_.data_frag_sm_ == 0)
        {
          this->u_.data_frag_sm_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.data_frag_sm_,
              OpenDDS::RTPS::DataFragSubmessage (*u.u_.data_frag_sm_),
              *this
            );
        }
    }
    break;
    default:
    {
      this->u_.unknown_sm_ = u.u_.unknown_sm_;
    }
    break;
  }
  
  return *this;
}

/// Reset method to reset old values of a union.
void OpenDDS::RTPS::Submessage::_reset (void)
{
  switch (this->disc_)
  {
    
    case OpenDDS::RTPS::PAD:
      
    break;
    
    case OpenDDS::RTPS::ACKNACK:
      delete this->u_.acknack_sm_;
      this->u_.acknack_sm_ = 0;
      
    break;
    
    case OpenDDS::RTPS::HEARTBEAT:
      
    break;
    
    case OpenDDS::RTPS::GAP:
      delete this->u_.gap_sm_;
      this->u_.gap_sm_ = 0;
      
    break;
    
    case OpenDDS::RTPS::INFO_TS:
      
    break;
    
    case OpenDDS::RTPS::INFO_SRC:
      
    break;
    
    case OpenDDS::RTPS::INFO_REPLY_IP4:
      
    break;
    
    case OpenDDS::RTPS::INFO_DST:
      
    break;
    
    case OpenDDS::RTPS::INFO_REPLY:
      delete this->u_.info_reply_sm_;
      this->u_.info_reply_sm_ = 0;
      
    break;
    
    case OpenDDS::RTPS::NACK_FRAG:
      delete this->u_.nack_frag_sm_;
      this->u_.nack_frag_sm_ = 0;
      
    break;
    
    case OpenDDS::RTPS::HEARTBEAT_FRAG:
      
    break;
    
    case OpenDDS::RTPS::DATA:
      delete this->u_.data_sm_;
      this->u_.data_sm_ = 0;
      
    break;
    
    case OpenDDS::RTPS::DATA_FRAG:
      delete this->u_.data_frag_sm_;
      this->u_.data_frag_sm_ = 0;
      
    break;
    
    default:
      
    break;
    
  }
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:73

#if !defined (_OPENDDS_RTPS_SUBMESSAGESEQ_CS_)
#define _OPENDDS_RTPS_SUBMESSAGESEQ_CS_

OpenDDS::RTPS::SubmessageSeq::SubmessageSeq (void)
{}

OpenDDS::RTPS::SubmessageSeq::SubmessageSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        Submessage
      > (max)
{}

OpenDDS::RTPS::SubmessageSeq::SubmessageSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    OpenDDS::RTPS::Submessage * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        Submessage
      >
    (max, length, buffer, release)
{}

OpenDDS::RTPS::SubmessageSeq::SubmessageSeq (
    const SubmessageSeq &seq)
  : ::TAO::unbounded_value_sequence<
        Submessage
      > (seq)
{}

OpenDDS::RTPS::SubmessageSeq::~SubmessageSeq (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:166



OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::OctetArray2_forany &_tao_array)
{
  return
    strm.write_octet_array (
        reinterpret_cast <const ACE_CDR::Octet *> (_tao_array.in ()),
        2);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::OctetArray2_forany &_tao_array)
{
  return
    strm.read_octet_array (
        reinterpret_cast <ACE_CDR::Octet *> (_tao_array.out ()),
        2);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:166



OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::OctetArray4_forany &_tao_array)
{
  return
    strm.write_octet_array (
        reinterpret_cast <const ACE_CDR::Octet *> (_tao_array.in ()),
        4);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::OctetArray4_forany &_tao_array)
{
  return
    strm.read_octet_array (
        reinterpret_cast <ACE_CDR::Octet *> (_tao_array.out ()),
        4);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:166



OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::FilterSignature_t_forany &_tao_array)
{
  return
    strm.write_long_array (
        reinterpret_cast <const ACE_CDR::Long *> (_tao_array.in ()),
        4);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::FilterSignature_t_forany &_tao_array)
{
  return
    strm.read_long_array (
        reinterpret_cast <ACE_CDR::Long *> (_tao_array.out ()),
        4);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_OpenDDS_RTPS_FilterResult_t_CPP_
#define _TAO_CDR_OP_OpenDDS_RTPS_FilterResult_t_CPP_


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::FilterResult_t &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::FilterResult_t &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_OpenDDS_RTPS_FilterResult_t_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_OpenDDS_RTPS_FilterSignatureSeq_CPP_
#define _TAO_CDR_OP_OpenDDS_RTPS_FilterSignatureSeq_CPP_


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::FilterSignatureSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::FilterSignatureSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_OpenDDS_RTPS_FilterSignatureSeq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::ContentFilterInfo_t &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.filterResult) &&
    (strm << _tao_aggregate.filterSignatures);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::ContentFilterInfo_t &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.filterResult) &&
    (strm >> _tao_aggregate.filterSignatures);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::Property_t &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.value.in ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::Property_t &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.value.out ());
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_OpenDDS_RTPS_PropertySeq_CPP_
#define _TAO_CDR_OP_OpenDDS_RTPS_PropertySeq_CPP_


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::PropertySeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::PropertySeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_OpenDDS_RTPS_PropertySeq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::EntityName_t &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.name.in ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::EntityName_t &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.name.out ());
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::Count_t &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.value);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::Count_t &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.value);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::SequenceNumber_t &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.high) &&
    (strm << _tao_aggregate.low);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::SequenceNumber_t &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.high) &&
    (strm >> _tao_aggregate.low);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_OpenDDS_RTPS_LongSeq8_CPP_
#define _TAO_CDR_OP_OpenDDS_RTPS_LongSeq8_CPP_


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::LongSeq8 &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::LongSeq8 &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_OpenDDS_RTPS_LongSeq8_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::SequenceNumberSet &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.bitmapBase) &&
    (strm << _tao_aggregate.numBits) &&
    (strm << _tao_aggregate.bitmap);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::SequenceNumberSet &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.bitmapBase) &&
    (strm >> _tao_aggregate.numBits) &&
    (strm >> _tao_aggregate.bitmap);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_OpenDDS_RTPS_LocatorList_CPP_
#define _TAO_CDR_OP_OpenDDS_RTPS_LocatorList_CPP_


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::LocatorList &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::LocatorList &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_OpenDDS_RTPS_LocatorList_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::Time_t &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.seconds) &&
    (strm << _tao_aggregate.fraction);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::Time_t &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.seconds) &&
    (strm >> _tao_aggregate.fraction);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::LocatorUDPv4_t &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.address) &&
    (strm << _tao_aggregate.port);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::LocatorUDPv4_t &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.address) &&
    (strm >> _tao_aggregate.port);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::TopicKind_t &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.value);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::TopicKind_t &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.value);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::ReliabilityKind_t &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.value);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::ReliabilityKind_t &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.value);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::KeyHash_t &_tao_aggregate)
{
  OpenDDS::DCPS::OctetArray16_forany _tao_aggregate_value
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::DCPS::OctetArray16_slice*) (
      #else
      (const_cast<
          OpenDDS::DCPS::OctetArray16_slice*> (
      #endif
          _tao_aggregate.value
        )
    );
  return
    (strm << _tao_aggregate_value);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::KeyHash_t &_tao_aggregate)
{
  OpenDDS::DCPS::OctetArray16_forany _tao_aggregate_value
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::DCPS::OctetArray16_slice*) (
      #else
      (const_cast<
          OpenDDS::DCPS::OctetArray16_slice*> (
      #endif
          _tao_aggregate.value
        )
    );
  return
    (strm >> _tao_aggregate_value);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::StatusInfo_t &_tao_aggregate)
{
  OpenDDS::RTPS::OctetArray4_forany _tao_aggregate_value
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::RTPS::OctetArray4_slice*) (
      #else
      (const_cast<
          OpenDDS::RTPS::OctetArray4_slice*> (
      #endif
          _tao_aggregate.value
        )
    );
  return
    (strm << _tao_aggregate_value);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::StatusInfo_t &_tao_aggregate)
{
  OpenDDS::RTPS::OctetArray4_forany _tao_aggregate_value
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::RTPS::OctetArray4_slice*) (
      #else
      (const_cast<
          OpenDDS::RTPS::OctetArray4_slice*> (
      #endif
          _tao_aggregate.value
        )
    );
  return
    (strm >> _tao_aggregate_value);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::ProtocolVersion_t &_tao_aggregate)
{
  return
    (strm << ::ACE_OutputCDR::from_octet (_tao_aggregate.major)) &&
    (strm << ::ACE_OutputCDR::from_octet (_tao_aggregate.minor));
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::ProtocolVersion_t &_tao_aggregate)
{
  return
    (strm >> ::ACE_InputCDR::to_octet (_tao_aggregate.major)) &&
    (strm >> ::ACE_InputCDR::to_octet (_tao_aggregate.minor));
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::VendorId_t &_tao_aggregate)
{
  OpenDDS::RTPS::OctetArray2_forany _tao_aggregate_vendorId
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::RTPS::OctetArray2_slice*) (
      #else
      (const_cast<
          OpenDDS::RTPS::OctetArray2_slice*> (
      #endif
          _tao_aggregate.vendorId
        )
    );
  return
    (strm << _tao_aggregate_vendorId);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::VendorId_t &_tao_aggregate)
{
  OpenDDS::RTPS::OctetArray2_forany _tao_aggregate_vendorId
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::RTPS::OctetArray2_slice*) (
      #else
      (const_cast<
          OpenDDS::RTPS::OctetArray2_slice*> (
      #endif
          _tao_aggregate.vendorId
        )
    );
  return
    (strm >> _tao_aggregate_vendorId);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_OpenDDS_RTPS_ParameterList_CPP_
#define _TAO_CDR_OP_OpenDDS_RTPS_ParameterList_CPP_


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::ParameterList &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::ParameterList &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_OpenDDS_RTPS_ParameterList_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::OriginalWriterInfo_t &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.originalWriterGUID) &&
    (strm << _tao_aggregate.originalWriterSN) &&
    (strm << _tao_aggregate.originalWriterQos);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::OriginalWriterInfo_t &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.originalWriterGUID) &&
    (strm >> _tao_aggregate.originalWriterSN) &&
    (strm >> _tao_aggregate.originalWriterQos);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_union/cdr_op_cs.cpp:77



OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::Parameter &_tao_union
  )
{
  if ( !(strm << _tao_union._d ()) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_union._d ())
  {
    case 5U:
    case 7U:
      {
        result = strm << ACE_OutputCDR::from_string (_tao_union.string_data (), 256);
      }
      break;
    case 44U:
      {
        result = strm << _tao_union.user_data ();
      }
      break;
    case 45U:
      {
        result = strm << _tao_union.group_data ();
      }
      break;
    case 46U:
      {
        result = strm << _tao_union.topic_data ();
      }
      break;
    case 29U:
      {
        result = strm << _tao_union.durability ();
      }
      break;
    case 30U:
      {
        result = strm << _tao_union.durability_service ();
      }
      break;
    case 35U:
      {
        result = strm << _tao_union.deadline ();
      }
      break;
    case 39U:
      {
        result = strm << _tao_union.latency_budget ();
      }
      break;
    case 27U:
      {
        result = strm << _tao_union.liveliness ();
      }
      break;
    case 26U:
      {
        result = strm << _tao_union.reliability ();
      }
      break;
    case 43U:
      {
        result = strm << _tao_union.lifespan ();
      }
      break;
    case 37U:
      {
        result = strm << _tao_union.destination_order ();
      }
      break;
    case 64U:
      {
        result = strm << _tao_union.history ();
      }
      break;
    case 65U:
      {
        result = strm << _tao_union.resource_limits ();
      }
      break;
    case 31U:
      {
        result = strm << _tao_union.ownership ();
      }
      break;
    case 6U:
      {
        result = strm << _tao_union.ownership_strength ();
      }
      break;
    case 33U:
      {
        result = strm << _tao_union.presentation ();
      }
      break;
    case 41U:
      {
        result = strm << _tao_union.partition ();
      }
      break;
    case 4U:
      {
        result = strm << _tao_union.time_based_filter ();
      }
      break;
    case 73U:
      {
        result = strm << _tao_union.transport_priority ();
      }
      break;
    case 21U:
      {
        result = strm << _tao_union.version ();
      }
      break;
    case 22U:
      {
        result = strm << _tao_union.vendor ();
      }
      break;
    case 47U:
    case 48U:
    case 49U:
    case 72U:
    case 50U:
    case 51U:
      {
        result = strm << _tao_union.locator ();
      }
      break;
    case 17U:
    case 12U:
    case 69U:
    case 11U:
      {
        result = strm << _tao_union.ipv4_address ();
      }
      break;
    case 14U:
    case 13U:
    case 70U:
      {
        result = strm << _tao_union.udpv4_port ();
      }
      break;
    case 67U:
      {
        result = strm << ::ACE_OutputCDR::from_boolean (_tao_union.expects_inline_qos ());
      }
      break;
    case 52U:
      {
        result = strm << _tao_union.count ();
      }
      break;
    case 68U:
      {
        result = strm << _tao_union.participant_builtin_endpoints ();
      }
      break;
    case 2U:
      {
        result = strm << _tao_union.duration ();
      }
      break;
    case 53U:
      {
        result = strm << _tao_union.content_filter_property ();
      }
      break;
    case 80U:
    case 90U:
    case 82U:
    case 45058U:
      {
        result = strm << _tao_union.guid ();
      }
      break;
    case 81U:
    case 83U:
      {
        result = strm << _tao_union.entity_id ();
      }
      break;
    case 88U:
      {
        result = strm << _tao_union.builtin_endpoints ();
      }
      break;
    case 89U:
      {
        result = strm << _tao_union.properties ();
      }
      break;
    case 96U:
      {
        result = strm << _tao_union.type_max_size_serialized ();
      }
      break;
    case 98U:
      {
        result = strm << _tao_union.entity_name ();
      }
      break;
    case 112U:
      {
        result = strm << _tao_union.key_hash ();
      }
      break;
    case 113U:
      {
        result = strm << _tao_union.status_info ();
      }
      break;
    case 85U:
      {
        result = strm << _tao_union.content_filter_info ();
      }
      break;
    case 86U:
      {
        result = strm << _tao_union.coherent_set ();
      }
      break;
    case 87U:
      {
        result = strm << _tao_union.directed_write ();
      }
      break;
    case 97U:
      {
        result = strm << _tao_union.original_writer_info ();
      }
      break;
    case 45057U:
      {
        result = strm << _tao_union.opendds_locator ();
      }
      break;
    default:
      {
        result = strm << _tao_union.unknown_data ();
      }
      break;
  }

  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::Parameter &_tao_union
  )
{
  CORBA::UShort _tao_discriminant;
  if ( !(strm >> _tao_discriminant) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_discriminant)
  {
    case 5U:
    case 7U:
      {
        ::CORBA::String_var _tao_union_tmp;
        result = strm >> ACE_InputCDR::to_string (_tao_union_tmp.out (), 256);

        if (result)
          {
            _tao_union.string_data (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 44U:
      {
        DDS::UserDataQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.user_data (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 45U:
      {
        DDS::GroupDataQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.group_data (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 46U:
      {
        DDS::TopicDataQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.topic_data (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 29U:
      {
        DDS::DurabilityQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.durability (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 30U:
      {
        DDS::DurabilityServiceQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.durability_service (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 35U:
      {
        DDS::DeadlineQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.deadline (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 39U:
      {
        DDS::LatencyBudgetQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.latency_budget (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 27U:
      {
        DDS::LivelinessQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.liveliness (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 26U:
      {
        DDS::ReliabilityQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.reliability (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 43U:
      {
        DDS::LifespanQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.lifespan (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 37U:
      {
        DDS::DestinationOrderQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.destination_order (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 64U:
      {
        DDS::HistoryQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.history (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 65U:
      {
        DDS::ResourceLimitsQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.resource_limits (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 31U:
      {
        DDS::OwnershipQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.ownership (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 6U:
      {
        DDS::OwnershipStrengthQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.ownership_strength (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 33U:
      {
        DDS::PresentationQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.presentation (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 41U:
      {
        DDS::PartitionQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.partition (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 4U:
      {
        DDS::TimeBasedFilterQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.time_based_filter (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 73U:
      {
        DDS::TransportPriorityQosPolicy _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.transport_priority (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 21U:
      {
        OpenDDS::RTPS::ProtocolVersion_t _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.version (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 22U:
      {
        OpenDDS::RTPS::VendorId_t _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.vendor (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 47U:
    case 48U:
    case 49U:
    case 72U:
    case 50U:
    case 51U:
      {
        OpenDDS::DCPS::Locator_t _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.locator (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 17U:
    case 12U:
    case 69U:
    case 11U:
      {
        CORBA::ULong _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.ipv4_address (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 14U:
    case 13U:
    case 70U:
      {
        CORBA::ULong _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.udpv4_port (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 67U:
      {
        ::CORBA::Boolean _tao_union_tmp;
        ::ACE_InputCDR::to_boolean _tao_union_helper (_tao_union_tmp);
        result = strm >> _tao_union_helper;

        if (result)
          {
            _tao_union.expects_inline_qos (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 52U:
      {
        OpenDDS::RTPS::Count_t _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.count (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 68U:
      {
        CORBA::ULong _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.participant_builtin_endpoints (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 2U:
      {
        OpenDDS::RTPS::Time_t _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.duration (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 53U:
      {
        OpenDDS::DCPS::ContentFilterProperty_t _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.content_filter_property (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 80U:
    case 90U:
    case 82U:
    case 45058U:
      {
        OpenDDS::DCPS::GUID_t _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.guid (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 81U:
    case 83U:
      {
        OpenDDS::DCPS::EntityId_t _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.entity_id (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 88U:
      {
        CORBA::ULong _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.builtin_endpoints (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 89U:
      {
        OpenDDS::RTPS::PropertySeq _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.properties (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 96U:
      {
        CORBA::Long _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.type_max_size_serialized (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 98U:
      {
        OpenDDS::RTPS::EntityName_t _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.entity_name (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 112U:
      {
        OpenDDS::RTPS::KeyHash_t _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.key_hash (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 113U:
      {
        OpenDDS::RTPS::StatusInfo_t _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.status_info (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 85U:
      {
        OpenDDS::RTPS::ContentFilterInfo_t _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.content_filter_info (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 86U:
      {
        OpenDDS::RTPS::SequenceNumber_t _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.coherent_set (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 87U:
      {
        OpenDDS::DCPS::GUIDSeq _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.directed_write (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 97U:
      {
        OpenDDS::RTPS::OriginalWriterInfo_t _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.original_writer_info (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 45057U:
      {
        OpenDDS::DCPS::TransportLocator _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.opendds_locator (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      {
        DDS::OctetSeq _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.unknown_data (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
  }

  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::SubmessageHeader &_tao_aggregate)
{
  return
    (strm << ::ACE_OutputCDR::from_octet (_tao_aggregate.submessageId)) &&
    (strm << ::ACE_OutputCDR::from_octet (_tao_aggregate.flags)) &&
    (strm << _tao_aggregate.submessageLength);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::SubmessageHeader &_tao_aggregate)
{
  return
    (strm >> ::ACE_InputCDR::to_octet (_tao_aggregate.submessageId)) &&
    (strm >> ::ACE_InputCDR::to_octet (_tao_aggregate.flags)) &&
    (strm >> _tao_aggregate.submessageLength);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::FragmentNumber_t &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.value);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::FragmentNumber_t &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.value);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::FragmentNumberSet &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.bitmapBase) &&
    (strm << _tao_aggregate.numBits) &&
    (strm << _tao_aggregate.bitmap);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::FragmentNumberSet &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.bitmapBase) &&
    (strm >> _tao_aggregate.numBits) &&
    (strm >> _tao_aggregate.bitmap);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::AckNackSubmessage &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.smHeader) &&
    (strm << _tao_aggregate.readerId) &&
    (strm << _tao_aggregate.writerId) &&
    (strm << _tao_aggregate.readerSNState) &&
    (strm << _tao_aggregate.count);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::AckNackSubmessage &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.smHeader) &&
    (strm >> _tao_aggregate.readerId) &&
    (strm >> _tao_aggregate.writerId) &&
    (strm >> _tao_aggregate.readerSNState) &&
    (strm >> _tao_aggregate.count);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::GapSubmessage &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.smHeader) &&
    (strm << _tao_aggregate.readerId) &&
    (strm << _tao_aggregate.writerId) &&
    (strm << _tao_aggregate.gapStart) &&
    (strm << _tao_aggregate.gapList);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::GapSubmessage &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.smHeader) &&
    (strm >> _tao_aggregate.readerId) &&
    (strm >> _tao_aggregate.writerId) &&
    (strm >> _tao_aggregate.gapStart) &&
    (strm >> _tao_aggregate.gapList);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::InfoReplySubmessage &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.smHeader) &&
    (strm << _tao_aggregate.unicastLocatorList) &&
    (strm << _tao_aggregate.multicastLocatorList);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::InfoReplySubmessage &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.smHeader) &&
    (strm >> _tao_aggregate.unicastLocatorList) &&
    (strm >> _tao_aggregate.multicastLocatorList);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::NackFragSubmessage &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.smHeader) &&
    (strm << _tao_aggregate.readerId) &&
    (strm << _tao_aggregate.writerId) &&
    (strm << _tao_aggregate.writerSN) &&
    (strm << _tao_aggregate.fragmentNumberState) &&
    (strm << _tao_aggregate.count);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::NackFragSubmessage &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.smHeader) &&
    (strm >> _tao_aggregate.readerId) &&
    (strm >> _tao_aggregate.writerId) &&
    (strm >> _tao_aggregate.writerSN) &&
    (strm >> _tao_aggregate.fragmentNumberState) &&
    (strm >> _tao_aggregate.count);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::ParticipantProxy_t &_tao_aggregate)
{
  OpenDDS::DCPS::GuidPrefix_t_forany _tao_aggregate_guidPrefix
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::DCPS::GuidPrefix_t_slice*) (
      #else
      (const_cast<
          OpenDDS::DCPS::GuidPrefix_t_slice*> (
      #endif
          _tao_aggregate.guidPrefix
        )
    );
  return
    (strm << _tao_aggregate.protocolVersion) &&
    (strm << _tao_aggregate_guidPrefix) &&
    (strm << _tao_aggregate.vendorId) &&
    (strm << ::ACE_OutputCDR::from_boolean (_tao_aggregate.expectsInlineQos)) &&
    (strm << _tao_aggregate.availableBuiltinEndpoints) &&
    (strm << _tao_aggregate.metatrafficUnicastLocatorList) &&
    (strm << _tao_aggregate.metatrafficMulticastLocatorList) &&
    (strm << _tao_aggregate.defaultMulticastLocatorList) &&
    (strm << _tao_aggregate.defaultUnicastLocatorList) &&
    (strm << _tao_aggregate.manualLivelinessCount);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::ParticipantProxy_t &_tao_aggregate)
{
  OpenDDS::DCPS::GuidPrefix_t_forany _tao_aggregate_guidPrefix
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::DCPS::GuidPrefix_t_slice*) (
      #else
      (const_cast<
          OpenDDS::DCPS::GuidPrefix_t_slice*> (
      #endif
          _tao_aggregate.guidPrefix
        )
    );
  return
    (strm >> _tao_aggregate.protocolVersion) &&
    (strm >> _tao_aggregate_guidPrefix) &&
    (strm >> _tao_aggregate.vendorId) &&
    (strm >> ::ACE_InputCDR::to_boolean (_tao_aggregate.expectsInlineQos)) &&
    (strm >> _tao_aggregate.availableBuiltinEndpoints) &&
    (strm >> _tao_aggregate.metatrafficUnicastLocatorList) &&
    (strm >> _tao_aggregate.metatrafficMulticastLocatorList) &&
    (strm >> _tao_aggregate.defaultMulticastLocatorList) &&
    (strm >> _tao_aggregate.defaultUnicastLocatorList) &&
    (strm >> _tao_aggregate.manualLivelinessCount);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::SPDPdiscoveredParticipantData &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.ddsParticipantData) &&
    (strm << _tao_aggregate.participantProxy) &&
    (strm << _tao_aggregate.leaseDuration);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::SPDPdiscoveredParticipantData &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.ddsParticipantData) &&
    (strm >> _tao_aggregate.participantProxy) &&
    (strm >> _tao_aggregate.leaseDuration);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::ParticipantMessageData &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.participantGuid) &&
    (strm << _tao_aggregate.data);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::ParticipantMessageData &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.participantGuid) &&
    (strm >> _tao_aggregate.data);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::Header &_tao_aggregate)
{
  OpenDDS::RTPS::OctetArray4_forany _tao_aggregate_prefix
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::RTPS::OctetArray4_slice*) (
      #else
      (const_cast<
          OpenDDS::RTPS::OctetArray4_slice*> (
      #endif
          _tao_aggregate.prefix
        )
    );
  OpenDDS::DCPS::GuidPrefix_t_forany _tao_aggregate_guidPrefix
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::DCPS::GuidPrefix_t_slice*) (
      #else
      (const_cast<
          OpenDDS::DCPS::GuidPrefix_t_slice*> (
      #endif
          _tao_aggregate.guidPrefix
        )
    );
  return
    (strm << _tao_aggregate_prefix) &&
    (strm << _tao_aggregate.version) &&
    (strm << _tao_aggregate.vendorId) &&
    (strm << _tao_aggregate_guidPrefix);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::Header &_tao_aggregate)
{
  OpenDDS::RTPS::OctetArray4_forany _tao_aggregate_prefix
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::RTPS::OctetArray4_slice*) (
      #else
      (const_cast<
          OpenDDS::RTPS::OctetArray4_slice*> (
      #endif
          _tao_aggregate.prefix
        )
    );
  OpenDDS::DCPS::GuidPrefix_t_forany _tao_aggregate_guidPrefix
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::DCPS::GuidPrefix_t_slice*) (
      #else
      (const_cast<
          OpenDDS::DCPS::GuidPrefix_t_slice*> (
      #endif
          _tao_aggregate.guidPrefix
        )
    );
  return
    (strm >> _tao_aggregate_prefix) &&
    (strm >> _tao_aggregate.version) &&
    (strm >> _tao_aggregate.vendorId) &&
    (strm >> _tao_aggregate_guidPrefix);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::DataSubmessage &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.smHeader) &&
    (strm << _tao_aggregate.extraFlags) &&
    (strm << _tao_aggregate.octetsToInlineQos) &&
    (strm << _tao_aggregate.readerId) &&
    (strm << _tao_aggregate.writerId) &&
    (strm << _tao_aggregate.writerSN) &&
    (strm << _tao_aggregate.inlineQos);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::DataSubmessage &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.smHeader) &&
    (strm >> _tao_aggregate.extraFlags) &&
    (strm >> _tao_aggregate.octetsToInlineQos) &&
    (strm >> _tao_aggregate.readerId) &&
    (strm >> _tao_aggregate.writerId) &&
    (strm >> _tao_aggregate.writerSN) &&
    (strm >> _tao_aggregate.inlineQos);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::DataFragSubmessage &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.smHeader) &&
    (strm << _tao_aggregate.extraFlags) &&
    (strm << _tao_aggregate.octetsToInlineQos) &&
    (strm << _tao_aggregate.readerId) &&
    (strm << _tao_aggregate.writerId) &&
    (strm << _tao_aggregate.writerSN) &&
    (strm << _tao_aggregate.fragmentStartingNum) &&
    (strm << _tao_aggregate.fragmentsInSubmessage) &&
    (strm << _tao_aggregate.fragmentSize) &&
    (strm << _tao_aggregate.sampleSize) &&
    (strm << _tao_aggregate.inlineQos);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::DataFragSubmessage &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.smHeader) &&
    (strm >> _tao_aggregate.extraFlags) &&
    (strm >> _tao_aggregate.octetsToInlineQos) &&
    (strm >> _tao_aggregate.readerId) &&
    (strm >> _tao_aggregate.writerId) &&
    (strm >> _tao_aggregate.writerSN) &&
    (strm >> _tao_aggregate.fragmentStartingNum) &&
    (strm >> _tao_aggregate.fragmentsInSubmessage) &&
    (strm >> _tao_aggregate.fragmentSize) &&
    (strm >> _tao_aggregate.sampleSize) &&
    (strm >> _tao_aggregate.inlineQos);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::HeartBeatSubmessage &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.smHeader) &&
    (strm << _tao_aggregate.readerId) &&
    (strm << _tao_aggregate.writerId) &&
    (strm << _tao_aggregate.firstSN) &&
    (strm << _tao_aggregate.lastSN) &&
    (strm << _tao_aggregate.count);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::HeartBeatSubmessage &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.smHeader) &&
    (strm >> _tao_aggregate.readerId) &&
    (strm >> _tao_aggregate.writerId) &&
    (strm >> _tao_aggregate.firstSN) &&
    (strm >> _tao_aggregate.lastSN) &&
    (strm >> _tao_aggregate.count);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::HeartBeatFragSubmessage &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.smHeader) &&
    (strm << _tao_aggregate.readerId) &&
    (strm << _tao_aggregate.writerId) &&
    (strm << _tao_aggregate.writerSN) &&
    (strm << _tao_aggregate.lastFragmentNum) &&
    (strm << _tao_aggregate.count);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::HeartBeatFragSubmessage &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.smHeader) &&
    (strm >> _tao_aggregate.readerId) &&
    (strm >> _tao_aggregate.writerId) &&
    (strm >> _tao_aggregate.writerSN) &&
    (strm >> _tao_aggregate.lastFragmentNum) &&
    (strm >> _tao_aggregate.count);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::InfoDestinationSubmessage &_tao_aggregate)
{
  OpenDDS::DCPS::GuidPrefix_t_forany _tao_aggregate_guidPrefix
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::DCPS::GuidPrefix_t_slice*) (
      #else
      (const_cast<
          OpenDDS::DCPS::GuidPrefix_t_slice*> (
      #endif
          _tao_aggregate.guidPrefix
        )
    );
  return
    (strm << _tao_aggregate.smHeader) &&
    (strm << _tao_aggregate_guidPrefix);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::InfoDestinationSubmessage &_tao_aggregate)
{
  OpenDDS::DCPS::GuidPrefix_t_forany _tao_aggregate_guidPrefix
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::DCPS::GuidPrefix_t_slice*) (
      #else
      (const_cast<
          OpenDDS::DCPS::GuidPrefix_t_slice*> (
      #endif
          _tao_aggregate.guidPrefix
        )
    );
  return
    (strm >> _tao_aggregate.smHeader) &&
    (strm >> _tao_aggregate_guidPrefix);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::InfoSourceSubmessage &_tao_aggregate)
{
  OpenDDS::DCPS::GuidPrefix_t_forany _tao_aggregate_guidPrefix
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::DCPS::GuidPrefix_t_slice*) (
      #else
      (const_cast<
          OpenDDS::DCPS::GuidPrefix_t_slice*> (
      #endif
          _tao_aggregate.guidPrefix
        )
    );
  return
    (strm << _tao_aggregate.smHeader) &&
    (strm << _tao_aggregate.unused) &&
    (strm << _tao_aggregate.version) &&
    (strm << _tao_aggregate.vendorId) &&
    (strm << _tao_aggregate_guidPrefix);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::InfoSourceSubmessage &_tao_aggregate)
{
  OpenDDS::DCPS::GuidPrefix_t_forany _tao_aggregate_guidPrefix
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((OpenDDS::DCPS::GuidPrefix_t_slice*) (
      #else
      (const_cast<
          OpenDDS::DCPS::GuidPrefix_t_slice*> (
      #endif
          _tao_aggregate.guidPrefix
        )
    );
  return
    (strm >> _tao_aggregate.smHeader) &&
    (strm >> _tao_aggregate.unused) &&
    (strm >> _tao_aggregate.version) &&
    (strm >> _tao_aggregate.vendorId) &&
    (strm >> _tao_aggregate_guidPrefix);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::InfoTimestampSubmessage &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.smHeader) &&
    (strm << _tao_aggregate.timestamp);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::InfoTimestampSubmessage &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.smHeader) &&
    (strm >> _tao_aggregate.timestamp);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::PadSubmessage &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.smHeader);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::PadSubmessage &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.smHeader);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::InfoReplyIp4Submessage &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.smHeader) &&
    (strm << _tao_aggregate.unicastLocator) &&
    (strm << _tao_aggregate.multicastLocator);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::InfoReplyIp4Submessage &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.smHeader) &&
    (strm >> _tao_aggregate.unicastLocator) &&
    (strm >> _tao_aggregate.multicastLocator);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_enum/cdr_op_cs.cpp:37



OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, OpenDDS::RTPS::SubmessageKind _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, OpenDDS::RTPS::SubmessageKind & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<OpenDDS::RTPS::SubmessageKind> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_union/cdr_op_cs.cpp:77



OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::Submessage &_tao_union
  )
{
  if ( !(strm << _tao_union._d ()) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_union._d ())
  {
    case OpenDDS::RTPS::PAD:
      {
        result = strm << _tao_union.pad_sm ();
      }
      break;
    case OpenDDS::RTPS::ACKNACK:
      {
        result = strm << _tao_union.acknack_sm ();
      }
      break;
    case OpenDDS::RTPS::HEARTBEAT:
      {
        result = strm << _tao_union.heartbeat_sm ();
      }
      break;
    case OpenDDS::RTPS::GAP:
      {
        result = strm << _tao_union.gap_sm ();
      }
      break;
    case OpenDDS::RTPS::INFO_TS:
      {
        result = strm << _tao_union.info_ts_sm ();
      }
      break;
    case OpenDDS::RTPS::INFO_SRC:
      {
        result = strm << _tao_union.info_src_sm ();
      }
      break;
    case OpenDDS::RTPS::INFO_REPLY_IP4:
      {
        result = strm << _tao_union.info_reply_ipv4_sm ();
      }
      break;
    case OpenDDS::RTPS::INFO_DST:
      {
        result = strm << _tao_union.info_dst_sm ();
      }
      break;
    case OpenDDS::RTPS::INFO_REPLY:
      {
        result = strm << _tao_union.info_reply_sm ();
      }
      break;
    case OpenDDS::RTPS::NACK_FRAG:
      {
        result = strm << _tao_union.nack_frag_sm ();
      }
      break;
    case OpenDDS::RTPS::HEARTBEAT_FRAG:
      {
        result = strm << _tao_union.hb_frag_sm ();
      }
      break;
    case OpenDDS::RTPS::DATA:
      {
        result = strm << _tao_union.data_sm ();
      }
      break;
    case OpenDDS::RTPS::DATA_FRAG:
      {
        result = strm << _tao_union.data_frag_sm ();
      }
      break;
    default:
      {
        result = strm << _tao_union.unknown_sm ();
      }
      break;
  }

  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::Submessage &_tao_union
  )
{
  OpenDDS::RTPS::SubmessageKind _tao_discriminant;
  if ( !(strm >> _tao_discriminant) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_discriminant)
  {
    case OpenDDS::RTPS::PAD:
      {
        OpenDDS::RTPS::PadSubmessage _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.pad_sm (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case OpenDDS::RTPS::ACKNACK:
      {
        OpenDDS::RTPS::AckNackSubmessage _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.acknack_sm (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case OpenDDS::RTPS::HEARTBEAT:
      {
        OpenDDS::RTPS::HeartBeatSubmessage _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.heartbeat_sm (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case OpenDDS::RTPS::GAP:
      {
        OpenDDS::RTPS::GapSubmessage _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.gap_sm (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case OpenDDS::RTPS::INFO_TS:
      {
        OpenDDS::RTPS::InfoTimestampSubmessage _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.info_ts_sm (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case OpenDDS::RTPS::INFO_SRC:
      {
        OpenDDS::RTPS::InfoSourceSubmessage _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.info_src_sm (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case OpenDDS::RTPS::INFO_REPLY_IP4:
      {
        OpenDDS::RTPS::InfoReplyIp4Submessage _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.info_reply_ipv4_sm (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case OpenDDS::RTPS::INFO_DST:
      {
        OpenDDS::RTPS::InfoDestinationSubmessage _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.info_dst_sm (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case OpenDDS::RTPS::INFO_REPLY:
      {
        OpenDDS::RTPS::InfoReplySubmessage _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.info_reply_sm (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case OpenDDS::RTPS::NACK_FRAG:
      {
        OpenDDS::RTPS::NackFragSubmessage _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.nack_frag_sm (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case OpenDDS::RTPS::HEARTBEAT_FRAG:
      {
        OpenDDS::RTPS::HeartBeatFragSubmessage _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.hb_frag_sm (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case OpenDDS::RTPS::DATA:
      {
        OpenDDS::RTPS::DataSubmessage _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.data_sm (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case OpenDDS::RTPS::DATA_FRAG:
      {
        OpenDDS::RTPS::DataFragSubmessage _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.data_frag_sm (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      {
        OpenDDS::RTPS::SubmessageHeader _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.unknown_sm (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
  }

  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_OpenDDS_RTPS_SubmessageSeq_CPP_
#define _TAO_CDR_OP_OpenDDS_RTPS_SubmessageSeq_CPP_


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::SubmessageSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::SubmessageSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_OpenDDS_RTPS_SubmessageSeq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


OPENDDS_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpenDDS::RTPS::DiscoveredTopicData &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.ddsTopicData);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpenDDS::RTPS::DiscoveredTopicData &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.ddsTopicData);
}

TAO_END_VERSIONED_NAMESPACE_DECL


OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL





OPENDDS_END_VERSIONED_NAMESPACE_DECL


