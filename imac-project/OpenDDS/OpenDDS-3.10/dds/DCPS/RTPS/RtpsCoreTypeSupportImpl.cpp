/* Generated by /Users/yc/MyGithub/imac-project/OpenDDS/OpenDDS-3.10/bin/opendds_idl version 3.10 (ACE version 6.2a_p11) running on input file RtpsCore.idl */
#include "RtpsCoreTypeSupportImpl.h"

#include <cstring>
#include <stdexcept>
#include "dds/CorbaSeq/LongSeqTypeSupportImpl.h"
#include "dds/DCPS/FilterEvaluator.h"
#include "dds/DCPS/PoolAllocator.h"
#include "dds/DdsDcpsCoreTypeSupportImpl.h"
#include "dds/DdsDcpsGuidTypeSupportImpl.h"
#include "dds/DdsDcpsInfoUtilsTypeSupportImpl.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: LongSeq */


/* End TYPEDEF: LongSeq */

/* End MODULE: CORBA */


/* Begin MODULE: DDS */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */


/* Begin TYPEDEF: InstanceHandle_t */


/* End TYPEDEF: InstanceHandle_t */


/* Begin TYPEDEF: BuiltinTopicKeyValue */


/* End TYPEDEF: BuiltinTopicKeyValue */


/* Begin TYPEDEF: InstanceHandleSeq */


/* End TYPEDEF: InstanceHandleSeq */


/* Begin TYPEDEF: QosPolicyId_t */


/* End TYPEDEF: QosPolicyId_t */


/* Begin STRUCT: QosPolicyCount */


/* End STRUCT: QosPolicyCount */


/* Begin TYPEDEF: QosPolicyCountSeq */


/* End TYPEDEF: QosPolicyCountSeq */


/* Begin TYPEDEF: OctetSeq */


/* End TYPEDEF: OctetSeq */


/* Begin STRUCT: Duration_t */


/* End STRUCT: Duration_t */


/* Begin STRUCT: UserDataQosPolicy */


/* End STRUCT: UserDataQosPolicy */


/* Begin STRUCT: GroupDataQosPolicy */


/* End STRUCT: GroupDataQosPolicy */


/* Begin STRUCT: TopicDataQosPolicy */


/* End STRUCT: TopicDataQosPolicy */


/* Begin STRUCT: PartitionQosPolicy */


/* End STRUCT: PartitionQosPolicy */


/* Begin ENUM: HistoryQosPolicyKind */


/* End ENUM: HistoryQosPolicyKind */


/* Begin ENUM: DurabilityQosPolicyKind */


/* End ENUM: DurabilityQosPolicyKind */


/* Begin STRUCT: DurabilityQosPolicy */


/* End STRUCT: DurabilityQosPolicy */


/* Begin STRUCT: DurabilityServiceQosPolicy */


/* End STRUCT: DurabilityServiceQosPolicy */


/* Begin STRUCT: DeadlineQosPolicy */


/* End STRUCT: DeadlineQosPolicy */


/* Begin STRUCT: LatencyBudgetQosPolicy */


/* End STRUCT: LatencyBudgetQosPolicy */


/* Begin ENUM: LivelinessQosPolicyKind */


/* End ENUM: LivelinessQosPolicyKind */


/* Begin STRUCT: LivelinessQosPolicy */


/* End STRUCT: LivelinessQosPolicy */


/* Begin ENUM: ReliabilityQosPolicyKind */


/* End ENUM: ReliabilityQosPolicyKind */


/* Begin STRUCT: ReliabilityQosPolicy */


/* End STRUCT: ReliabilityQosPolicy */


/* Begin ENUM: DestinationOrderQosPolicyKind */


/* End ENUM: DestinationOrderQosPolicyKind */


/* Begin STRUCT: DestinationOrderQosPolicy */


/* End STRUCT: DestinationOrderQosPolicy */


/* Begin STRUCT: HistoryQosPolicy */


/* End STRUCT: HistoryQosPolicy */


/* Begin STRUCT: ResourceLimitsQosPolicy */


/* End STRUCT: ResourceLimitsQosPolicy */


/* Begin STRUCT: TransportPriorityQosPolicy */


/* End STRUCT: TransportPriorityQosPolicy */


/* Begin STRUCT: LifespanQosPolicy */


/* End STRUCT: LifespanQosPolicy */


/* Begin ENUM: OwnershipQosPolicyKind */


/* End ENUM: OwnershipQosPolicyKind */


/* Begin STRUCT: OwnershipQosPolicy */


/* End STRUCT: OwnershipQosPolicy */


/* Begin STRUCT: OwnershipStrengthQosPolicy */


/* End STRUCT: OwnershipStrengthQosPolicy */


/* Begin ENUM: PresentationQosPolicyAccessScopeKind */


/* End ENUM: PresentationQosPolicyAccessScopeKind */


/* Begin STRUCT: PresentationQosPolicy */


/* End STRUCT: PresentationQosPolicy */


/* Begin STRUCT: TimeBasedFilterQosPolicy */


/* End STRUCT: TimeBasedFilterQosPolicy */


/* Begin STRUCT: TopicQos */


/* End STRUCT: TopicQos */


/* Begin STRUCT: WriterDataLifecycleQosPolicy */


/* End STRUCT: WriterDataLifecycleQosPolicy */


/* Begin STRUCT: DataWriterQos */


/* End STRUCT: DataWriterQos */


/* Begin STRUCT: EntityFactoryQosPolicy */


/* End STRUCT: EntityFactoryQosPolicy */


/* Begin STRUCT: PublisherQos */


/* End STRUCT: PublisherQos */


/* Begin STRUCT: ReaderDataLifecycleQosPolicy */


/* End STRUCT: ReaderDataLifecycleQosPolicy */


/* Begin STRUCT: DataReaderQos */


/* End STRUCT: DataReaderQos */


/* Begin STRUCT: SubscriberQos */


/* End STRUCT: SubscriberQos */


/* Begin STRUCT: DomainParticipantFactoryQos */


/* End STRUCT: DomainParticipantFactoryQos */


/* Begin STRUCT: DomainParticipantQos */


/* End STRUCT: DomainParticipantQos */


/* Begin STRUCT: BuiltinTopicKey_t */


/* End STRUCT: BuiltinTopicKey_t */


/* Begin STRUCT: ParticipantBuiltinTopicData */


/* End STRUCT: ParticipantBuiltinTopicData */


/* Begin STRUCT: PublicationBuiltinTopicData */


/* End STRUCT: PublicationBuiltinTopicData */


/* Begin STRUCT: SubscriptionBuiltinTopicData */


/* End STRUCT: SubscriptionBuiltinTopicData */


/* Begin STRUCT: TopicBuiltinTopicData */


/* End STRUCT: TopicBuiltinTopicData */


/* Begin TYPEDEF: SampleStateKind */


/* End TYPEDEF: SampleStateKind */


/* Begin CONST: READ_SAMPLE_STATE */


/* End CONST: READ_SAMPLE_STATE */


/* Begin CONST: NOT_READ_SAMPLE_STATE */


/* End CONST: NOT_READ_SAMPLE_STATE */


/* Begin TYPEDEF: SampleStateMask */


/* End TYPEDEF: SampleStateMask */


/* Begin CONST: ANY_SAMPLE_STATE */


/* End CONST: ANY_SAMPLE_STATE */


/* Begin TYPEDEF: ViewStateKind */


/* End TYPEDEF: ViewStateKind */


/* Begin CONST: NEW_VIEW_STATE */


/* End CONST: NEW_VIEW_STATE */


/* Begin CONST: NOT_NEW_VIEW_STATE */


/* End CONST: NOT_NEW_VIEW_STATE */


/* Begin TYPEDEF: ViewStateMask */


/* End TYPEDEF: ViewStateMask */


/* Begin CONST: ANY_VIEW_STATE */


/* End CONST: ANY_VIEW_STATE */


/* Begin TYPEDEF: InstanceStateKind */


/* End TYPEDEF: InstanceStateKind */


/* Begin CONST: ALIVE_INSTANCE_STATE */


/* End CONST: ALIVE_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* Begin TYPEDEF: InstanceStateMask */


/* End TYPEDEF: InstanceStateMask */


/* Begin CONST: ANY_INSTANCE_STATE */


/* End CONST: ANY_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_INSTANCE_STATE */


/* Begin STRUCT: Time_t */


/* End STRUCT: Time_t */


/* Begin STRUCT: SampleInfo */


/* End STRUCT: SampleInfo */


/* Begin TYPEDEF: SampleInfoSeq */


/* End TYPEDEF: SampleInfoSeq */

/* End MODULE: DDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin TYPEDEF: GuidVendorId_t */


/* End TYPEDEF: GuidVendorId_t */


/* Begin TYPEDEF: GuidPrefix_t */


/* End TYPEDEF: GuidPrefix_t */


/* Begin TYPEDEF: EntityKey_t */


/* End TYPEDEF: EntityKey_t */


/* Begin STRUCT: EntityId_t */


/* End STRUCT: EntityId_t */


/* Begin CONST: ENTITYKIND_BUILTIN_UNKNOWN */


/* End CONST: ENTITYKIND_BUILTIN_UNKNOWN */


/* Begin CONST: ENTITYKIND_BUILTIN_PARTICIPANT */


/* End CONST: ENTITYKIND_BUILTIN_PARTICIPANT */


/* Begin CONST: ENTITYKIND_BUILTIN_WRITER_WITH_KEY */


/* End CONST: ENTITYKIND_BUILTIN_WRITER_WITH_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_WRITER_NO_KEY */


/* End CONST: ENTITYKIND_BUILTIN_WRITER_NO_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_READER_NO_KEY */


/* End CONST: ENTITYKIND_BUILTIN_READER_NO_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_READER_WITH_KEY */


/* End CONST: ENTITYKIND_BUILTIN_READER_WITH_KEY */


/* Begin CONST: ENTITYKIND_USER_UNKNOWN */


/* End CONST: ENTITYKIND_USER_UNKNOWN */


/* Begin CONST: ENTITYKIND_USER_WRITER_WITH_KEY */


/* End CONST: ENTITYKIND_USER_WRITER_WITH_KEY */


/* Begin CONST: ENTITYKIND_USER_WRITER_NO_KEY */


/* End CONST: ENTITYKIND_USER_WRITER_NO_KEY */


/* Begin CONST: ENTITYKIND_USER_READER_NO_KEY */


/* End CONST: ENTITYKIND_USER_READER_NO_KEY */


/* Begin CONST: ENTITYKIND_USER_READER_WITH_KEY */


/* End CONST: ENTITYKIND_USER_READER_WITH_KEY */


/* Begin CONST: ENTITYKIND_OPENDDS_SUBSCRIBER */


/* End CONST: ENTITYKIND_OPENDDS_SUBSCRIBER */


/* Begin CONST: ENTITYKIND_OPENDDS_PUBLISHER */


/* End CONST: ENTITYKIND_OPENDDS_PUBLISHER */


/* Begin CONST: ENTITYKIND_OPENDDS_TOPIC */


/* End CONST: ENTITYKIND_OPENDDS_TOPIC */


/* Begin CONST: ENTITYKIND_OPENDDS_USER */


/* End CONST: ENTITYKIND_OPENDDS_USER */


/* Begin CONST: ENTITYKIND_OPENDDS_NIL_WRITER */


/* End CONST: ENTITYKIND_OPENDDS_NIL_WRITER */


/* Begin STRUCT: GUID_t */


/* End STRUCT: GUID_t */


/* Begin TYPEDEF: GUIDSeq */


/* End TYPEDEF: GUIDSeq */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin TYPEDEF: RepoId */


/* End TYPEDEF: RepoId */


/* Begin TYPEDEF: TransportBLOB */


/* End TYPEDEF: TransportBLOB */


/* Begin STRUCT: TransportLocator */


/* End STRUCT: TransportLocator */


/* Begin TYPEDEF: TransportLocatorSeq */


/* End TYPEDEF: TransportLocatorSeq */


/* Begin STRUCT: IncompatibleQosStatus */


/* End STRUCT: IncompatibleQosStatus */


/* Begin STRUCT: AddDomainStatus */


/* End STRUCT: AddDomainStatus */


/* Begin ENUM: TopicStatus */


/* End ENUM: TopicStatus */


/* Begin STRUCT: WriterAssociation */


/* End STRUCT: WriterAssociation */


/* Begin STRUCT: ReaderAssociation */


/* End STRUCT: ReaderAssociation */


/* Begin TYPEDEF: WriterIdSeq */


/* End TYPEDEF: WriterIdSeq */


/* Begin TYPEDEF: ReaderIdSeq */


/* End TYPEDEF: ReaderIdSeq */


/* Begin TYPEDEF: OctetArray16 */


/* End TYPEDEF: OctetArray16 */


/* Begin STRUCT: Locator_t */


/* End STRUCT: Locator_t */


/* Begin TYPEDEF: LocatorSeq */


/* End TYPEDEF: LocatorSeq */


/* Begin TYPEDEF: String256 */


/* End TYPEDEF: String256 */


/* Begin STRUCT: ContentFilterProperty_t */


/* End STRUCT: ContentFilterProperty_t */


/* Begin STRUCT: ReaderProxy_t */


/* End STRUCT: ReaderProxy_t */


/* Begin STRUCT: DiscoveredReaderData */


/* End STRUCT: DiscoveredReaderData */


/* Begin STRUCT: WriterProxy_t */


/* End STRUCT: WriterProxy_t */


/* Begin STRUCT: DiscoveredWriterData */


/* End STRUCT: DiscoveredWriterData */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: RTPS */



/* Begin TYPEDEF: OctetArray2 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::OctetArray2_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += 2 * max_marshaled_size_octet();
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::OctetArray2_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.write_octet_array(arr.in(), 2);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::OctetArray2_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.read_octet_array(arr.out(), 2);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::OctetArray2_forany*)
{
  ACE_UNUSED_ARG(ser);
  ser.skip(2, 1);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: OctetArray2 */


/* Begin TYPEDEF: OctetArray4 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::OctetArray4_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += 4 * max_marshaled_size_octet();
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::OctetArray4_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.write_octet_array(arr.in(), 4);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::OctetArray4_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.read_octet_array(arr.out(), 4);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::OctetArray4_forany*)
{
  ACE_UNUSED_ARG(ser);
  ser.skip(4, 1);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: OctetArray4 */


/* Begin TYPEDEF: FilterSignature_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::FilterSignature_t_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += 4 * gen_max_marshaled_size(CORBA::Long());
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::FilterSignature_t_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.write_long_array(arr.in(), 4);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::FilterSignature_t_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.read_long_array(arr.out(), 4);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::FilterSignature_t_forany*)
{
  ACE_UNUSED_ARG(ser);
  ser.skip(4, 4);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: FilterSignature_t */


/* Begin TYPEDEF: FilterResult_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::FilterResult_t& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  size += seq.length() * gen_max_marshaled_size(CORBA::Long());
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::FilterResult_t& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  return strm.write_long_array(seq.get_buffer(), length);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::FilterResult_t& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  if (length == 0) {
    return true;
  }
  return strm.read_long_array(seq.get_buffer(), length);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::FilterResult_t*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  ser.skip(length, 4);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: FilterResult_t */


/* Begin TYPEDEF: FilterSignatureSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::FilterSignatureSeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    OpenDDS::RTPS::FilterSignature_t_var tmp_var = OpenDDS::RTPS::FilterSignature_t_dup(seq[i]);
    OpenDDS::RTPS::FilterSignature_t_forany tmp = tmp_var.inout();
    gen_find_size(tmp, size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::FilterSignatureSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    OpenDDS::RTPS::FilterSignature_t_var tmp_var = OpenDDS::RTPS::FilterSignature_t_dup(seq[i]);
    OpenDDS::RTPS::FilterSignature_t_forany tmp = tmp_var.inout();
    if (!(strm << tmp)) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::FilterSignatureSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    OpenDDS::RTPS::FilterSignature_t_var tmp = OpenDDS::RTPS::FilterSignature_t_alloc();
    OpenDDS::RTPS::FilterSignature_t_forany fa = tmp.inout();
    if (!(strm >> fa)) {
      return false;
    }
    OpenDDS::RTPS::FilterSignature_t_copy(seq[i], tmp.in());
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::FilterSignatureSeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::FilterSignature_t_forany*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: FilterSignatureSeq */


/* Begin STRUCT: ContentFilterInfo_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::ContentFilterInfo_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.filterResult, size, padding);
  gen_find_size(stru.filterSignatures, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::ContentFilterInfo_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.filterResult)
    && (strm << stru.filterSignatures);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::ContentFilterInfo_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.filterResult)
    && (strm >> stru.filterSignatures);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::ContentFilterInfo_t> : MetaStruct {
  typedef OpenDDS::RTPS::ContentFilterInfo_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::ContentFilterInfo_t& typed = *static_cast<const OpenDDS::RTPS::ContentFilterInfo_t*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ContentFilterInfo_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::FilterResult_t*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::FilterSignatureSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::ContentFilterInfo_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ContentFilterInfo_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"filterResult", "filterSignatures", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "filterResult") == 0) {
      return &static_cast<const T*>(stru)->filterResult;
    }
    if (std::strcmp(field, "filterSignatures") == 0) {
      return &static_cast<const T*>(stru)->filterSignatures;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ContentFilterInfo_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "filterResult") == 0) {
      static_cast<T*>(lhs)->filterResult = *static_cast<const OpenDDS::RTPS::FilterResult_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "filterSignatures") == 0) {
      static_cast<T*>(lhs)->filterSignatures = *static_cast<const OpenDDS::RTPS::FilterSignatureSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ContentFilterInfo_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ContentFilterInfo_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::ContentFilterInfo_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::ContentFilterInfo_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::ContentFilterInfo_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::ContentFilterInfo_t>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ContentFilterInfo_t */


/* Begin STRUCT: Property_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::Property_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.name.in()) + 1;
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.value.in()) + 1;
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::Property_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.name.in())
    && (strm << stru.value.in());
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::Property_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.name.out())
    && (strm >> stru.value.out());
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::Property_t> : MetaStruct {
  typedef OpenDDS::RTPS::Property_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::Property_t& typed = *static_cast<const OpenDDS::RTPS::Property_t*>(stru);
    if (std::strcmp(field, "name") == 0) {
      return typed.name.in();
    }
    if (std::strcmp(field, "value") == 0) {
      return typed.value.in();
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Property_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "name") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'name' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (std::strcmp(field, "value") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'value' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'value' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::Property_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "name") == 0) {
      return make_field_cmp(&T::name, next);
    }
    if (std::strcmp(field, "value") == 0) {
      return make_field_cmp(&T::value, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Property_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"name", "value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "name") == 0) {
      return &static_cast<const T*>(stru)->name;
    }
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Property_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "name") == 0) {
      static_cast<T*>(lhs)->name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Property_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->name.in(), static_cast<const T*>(rhs)->name.in());
    }
    if (std::strcmp(field, "value") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->value.in(), static_cast<const T*>(rhs)->value.in());
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Property_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::Property_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::Property_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::Property_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::Property_t>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Property_t */


/* Begin TYPEDEF: PropertySeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::PropertySeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::PropertySeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::PropertySeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::PropertySeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::Property_t*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: PropertySeq */


/* Begin STRUCT: EntityName_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::EntityName_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.name.in()) + 1;
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::EntityName_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.name.in());
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::EntityName_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.name.out());
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::EntityName_t> : MetaStruct {
  typedef OpenDDS::RTPS::EntityName_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::EntityName_t& typed = *static_cast<const OpenDDS::RTPS::EntityName_t*>(stru);
    if (std::strcmp(field, "name") == 0) {
      return typed.name.in();
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::EntityName_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "name") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'name' length could not be deserialized");
      }
      ser.skip(len);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::EntityName_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "name") == 0) {
      return make_field_cmp(&T::name, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::EntityName_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"name", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "name") == 0) {
      return &static_cast<const T*>(stru)->name;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::EntityName_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "name") == 0) {
      static_cast<T*>(lhs)->name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::EntityName_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->name.in(), static_cast<const T*>(rhs)->name.in());
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::EntityName_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::EntityName_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::EntityName_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::EntityName_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::EntityName_t>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: EntityName_t */


/* Begin STRUCT: Count_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::Count_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.value);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::Count_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.value);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::Count_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.value);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::Count_t> : MetaStruct {
  typedef OpenDDS::RTPS::Count_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::Count_t& typed = *static_cast<const OpenDDS::RTPS::Count_t*>(stru);
    if (std::strcmp(field, "value") == 0) {
      return typed.value;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Count_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'value' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::Count_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "value") == 0) {
      return make_field_cmp(&T::value, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Count_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Count_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Count_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "value") == 0) {
      return static_cast<const T*>(lhs)->value == static_cast<const T*>(rhs)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Count_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::Count_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::Count_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::Count_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::Count_t>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Count_t */


/* Begin STRUCT: SequenceNumber_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::SequenceNumber_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.high);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.low);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::SequenceNumber_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.high)
    && (strm << stru.low);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::SequenceNumber_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.high)
    && (strm >> stru.low);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::SequenceNumber_t> : MetaStruct {
  typedef OpenDDS::RTPS::SequenceNumber_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::SequenceNumber_t& typed = *static_cast<const OpenDDS::RTPS::SequenceNumber_t*>(stru);
    if (std::strcmp(field, "high") == 0) {
      return typed.high;
    }
    if (std::strcmp(field, "low") == 0) {
      return typed.low;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SequenceNumber_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "high") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'high' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "low") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'low' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::SequenceNumber_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "high") == 0) {
      return make_field_cmp(&T::high, next);
    }
    if (std::strcmp(field, "low") == 0) {
      return make_field_cmp(&T::low, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SequenceNumber_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"high", "low", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "high") == 0) {
      return &static_cast<const T*>(stru)->high;
    }
    if (std::strcmp(field, "low") == 0) {
      return &static_cast<const T*>(stru)->low;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SequenceNumber_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "high") == 0) {
      static_cast<T*>(lhs)->high = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "low") == 0) {
      static_cast<T*>(lhs)->low = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SequenceNumber_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "high") == 0) {
      return static_cast<const T*>(lhs)->high == static_cast<const T*>(rhs)->high;
    }
    if (std::strcmp(field, "low") == 0) {
      return static_cast<const T*>(lhs)->low == static_cast<const T*>(rhs)->low;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SequenceNumber_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::SequenceNumber_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::SequenceNumber_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::SequenceNumber_t>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SequenceNumber_t */


/* Begin TYPEDEF: LongSeq8 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::LongSeq8& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  size += seq.length() * gen_max_marshaled_size(CORBA::Long());
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::LongSeq8& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  return strm.write_long_array(seq.get_buffer(), length);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::LongSeq8& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > seq.maximum()) {
    return false;
  }
  seq.length(length);
  if (length == 0) {
    return true;
  }
  return strm.read_long_array(seq.get_buffer(), length);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::LongSeq8*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  ser.skip(length, 4);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: LongSeq8 */


/* Begin STRUCT: SequenceNumberSet */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::SequenceNumberSet& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += 12 + 4 * ((stru.numBits + 31) / 32); // RTPS Custom
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::SequenceNumberSet& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  if ((strm << stru.bitmapBase) && (strm << stru.numBits)) {
    const CORBA::ULong M = (stru.numBits + 31) / 32;
    if (stru.bitmap.length() < M) {
      return false;
    }
    for (CORBA::ULong i = 0; i < M; ++i) {
      if (!(strm << stru.bitmap[i])) {
        return false;
      }
    }
    return true;
  }
  return false;
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::SequenceNumberSet& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  if ((strm >> stru.bitmapBase) && (strm >> stru.numBits)) {
    const CORBA::ULong M = (stru.numBits + 31) / 32;
    if (M > 8) {
      return false;
    }
    stru.bitmap.length(M);
    for (CORBA::ULong i = 0; i < M; ++i) {
      if (!(strm >> stru.bitmap[i])) {
        return false;
      }
    }
    return true;
  }
  return false;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::SequenceNumberSet> : MetaStruct {
  typedef OpenDDS::RTPS::SequenceNumberSet T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::SequenceNumberSet& typed = *static_cast<const OpenDDS::RTPS::SequenceNumberSet*>(stru);
    if (std::strncmp(field, "bitmapBase.", 11) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.bitmapBase, field + 11);
    }
    if (std::strcmp(field, "numBits") == 0) {
      return typed.numBits;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SequenceNumberSet)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "bitmapBase.", 11) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumber_t*>(0));
    }
    if (std::strcmp(field, "numBits") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'numBits' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::LongSeq8*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::SequenceNumberSet");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "bitmapBase.", 11) == 0) {
      return make_struct_cmp(&T::bitmapBase, getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 11), next);
    }
    if (std::strcmp(field, "numBits") == 0) {
      return make_field_cmp(&T::numBits, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SequenceNumberSet)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"bitmapBase", "numBits", "bitmap", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "bitmapBase") == 0) {
      return &static_cast<const T*>(stru)->bitmapBase;
    }
    if (std::strcmp(field, "numBits") == 0) {
      return &static_cast<const T*>(stru)->numBits;
    }
    if (std::strcmp(field, "bitmap") == 0) {
      return &static_cast<const T*>(stru)->bitmap;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SequenceNumberSet)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "bitmapBase") == 0) {
      static_cast<T*>(lhs)->bitmapBase = *static_cast<const OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "numBits") == 0) {
      static_cast<T*>(lhs)->numBits = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "bitmap") == 0) {
      static_cast<T*>(lhs)->bitmap = *static_cast<const OpenDDS::RTPS::LongSeq8*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SequenceNumberSet)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "numBits") == 0) {
      return static_cast<const T*>(lhs)->numBits == static_cast<const T*>(rhs)->numBits;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SequenceNumberSet)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::SequenceNumberSet>()
{
  static MetaStructImpl<OpenDDS::RTPS::SequenceNumberSet> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::SequenceNumberSet*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::SequenceNumberSet>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SequenceNumberSet */


/* Begin TYPEDEF: LocatorList */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::LocatorList& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::LocatorList& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::LocatorList& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > seq.maximum()) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::LocatorList*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::Locator_t*>(0));
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: LocatorList */


/* Begin STRUCT: Time_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::Time_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.seconds);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.fraction);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::Time_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.seconds)
    && (strm << stru.fraction);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::Time_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.seconds)
    && (strm >> stru.fraction);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::Time_t> : MetaStruct {
  typedef OpenDDS::RTPS::Time_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::Time_t& typed = *static_cast<const OpenDDS::RTPS::Time_t*>(stru);
    if (std::strcmp(field, "seconds") == 0) {
      return typed.seconds;
    }
    if (std::strcmp(field, "fraction") == 0) {
      return typed.fraction;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Time_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "seconds") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'seconds' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "fraction") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'fraction' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::Time_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "seconds") == 0) {
      return make_field_cmp(&T::seconds, next);
    }
    if (std::strcmp(field, "fraction") == 0) {
      return make_field_cmp(&T::fraction, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Time_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"seconds", "fraction", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "seconds") == 0) {
      return &static_cast<const T*>(stru)->seconds;
    }
    if (std::strcmp(field, "fraction") == 0) {
      return &static_cast<const T*>(stru)->fraction;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Time_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "seconds") == 0) {
      static_cast<T*>(lhs)->seconds = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "fraction") == 0) {
      static_cast<T*>(lhs)->fraction = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Time_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "seconds") == 0) {
      return static_cast<const T*>(lhs)->seconds == static_cast<const T*>(rhs)->seconds;
    }
    if (std::strcmp(field, "fraction") == 0) {
      return static_cast<const T*>(lhs)->fraction == static_cast<const T*>(rhs)->fraction;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Time_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::Time_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::Time_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::Time_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::Time_t>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Time_t */


/* Begin TYPEDEF: Timestamp_t */


/* End TYPEDEF: Timestamp_t */


/* Begin TYPEDEF: Duration_t */


/* End TYPEDEF: Duration_t */


/* Begin CONST: LOCATOR_KIND_INVALID */


/* End CONST: LOCATOR_KIND_INVALID */


/* Begin CONST: LOCATOR_KIND_RESERVED */


/* End CONST: LOCATOR_KIND_RESERVED */


/* Begin CONST: LOCATOR_KIND_UDPv4 */


/* End CONST: LOCATOR_KIND_UDPv4 */


/* Begin CONST: LOCATOR_KIND_UDPv6 */


/* End CONST: LOCATOR_KIND_UDPv6 */


/* Begin CONST: LOCATOR_PORT_INVALID */


/* End CONST: LOCATOR_PORT_INVALID */


/* Begin STRUCT: LocatorUDPv4_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::LocatorUDPv4_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.address);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.port);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::LocatorUDPv4_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.address)
    && (strm << stru.port);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::LocatorUDPv4_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.address)
    && (strm >> stru.port);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::LocatorUDPv4_t> : MetaStruct {
  typedef OpenDDS::RTPS::LocatorUDPv4_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::LocatorUDPv4_t& typed = *static_cast<const OpenDDS::RTPS::LocatorUDPv4_t*>(stru);
    if (std::strcmp(field, "address") == 0) {
      return typed.address;
    }
    if (std::strcmp(field, "port") == 0) {
      return typed.port;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::LocatorUDPv4_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "address") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'address' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strcmp(field, "port") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'port' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::LocatorUDPv4_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "address") == 0) {
      return make_field_cmp(&T::address, next);
    }
    if (std::strcmp(field, "port") == 0) {
      return make_field_cmp(&T::port, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::LocatorUDPv4_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"address", "port", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "address") == 0) {
      return &static_cast<const T*>(stru)->address;
    }
    if (std::strcmp(field, "port") == 0) {
      return &static_cast<const T*>(stru)->port;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::LocatorUDPv4_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "address") == 0) {
      static_cast<T*>(lhs)->address = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "port") == 0) {
      static_cast<T*>(lhs)->port = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::LocatorUDPv4_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "address") == 0) {
      return static_cast<const T*>(lhs)->address == static_cast<const T*>(rhs)->address;
    }
    if (std::strcmp(field, "port") == 0) {
      return static_cast<const T*>(lhs)->port == static_cast<const T*>(rhs)->port;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::LocatorUDPv4_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::LocatorUDPv4_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::LocatorUDPv4_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::LocatorUDPv4_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::LocatorUDPv4_t>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: LocatorUDPv4_t */


/* Begin STRUCT: TopicKind_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::TopicKind_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.value);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::TopicKind_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.value);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::TopicKind_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.value);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::TopicKind_t> : MetaStruct {
  typedef OpenDDS::RTPS::TopicKind_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::TopicKind_t& typed = *static_cast<const OpenDDS::RTPS::TopicKind_t*>(stru);
    if (std::strcmp(field, "value") == 0) {
      return typed.value;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::TopicKind_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'value' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::TopicKind_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "value") == 0) {
      return make_field_cmp(&T::value, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::TopicKind_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::TopicKind_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::TopicKind_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "value") == 0) {
      return static_cast<const T*>(lhs)->value == static_cast<const T*>(rhs)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::TopicKind_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::TopicKind_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::TopicKind_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::TopicKind_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::TopicKind_t>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TopicKind_t */


/* Begin CONST: NO_KEY */


/* End CONST: NO_KEY */


/* Begin CONST: WITH_KEY */


/* End CONST: WITH_KEY */


/* Begin STRUCT: ReliabilityKind_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::ReliabilityKind_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.value);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::ReliabilityKind_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.value);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::ReliabilityKind_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.value);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::ReliabilityKind_t> : MetaStruct {
  typedef OpenDDS::RTPS::ReliabilityKind_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::ReliabilityKind_t& typed = *static_cast<const OpenDDS::RTPS::ReliabilityKind_t*>(stru);
    if (std::strcmp(field, "value") == 0) {
      return typed.value;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ReliabilityKind_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'value' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::ReliabilityKind_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "value") == 0) {
      return make_field_cmp(&T::value, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ReliabilityKind_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ReliabilityKind_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ReliabilityKind_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "value") == 0) {
      return static_cast<const T*>(lhs)->value == static_cast<const T*>(rhs)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ReliabilityKind_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::ReliabilityKind_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::ReliabilityKind_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::ReliabilityKind_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::ReliabilityKind_t>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ReliabilityKind_t */


/* Begin CONST: BEST_EFFORT */


/* End CONST: BEST_EFFORT */


/* Begin CONST: RELIABLE */


/* End CONST: RELIABLE */


/* Begin STRUCT: KeyHash_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::KeyHash_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  OpenDDS::DCPS::OctetArray16_forany stru_value(const_cast<OpenDDS::DCPS::OctetArray16_slice*>(stru.value));
  gen_find_size(stru_value, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::KeyHash_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::DCPS::OctetArray16_forany stru_value(const_cast<OpenDDS::DCPS::OctetArray16_slice*>(stru.value));
  return (strm << stru_value);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::KeyHash_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::DCPS::OctetArray16_forany stru_value(const_cast<OpenDDS::DCPS::OctetArray16_slice*>(stru.value));
  return (strm >> stru_value);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::KeyHash_t> : MetaStruct {
  typedef OpenDDS::RTPS::KeyHash_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::KeyHash_t& typed = *static_cast<const OpenDDS::RTPS::KeyHash_t*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::KeyHash_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::OctetArray16_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::KeyHash_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::KeyHash_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::KeyHash_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      OpenDDS::DCPS::OctetArray16* lhsArr = &static_cast<T*>(lhs)->value;
      const OpenDDS::DCPS::OctetArray16* rhsArr = static_cast<const OpenDDS::DCPS::OctetArray16*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 16; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::KeyHash_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::KeyHash_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::KeyHash_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::KeyHash_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::KeyHash_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::KeyHash_t>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: KeyHash_t */


/* Begin STRUCT: StatusInfo_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::StatusInfo_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  OpenDDS::RTPS::OctetArray4_forany stru_value(const_cast<OpenDDS::RTPS::OctetArray4_slice*>(stru.value));
  gen_find_size(stru_value, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::StatusInfo_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::RTPS::OctetArray4_forany stru_value(const_cast<OpenDDS::RTPS::OctetArray4_slice*>(stru.value));
  return (strm << stru_value);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::StatusInfo_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::RTPS::OctetArray4_forany stru_value(const_cast<OpenDDS::RTPS::OctetArray4_slice*>(stru.value));
  return (strm >> stru_value);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::StatusInfo_t> : MetaStruct {
  typedef OpenDDS::RTPS::StatusInfo_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::StatusInfo_t& typed = *static_cast<const OpenDDS::RTPS::StatusInfo_t*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::StatusInfo_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::OctetArray4_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::StatusInfo_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::StatusInfo_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::StatusInfo_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      OpenDDS::RTPS::OctetArray4* lhsArr = &static_cast<T*>(lhs)->value;
      const OpenDDS::RTPS::OctetArray4* rhsArr = static_cast<const OpenDDS::RTPS::OctetArray4*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 4; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::StatusInfo_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::StatusInfo_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::StatusInfo_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::StatusInfo_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::StatusInfo_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::StatusInfo_t>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StatusInfo_t */


/* Begin STRUCT: ProtocolVersion_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::ProtocolVersion_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.major));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.minor));
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::ProtocolVersion_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << ACE_OutputCDR::from_octet(stru.major))
    && (strm << ACE_OutputCDR::from_octet(stru.minor));
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::ProtocolVersion_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> ACE_InputCDR::to_octet(stru.major))
    && (strm >> ACE_InputCDR::to_octet(stru.minor));
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::ProtocolVersion_t> : MetaStruct {
  typedef OpenDDS::RTPS::ProtocolVersion_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::ProtocolVersion_t& typed = *static_cast<const OpenDDS::RTPS::ProtocolVersion_t*>(stru);
    if (std::strcmp(field, "major") == 0) {
      return typed.major;
    }
    if (std::strcmp(field, "minor") == 0) {
      return typed.minor;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ProtocolVersion_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "major") == 0) {
      ACE_CDR::Octet val;
      if (!(ser >> ACE_InputCDR::to_octet(val))) {
        throw std::runtime_error("Field 'major' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 1);
    }
    if (std::strcmp(field, "minor") == 0) {
      ACE_CDR::Octet val;
      if (!(ser >> ACE_InputCDR::to_octet(val))) {
        throw std::runtime_error("Field 'minor' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 1);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::ProtocolVersion_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "major") == 0) {
      return make_field_cmp(&T::major, next);
    }
    if (std::strcmp(field, "minor") == 0) {
      return make_field_cmp(&T::minor, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ProtocolVersion_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"major", "minor", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "major") == 0) {
      return &static_cast<const T*>(stru)->major;
    }
    if (std::strcmp(field, "minor") == 0) {
      return &static_cast<const T*>(stru)->minor;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ProtocolVersion_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "major") == 0) {
      static_cast<T*>(lhs)->major = *static_cast<const CORBA::Octet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "minor") == 0) {
      static_cast<T*>(lhs)->minor = *static_cast<const CORBA::Octet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ProtocolVersion_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "major") == 0) {
      return static_cast<const T*>(lhs)->major == static_cast<const T*>(rhs)->major;
    }
    if (std::strcmp(field, "minor") == 0) {
      return static_cast<const T*>(lhs)->minor == static_cast<const T*>(rhs)->minor;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ProtocolVersion_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::ProtocolVersion_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::ProtocolVersion_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::ProtocolVersion_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::ProtocolVersion_t>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ProtocolVersion_t */


/* Begin STRUCT: VendorId_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::VendorId_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  OpenDDS::RTPS::OctetArray2_forany stru_vendorId(const_cast<OpenDDS::RTPS::OctetArray2_slice*>(stru.vendorId));
  gen_find_size(stru_vendorId, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::VendorId_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::RTPS::OctetArray2_forany stru_vendorId(const_cast<OpenDDS::RTPS::OctetArray2_slice*>(stru.vendorId));
  return (strm << stru_vendorId);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::VendorId_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::RTPS::OctetArray2_forany stru_vendorId(const_cast<OpenDDS::RTPS::OctetArray2_slice*>(stru.vendorId));
  return (strm >> stru_vendorId);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::VendorId_t> : MetaStruct {
  typedef OpenDDS::RTPS::VendorId_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::VendorId_t& typed = *static_cast<const OpenDDS::RTPS::VendorId_t*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::VendorId_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::OctetArray2_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::VendorId_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::VendorId_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"vendorId", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "vendorId") == 0) {
      return &static_cast<const T*>(stru)->vendorId;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::VendorId_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "vendorId") == 0) {
      OpenDDS::RTPS::OctetArray2* lhsArr = &static_cast<T*>(lhs)->vendorId;
      const OpenDDS::RTPS::OctetArray2* rhsArr = static_cast<const OpenDDS::RTPS::OctetArray2*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 2; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::VendorId_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::VendorId_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::VendorId_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::VendorId_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::VendorId_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::VendorId_t>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: VendorId_t */


/* Begin TYPEDEF: BuiltinEndpointSet_t */


/* End TYPEDEF: BuiltinEndpointSet_t */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_ANNOUNCER */


/* End CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_ANNOUNCER */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_DETECTOR */


/* End CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_DETECTOR */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_PUBLICATION_ANNOUNCER */


/* End CONST: DISC_BUILTIN_ENDPOINT_PUBLICATION_ANNOUNCER */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_PUBLICATION_DETECTOR */


/* End CONST: DISC_BUILTIN_ENDPOINT_PUBLICATION_DETECTOR */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_SUBSCRIPTION_ANNOUNCER */


/* End CONST: DISC_BUILTIN_ENDPOINT_SUBSCRIPTION_ANNOUNCER */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_SUBSCRIPTION_DETECTOR */


/* End CONST: DISC_BUILTIN_ENDPOINT_SUBSCRIPTION_DETECTOR */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_PROXY_ANNOUNCER */


/* End CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_PROXY_ANNOUNCER */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_PROXY_DETECTOR */


/* End CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_PROXY_DETECTOR */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_STATE_ANNOUNCER */


/* End CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_STATE_ANNOUNCER */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_STATE_DETECTOR */


/* End CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_STATE_DETECTOR */


/* Begin CONST: BUILTIN_ENDPOINT_PARTICIPANT_MESSAGE_DATA_WRITER */


/* End CONST: BUILTIN_ENDPOINT_PARTICIPANT_MESSAGE_DATA_WRITER */


/* Begin CONST: BUILTIN_ENDPOINT_PARTICIPANT_MESSAGE_DATA_READER */


/* End CONST: BUILTIN_ENDPOINT_PARTICIPANT_MESSAGE_DATA_READER */


/* Begin UNION-FWD: Parameter */


/* End UNION-FWD: Parameter */


/* Begin TYPEDEF: ParameterList */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::ParameterList& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    if (seq[i]._d() == OpenDDS::RTPS::PID_SENTINEL) continue;
    size_t param_size = 0, param_padding = 0;
    gen_find_size(seq[i], param_size, param_padding);
    size += param_size + param_padding;
    if (size % 4) {
      size += 4 - (size % 4);
    }
  }
  size += 4; /* PID_SENTINEL */
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::ParameterList& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    if (seq[i]._d() == OpenDDS::RTPS::PID_SENTINEL) continue;
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return (strm << OpenDDS::RTPS::PID_SENTINEL)
    && (strm << OpenDDS::RTPS::PID_PAD);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::ParameterList& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  while (true) {
    const CORBA::ULong len = seq.length();
    seq.length(len + 1);
    if (!(strm >> seq[len])) {
      return false;
    }
    if (seq[len]._d() == OpenDDS::RTPS::PID_SENTINEL) {
      seq.length(len);
      return true;
    }
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::ParameterList*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: ParameterList */


/* Begin STRUCT: OriginalWriterInfo_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::OriginalWriterInfo_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.originalWriterGUID, size, padding);
  gen_find_size(stru.originalWriterSN, size, padding);
  gen_find_size(stru.originalWriterQos, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::OriginalWriterInfo_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.originalWriterGUID)
    && (strm << stru.originalWriterSN)
    && (strm << stru.originalWriterQos);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::OriginalWriterInfo_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.originalWriterGUID)
    && (strm >> stru.originalWriterSN)
    && (strm >> stru.originalWriterQos);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::OriginalWriterInfo_t> : MetaStruct {
  typedef OpenDDS::RTPS::OriginalWriterInfo_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::OriginalWriterInfo_t& typed = *static_cast<const OpenDDS::RTPS::OriginalWriterInfo_t*>(stru);
    if (std::strncmp(field, "originalWriterGUID.", 19) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.originalWriterGUID, field + 19);
    }
    if (std::strncmp(field, "originalWriterSN.", 17) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.originalWriterSN, field + 17);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::OriginalWriterInfo_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "originalWriterGUID.", 19) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 19);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    if (std::strncmp(field, "originalWriterSN.", 17) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(ser, field + 17);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumber_t*>(0));
    }
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::ParameterList*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::OriginalWriterInfo_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "originalWriterGUID.", 19) == 0) {
      return make_struct_cmp(&T::originalWriterGUID, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 19), next);
    }
    if (std::strncmp(field, "originalWriterSN.", 17) == 0) {
      return make_struct_cmp(&T::originalWriterSN, getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 17), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::OriginalWriterInfo_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"originalWriterGUID", "originalWriterSN", "originalWriterQos", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "originalWriterGUID") == 0) {
      return &static_cast<const T*>(stru)->originalWriterGUID;
    }
    if (std::strcmp(field, "originalWriterSN") == 0) {
      return &static_cast<const T*>(stru)->originalWriterSN;
    }
    if (std::strcmp(field, "originalWriterQos") == 0) {
      return &static_cast<const T*>(stru)->originalWriterQos;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::OriginalWriterInfo_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "originalWriterGUID") == 0) {
      static_cast<T*>(lhs)->originalWriterGUID = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "originalWriterSN") == 0) {
      static_cast<T*>(lhs)->originalWriterSN = *static_cast<const OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "originalWriterQos") == 0) {
      static_cast<T*>(lhs)->originalWriterQos = *static_cast<const OpenDDS::RTPS::ParameterList*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::OriginalWriterInfo_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::OriginalWriterInfo_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::OriginalWriterInfo_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::OriginalWriterInfo_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::OriginalWriterInfo_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::OriginalWriterInfo_t>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: OriginalWriterInfo_t */


/* Begin TYPEDEF: ParameterId_t */


/* End TYPEDEF: ParameterId_t */


/* Begin CONST: PID_PAD */


/* End CONST: PID_PAD */


/* Begin CONST: PID_SENTINEL */


/* End CONST: PID_SENTINEL */


/* Begin CONST: PID_USER_DATA */


/* End CONST: PID_USER_DATA */


/* Begin CONST: PID_TOPIC_NAME */


/* End CONST: PID_TOPIC_NAME */


/* Begin CONST: PID_TYPE_NAME */


/* End CONST: PID_TYPE_NAME */


/* Begin CONST: PID_GROUP_DATA */


/* End CONST: PID_GROUP_DATA */


/* Begin CONST: PID_TOPIC_DATA */


/* End CONST: PID_TOPIC_DATA */


/* Begin CONST: PID_DURABILITY */


/* End CONST: PID_DURABILITY */


/* Begin CONST: PID_DURABILITY_SERVICE */


/* End CONST: PID_DURABILITY_SERVICE */


/* Begin CONST: PID_DEADLINE */


/* End CONST: PID_DEADLINE */


/* Begin CONST: PID_LATENCY_BUDGET */


/* End CONST: PID_LATENCY_BUDGET */


/* Begin CONST: PID_LIVELINESS */


/* End CONST: PID_LIVELINESS */


/* Begin CONST: PID_RELIABILITY */


/* End CONST: PID_RELIABILITY */


/* Begin CONST: PID_LIFESPAN */


/* End CONST: PID_LIFESPAN */


/* Begin CONST: PID_DESTINATION_ORDER */


/* End CONST: PID_DESTINATION_ORDER */


/* Begin CONST: PID_HISTORY */


/* End CONST: PID_HISTORY */


/* Begin CONST: PID_RESOURCE_LIMITS */


/* End CONST: PID_RESOURCE_LIMITS */


/* Begin CONST: PID_OWNERSHIP */


/* End CONST: PID_OWNERSHIP */


/* Begin CONST: PID_OWNERSHIP_STRENGTH */


/* End CONST: PID_OWNERSHIP_STRENGTH */


/* Begin CONST: PID_PRESENTATION */


/* End CONST: PID_PRESENTATION */


/* Begin CONST: PID_PARTITION */


/* End CONST: PID_PARTITION */


/* Begin CONST: PID_TIME_BASED_FILTER */


/* End CONST: PID_TIME_BASED_FILTER */


/* Begin CONST: PID_TRANSPORT_PRIORITY */


/* End CONST: PID_TRANSPORT_PRIORITY */


/* Begin CONST: PID_PROTOCOL_VERSION */


/* End CONST: PID_PROTOCOL_VERSION */


/* Begin CONST: PID_VENDORID */


/* End CONST: PID_VENDORID */


/* Begin CONST: PID_UNICAST_LOCATOR */


/* End CONST: PID_UNICAST_LOCATOR */


/* Begin CONST: PID_MULTICAST_LOCATOR */


/* End CONST: PID_MULTICAST_LOCATOR */


/* Begin CONST: PID_MULTICAST_IPADDRESS */


/* End CONST: PID_MULTICAST_IPADDRESS */


/* Begin CONST: PID_DEFAULT_UNICAST_LOCATOR */


/* End CONST: PID_DEFAULT_UNICAST_LOCATOR */


/* Begin CONST: PID_DEFAULT_MULTICAST_LOCATOR */


/* End CONST: PID_DEFAULT_MULTICAST_LOCATOR */


/* Begin CONST: PID_METATRAFFIC_UNICAST_LOCATOR */


/* End CONST: PID_METATRAFFIC_UNICAST_LOCATOR */


/* Begin CONST: PID_METATRAFFIC_MULTICAST_LOCATOR */


/* End CONST: PID_METATRAFFIC_MULTICAST_LOCATOR */


/* Begin CONST: PID_DEFAULT_UNICAST_IPADDRESS */


/* End CONST: PID_DEFAULT_UNICAST_IPADDRESS */


/* Begin CONST: PID_DEFAULT_UNICAST_PORT */


/* End CONST: PID_DEFAULT_UNICAST_PORT */


/* Begin CONST: PID_METATRAFFIC_UNICAST_IPADDRESS */


/* End CONST: PID_METATRAFFIC_UNICAST_IPADDRESS */


/* Begin CONST: PID_METATRAFFIC_UNICAST_PORT */


/* End CONST: PID_METATRAFFIC_UNICAST_PORT */


/* Begin CONST: PID_METATRAFFIC_MULTICAST_IPADDRESS */


/* End CONST: PID_METATRAFFIC_MULTICAST_IPADDRESS */


/* Begin CONST: PID_METATRAFFIC_MULTICAST_PORT */


/* End CONST: PID_METATRAFFIC_MULTICAST_PORT */


/* Begin CONST: PID_EXPECTS_INLINE_QOS */


/* End CONST: PID_EXPECTS_INLINE_QOS */


/* Begin CONST: PID_PARTICIPANT_MANUAL_LIVELINESS_COUNT */


/* End CONST: PID_PARTICIPANT_MANUAL_LIVELINESS_COUNT */


/* Begin CONST: PID_PARTICIPANT_BUILTIN_ENDPOINTS */


/* End CONST: PID_PARTICIPANT_BUILTIN_ENDPOINTS */


/* Begin CONST: PID_PARTICIPANT_LEASE_DURATION */


/* End CONST: PID_PARTICIPANT_LEASE_DURATION */


/* Begin CONST: PID_CONTENT_FILTER_PROPERTY */


/* End CONST: PID_CONTENT_FILTER_PROPERTY */


/* Begin CONST: PID_PARTICIPANT_GUID */


/* End CONST: PID_PARTICIPANT_GUID */


/* Begin CONST: PID_PARTICIPANT_ENTITYID */


/* End CONST: PID_PARTICIPANT_ENTITYID */


/* Begin CONST: PID_GROUP_GUID */


/* End CONST: PID_GROUP_GUID */


/* Begin CONST: PID_GROUP_ENTITYID */


/* End CONST: PID_GROUP_ENTITYID */


/* Begin CONST: PID_BUILTIN_ENDPOINT_SET */


/* End CONST: PID_BUILTIN_ENDPOINT_SET */


/* Begin CONST: PID_PROPERTY_LIST */


/* End CONST: PID_PROPERTY_LIST */


/* Begin CONST: PID_TYPE_MAX_SIZE_SERIALIZED */


/* End CONST: PID_TYPE_MAX_SIZE_SERIALIZED */


/* Begin CONST: PID_ENTITY_NAME */


/* End CONST: PID_ENTITY_NAME */


/* Begin CONST: PID_KEY_HASH */


/* End CONST: PID_KEY_HASH */


/* Begin CONST: PID_STATUS_INFO */


/* End CONST: PID_STATUS_INFO */


/* Begin CONST: PID_ENDPOINT_GUID */


/* End CONST: PID_ENDPOINT_GUID */


/* Begin CONST: PID_CONTENT_FILTER_INFO */


/* End CONST: PID_CONTENT_FILTER_INFO */


/* Begin CONST: PID_COHERENT_SET */


/* End CONST: PID_COHERENT_SET */


/* Begin CONST: PID_DIRECTED_WRITE */


/* End CONST: PID_DIRECTED_WRITE */


/* Begin CONST: PID_ORIGINAL_WRITER_INFO */


/* End CONST: PID_ORIGINAL_WRITER_INFO */


/* Begin CONST: PIDMASK_VENDOR_SPECIFIC */


/* End CONST: PIDMASK_VENDOR_SPECIFIC */


/* Begin CONST: PIDMASK_INCOMPATIBLE */


/* End CONST: PIDMASK_INCOMPATIBLE */


/* Begin CONST: PID_OPENDDS_BASE */


/* End CONST: PID_OPENDDS_BASE */


/* Begin CONST: PID_OPENDDS_LOCATOR */


/* End CONST: PID_OPENDDS_LOCATOR */


/* Begin CONST: PID_OPENDDS_ASSOCIATED_WRITER */


/* End CONST: PID_OPENDDS_ASSOCIATED_WRITER */


/* Begin UNION: Parameter */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::Parameter& uni, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(uni);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  switch (uni._d()) {
  case 5u:
  case 7u:
    {
      find_size_ulong(size, padding);
      size += ACE_OS::strlen(uni.string_data()) + 1;
      break;
    }
  case 44u:
    {
      gen_find_size(uni.user_data(), size, padding);
      break;
    }
  case 45u:
    {
      gen_find_size(uni.group_data(), size, padding);
      break;
    }
  case 46u:
    {
      gen_find_size(uni.topic_data(), size, padding);
      break;
    }
  case 29u:
    {
      gen_find_size(uni.durability(), size, padding);
      break;
    }
  case 30u:
    {
      gen_find_size(uni.durability_service(), size, padding);
      break;
    }
  case 35u:
    {
      gen_find_size(uni.deadline(), size, padding);
      break;
    }
  case 39u:
    {
      gen_find_size(uni.latency_budget(), size, padding);
      break;
    }
  case 27u:
    {
      gen_find_size(uni.liveliness(), size, padding);
      break;
    }
  case 26u:
    {
      gen_find_size(uni.reliability(), size, padding);
      break;
    }
  case 43u:
    {
      gen_find_size(uni.lifespan(), size, padding);
      break;
    }
  case 37u:
    {
      gen_find_size(uni.destination_order(), size, padding);
      break;
    }
  case 64u:
    {
      gen_find_size(uni.history(), size, padding);
      break;
    }
  case 65u:
    {
      gen_find_size(uni.resource_limits(), size, padding);
      break;
    }
  case 31u:
    {
      gen_find_size(uni.ownership(), size, padding);
      break;
    }
  case 6u:
    {
      gen_find_size(uni.ownership_strength(), size, padding);
      break;
    }
  case 33u:
    {
      gen_find_size(uni.presentation(), size, padding);
      break;
    }
  case 41u:
    {
      gen_find_size(uni.partition(), size, padding);
      break;
    }
  case 4u:
    {
      gen_find_size(uni.time_based_filter(), size, padding);
      break;
    }
  case 73u:
    {
      gen_find_size(uni.transport_priority(), size, padding);
      break;
    }
  case 21u:
    {
      gen_find_size(uni.version(), size, padding);
      break;
    }
  case 22u:
    {
      gen_find_size(uni.vendor(), size, padding);
      break;
    }
  case 47u:
  case 48u:
  case 49u:
  case 72u:
  case 50u:
  case 51u:
    {
      gen_find_size(uni.locator(), size, padding);
      break;
    }
  case 17u:
  case 12u:
  case 69u:
  case 11u:
    {
      if ((size + padding) % 4) {
        padding += 4 - ((size + padding) % 4);
      }
      size += gen_max_marshaled_size(uni.ipv4_address());
      break;
    }
  case 14u:
  case 13u:
  case 70u:
    {
      if ((size + padding) % 4) {
        padding += 4 - ((size + padding) % 4);
      }
      size += gen_max_marshaled_size(uni.udpv4_port());
      break;
    }
  case 67u:
    {
      size += gen_max_marshaled_size(ACE_OutputCDR::from_boolean(uni.expects_inline_qos()));
      break;
    }
  case 52u:
    {
      gen_find_size(uni.count(), size, padding);
      break;
    }
  case 68u:
    {
      if ((size + padding) % 4) {
        padding += 4 - ((size + padding) % 4);
      }
      size += gen_max_marshaled_size(uni.participant_builtin_endpoints());
      break;
    }
  case 2u:
    {
      gen_find_size(uni.duration(), size, padding);
      break;
    }
  case 53u:
    {
      gen_find_size(uni.content_filter_property(), size, padding);
      break;
    }
  case 80u:
  case 90u:
  case 82u:
  case 45058u:
    {
      gen_find_size(uni.guid(), size, padding);
      break;
    }
  case 81u:
  case 83u:
    {
      gen_find_size(uni.entity_id(), size, padding);
      break;
    }
  case 88u:
    {
      if ((size + padding) % 4) {
        padding += 4 - ((size + padding) % 4);
      }
      size += gen_max_marshaled_size(uni.builtin_endpoints());
      break;
    }
  case 89u:
    {
      gen_find_size(uni.properties(), size, padding);
      break;
    }
  case 96u:
    {
      if ((size + padding) % 4) {
        padding += 4 - ((size + padding) % 4);
      }
      size += gen_max_marshaled_size(uni.type_max_size_serialized());
      break;
    }
  case 98u:
    {
      gen_find_size(uni.entity_name(), size, padding);
      break;
    }
  case 112u:
    {
      gen_find_size(uni.key_hash(), size, padding);
      break;
    }
  case 113u:
    {
      gen_find_size(uni.status_info(), size, padding);
      break;
    }
  case 85u:
    {
      gen_find_size(uni.content_filter_info(), size, padding);
      break;
    }
  case 86u:
    {
      gen_find_size(uni.coherent_set(), size, padding);
      break;
    }
  case 87u:
    {
      gen_find_size(uni.directed_write(), size, padding);
      break;
    }
  case 97u:
    {
      gen_find_size(uni.original_writer_info(), size, padding);
      break;
    }
  case 45057u:
    {
      gen_find_size(uni.opendds_locator(), size, padding);
      break;
    }
  default:
    {
      gen_find_size(uni.unknown_data(), size, padding);
      break;
    }
  }
  size += 4; // parameterId & length
}

bool operator<<(Serializer& outer_strm, const OpenDDS::RTPS::Parameter& uni)
{
  ACE_UNUSED_ARG(outer_strm);
  ACE_UNUSED_ARG(uni);
  if (!(outer_strm << uni._d())) {
    return false;
  }
  size_t size = 0, pad = 0;
  gen_find_size(uni, size, pad);
  size -= 4; // parameterId & length
  const size_t post_pad = 4 - ((size + pad) % 4);
  const size_t total = size + pad + ((post_pad < 4) ? post_pad : 0);
  if (size + pad > ACE_UINT16_MAX || !(outer_strm << ACE_CDR::UShort(total))) {
    return false;
  }
  ACE_Message_Block param(size + pad);
  Serializer strm(&param, outer_strm.swap_bytes(), outer_strm.alignment());
  if (!insertParamData(strm, uni)) {
    return false;
  }
  const ACE_CDR::Octet* data = reinterpret_cast<ACE_CDR::Octet*>(param.rd_ptr());
  if (!outer_strm.write_octet_array(data, ACE_CDR::ULong(param.length()))) {
    return false;
  }
  if (post_pad < 4 && outer_strm.alignment() != Serializer::ALIGN_NONE) {
    static const ACE_CDR::Octet padding[3] = {0};
    return outer_strm.write_octet_array(padding, ACE_CDR::ULong(post_pad));
  }
  return true;
}

bool insertParamData(Serializer& strm, const OpenDDS::RTPS::Parameter& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  switch (uni._d()) {
  case 5u:
  case 7u:
    {
      return (strm << uni.string_data());
    }
  case 44u:
    {
      return (strm << uni.user_data());
    }
  case 45u:
    {
      return (strm << uni.group_data());
    }
  case 46u:
    {
      return (strm << uni.topic_data());
    }
  case 29u:
    {
      return (strm << uni.durability());
    }
  case 30u:
    {
      return (strm << uni.durability_service());
    }
  case 35u:
    {
      return (strm << uni.deadline());
    }
  case 39u:
    {
      return (strm << uni.latency_budget());
    }
  case 27u:
    {
      return (strm << uni.liveliness());
    }
  case 26u:
    {
      return (strm << uni.reliability());
    }
  case 43u:
    {
      return (strm << uni.lifespan());
    }
  case 37u:
    {
      return (strm << uni.destination_order());
    }
  case 64u:
    {
      return (strm << uni.history());
    }
  case 65u:
    {
      return (strm << uni.resource_limits());
    }
  case 31u:
    {
      return (strm << uni.ownership());
    }
  case 6u:
    {
      return (strm << uni.ownership_strength());
    }
  case 33u:
    {
      return (strm << uni.presentation());
    }
  case 41u:
    {
      return (strm << uni.partition());
    }
  case 4u:
    {
      return (strm << uni.time_based_filter());
    }
  case 73u:
    {
      return (strm << uni.transport_priority());
    }
  case 21u:
    {
      return (strm << uni.version());
    }
  case 22u:
    {
      return (strm << uni.vendor());
    }
  case 47u:
  case 48u:
  case 49u:
  case 72u:
  case 50u:
  case 51u:
    {
      return (strm << uni.locator());
    }
  case 17u:
  case 12u:
  case 69u:
  case 11u:
    {
      return (strm << uni.ipv4_address());
    }
  case 14u:
  case 13u:
  case 70u:
    {
      return (strm << uni.udpv4_port());
    }
  case 67u:
    {
      return (strm << ACE_OutputCDR::from_boolean(uni.expects_inline_qos()));
    }
  case 52u:
    {
      return (strm << uni.count());
    }
  case 68u:
    {
      return (strm << uni.participant_builtin_endpoints());
    }
  case 2u:
    {
      return (strm << uni.duration());
    }
  case 53u:
    {
      return (strm << uni.content_filter_property());
    }
  case 80u:
  case 90u:
  case 82u:
  case 45058u:
    {
      return (strm << uni.guid());
    }
  case 81u:
  case 83u:
    {
      return (strm << uni.entity_id());
    }
  case 88u:
    {
      return (strm << uni.builtin_endpoints());
    }
  case 89u:
    {
      return (strm << uni.properties());
    }
  case 96u:
    {
      return (strm << uni.type_max_size_serialized());
    }
  case 98u:
    {
      return (strm << uni.entity_name());
    }
  case 112u:
    {
      return (strm << uni.key_hash());
    }
  case 113u:
    {
      return (strm << uni.status_info());
    }
  case 85u:
    {
      return (strm << uni.content_filter_info());
    }
  case 86u:
    {
      return (strm << uni.coherent_set());
    }
  case 87u:
    {
      return (strm << uni.directed_write());
    }
  case 97u:
    {
      return (strm << uni.original_writer_info());
    }
  case 45057u:
    {
      return (strm << uni.opendds_locator());
    }
  default:
    {
      return (strm << uni.unknown_data());
    }
  }
}

bool operator>>(Serializer& outer_strm, OpenDDS::RTPS::Parameter& uni)
{
  ACE_UNUSED_ARG(outer_strm);
  ACE_UNUSED_ARG(uni);
  ACE_CDR::UShort disc, size;
  if (!(outer_strm >> disc) || !(outer_strm >> size)) {
    return false;
  }
  if (disc == OpenDDS::RTPS::PID_SENTINEL) {
    uni._d(OpenDDS::RTPS::PID_SENTINEL);
    return true;
  }
  ACE_Message_Block param(size);
  ACE_CDR::Octet* data = reinterpret_cast<ACE_CDR::Octet*>(param.wr_ptr());
  if (!outer_strm.read_octet_array(data, size)) {
    return false;
  }
  param.wr_ptr(size);
  Serializer strm(&param, outer_strm.swap_bytes(), Serializer::ALIGN_CDR);
  switch (disc) {
  case 5u:
  case 7u:
    {
      CORBA::String_var tmp;
      if (strm >> tmp.out()) {
        uni.string_data(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 44u:
    {
      DDS::UserDataQosPolicy tmp;
      if (strm >> tmp) {
        uni.user_data(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 45u:
    {
      DDS::GroupDataQosPolicy tmp;
      if (strm >> tmp) {
        uni.group_data(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 46u:
    {
      DDS::TopicDataQosPolicy tmp;
      if (strm >> tmp) {
        uni.topic_data(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 29u:
    {
      DDS::DurabilityQosPolicy tmp;
      if (strm >> tmp) {
        uni.durability(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 30u:
    {
      DDS::DurabilityServiceQosPolicy tmp;
      if (strm >> tmp) {
        uni.durability_service(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 35u:
    {
      DDS::DeadlineQosPolicy tmp;
      if (strm >> tmp) {
        uni.deadline(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 39u:
    {
      DDS::LatencyBudgetQosPolicy tmp;
      if (strm >> tmp) {
        uni.latency_budget(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 27u:
    {
      DDS::LivelinessQosPolicy tmp;
      if (strm >> tmp) {
        uni.liveliness(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 26u:
    {
      DDS::ReliabilityQosPolicy tmp;
      if (strm >> tmp) {
        uni.reliability(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 43u:
    {
      DDS::LifespanQosPolicy tmp;
      if (strm >> tmp) {
        uni.lifespan(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 37u:
    {
      DDS::DestinationOrderQosPolicy tmp;
      if (strm >> tmp) {
        uni.destination_order(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 64u:
    {
      DDS::HistoryQosPolicy tmp;
      if (strm >> tmp) {
        uni.history(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 65u:
    {
      DDS::ResourceLimitsQosPolicy tmp;
      if (strm >> tmp) {
        uni.resource_limits(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 31u:
    {
      DDS::OwnershipQosPolicy tmp;
      if (strm >> tmp) {
        uni.ownership(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 6u:
    {
      DDS::OwnershipStrengthQosPolicy tmp;
      if (strm >> tmp) {
        uni.ownership_strength(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 33u:
    {
      DDS::PresentationQosPolicy tmp;
      if (strm >> tmp) {
        uni.presentation(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 41u:
    {
      DDS::PartitionQosPolicy tmp;
      if (strm >> tmp) {
        uni.partition(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 4u:
    {
      DDS::TimeBasedFilterQosPolicy tmp;
      if (strm >> tmp) {
        uni.time_based_filter(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 73u:
    {
      DDS::TransportPriorityQosPolicy tmp;
      if (strm >> tmp) {
        uni.transport_priority(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 21u:
    {
      OpenDDS::RTPS::ProtocolVersion_t tmp;
      if (strm >> tmp) {
        uni.version(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 22u:
    {
      OpenDDS::RTPS::VendorId_t tmp;
      if (strm >> tmp) {
        uni.vendor(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 47u:
  case 48u:
  case 49u:
  case 72u:
  case 50u:
  case 51u:
    {
      OpenDDS::DCPS::Locator_t tmp;
      if (strm >> tmp) {
        uni.locator(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 17u:
  case 12u:
  case 69u:
  case 11u:
    {
      CORBA::ULong tmp;
      if (strm >> tmp) {
        uni.ipv4_address(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 14u:
  case 13u:
  case 70u:
    {
      CORBA::ULong tmp;
      if (strm >> tmp) {
        uni.udpv4_port(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 67u:
    {
      CORBA::Boolean tmp;
      if (strm >> ACE_InputCDR::to_boolean(tmp)) {
        uni.expects_inline_qos(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 52u:
    {
      OpenDDS::RTPS::Count_t tmp;
      if (strm >> tmp) {
        uni.count(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 68u:
    {
      CORBA::ULong tmp;
      if (strm >> tmp) {
        uni.participant_builtin_endpoints(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 2u:
    {
      OpenDDS::RTPS::Duration_t tmp;
      if (strm >> tmp) {
        uni.duration(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 53u:
    {
      OpenDDS::DCPS::ContentFilterProperty_t tmp;
      if (strm >> tmp) {
        uni.content_filter_property(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 80u:
  case 90u:
  case 82u:
  case 45058u:
    {
      OpenDDS::DCPS::GUID_t tmp;
      if (strm >> tmp) {
        uni.guid(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 81u:
  case 83u:
    {
      OpenDDS::DCPS::EntityId_t tmp;
      if (strm >> tmp) {
        uni.entity_id(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 88u:
    {
      OpenDDS::RTPS::BuiltinEndpointSet_t tmp;
      if (strm >> tmp) {
        uni.builtin_endpoints(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 89u:
    {
      OpenDDS::RTPS::PropertySeq tmp;
      if (strm >> tmp) {
        uni.properties(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 96u:
    {
      CORBA::Long tmp;
      if (strm >> tmp) {
        uni.type_max_size_serialized(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 98u:
    {
      OpenDDS::RTPS::EntityName_t tmp;
      if (strm >> tmp) {
        uni.entity_name(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 112u:
    {
      OpenDDS::RTPS::KeyHash_t tmp;
      if (strm >> tmp) {
        uni.key_hash(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 113u:
    {
      OpenDDS::RTPS::StatusInfo_t tmp;
      if (strm >> tmp) {
        uni.status_info(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 85u:
    {
      OpenDDS::RTPS::ContentFilterInfo_t tmp;
      if (strm >> tmp) {
        uni.content_filter_info(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 86u:
    {
      OpenDDS::RTPS::SequenceNumber_t tmp;
      if (strm >> tmp) {
        uni.coherent_set(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 87u:
    {
      OpenDDS::DCPS::GUIDSeq tmp;
      if (strm >> tmp) {
        uni.directed_write(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 97u:
    {
      OpenDDS::RTPS::OriginalWriterInfo_t tmp;
      if (strm >> tmp) {
        uni.original_writer_info(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  case 45057u:
    {
      OpenDDS::DCPS::TransportLocator tmp;
      if (strm >> tmp) {
        uni.opendds_locator(tmp);
        uni._d(disc);
        return true;
      }
      return false;
    }
  default:
    {
      uni.unknown_data(DDS::OctetSeq(size));
      uni.unknown_data().length(size);
      std::memcpy(uni.unknown_data().get_buffer(), data, size);
      uni._d(disc);
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::Parameter*)
{
  ACE_UNUSED_ARG(ser);
  CORBA::UShort disc;
  if (!(ser >> disc)) {
    return;
  }
  switch (disc) {
  case 5u:
  case 7u:
    {
      ACE_CDR::ULong len;
      ser >> len;
      ser.skip(len);
      break;
    }
  case 44u:
    {
    gen_skip_over(ser, static_cast<DDS::UserDataQosPolicy*>(0));
      break;
    }
  case 45u:
    {
    gen_skip_over(ser, static_cast<DDS::GroupDataQosPolicy*>(0));
      break;
    }
  case 46u:
    {
    gen_skip_over(ser, static_cast<DDS::TopicDataQosPolicy*>(0));
      break;
    }
  case 29u:
    {
    gen_skip_over(ser, static_cast<DDS::DurabilityQosPolicy*>(0));
      break;
    }
  case 30u:
    {
    gen_skip_over(ser, static_cast<DDS::DurabilityServiceQosPolicy*>(0));
      break;
    }
  case 35u:
    {
    gen_skip_over(ser, static_cast<DDS::DeadlineQosPolicy*>(0));
      break;
    }
  case 39u:
    {
    gen_skip_over(ser, static_cast<DDS::LatencyBudgetQosPolicy*>(0));
      break;
    }
  case 27u:
    {
    gen_skip_over(ser, static_cast<DDS::LivelinessQosPolicy*>(0));
      break;
    }
  case 26u:
    {
    gen_skip_over(ser, static_cast<DDS::ReliabilityQosPolicy*>(0));
      break;
    }
  case 43u:
    {
    gen_skip_over(ser, static_cast<DDS::LifespanQosPolicy*>(0));
      break;
    }
  case 37u:
    {
    gen_skip_over(ser, static_cast<DDS::DestinationOrderQosPolicy*>(0));
      break;
    }
  case 64u:
    {
    gen_skip_over(ser, static_cast<DDS::HistoryQosPolicy*>(0));
      break;
    }
  case 65u:
    {
    gen_skip_over(ser, static_cast<DDS::ResourceLimitsQosPolicy*>(0));
      break;
    }
  case 31u:
    {
    gen_skip_over(ser, static_cast<DDS::OwnershipQosPolicy*>(0));
      break;
    }
  case 6u:
    {
    gen_skip_over(ser, static_cast<DDS::OwnershipStrengthQosPolicy*>(0));
      break;
    }
  case 33u:
    {
    gen_skip_over(ser, static_cast<DDS::PresentationQosPolicy*>(0));
      break;
    }
  case 41u:
    {
    gen_skip_over(ser, static_cast<DDS::PartitionQosPolicy*>(0));
      break;
    }
  case 4u:
    {
    gen_skip_over(ser, static_cast<DDS::TimeBasedFilterQosPolicy*>(0));
      break;
    }
  case 73u:
    {
    gen_skip_over(ser, static_cast<DDS::TransportPriorityQosPolicy*>(0));
      break;
    }
  case 21u:
    {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::ProtocolVersion_t*>(0));
      break;
    }
  case 22u:
    {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::VendorId_t*>(0));
      break;
    }
  case 47u:
  case 48u:
  case 49u:
  case 72u:
  case 50u:
  case 51u:
    {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::Locator_t*>(0));
      break;
    }
  case 17u:
  case 12u:
  case 69u:
  case 11u:
    {
    ser.skip(1, 4);
      break;
    }
  case 14u:
  case 13u:
  case 70u:
    {
    ser.skip(1, 4);
      break;
    }
  case 67u:
    {
    ser.skip(1, 1);
      break;
    }
  case 52u:
    {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::Count_t*>(0));
      break;
    }
  case 68u:
    {
    ser.skip(1, 4);
      break;
    }
  case 2u:
    {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::Duration_t*>(0));
      break;
    }
  case 53u:
    {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::ContentFilterProperty_t*>(0));
      break;
    }
  case 80u:
  case 90u:
  case 82u:
  case 45058u:
    {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
      break;
    }
  case 81u:
  case 83u:
    {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::EntityId_t*>(0));
      break;
    }
  case 88u:
    {
    ser.skip(1, 4);
      break;
    }
  case 89u:
    {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::PropertySeq*>(0));
      break;
    }
  case 96u:
    {
    ser.skip(1, 4);
      break;
    }
  case 98u:
    {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::EntityName_t*>(0));
      break;
    }
  case 112u:
    {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::KeyHash_t*>(0));
      break;
    }
  case 113u:
    {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::StatusInfo_t*>(0));
      break;
    }
  case 85u:
    {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::ContentFilterInfo_t*>(0));
      break;
    }
  case 86u:
    {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumber_t*>(0));
      break;
    }
  case 87u:
    {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUIDSeq*>(0));
      break;
    }
  case 97u:
    {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::OriginalWriterInfo_t*>(0));
      break;
    }
  case 45057u:
    {
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::TransportLocator*>(0));
      break;
    }
  default:
    {
    gen_skip_over(ser, static_cast<DDS::OctetSeq*>(0));
      break;
    }
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End UNION: Parameter */


/* Begin STRUCT: SubmessageHeader */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::SubmessageHeader& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.submessageId));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.flags));
  if ((size + padding) % 2) {
    padding += 2 - ((size + padding) % 2);
  }
  size += gen_max_marshaled_size(stru.submessageLength);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::SubmessageHeader& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  strm.swap_bytes(ACE_CDR_BYTE_ORDER != (stru.flags & 1));
  return (strm << ACE_OutputCDR::from_octet(stru.submessageId))
    && (strm << ACE_OutputCDR::from_octet(stru.flags))
    && (strm << stru.submessageLength);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::SubmessageHeader& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> ACE_InputCDR::to_octet(stru.submessageId))
    && (strm >> ACE_InputCDR::to_octet(stru.flags))
    && (strm >> stru.submessageLength);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::SubmessageHeader> : MetaStruct {
  typedef OpenDDS::RTPS::SubmessageHeader T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::SubmessageHeader& typed = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(stru);
    if (std::strcmp(field, "submessageId") == 0) {
      return typed.submessageId;
    }
    if (std::strcmp(field, "flags") == 0) {
      return typed.flags;
    }
    if (std::strcmp(field, "submessageLength") == 0) {
      return typed.submessageLength;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SubmessageHeader)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "submessageId") == 0) {
      ACE_CDR::Octet val;
      if (!(ser >> ACE_InputCDR::to_octet(val))) {
        throw std::runtime_error("Field 'submessageId' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 1);
    }
    if (std::strcmp(field, "flags") == 0) {
      ACE_CDR::Octet val;
      if (!(ser >> ACE_InputCDR::to_octet(val))) {
        throw std::runtime_error("Field 'flags' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 1);
    }
    if (std::strcmp(field, "submessageLength") == 0) {
      ACE_CDR::UShort val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'submessageLength' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 2);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::SubmessageHeader");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "submessageId") == 0) {
      return make_field_cmp(&T::submessageId, next);
    }
    if (std::strcmp(field, "flags") == 0) {
      return make_field_cmp(&T::flags, next);
    }
    if (std::strcmp(field, "submessageLength") == 0) {
      return make_field_cmp(&T::submessageLength, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SubmessageHeader)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"submessageId", "flags", "submessageLength", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "submessageId") == 0) {
      return &static_cast<const T*>(stru)->submessageId;
    }
    if (std::strcmp(field, "flags") == 0) {
      return &static_cast<const T*>(stru)->flags;
    }
    if (std::strcmp(field, "submessageLength") == 0) {
      return &static_cast<const T*>(stru)->submessageLength;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SubmessageHeader)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "submessageId") == 0) {
      static_cast<T*>(lhs)->submessageId = *static_cast<const CORBA::Octet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "flags") == 0) {
      static_cast<T*>(lhs)->flags = *static_cast<const CORBA::Octet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "submessageLength") == 0) {
      static_cast<T*>(lhs)->submessageLength = *static_cast<const CORBA::UShort*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SubmessageHeader)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "submessageId") == 0) {
      return static_cast<const T*>(lhs)->submessageId == static_cast<const T*>(rhs)->submessageId;
    }
    if (std::strcmp(field, "flags") == 0) {
      return static_cast<const T*>(lhs)->flags == static_cast<const T*>(rhs)->flags;
    }
    if (std::strcmp(field, "submessageLength") == 0) {
      return static_cast<const T*>(lhs)->submessageLength == static_cast<const T*>(rhs)->submessageLength;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SubmessageHeader)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::SubmessageHeader>()
{
  static MetaStructImpl<OpenDDS::RTPS::SubmessageHeader> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::SubmessageHeader*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SubmessageHeader */


/* Begin STRUCT: FragmentNumber_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::FragmentNumber_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.value);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::FragmentNumber_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.value);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::FragmentNumber_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.value);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::FragmentNumber_t> : MetaStruct {
  typedef OpenDDS::RTPS::FragmentNumber_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::FragmentNumber_t& typed = *static_cast<const OpenDDS::RTPS::FragmentNumber_t*>(stru);
    if (std::strcmp(field, "value") == 0) {
      return typed.value;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::FragmentNumber_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'value' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::FragmentNumber_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "value") == 0) {
      return make_field_cmp(&T::value, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::FragmentNumber_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::FragmentNumber_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::FragmentNumber_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "value") == 0) {
      return static_cast<const T*>(lhs)->value == static_cast<const T*>(rhs)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::FragmentNumber_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::FragmentNumber_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::FragmentNumber_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::FragmentNumber_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::FragmentNumber_t>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: FragmentNumber_t */


/* Begin STRUCT: FragmentNumberSet */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::FragmentNumberSet& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += 8 + 4 * ((stru.numBits + 31) / 32); // RTPS Custom
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::FragmentNumberSet& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  if ((strm << stru.bitmapBase) && (strm << stru.numBits)) {
    const CORBA::ULong M = (stru.numBits + 31) / 32;
    if (stru.bitmap.length() < M) {
      return false;
    }
    for (CORBA::ULong i = 0; i < M; ++i) {
      if (!(strm << stru.bitmap[i])) {
        return false;
      }
    }
    return true;
  }
  return false;
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::FragmentNumberSet& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  if ((strm >> stru.bitmapBase) && (strm >> stru.numBits)) {
    const CORBA::ULong M = (stru.numBits + 31) / 32;
    if (M > 8) {
      return false;
    }
    stru.bitmap.length(M);
    for (CORBA::ULong i = 0; i < M; ++i) {
      if (!(strm >> stru.bitmap[i])) {
        return false;
      }
    }
    return true;
  }
  return false;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::FragmentNumberSet> : MetaStruct {
  typedef OpenDDS::RTPS::FragmentNumberSet T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::FragmentNumberSet& typed = *static_cast<const OpenDDS::RTPS::FragmentNumberSet*>(stru);
    if (std::strncmp(field, "bitmapBase.", 11) == 0) {
      return getMetaStruct<OpenDDS::RTPS::FragmentNumber_t>().getValue(&typed.bitmapBase, field + 11);
    }
    if (std::strcmp(field, "numBits") == 0) {
      return typed.numBits;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::FragmentNumberSet)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "bitmapBase.", 11) == 0) {
      return getMetaStruct<OpenDDS::RTPS::FragmentNumber_t>().getValue(ser, field + 11);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::FragmentNumber_t*>(0));
    }
    if (std::strcmp(field, "numBits") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'numBits' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::LongSeq8*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::FragmentNumberSet");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "bitmapBase.", 11) == 0) {
      return make_struct_cmp(&T::bitmapBase, getMetaStruct<OpenDDS::RTPS::FragmentNumber_t>().create_qc_comparator(field + 11), next);
    }
    if (std::strcmp(field, "numBits") == 0) {
      return make_field_cmp(&T::numBits, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::FragmentNumberSet)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"bitmapBase", "numBits", "bitmap", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "bitmapBase") == 0) {
      return &static_cast<const T*>(stru)->bitmapBase;
    }
    if (std::strcmp(field, "numBits") == 0) {
      return &static_cast<const T*>(stru)->numBits;
    }
    if (std::strcmp(field, "bitmap") == 0) {
      return &static_cast<const T*>(stru)->bitmap;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::FragmentNumberSet)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "bitmapBase") == 0) {
      static_cast<T*>(lhs)->bitmapBase = *static_cast<const OpenDDS::RTPS::FragmentNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "numBits") == 0) {
      static_cast<T*>(lhs)->numBits = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "bitmap") == 0) {
      static_cast<T*>(lhs)->bitmap = *static_cast<const OpenDDS::RTPS::LongSeq8*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::FragmentNumberSet)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "numBits") == 0) {
      return static_cast<const T*>(lhs)->numBits == static_cast<const T*>(rhs)->numBits;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::FragmentNumberSet)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::FragmentNumberSet>()
{
  static MetaStructImpl<OpenDDS::RTPS::FragmentNumberSet> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::FragmentNumberSet*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::FragmentNumberSet>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: FragmentNumberSet */


/* Begin STRUCT: AckNackSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::AckNackSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
  gen_find_size(stru.readerId, size, padding);
  gen_find_size(stru.writerId, size, padding);
  gen_find_size(stru.readerSNState, size, padding);
  gen_find_size(stru.count, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::AckNackSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader)
    && (strm << stru.readerId)
    && (strm << stru.writerId)
    && (strm << stru.readerSNState)
    && (strm << stru.count);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::AckNackSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader)
    && (strm >> stru.readerId)
    && (strm >> stru.writerId)
    && (strm >> stru.readerSNState)
    && (strm >> stru.count);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::AckNackSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::AckNackSubmessage T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::AckNackSubmessage& typed = *static_cast<const OpenDDS::RTPS::AckNackSubmessage*>(stru);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(&typed.readerId, field + 9);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(&typed.writerId, field + 9);
    }
    if (std::strncmp(field, "readerSNState.", 14) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumberSet>().getValue(&typed.readerSNState, field + 14);
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Count_t>().getValue(&typed.count, field + 6);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::AckNackSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0));
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::EntityId_t*>(0));
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::EntityId_t*>(0));
    }
    if (std::strncmp(field, "readerSNState.", 14) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumberSet>().getValue(ser, field + 14);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumberSet*>(0));
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Count_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::Count_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::AckNackSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return make_struct_cmp(&T::readerId, getMetaStruct<OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return make_struct_cmp(&T::writerId, getMetaStruct<OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "readerSNState.", 14) == 0) {
      return make_struct_cmp(&T::readerSNState, getMetaStruct<OpenDDS::RTPS::SequenceNumberSet>().create_qc_comparator(field + 14), next);
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return make_struct_cmp(&T::count, getMetaStruct<OpenDDS::RTPS::Count_t>().create_qc_comparator(field + 6), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::AckNackSubmessage)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "readerId", "writerId", "readerSNState", "count", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "readerId") == 0) {
      return &static_cast<const T*>(stru)->readerId;
    }
    if (std::strcmp(field, "writerId") == 0) {
      return &static_cast<const T*>(stru)->writerId;
    }
    if (std::strcmp(field, "readerSNState") == 0) {
      return &static_cast<const T*>(stru)->readerSNState;
    }
    if (std::strcmp(field, "count") == 0) {
      return &static_cast<const T*>(stru)->count;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::AckNackSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerId") == 0) {
      static_cast<T*>(lhs)->readerId = *static_cast<const OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerId") == 0) {
      static_cast<T*>(lhs)->writerId = *static_cast<const OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerSNState") == 0) {
      static_cast<T*>(lhs)->readerSNState = *static_cast<const OpenDDS::RTPS::SequenceNumberSet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "count") == 0) {
      static_cast<T*>(lhs)->count = *static_cast<const OpenDDS::RTPS::Count_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::AckNackSubmessage)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::AckNackSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::AckNackSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::AckNackSubmessage> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::AckNackSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::AckNackSubmessage>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: AckNackSubmessage */


/* Begin STRUCT: GapSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::GapSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
  gen_find_size(stru.readerId, size, padding);
  gen_find_size(stru.writerId, size, padding);
  gen_find_size(stru.gapStart, size, padding);
  gen_find_size(stru.gapList, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::GapSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader)
    && (strm << stru.readerId)
    && (strm << stru.writerId)
    && (strm << stru.gapStart)
    && (strm << stru.gapList);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::GapSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader)
    && (strm >> stru.readerId)
    && (strm >> stru.writerId)
    && (strm >> stru.gapStart)
    && (strm >> stru.gapList);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::GapSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::GapSubmessage T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::GapSubmessage& typed = *static_cast<const OpenDDS::RTPS::GapSubmessage*>(stru);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(&typed.readerId, field + 9);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(&typed.writerId, field + 9);
    }
    if (std::strncmp(field, "gapStart.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.gapStart, field + 9);
    }
    if (std::strncmp(field, "gapList.", 8) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumberSet>().getValue(&typed.gapList, field + 8);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::GapSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0));
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::EntityId_t*>(0));
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::EntityId_t*>(0));
    }
    if (std::strncmp(field, "gapStart.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumber_t*>(0));
    }
    if (std::strncmp(field, "gapList.", 8) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumberSet>().getValue(ser, field + 8);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumberSet*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::GapSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return make_struct_cmp(&T::readerId, getMetaStruct<OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return make_struct_cmp(&T::writerId, getMetaStruct<OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "gapStart.", 9) == 0) {
      return make_struct_cmp(&T::gapStart, getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "gapList.", 8) == 0) {
      return make_struct_cmp(&T::gapList, getMetaStruct<OpenDDS::RTPS::SequenceNumberSet>().create_qc_comparator(field + 8), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::GapSubmessage)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "readerId", "writerId", "gapStart", "gapList", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "readerId") == 0) {
      return &static_cast<const T*>(stru)->readerId;
    }
    if (std::strcmp(field, "writerId") == 0) {
      return &static_cast<const T*>(stru)->writerId;
    }
    if (std::strcmp(field, "gapStart") == 0) {
      return &static_cast<const T*>(stru)->gapStart;
    }
    if (std::strcmp(field, "gapList") == 0) {
      return &static_cast<const T*>(stru)->gapList;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::GapSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerId") == 0) {
      static_cast<T*>(lhs)->readerId = *static_cast<const OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerId") == 0) {
      static_cast<T*>(lhs)->writerId = *static_cast<const OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "gapStart") == 0) {
      static_cast<T*>(lhs)->gapStart = *static_cast<const OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "gapList") == 0) {
      static_cast<T*>(lhs)->gapList = *static_cast<const OpenDDS::RTPS::SequenceNumberSet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::GapSubmessage)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::GapSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::GapSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::GapSubmessage> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::GapSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::GapSubmessage>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: GapSubmessage */


/* Begin STRUCT: InfoReplySubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::InfoReplySubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
  gen_find_size(stru.unicastLocatorList, size, padding);
  if (stru.smHeader.flags & 2) {
    gen_find_size(stru.multicastLocatorList, size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::InfoReplySubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader)
    && (strm << stru.unicastLocatorList)
    && (!(stru.smHeader.flags & 2) || (strm << stru.multicastLocatorList));
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::InfoReplySubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader)
    && (strm >> stru.unicastLocatorList)
    && (!(stru.smHeader.flags & 2) || (strm >> stru.multicastLocatorList));
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::InfoReplySubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::InfoReplySubmessage T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::InfoReplySubmessage& typed = *static_cast<const OpenDDS::RTPS::InfoReplySubmessage*>(stru);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoReplySubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0));
    }
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::LocatorList*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::LocatorList*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::InfoReplySubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoReplySubmessage)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "unicastLocatorList", "multicastLocatorList", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "unicastLocatorList") == 0) {
      return &static_cast<const T*>(stru)->unicastLocatorList;
    }
    if (std::strcmp(field, "multicastLocatorList") == 0) {
      return &static_cast<const T*>(stru)->multicastLocatorList;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoReplySubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "unicastLocatorList") == 0) {
      static_cast<T*>(lhs)->unicastLocatorList = *static_cast<const OpenDDS::RTPS::LocatorList*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "multicastLocatorList") == 0) {
      static_cast<T*>(lhs)->multicastLocatorList = *static_cast<const OpenDDS::RTPS::LocatorList*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoReplySubmessage)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoReplySubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::InfoReplySubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::InfoReplySubmessage> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::InfoReplySubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::InfoReplySubmessage>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: InfoReplySubmessage */


/* Begin STRUCT: NackFragSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::NackFragSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
  gen_find_size(stru.readerId, size, padding);
  gen_find_size(stru.writerId, size, padding);
  gen_find_size(stru.writerSN, size, padding);
  gen_find_size(stru.fragmentNumberState, size, padding);
  gen_find_size(stru.count, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::NackFragSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader)
    && (strm << stru.readerId)
    && (strm << stru.writerId)
    && (strm << stru.writerSN)
    && (strm << stru.fragmentNumberState)
    && (strm << stru.count);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::NackFragSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader)
    && (strm >> stru.readerId)
    && (strm >> stru.writerId)
    && (strm >> stru.writerSN)
    && (strm >> stru.fragmentNumberState)
    && (strm >> stru.count);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::NackFragSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::NackFragSubmessage T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::NackFragSubmessage& typed = *static_cast<const OpenDDS::RTPS::NackFragSubmessage*>(stru);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(&typed.readerId, field + 9);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(&typed.writerId, field + 9);
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.writerSN, field + 9);
    }
    if (std::strncmp(field, "fragmentNumberState.", 20) == 0) {
      return getMetaStruct<OpenDDS::RTPS::FragmentNumberSet>().getValue(&typed.fragmentNumberState, field + 20);
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Count_t>().getValue(&typed.count, field + 6);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::NackFragSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0));
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::EntityId_t*>(0));
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::EntityId_t*>(0));
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumber_t*>(0));
    }
    if (std::strncmp(field, "fragmentNumberState.", 20) == 0) {
      return getMetaStruct<OpenDDS::RTPS::FragmentNumberSet>().getValue(ser, field + 20);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::FragmentNumberSet*>(0));
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Count_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::Count_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::NackFragSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return make_struct_cmp(&T::readerId, getMetaStruct<OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return make_struct_cmp(&T::writerId, getMetaStruct<OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return make_struct_cmp(&T::writerSN, getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "fragmentNumberState.", 20) == 0) {
      return make_struct_cmp(&T::fragmentNumberState, getMetaStruct<OpenDDS::RTPS::FragmentNumberSet>().create_qc_comparator(field + 20), next);
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return make_struct_cmp(&T::count, getMetaStruct<OpenDDS::RTPS::Count_t>().create_qc_comparator(field + 6), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::NackFragSubmessage)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "readerId", "writerId", "writerSN", "fragmentNumberState", "count", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "readerId") == 0) {
      return &static_cast<const T*>(stru)->readerId;
    }
    if (std::strcmp(field, "writerId") == 0) {
      return &static_cast<const T*>(stru)->writerId;
    }
    if (std::strcmp(field, "writerSN") == 0) {
      return &static_cast<const T*>(stru)->writerSN;
    }
    if (std::strcmp(field, "fragmentNumberState") == 0) {
      return &static_cast<const T*>(stru)->fragmentNumberState;
    }
    if (std::strcmp(field, "count") == 0) {
      return &static_cast<const T*>(stru)->count;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::NackFragSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerId") == 0) {
      static_cast<T*>(lhs)->readerId = *static_cast<const OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerId") == 0) {
      static_cast<T*>(lhs)->writerId = *static_cast<const OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerSN") == 0) {
      static_cast<T*>(lhs)->writerSN = *static_cast<const OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "fragmentNumberState") == 0) {
      static_cast<T*>(lhs)->fragmentNumberState = *static_cast<const OpenDDS::RTPS::FragmentNumberSet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "count") == 0) {
      static_cast<T*>(lhs)->count = *static_cast<const OpenDDS::RTPS::Count_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::NackFragSubmessage)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::NackFragSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::NackFragSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::NackFragSubmessage> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::NackFragSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::NackFragSubmessage>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: NackFragSubmessage */


/* Begin STRUCT: ParticipantProxy_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::ParticipantProxy_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  gen_find_size(stru.protocolVersion, size, padding);
  gen_find_size(stru_guidPrefix, size, padding);
  gen_find_size(stru.vendorId, size, padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_boolean(stru.expectsInlineQos));
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.availableBuiltinEndpoints);
  gen_find_size(stru.metatrafficUnicastLocatorList, size, padding);
  gen_find_size(stru.metatrafficMulticastLocatorList, size, padding);
  gen_find_size(stru.defaultMulticastLocatorList, size, padding);
  gen_find_size(stru.defaultUnicastLocatorList, size, padding);
  gen_find_size(stru.manualLivelinessCount, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::ParticipantProxy_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  return (strm << stru.protocolVersion)
    && (strm << stru_guidPrefix)
    && (strm << stru.vendorId)
    && (strm << ACE_OutputCDR::from_boolean(stru.expectsInlineQos))
    && (strm << stru.availableBuiltinEndpoints)
    && (strm << stru.metatrafficUnicastLocatorList)
    && (strm << stru.metatrafficMulticastLocatorList)
    && (strm << stru.defaultMulticastLocatorList)
    && (strm << stru.defaultUnicastLocatorList)
    && (strm << stru.manualLivelinessCount);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::ParticipantProxy_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  return (strm >> stru.protocolVersion)
    && (strm >> stru_guidPrefix)
    && (strm >> stru.vendorId)
    && (strm >> ACE_InputCDR::to_boolean(stru.expectsInlineQos))
    && (strm >> stru.availableBuiltinEndpoints)
    && (strm >> stru.metatrafficUnicastLocatorList)
    && (strm >> stru.metatrafficMulticastLocatorList)
    && (strm >> stru.defaultMulticastLocatorList)
    && (strm >> stru.defaultUnicastLocatorList)
    && (strm >> stru.manualLivelinessCount);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::ParticipantProxy_t> : MetaStruct {
  typedef OpenDDS::RTPS::ParticipantProxy_t T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::ParticipantProxy_t& typed = *static_cast<const OpenDDS::RTPS::ParticipantProxy_t*>(stru);
    if (std::strncmp(field, "protocolVersion.", 16) == 0) {
      return getMetaStruct<OpenDDS::RTPS::ProtocolVersion_t>().getValue(&typed.protocolVersion, field + 16);
    }
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::VendorId_t>().getValue(&typed.vendorId, field + 9);
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      return typed.expectsInlineQos;
    }
    if (std::strcmp(field, "availableBuiltinEndpoints") == 0) {
      return typed.availableBuiltinEndpoints;
    }
    if (std::strncmp(field, "manualLivelinessCount.", 22) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Count_t>().getValue(&typed.manualLivelinessCount, field + 22);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ParticipantProxy_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "protocolVersion.", 16) == 0) {
      return getMetaStruct<OpenDDS::RTPS::ProtocolVersion_t>().getValue(ser, field + 16);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::ProtocolVersion_t*>(0));
    }
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::GuidPrefix_t_forany*>(0));
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::VendorId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::VendorId_t*>(0));
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      ACE_CDR::Boolean val;
      if (!(ser >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'expectsInlineQos' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 1);
    }
    if (std::strcmp(field, "availableBuiltinEndpoints") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'availableBuiltinEndpoints' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::LocatorSeq*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::LocatorSeq*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::LocatorSeq*>(0));
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::LocatorSeq*>(0));
    if (std::strncmp(field, "manualLivelinessCount.", 22) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Count_t>().getValue(ser, field + 22);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::Count_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::ParticipantProxy_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "protocolVersion.", 16) == 0) {
      return make_struct_cmp(&T::protocolVersion, getMetaStruct<OpenDDS::RTPS::ProtocolVersion_t>().create_qc_comparator(field + 16), next);
    }
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return make_struct_cmp(&T::vendorId, getMetaStruct<OpenDDS::RTPS::VendorId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      return make_field_cmp(&T::expectsInlineQos, next);
    }
    if (std::strcmp(field, "availableBuiltinEndpoints") == 0) {
      return make_field_cmp(&T::availableBuiltinEndpoints, next);
    }
    if (std::strncmp(field, "manualLivelinessCount.", 22) == 0) {
      return make_struct_cmp(&T::manualLivelinessCount, getMetaStruct<OpenDDS::RTPS::Count_t>().create_qc_comparator(field + 22), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ParticipantProxy_t)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"protocolVersion", "guidPrefix", "vendorId", "expectsInlineQos", "availableBuiltinEndpoints", "metatrafficUnicastLocatorList", "metatrafficMulticastLocatorList", "defaultMulticastLocatorList", "defaultUnicastLocatorList", "manualLivelinessCount", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "protocolVersion") == 0) {
      return &static_cast<const T*>(stru)->protocolVersion;
    }
    if (std::strcmp(field, "guidPrefix") == 0) {
      return &static_cast<const T*>(stru)->guidPrefix;
    }
    if (std::strcmp(field, "vendorId") == 0) {
      return &static_cast<const T*>(stru)->vendorId;
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      return &static_cast<const T*>(stru)->expectsInlineQos;
    }
    if (std::strcmp(field, "availableBuiltinEndpoints") == 0) {
      return &static_cast<const T*>(stru)->availableBuiltinEndpoints;
    }
    if (std::strcmp(field, "metatrafficUnicastLocatorList") == 0) {
      return &static_cast<const T*>(stru)->metatrafficUnicastLocatorList;
    }
    if (std::strcmp(field, "metatrafficMulticastLocatorList") == 0) {
      return &static_cast<const T*>(stru)->metatrafficMulticastLocatorList;
    }
    if (std::strcmp(field, "defaultMulticastLocatorList") == 0) {
      return &static_cast<const T*>(stru)->defaultMulticastLocatorList;
    }
    if (std::strcmp(field, "defaultUnicastLocatorList") == 0) {
      return &static_cast<const T*>(stru)->defaultUnicastLocatorList;
    }
    if (std::strcmp(field, "manualLivelinessCount") == 0) {
      return &static_cast<const T*>(stru)->manualLivelinessCount;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ParticipantProxy_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "protocolVersion") == 0) {
      static_cast<T*>(lhs)->protocolVersion = *static_cast<const OpenDDS::RTPS::ProtocolVersion_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "guidPrefix") == 0) {
      OpenDDS::DCPS::GuidPrefix_t* lhsArr = &static_cast<T*>(lhs)->guidPrefix;
      const OpenDDS::DCPS::GuidPrefix_t* rhsArr = static_cast<const OpenDDS::DCPS::GuidPrefix_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 12; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    if (std::strcmp(field, "vendorId") == 0) {
      static_cast<T*>(lhs)->vendorId = *static_cast<const OpenDDS::RTPS::VendorId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      static_cast<T*>(lhs)->expectsInlineQos = *static_cast<const CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "availableBuiltinEndpoints") == 0) {
      static_cast<T*>(lhs)->availableBuiltinEndpoints = *static_cast<const OpenDDS::RTPS::BuiltinEndpointSet_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "metatrafficUnicastLocatorList") == 0) {
      static_cast<T*>(lhs)->metatrafficUnicastLocatorList = *static_cast<const OpenDDS::DCPS::LocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "metatrafficMulticastLocatorList") == 0) {
      static_cast<T*>(lhs)->metatrafficMulticastLocatorList = *static_cast<const OpenDDS::DCPS::LocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "defaultMulticastLocatorList") == 0) {
      static_cast<T*>(lhs)->defaultMulticastLocatorList = *static_cast<const OpenDDS::DCPS::LocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "defaultUnicastLocatorList") == 0) {
      static_cast<T*>(lhs)->defaultUnicastLocatorList = *static_cast<const OpenDDS::DCPS::LocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "manualLivelinessCount") == 0) {
      static_cast<T*>(lhs)->manualLivelinessCount = *static_cast<const OpenDDS::RTPS::Count_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ParticipantProxy_t)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      return static_cast<const T*>(lhs)->expectsInlineQos == static_cast<const T*>(rhs)->expectsInlineQos;
    }
    if (std::strcmp(field, "availableBuiltinEndpoints") == 0) {
      return static_cast<const T*>(lhs)->availableBuiltinEndpoints == static_cast<const T*>(rhs)->availableBuiltinEndpoints;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ParticipantProxy_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::ParticipantProxy_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::ParticipantProxy_t> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::ParticipantProxy_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::ParticipantProxy_t>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ParticipantProxy_t */


/* Begin STRUCT: SPDPdiscoveredParticipantData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::SPDPdiscoveredParticipantData& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.ddsParticipantData, size, padding);
  gen_find_size(stru.participantProxy, size, padding);
  gen_find_size(stru.leaseDuration, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::SPDPdiscoveredParticipantData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.ddsParticipantData)
    && (strm << stru.participantProxy)
    && (strm << stru.leaseDuration);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::SPDPdiscoveredParticipantData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.ddsParticipantData)
    && (strm >> stru.participantProxy)
    && (strm >> stru.leaseDuration);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::SPDPdiscoveredParticipantData> : MetaStruct {
  typedef OpenDDS::RTPS::SPDPdiscoveredParticipantData T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::SPDPdiscoveredParticipantData& typed = *static_cast<const OpenDDS::RTPS::SPDPdiscoveredParticipantData*>(stru);
    if (std::strncmp(field, "ddsParticipantData.", 19) == 0) {
      return getMetaStruct<DDS::ParticipantBuiltinTopicData>().getValue(&typed.ddsParticipantData, field + 19);
    }
    if (std::strncmp(field, "participantProxy.", 17) == 0) {
      return getMetaStruct<OpenDDS::RTPS::ParticipantProxy_t>().getValue(&typed.participantProxy, field + 17);
    }
    if (std::strncmp(field, "leaseDuration.", 14) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Duration_t>().getValue(&typed.leaseDuration, field + 14);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SPDPdiscoveredParticipantData)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "ddsParticipantData.", 19) == 0) {
      return getMetaStruct<DDS::ParticipantBuiltinTopicData>().getValue(ser, field + 19);
    } else {
      gen_skip_over(ser, static_cast<DDS::ParticipantBuiltinTopicData*>(0));
    }
    if (std::strncmp(field, "participantProxy.", 17) == 0) {
      return getMetaStruct<OpenDDS::RTPS::ParticipantProxy_t>().getValue(ser, field + 17);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::ParticipantProxy_t*>(0));
    }
    if (std::strncmp(field, "leaseDuration.", 14) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Duration_t>().getValue(ser, field + 14);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::Duration_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::SPDPdiscoveredParticipantData");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "ddsParticipantData.", 19) == 0) {
      return make_struct_cmp(&T::ddsParticipantData, getMetaStruct<DDS::ParticipantBuiltinTopicData>().create_qc_comparator(field + 19), next);
    }
    if (std::strncmp(field, "participantProxy.", 17) == 0) {
      return make_struct_cmp(&T::participantProxy, getMetaStruct<OpenDDS::RTPS::ParticipantProxy_t>().create_qc_comparator(field + 17), next);
    }
    if (std::strncmp(field, "leaseDuration.", 14) == 0) {
      return make_struct_cmp(&T::leaseDuration, getMetaStruct<OpenDDS::RTPS::Duration_t>().create_qc_comparator(field + 14), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SPDPdiscoveredParticipantData)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"ddsParticipantData", "participantProxy", "leaseDuration", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "ddsParticipantData") == 0) {
      return &static_cast<const T*>(stru)->ddsParticipantData;
    }
    if (std::strcmp(field, "participantProxy") == 0) {
      return &static_cast<const T*>(stru)->participantProxy;
    }
    if (std::strcmp(field, "leaseDuration") == 0) {
      return &static_cast<const T*>(stru)->leaseDuration;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SPDPdiscoveredParticipantData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "ddsParticipantData") == 0) {
      static_cast<T*>(lhs)->ddsParticipantData = *static_cast<const DDS::ParticipantBuiltinTopicData*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "participantProxy") == 0) {
      static_cast<T*>(lhs)->participantProxy = *static_cast<const OpenDDS::RTPS::ParticipantProxy_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "leaseDuration") == 0) {
      static_cast<T*>(lhs)->leaseDuration = *static_cast<const OpenDDS::RTPS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SPDPdiscoveredParticipantData)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SPDPdiscoveredParticipantData)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::SPDPdiscoveredParticipantData>()
{
  static MetaStructImpl<OpenDDS::RTPS::SPDPdiscoveredParticipantData> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::SPDPdiscoveredParticipantData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::SPDPdiscoveredParticipantData>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SPDPdiscoveredParticipantData */


/* Begin STRUCT: ParticipantMessageData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::ParticipantMessageData& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.participantGuid, size, padding);
  gen_find_size(stru.data, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::ParticipantMessageData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.participantGuid)
    && (strm << stru.data);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::ParticipantMessageData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.participantGuid)
    && (strm >> stru.data);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::ParticipantMessageData> : MetaStruct {
  typedef OpenDDS::RTPS::ParticipantMessageData T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::ParticipantMessageData& typed = *static_cast<const OpenDDS::RTPS::ParticipantMessageData*>(stru);
    if (std::strncmp(field, "participantGuid.", 16) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.participantGuid, field + 16);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ParticipantMessageData)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "participantGuid.", 16) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 16);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0));
    }
    gen_skip_over(ser, static_cast<DDS::OctetSeq*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::ParticipantMessageData");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "participantGuid.", 16) == 0) {
      return make_struct_cmp(&T::participantGuid, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 16), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ParticipantMessageData)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"participantGuid", "data", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "participantGuid") == 0) {
      return &static_cast<const T*>(stru)->participantGuid;
    }
    if (std::strcmp(field, "data") == 0) {
      return &static_cast<const T*>(stru)->data;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ParticipantMessageData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "participantGuid") == 0) {
      static_cast<T*>(lhs)->participantGuid = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "data") == 0) {
      static_cast<T*>(lhs)->data = *static_cast<const DDS::OctetSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ParticipantMessageData)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ParticipantMessageData)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::ParticipantMessageData>()
{
  static MetaStructImpl<OpenDDS::RTPS::ParticipantMessageData> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::ParticipantMessageData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::ParticipantMessageData>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ParticipantMessageData */


/* Begin STRUCT: Header */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::Header& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  OpenDDS::RTPS::OctetArray4_forany stru_prefix(const_cast<OpenDDS::RTPS::OctetArray4_slice*>(stru.prefix));
  OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  gen_find_size(stru_prefix, size, padding);
  gen_find_size(stru.version, size, padding);
  gen_find_size(stru.vendorId, size, padding);
  gen_find_size(stru_guidPrefix, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::Header& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::RTPS::OctetArray4_forany stru_prefix(const_cast<OpenDDS::RTPS::OctetArray4_slice*>(stru.prefix));
  OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  return (strm << stru_prefix)
    && (strm << stru.version)
    && (strm << stru.vendorId)
    && (strm << stru_guidPrefix);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::Header& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::RTPS::OctetArray4_forany stru_prefix(const_cast<OpenDDS::RTPS::OctetArray4_slice*>(stru.prefix));
  OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  return (strm >> stru_prefix)
    && (strm >> stru.version)
    && (strm >> stru.vendorId)
    && (strm >> stru_guidPrefix);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::Header> : MetaStruct {
  typedef OpenDDS::RTPS::Header T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::Header& typed = *static_cast<const OpenDDS::RTPS::Header*>(stru);
    if (std::strncmp(field, "version.", 8) == 0) {
      return getMetaStruct<OpenDDS::RTPS::ProtocolVersion_t>().getValue(&typed.version, field + 8);
    }
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::VendorId_t>().getValue(&typed.vendorId, field + 9);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Header)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::OctetArray4_forany*>(0));
    if (std::strncmp(field, "version.", 8) == 0) {
      return getMetaStruct<OpenDDS::RTPS::ProtocolVersion_t>().getValue(ser, field + 8);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::ProtocolVersion_t*>(0));
    }
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::VendorId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::VendorId_t*>(0));
    }
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::GuidPrefix_t_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::Header");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "version.", 8) == 0) {
      return make_struct_cmp(&T::version, getMetaStruct<OpenDDS::RTPS::ProtocolVersion_t>().create_qc_comparator(field + 8), next);
    }
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return make_struct_cmp(&T::vendorId, getMetaStruct<OpenDDS::RTPS::VendorId_t>().create_qc_comparator(field + 9), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Header)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"prefix", "version", "vendorId", "guidPrefix", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "prefix") == 0) {
      return &static_cast<const T*>(stru)->prefix;
    }
    if (std::strcmp(field, "version") == 0) {
      return &static_cast<const T*>(stru)->version;
    }
    if (std::strcmp(field, "vendorId") == 0) {
      return &static_cast<const T*>(stru)->vendorId;
    }
    if (std::strcmp(field, "guidPrefix") == 0) {
      return &static_cast<const T*>(stru)->guidPrefix;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Header)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "prefix") == 0) {
      OpenDDS::RTPS::OctetArray4* lhsArr = &static_cast<T*>(lhs)->prefix;
      const OpenDDS::RTPS::OctetArray4* rhsArr = static_cast<const OpenDDS::RTPS::OctetArray4*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 4; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    if (std::strcmp(field, "version") == 0) {
      static_cast<T*>(lhs)->version = *static_cast<const OpenDDS::RTPS::ProtocolVersion_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "vendorId") == 0) {
      static_cast<T*>(lhs)->vendorId = *static_cast<const OpenDDS::RTPS::VendorId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "guidPrefix") == 0) {
      OpenDDS::DCPS::GuidPrefix_t* lhsArr = &static_cast<T*>(lhs)->guidPrefix;
      const OpenDDS::DCPS::GuidPrefix_t* rhsArr = static_cast<const OpenDDS::DCPS::GuidPrefix_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 12; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Header)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Header)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::Header>()
{
  static MetaStructImpl<OpenDDS::RTPS::Header> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::Header*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::Header>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Header */


/* Begin STRUCT: DataSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::DataSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
  if ((size + padding) % 2) {
    padding += 2 - ((size + padding) % 2);
  }
  size += gen_max_marshaled_size(stru.extraFlags);
  if ((size + padding) % 2) {
    padding += 2 - ((size + padding) % 2);
  }
  size += gen_max_marshaled_size(stru.octetsToInlineQos);
  gen_find_size(stru.readerId, size, padding);
  gen_find_size(stru.writerId, size, padding);
  gen_find_size(stru.writerSN, size, padding);
  if (stru.smHeader.flags & 2) {
    gen_find_size(stru.inlineQos, size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::DataSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader)
    && (strm << stru.extraFlags)
    && (strm << stru.octetsToInlineQos)
    && (strm << stru.readerId)
    && (strm << stru.writerId)
    && (strm << stru.writerSN)
    && (!(stru.smHeader.flags & 2) || (strm << stru.inlineQos));
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::DataSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader)
    && (strm >> stru.extraFlags)
    && (strm >> stru.octetsToInlineQos)
    && (strm >> stru.readerId)
    && (strm >> stru.writerId)
    && (strm >> stru.writerSN)
    && strm.skip(stru.octetsToInlineQos - 16)
    && (!(stru.smHeader.flags & 2) || (strm >> stru.inlineQos));
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::DataSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::DataSubmessage T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::DataSubmessage& typed = *static_cast<const OpenDDS::RTPS::DataSubmessage*>(stru);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      return typed.extraFlags;
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      return typed.octetsToInlineQos;
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(&typed.readerId, field + 9);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(&typed.writerId, field + 9);
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.writerSN, field + 9);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DataSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0));
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      ACE_CDR::UShort val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'extraFlags' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 2);
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      ACE_CDR::UShort val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'octetsToInlineQos' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 2);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::EntityId_t*>(0));
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::EntityId_t*>(0));
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumber_t*>(0));
    }
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::ParameterList*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::DataSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      return make_field_cmp(&T::extraFlags, next);
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      return make_field_cmp(&T::octetsToInlineQos, next);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return make_struct_cmp(&T::readerId, getMetaStruct<OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return make_struct_cmp(&T::writerId, getMetaStruct<OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return make_struct_cmp(&T::writerSN, getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 9), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DataSubmessage)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "extraFlags", "octetsToInlineQos", "readerId", "writerId", "writerSN", "inlineQos", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      return &static_cast<const T*>(stru)->extraFlags;
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      return &static_cast<const T*>(stru)->octetsToInlineQos;
    }
    if (std::strcmp(field, "readerId") == 0) {
      return &static_cast<const T*>(stru)->readerId;
    }
    if (std::strcmp(field, "writerId") == 0) {
      return &static_cast<const T*>(stru)->writerId;
    }
    if (std::strcmp(field, "writerSN") == 0) {
      return &static_cast<const T*>(stru)->writerSN;
    }
    if (std::strcmp(field, "inlineQos") == 0) {
      return &static_cast<const T*>(stru)->inlineQos;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DataSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      static_cast<T*>(lhs)->extraFlags = *static_cast<const CORBA::UShort*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      static_cast<T*>(lhs)->octetsToInlineQos = *static_cast<const CORBA::UShort*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerId") == 0) {
      static_cast<T*>(lhs)->readerId = *static_cast<const OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerId") == 0) {
      static_cast<T*>(lhs)->writerId = *static_cast<const OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerSN") == 0) {
      static_cast<T*>(lhs)->writerSN = *static_cast<const OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "inlineQos") == 0) {
      static_cast<T*>(lhs)->inlineQos = *static_cast<const OpenDDS::RTPS::ParameterList*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DataSubmessage)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "extraFlags") == 0) {
      return static_cast<const T*>(lhs)->extraFlags == static_cast<const T*>(rhs)->extraFlags;
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      return static_cast<const T*>(lhs)->octetsToInlineQos == static_cast<const T*>(rhs)->octetsToInlineQos;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DataSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::DataSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::DataSubmessage> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::DataSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::DataSubmessage>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataSubmessage */


/* Begin STRUCT: DataFragSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::DataFragSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
  if ((size + padding) % 2) {
    padding += 2 - ((size + padding) % 2);
  }
  size += gen_max_marshaled_size(stru.extraFlags);
  if ((size + padding) % 2) {
    padding += 2 - ((size + padding) % 2);
  }
  size += gen_max_marshaled_size(stru.octetsToInlineQos);
  gen_find_size(stru.readerId, size, padding);
  gen_find_size(stru.writerId, size, padding);
  gen_find_size(stru.writerSN, size, padding);
  gen_find_size(stru.fragmentStartingNum, size, padding);
  if ((size + padding) % 2) {
    padding += 2 - ((size + padding) % 2);
  }
  size += gen_max_marshaled_size(stru.fragmentsInSubmessage);
  if ((size + padding) % 2) {
    padding += 2 - ((size + padding) % 2);
  }
  size += gen_max_marshaled_size(stru.fragmentSize);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.sampleSize);
  if (stru.smHeader.flags & 2) {
    gen_find_size(stru.inlineQos, size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::DataFragSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader)
    && (strm << stru.extraFlags)
    && (strm << stru.octetsToInlineQos)
    && (strm << stru.readerId)
    && (strm << stru.writerId)
    && (strm << stru.writerSN)
    && (strm << stru.fragmentStartingNum)
    && (strm << stru.fragmentsInSubmessage)
    && (strm << stru.fragmentSize)
    && (strm << stru.sampleSize)
    && (!(stru.smHeader.flags & 2) || (strm << stru.inlineQos));
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::DataFragSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader)
    && (strm >> stru.extraFlags)
    && (strm >> stru.octetsToInlineQos)
    && (strm >> stru.readerId)
    && (strm >> stru.writerId)
    && (strm >> stru.writerSN)
    && (strm >> stru.fragmentStartingNum)
    && (strm >> stru.fragmentsInSubmessage)
    && (strm >> stru.fragmentSize)
    && (strm >> stru.sampleSize)
    && strm.skip(stru.octetsToInlineQos - 28)
    && (!(stru.smHeader.flags & 2) || (strm >> stru.inlineQos));
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::DataFragSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::DataFragSubmessage T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::DataFragSubmessage& typed = *static_cast<const OpenDDS::RTPS::DataFragSubmessage*>(stru);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      return typed.extraFlags;
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      return typed.octetsToInlineQos;
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(&typed.readerId, field + 9);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(&typed.writerId, field + 9);
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.writerSN, field + 9);
    }
    if (std::strncmp(field, "fragmentStartingNum.", 20) == 0) {
      return getMetaStruct<OpenDDS::RTPS::FragmentNumber_t>().getValue(&typed.fragmentStartingNum, field + 20);
    }
    if (std::strcmp(field, "fragmentsInSubmessage") == 0) {
      return typed.fragmentsInSubmessage;
    }
    if (std::strcmp(field, "fragmentSize") == 0) {
      return typed.fragmentSize;
    }
    if (std::strcmp(field, "sampleSize") == 0) {
      return typed.sampleSize;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DataFragSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0));
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      ACE_CDR::UShort val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'extraFlags' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 2);
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      ACE_CDR::UShort val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'octetsToInlineQos' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 2);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::EntityId_t*>(0));
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::EntityId_t*>(0));
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumber_t*>(0));
    }
    if (std::strncmp(field, "fragmentStartingNum.", 20) == 0) {
      return getMetaStruct<OpenDDS::RTPS::FragmentNumber_t>().getValue(ser, field + 20);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::FragmentNumber_t*>(0));
    }
    if (std::strcmp(field, "fragmentsInSubmessage") == 0) {
      ACE_CDR::UShort val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'fragmentsInSubmessage' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 2);
    }
    if (std::strcmp(field, "fragmentSize") == 0) {
      ACE_CDR::UShort val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'fragmentSize' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 2);
    }
    if (std::strcmp(field, "sampleSize") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'sampleSize' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::ParameterList*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::DataFragSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      return make_field_cmp(&T::extraFlags, next);
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      return make_field_cmp(&T::octetsToInlineQos, next);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return make_struct_cmp(&T::readerId, getMetaStruct<OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return make_struct_cmp(&T::writerId, getMetaStruct<OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return make_struct_cmp(&T::writerSN, getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "fragmentStartingNum.", 20) == 0) {
      return make_struct_cmp(&T::fragmentStartingNum, getMetaStruct<OpenDDS::RTPS::FragmentNumber_t>().create_qc_comparator(field + 20), next);
    }
    if (std::strcmp(field, "fragmentsInSubmessage") == 0) {
      return make_field_cmp(&T::fragmentsInSubmessage, next);
    }
    if (std::strcmp(field, "fragmentSize") == 0) {
      return make_field_cmp(&T::fragmentSize, next);
    }
    if (std::strcmp(field, "sampleSize") == 0) {
      return make_field_cmp(&T::sampleSize, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DataFragSubmessage)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "extraFlags", "octetsToInlineQos", "readerId", "writerId", "writerSN", "fragmentStartingNum", "fragmentsInSubmessage", "fragmentSize", "sampleSize", "inlineQos", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      return &static_cast<const T*>(stru)->extraFlags;
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      return &static_cast<const T*>(stru)->octetsToInlineQos;
    }
    if (std::strcmp(field, "readerId") == 0) {
      return &static_cast<const T*>(stru)->readerId;
    }
    if (std::strcmp(field, "writerId") == 0) {
      return &static_cast<const T*>(stru)->writerId;
    }
    if (std::strcmp(field, "writerSN") == 0) {
      return &static_cast<const T*>(stru)->writerSN;
    }
    if (std::strcmp(field, "fragmentStartingNum") == 0) {
      return &static_cast<const T*>(stru)->fragmentStartingNum;
    }
    if (std::strcmp(field, "fragmentsInSubmessage") == 0) {
      return &static_cast<const T*>(stru)->fragmentsInSubmessage;
    }
    if (std::strcmp(field, "fragmentSize") == 0) {
      return &static_cast<const T*>(stru)->fragmentSize;
    }
    if (std::strcmp(field, "sampleSize") == 0) {
      return &static_cast<const T*>(stru)->sampleSize;
    }
    if (std::strcmp(field, "inlineQos") == 0) {
      return &static_cast<const T*>(stru)->inlineQos;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DataFragSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      static_cast<T*>(lhs)->extraFlags = *static_cast<const CORBA::UShort*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      static_cast<T*>(lhs)->octetsToInlineQos = *static_cast<const CORBA::UShort*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerId") == 0) {
      static_cast<T*>(lhs)->readerId = *static_cast<const OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerId") == 0) {
      static_cast<T*>(lhs)->writerId = *static_cast<const OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerSN") == 0) {
      static_cast<T*>(lhs)->writerSN = *static_cast<const OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "fragmentStartingNum") == 0) {
      static_cast<T*>(lhs)->fragmentStartingNum = *static_cast<const OpenDDS::RTPS::FragmentNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "fragmentsInSubmessage") == 0) {
      static_cast<T*>(lhs)->fragmentsInSubmessage = *static_cast<const CORBA::UShort*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "fragmentSize") == 0) {
      static_cast<T*>(lhs)->fragmentSize = *static_cast<const CORBA::UShort*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "sampleSize") == 0) {
      static_cast<T*>(lhs)->sampleSize = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "inlineQos") == 0) {
      static_cast<T*>(lhs)->inlineQos = *static_cast<const OpenDDS::RTPS::ParameterList*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DataFragSubmessage)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "extraFlags") == 0) {
      return static_cast<const T*>(lhs)->extraFlags == static_cast<const T*>(rhs)->extraFlags;
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      return static_cast<const T*>(lhs)->octetsToInlineQos == static_cast<const T*>(rhs)->octetsToInlineQos;
    }
    if (std::strcmp(field, "fragmentsInSubmessage") == 0) {
      return static_cast<const T*>(lhs)->fragmentsInSubmessage == static_cast<const T*>(rhs)->fragmentsInSubmessage;
    }
    if (std::strcmp(field, "fragmentSize") == 0) {
      return static_cast<const T*>(lhs)->fragmentSize == static_cast<const T*>(rhs)->fragmentSize;
    }
    if (std::strcmp(field, "sampleSize") == 0) {
      return static_cast<const T*>(lhs)->sampleSize == static_cast<const T*>(rhs)->sampleSize;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DataFragSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::DataFragSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::DataFragSubmessage> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::DataFragSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::DataFragSubmessage>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataFragSubmessage */


/* Begin STRUCT: HeartBeatSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::HeartBeatSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
  gen_find_size(stru.readerId, size, padding);
  gen_find_size(stru.writerId, size, padding);
  gen_find_size(stru.firstSN, size, padding);
  gen_find_size(stru.lastSN, size, padding);
  gen_find_size(stru.count, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::HeartBeatSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader)
    && (strm << stru.readerId)
    && (strm << stru.writerId)
    && (strm << stru.firstSN)
    && (strm << stru.lastSN)
    && (strm << stru.count);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::HeartBeatSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader)
    && (strm >> stru.readerId)
    && (strm >> stru.writerId)
    && (strm >> stru.firstSN)
    && (strm >> stru.lastSN)
    && (strm >> stru.count);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::HeartBeatSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::HeartBeatSubmessage T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::HeartBeatSubmessage& typed = *static_cast<const OpenDDS::RTPS::HeartBeatSubmessage*>(stru);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(&typed.readerId, field + 9);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(&typed.writerId, field + 9);
    }
    if (std::strncmp(field, "firstSN.", 8) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.firstSN, field + 8);
    }
    if (std::strncmp(field, "lastSN.", 7) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.lastSN, field + 7);
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Count_t>().getValue(&typed.count, field + 6);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::HeartBeatSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0));
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::EntityId_t*>(0));
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::EntityId_t*>(0));
    }
    if (std::strncmp(field, "firstSN.", 8) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(ser, field + 8);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumber_t*>(0));
    }
    if (std::strncmp(field, "lastSN.", 7) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(ser, field + 7);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumber_t*>(0));
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Count_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::Count_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::HeartBeatSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return make_struct_cmp(&T::readerId, getMetaStruct<OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return make_struct_cmp(&T::writerId, getMetaStruct<OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "firstSN.", 8) == 0) {
      return make_struct_cmp(&T::firstSN, getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 8), next);
    }
    if (std::strncmp(field, "lastSN.", 7) == 0) {
      return make_struct_cmp(&T::lastSN, getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 7), next);
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return make_struct_cmp(&T::count, getMetaStruct<OpenDDS::RTPS::Count_t>().create_qc_comparator(field + 6), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::HeartBeatSubmessage)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "readerId", "writerId", "firstSN", "lastSN", "count", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "readerId") == 0) {
      return &static_cast<const T*>(stru)->readerId;
    }
    if (std::strcmp(field, "writerId") == 0) {
      return &static_cast<const T*>(stru)->writerId;
    }
    if (std::strcmp(field, "firstSN") == 0) {
      return &static_cast<const T*>(stru)->firstSN;
    }
    if (std::strcmp(field, "lastSN") == 0) {
      return &static_cast<const T*>(stru)->lastSN;
    }
    if (std::strcmp(field, "count") == 0) {
      return &static_cast<const T*>(stru)->count;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::HeartBeatSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerId") == 0) {
      static_cast<T*>(lhs)->readerId = *static_cast<const OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerId") == 0) {
      static_cast<T*>(lhs)->writerId = *static_cast<const OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "firstSN") == 0) {
      static_cast<T*>(lhs)->firstSN = *static_cast<const OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "lastSN") == 0) {
      static_cast<T*>(lhs)->lastSN = *static_cast<const OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "count") == 0) {
      static_cast<T*>(lhs)->count = *static_cast<const OpenDDS::RTPS::Count_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::HeartBeatSubmessage)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::HeartBeatSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::HeartBeatSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::HeartBeatSubmessage> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::HeartBeatSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::HeartBeatSubmessage>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: HeartBeatSubmessage */


/* Begin STRUCT: HeartBeatFragSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::HeartBeatFragSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
  gen_find_size(stru.readerId, size, padding);
  gen_find_size(stru.writerId, size, padding);
  gen_find_size(stru.writerSN, size, padding);
  gen_find_size(stru.lastFragmentNum, size, padding);
  gen_find_size(stru.count, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::HeartBeatFragSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader)
    && (strm << stru.readerId)
    && (strm << stru.writerId)
    && (strm << stru.writerSN)
    && (strm << stru.lastFragmentNum)
    && (strm << stru.count);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::HeartBeatFragSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader)
    && (strm >> stru.readerId)
    && (strm >> stru.writerId)
    && (strm >> stru.writerSN)
    && (strm >> stru.lastFragmentNum)
    && (strm >> stru.count);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::HeartBeatFragSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::HeartBeatFragSubmessage T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::HeartBeatFragSubmessage& typed = *static_cast<const OpenDDS::RTPS::HeartBeatFragSubmessage*>(stru);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(&typed.readerId, field + 9);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(&typed.writerId, field + 9);
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.writerSN, field + 9);
    }
    if (std::strncmp(field, "lastFragmentNum.", 16) == 0) {
      return getMetaStruct<OpenDDS::RTPS::FragmentNumber_t>().getValue(&typed.lastFragmentNum, field + 16);
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Count_t>().getValue(&typed.count, field + 6);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::HeartBeatFragSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0));
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::EntityId_t*>(0));
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::DCPS::EntityId_t*>(0));
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumber_t*>(0));
    }
    if (std::strncmp(field, "lastFragmentNum.", 16) == 0) {
      return getMetaStruct<OpenDDS::RTPS::FragmentNumber_t>().getValue(ser, field + 16);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::FragmentNumber_t*>(0));
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Count_t>().getValue(ser, field + 6);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::Count_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::HeartBeatFragSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return make_struct_cmp(&T::readerId, getMetaStruct<OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return make_struct_cmp(&T::writerId, getMetaStruct<OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return make_struct_cmp(&T::writerSN, getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "lastFragmentNum.", 16) == 0) {
      return make_struct_cmp(&T::lastFragmentNum, getMetaStruct<OpenDDS::RTPS::FragmentNumber_t>().create_qc_comparator(field + 16), next);
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return make_struct_cmp(&T::count, getMetaStruct<OpenDDS::RTPS::Count_t>().create_qc_comparator(field + 6), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::HeartBeatFragSubmessage)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "readerId", "writerId", "writerSN", "lastFragmentNum", "count", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "readerId") == 0) {
      return &static_cast<const T*>(stru)->readerId;
    }
    if (std::strcmp(field, "writerId") == 0) {
      return &static_cast<const T*>(stru)->writerId;
    }
    if (std::strcmp(field, "writerSN") == 0) {
      return &static_cast<const T*>(stru)->writerSN;
    }
    if (std::strcmp(field, "lastFragmentNum") == 0) {
      return &static_cast<const T*>(stru)->lastFragmentNum;
    }
    if (std::strcmp(field, "count") == 0) {
      return &static_cast<const T*>(stru)->count;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::HeartBeatFragSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerId") == 0) {
      static_cast<T*>(lhs)->readerId = *static_cast<const OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerId") == 0) {
      static_cast<T*>(lhs)->writerId = *static_cast<const OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerSN") == 0) {
      static_cast<T*>(lhs)->writerSN = *static_cast<const OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "lastFragmentNum") == 0) {
      static_cast<T*>(lhs)->lastFragmentNum = *static_cast<const OpenDDS::RTPS::FragmentNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "count") == 0) {
      static_cast<T*>(lhs)->count = *static_cast<const OpenDDS::RTPS::Count_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::HeartBeatFragSubmessage)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::HeartBeatFragSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::HeartBeatFragSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::HeartBeatFragSubmessage> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::HeartBeatFragSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::HeartBeatFragSubmessage>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: HeartBeatFragSubmessage */


/* Begin STRUCT: InfoDestinationSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::InfoDestinationSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  gen_find_size(stru.smHeader, size, padding);
  gen_find_size(stru_guidPrefix, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::InfoDestinationSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  return (strm << stru.smHeader)
    && (strm << stru_guidPrefix);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::InfoDestinationSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  return (strm >> stru.smHeader)
    && (strm >> stru_guidPrefix);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::InfoDestinationSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::InfoDestinationSubmessage T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::InfoDestinationSubmessage& typed = *static_cast<const OpenDDS::RTPS::InfoDestinationSubmessage*>(stru);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoDestinationSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0));
    }
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::GuidPrefix_t_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::InfoDestinationSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoDestinationSubmessage)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "guidPrefix", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "guidPrefix") == 0) {
      return &static_cast<const T*>(stru)->guidPrefix;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoDestinationSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "guidPrefix") == 0) {
      OpenDDS::DCPS::GuidPrefix_t* lhsArr = &static_cast<T*>(lhs)->guidPrefix;
      const OpenDDS::DCPS::GuidPrefix_t* rhsArr = static_cast<const OpenDDS::DCPS::GuidPrefix_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 12; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoDestinationSubmessage)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoDestinationSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::InfoDestinationSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::InfoDestinationSubmessage> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::InfoDestinationSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::InfoDestinationSubmessage>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: InfoDestinationSubmessage */


/* Begin STRUCT: InfoSourceSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::InfoSourceSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  gen_find_size(stru.smHeader, size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.unused);
  gen_find_size(stru.version, size, padding);
  gen_find_size(stru.vendorId, size, padding);
  gen_find_size(stru_guidPrefix, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::InfoSourceSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  return (strm << stru.smHeader)
    && (strm << stru.unused)
    && (strm << stru.version)
    && (strm << stru.vendorId)
    && (strm << stru_guidPrefix);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::InfoSourceSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  return (strm >> stru.smHeader)
    && (strm >> stru.unused)
    && (strm >> stru.version)
    && (strm >> stru.vendorId)
    && (strm >> stru_guidPrefix);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::InfoSourceSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::InfoSourceSubmessage T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::InfoSourceSubmessage& typed = *static_cast<const OpenDDS::RTPS::InfoSourceSubmessage*>(stru);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strcmp(field, "unused") == 0) {
      return typed.unused;
    }
    if (std::strncmp(field, "version.", 8) == 0) {
      return getMetaStruct<OpenDDS::RTPS::ProtocolVersion_t>().getValue(&typed.version, field + 8);
    }
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::VendorId_t>().getValue(&typed.vendorId, field + 9);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoSourceSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0));
    }
    if (std::strcmp(field, "unused") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'unused' could not be deserialized");
      }
      return val;
    } else {
      ser.skip(1, 4);
    }
    if (std::strncmp(field, "version.", 8) == 0) {
      return getMetaStruct<OpenDDS::RTPS::ProtocolVersion_t>().getValue(ser, field + 8);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::ProtocolVersion_t*>(0));
    }
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::VendorId_t>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::VendorId_t*>(0));
    }
    gen_skip_over(ser, static_cast<OpenDDS::DCPS::GuidPrefix_t_forany*>(0));
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::InfoSourceSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    if (std::strcmp(field, "unused") == 0) {
      return make_field_cmp(&T::unused, next);
    }
    if (std::strncmp(field, "version.", 8) == 0) {
      return make_struct_cmp(&T::version, getMetaStruct<OpenDDS::RTPS::ProtocolVersion_t>().create_qc_comparator(field + 8), next);
    }
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return make_struct_cmp(&T::vendorId, getMetaStruct<OpenDDS::RTPS::VendorId_t>().create_qc_comparator(field + 9), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoSourceSubmessage)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "unused", "version", "vendorId", "guidPrefix", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "unused") == 0) {
      return &static_cast<const T*>(stru)->unused;
    }
    if (std::strcmp(field, "version") == 0) {
      return &static_cast<const T*>(stru)->version;
    }
    if (std::strcmp(field, "vendorId") == 0) {
      return &static_cast<const T*>(stru)->vendorId;
    }
    if (std::strcmp(field, "guidPrefix") == 0) {
      return &static_cast<const T*>(stru)->guidPrefix;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoSourceSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "unused") == 0) {
      static_cast<T*>(lhs)->unused = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "version") == 0) {
      static_cast<T*>(lhs)->version = *static_cast<const OpenDDS::RTPS::ProtocolVersion_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "vendorId") == 0) {
      static_cast<T*>(lhs)->vendorId = *static_cast<const OpenDDS::RTPS::VendorId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "guidPrefix") == 0) {
      OpenDDS::DCPS::GuidPrefix_t* lhsArr = &static_cast<T*>(lhs)->guidPrefix;
      const OpenDDS::DCPS::GuidPrefix_t* rhsArr = static_cast<const OpenDDS::DCPS::GuidPrefix_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 12; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoSourceSubmessage)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "unused") == 0) {
      return static_cast<const T*>(lhs)->unused == static_cast<const T*>(rhs)->unused;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoSourceSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::InfoSourceSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::InfoSourceSubmessage> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::InfoSourceSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::InfoSourceSubmessage>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: InfoSourceSubmessage */


/* Begin STRUCT: InfoTimestampSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::InfoTimestampSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
  if (!(stru.smHeader.flags & 2)) {
    gen_find_size(stru.timestamp, size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::InfoTimestampSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader)
    && (!(!(stru.smHeader.flags & 2)) || (strm << stru.timestamp));
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::InfoTimestampSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader)
    && (!(!(stru.smHeader.flags & 2)) || (strm >> stru.timestamp));
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::InfoTimestampSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::InfoTimestampSubmessage T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::InfoTimestampSubmessage& typed = *static_cast<const OpenDDS::RTPS::InfoTimestampSubmessage*>(stru);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strncmp(field, "timestamp.", 10) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Timestamp_t>().getValue(&typed.timestamp, field + 10);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoTimestampSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0));
    }
    if (std::strncmp(field, "timestamp.", 10) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Timestamp_t>().getValue(ser, field + 10);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::Timestamp_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::InfoTimestampSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "timestamp.", 10) == 0) {
      return make_struct_cmp(&T::timestamp, getMetaStruct<OpenDDS::RTPS::Timestamp_t>().create_qc_comparator(field + 10), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoTimestampSubmessage)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "timestamp", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "timestamp") == 0) {
      return &static_cast<const T*>(stru)->timestamp;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoTimestampSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "timestamp") == 0) {
      static_cast<T*>(lhs)->timestamp = *static_cast<const OpenDDS::RTPS::Timestamp_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoTimestampSubmessage)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoTimestampSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::InfoTimestampSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::InfoTimestampSubmessage> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::InfoTimestampSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::InfoTimestampSubmessage>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: InfoTimestampSubmessage */


/* Begin STRUCT: PadSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::PadSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::PadSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::PadSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::PadSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::PadSubmessage T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::PadSubmessage& typed = *static_cast<const OpenDDS::RTPS::PadSubmessage*>(stru);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::PadSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::PadSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::PadSubmessage)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::PadSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::PadSubmessage)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::PadSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::PadSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::PadSubmessage> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::PadSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::PadSubmessage>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PadSubmessage */


/* Begin STRUCT: InfoReplyIp4Submessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::InfoReplyIp4Submessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
  gen_find_size(stru.unicastLocator, size, padding);
  if (stru.smHeader.flags & 2) {
    gen_find_size(stru.multicastLocator, size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::InfoReplyIp4Submessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader)
    && (strm << stru.unicastLocator)
    && (!(stru.smHeader.flags & 2) || (strm << stru.multicastLocator));
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::InfoReplyIp4Submessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader)
    && (strm >> stru.unicastLocator)
    && (!(stru.smHeader.flags & 2) || (strm >> stru.multicastLocator));
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::InfoReplyIp4Submessage> : MetaStruct {
  typedef OpenDDS::RTPS::InfoReplyIp4Submessage T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::InfoReplyIp4Submessage& typed = *static_cast<const OpenDDS::RTPS::InfoReplyIp4Submessage*>(stru);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strncmp(field, "unicastLocator.", 15) == 0) {
      return getMetaStruct<OpenDDS::RTPS::LocatorUDPv4_t>().getValue(&typed.unicastLocator, field + 15);
    }
    if (std::strncmp(field, "multicastLocator.", 17) == 0) {
      return getMetaStruct<OpenDDS::RTPS::LocatorUDPv4_t>().getValue(&typed.multicastLocator, field + 17);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoReplyIp4Submessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0));
    }
    if (std::strncmp(field, "unicastLocator.", 15) == 0) {
      return getMetaStruct<OpenDDS::RTPS::LocatorUDPv4_t>().getValue(ser, field + 15);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::LocatorUDPv4_t*>(0));
    }
    if (std::strncmp(field, "multicastLocator.", 17) == 0) {
      return getMetaStruct<OpenDDS::RTPS::LocatorUDPv4_t>().getValue(ser, field + 17);
    } else {
      gen_skip_over(ser, static_cast<OpenDDS::RTPS::LocatorUDPv4_t*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::InfoReplyIp4Submessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "unicastLocator.", 15) == 0) {
      return make_struct_cmp(&T::unicastLocator, getMetaStruct<OpenDDS::RTPS::LocatorUDPv4_t>().create_qc_comparator(field + 15), next);
    }
    if (std::strncmp(field, "multicastLocator.", 17) == 0) {
      return make_struct_cmp(&T::multicastLocator, getMetaStruct<OpenDDS::RTPS::LocatorUDPv4_t>().create_qc_comparator(field + 17), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoReplyIp4Submessage)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "unicastLocator", "multicastLocator", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "unicastLocator") == 0) {
      return &static_cast<const T*>(stru)->unicastLocator;
    }
    if (std::strcmp(field, "multicastLocator") == 0) {
      return &static_cast<const T*>(stru)->multicastLocator;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoReplyIp4Submessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "unicastLocator") == 0) {
      static_cast<T*>(lhs)->unicastLocator = *static_cast<const OpenDDS::RTPS::LocatorUDPv4_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "multicastLocator") == 0) {
      static_cast<T*>(lhs)->multicastLocator = *static_cast<const OpenDDS::RTPS::LocatorUDPv4_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoReplyIp4Submessage)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoReplyIp4Submessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::InfoReplyIp4Submessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::InfoReplyIp4Submessage> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::InfoReplyIp4Submessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::InfoReplyIp4Submessage>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: InfoReplyIp4Submessage */


/* Begin ENUM: SubmessageKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const OpenDDS::RTPS::SubmessageKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::SubmessageKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    enumval = static_cast<OpenDDS::RTPS::SubmessageKind>(temp);
    return true;
  }
  return false;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

const char* gen_OpenDDS_RTPS_SubmessageKind_names[] = {
  "RESERVED_0",
  "PAD",
  "RESERVED_2",
  "RESERVED_3",
  "RESERVED_4",
  "RESERVED_5",
  "ACKNACK",
  "HEARTBEAT",
  "GAP",
  "INFO_TS",
  "RESERVED_10",
  "RESERVED_11",
  "INFO_SRC",
  "INFO_REPLY_IP4",
  "INFO_DST",
  "INFO_REPLY",
  "RESERVED_16",
  "RESERVED_17",
  "NACK_FRAG",
  "HEARTBEAT_FRAG",
  "RESERVED_20",
  "DATA",
  "DATA_FRAG"
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End ENUM: SubmessageKind */


/* Begin UNION: Submessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::Submessage& uni, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(uni);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  switch (uni._d()) {
  case OpenDDS::RTPS::PAD:
    {
      gen_find_size(uni.pad_sm(), size, padding);
      break;
    }
  case OpenDDS::RTPS::ACKNACK:
    {
      gen_find_size(uni.acknack_sm(), size, padding);
      break;
    }
  case OpenDDS::RTPS::HEARTBEAT:
    {
      gen_find_size(uni.heartbeat_sm(), size, padding);
      break;
    }
  case OpenDDS::RTPS::GAP:
    {
      gen_find_size(uni.gap_sm(), size, padding);
      break;
    }
  case OpenDDS::RTPS::INFO_TS:
    {
      gen_find_size(uni.info_ts_sm(), size, padding);
      break;
    }
  case OpenDDS::RTPS::INFO_SRC:
    {
      gen_find_size(uni.info_src_sm(), size, padding);
      break;
    }
  case OpenDDS::RTPS::INFO_REPLY_IP4:
    {
      gen_find_size(uni.info_reply_ipv4_sm(), size, padding);
      break;
    }
  case OpenDDS::RTPS::INFO_DST:
    {
      gen_find_size(uni.info_dst_sm(), size, padding);
      break;
    }
  case OpenDDS::RTPS::INFO_REPLY:
    {
      gen_find_size(uni.info_reply_sm(), size, padding);
      break;
    }
  case OpenDDS::RTPS::NACK_FRAG:
    {
      gen_find_size(uni.nack_frag_sm(), size, padding);
      break;
    }
  case OpenDDS::RTPS::HEARTBEAT_FRAG:
    {
      gen_find_size(uni.hb_frag_sm(), size, padding);
      break;
    }
  case OpenDDS::RTPS::DATA:
    {
      gen_find_size(uni.data_sm(), size, padding);
      break;
    }
  case OpenDDS::RTPS::DATA_FRAG:
    {
      gen_find_size(uni.data_frag_sm(), size, padding);
      break;
    }
  default:
    {
      gen_find_size(uni.unknown_sm(), size, padding);
      break;
    }
  }
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::Submessage& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  switch (uni._d()) {
  case OpenDDS::RTPS::PAD:
    {
      return (strm << uni.pad_sm());
    }
  case OpenDDS::RTPS::ACKNACK:
    {
      return (strm << uni.acknack_sm());
    }
  case OpenDDS::RTPS::HEARTBEAT:
    {
      return (strm << uni.heartbeat_sm());
    }
  case OpenDDS::RTPS::GAP:
    {
      return (strm << uni.gap_sm());
    }
  case OpenDDS::RTPS::INFO_TS:
    {
      return (strm << uni.info_ts_sm());
    }
  case OpenDDS::RTPS::INFO_SRC:
    {
      return (strm << uni.info_src_sm());
    }
  case OpenDDS::RTPS::INFO_REPLY_IP4:
    {
      return (strm << uni.info_reply_ipv4_sm());
    }
  case OpenDDS::RTPS::INFO_DST:
    {
      return (strm << uni.info_dst_sm());
    }
  case OpenDDS::RTPS::INFO_REPLY:
    {
      return (strm << uni.info_reply_sm());
    }
  case OpenDDS::RTPS::NACK_FRAG:
    {
      return (strm << uni.nack_frag_sm());
    }
  case OpenDDS::RTPS::HEARTBEAT_FRAG:
    {
      return (strm << uni.hb_frag_sm());
    }
  case OpenDDS::RTPS::DATA:
    {
      return (strm << uni.data_sm());
    }
  case OpenDDS::RTPS::DATA_FRAG:
    {
      return (strm << uni.data_frag_sm());
    }
  default:
    {
      return (strm << uni.unknown_sm());
    }
  }
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::Submessage& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  // unused
  return false;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::Submessage*)
{
  ACE_UNUSED_ARG(ser);
  OpenDDS::RTPS::SubmessageKind disc;
  if (!(ser >> disc)) {
    return;
  }
  switch (disc) {
  case OpenDDS::RTPS::PAD:
    {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::PadSubmessage*>(0));
      break;
    }
  case OpenDDS::RTPS::ACKNACK:
    {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::AckNackSubmessage*>(0));
      break;
    }
  case OpenDDS::RTPS::HEARTBEAT:
    {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::HeartBeatSubmessage*>(0));
      break;
    }
  case OpenDDS::RTPS::GAP:
    {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::GapSubmessage*>(0));
      break;
    }
  case OpenDDS::RTPS::INFO_TS:
    {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::InfoTimestampSubmessage*>(0));
      break;
    }
  case OpenDDS::RTPS::INFO_SRC:
    {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::InfoSourceSubmessage*>(0));
      break;
    }
  case OpenDDS::RTPS::INFO_REPLY_IP4:
    {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::InfoReplyIp4Submessage*>(0));
      break;
    }
  case OpenDDS::RTPS::INFO_DST:
    {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::InfoDestinationSubmessage*>(0));
      break;
    }
  case OpenDDS::RTPS::INFO_REPLY:
    {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::InfoReplySubmessage*>(0));
      break;
    }
  case OpenDDS::RTPS::NACK_FRAG:
    {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::NackFragSubmessage*>(0));
      break;
    }
  case OpenDDS::RTPS::HEARTBEAT_FRAG:
    {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::HeartBeatFragSubmessage*>(0));
      break;
    }
  case OpenDDS::RTPS::DATA:
    {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::DataSubmessage*>(0));
      break;
    }
  case OpenDDS::RTPS::DATA_FRAG:
    {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::DataFragSubmessage*>(0));
      break;
    }
  default:
    {
    gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0));
      break;
    }
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End UNION: Submessage */


/* Begin TYPEDEF: SubmessageSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::SubmessageSeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::SubmessageSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::SubmessageSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::SubmessageSeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  ser >> length;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SubmessageSeq */


/* Begin STRUCT: DiscoveredTopicData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::DiscoveredTopicData& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.ddsTopicData, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::DiscoveredTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.ddsTopicData);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::DiscoveredTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.ddsTopicData);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::DiscoveredTopicData> : MetaStruct {
  typedef OpenDDS::RTPS::DiscoveredTopicData T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::DiscoveredTopicData& typed = *static_cast<const OpenDDS::RTPS::DiscoveredTopicData*>(stru);
    if (std::strncmp(field, "ddsTopicData.", 13) == 0) {
      return getMetaStruct<DDS::TopicBuiltinTopicData>().getValue(&typed.ddsTopicData, field + 13);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DiscoveredTopicData)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "ddsTopicData.", 13) == 0) {
      return getMetaStruct<DDS::TopicBuiltinTopicData>().getValue(ser, field + 13);
    } else {
      gen_skip_over(ser, static_cast<DDS::TopicBuiltinTopicData*>(0));
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::DiscoveredTopicData");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "ddsTopicData.", 13) == 0) {
      return make_struct_cmp(&T::ddsTopicData, getMetaStruct<DDS::TopicBuiltinTopicData>().create_qc_comparator(field + 13), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DiscoveredTopicData)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"ddsTopicData", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "ddsTopicData") == 0) {
      return &static_cast<const T*>(stru)->ddsTopicData;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DiscoveredTopicData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "ddsTopicData") == 0) {
      static_cast<T*>(lhs)->ddsTopicData = *static_cast<const DDS::TopicBuiltinTopicData*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DiscoveredTopicData)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DiscoveredTopicData)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::DiscoveredTopicData>()
{
  static MetaStructImpl<OpenDDS::RTPS::DiscoveredTopicData> msi;
  return msi;
}

void gen_skip_over(Serializer& ser, OpenDDS::RTPS::DiscoveredTopicData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::DiscoveredTopicData>().getValue(ser, "");
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DiscoveredTopicData */

/* End MODULE: RTPS */

/* End MODULE: OpenDDS */
